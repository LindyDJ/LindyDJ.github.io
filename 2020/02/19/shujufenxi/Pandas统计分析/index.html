

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=light>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.ico">
  <link rel="icon" href="/img/fluid.ico">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="温酒斩华雄">
  <meta name="keywords" content="">
  
    <meta name="description" content="第二章 Pandas统计分析Pandas是Python的核心数据分析支持库，它提供了大量能使我们快速便捷地处理数据的函数和方法。由于Pandas相关知识非常多，本书将Pandas分为上、下两章进行讲解。本章开始Pandas入门内容，从安装开始，逐步介绍Pandas相关的入门知识，包括两个主要的数据结构，即Series对象和DataFrame对象，也包括如何导入外部数据、数据抽取，以及数据的增加、修">
<meta property="og:type" content="article">
<meta property="og:title" content="Pandas统计分析">
<meta property="og:url" content="http://example.com/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/index.html">
<meta property="og:site_name" content="zhaoShuoLin的博客">
<meta property="og:description" content="第二章 Pandas统计分析Pandas是Python的核心数据分析支持库，它提供了大量能使我们快速便捷地处理数据的函数和方法。由于Pandas相关知识非常多，本书将Pandas分为上、下两章进行讲解。本章开始Pandas入门内容，从安装开始，逐步介绍Pandas相关的入门知识，包括两个主要的数据结构，即Series对象和DataFrame对象，也包括如何导入外部数据、数据抽取，以及数据的增加、修">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/pandas.png">
<meta property="article:published_time" content="2020-02-19T03:37:50.000Z">
<meta property="article:modified_time" content="2020-02-19T03:37:50.000Z">
<meta property="article:author" content="温酒斩华雄">
<meta property="article:tag" content="数据分析">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/img/pandas.png">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>Pandas统计分析 - zhaoShuoLin的博客</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.0","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>

  
<meta name="generator" content="Hexo 5.4.2"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Lin&#39;s blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Pandas统计分析"></span>
          
        </div>

        
          
  <div class="mt-3">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-author" aria-hidden="true"></i>
        温酒斩华雄
      </span>
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2020-02-19 11:37" pubdate>
          2020年2月19日 中午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          55k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          458 分钟
        
      </span>
    

    
    
      
        <span id="busuanzi_container_page_pv" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="busuanzi_value_page_pv"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Pandas统计分析</h1>
            
              <p class="note note-info">
                
                  
                    本文最后更新于：2020年2月19日 中午
                  
                
              </p>
            
            <div class="markdown-body">
              
              <h1 id="第二章-Pandas统计分析"><a href="#第二章-Pandas统计分析" class="headerlink" title="第二章 Pandas统计分析"></a>第二章 Pandas统计分析</h1><p>Pandas是Python的核心数据分析支持库，它提供了大量能使我们快速便捷地处理数据的函数和方法。<br>由于Pandas相关知识非常多，本书将Pandas分为上、下两章进行讲解。本章开始Pandas入门内容，从安装开始，逐步介绍Pandas相关的入门知识，包括两个主要的数据结构，即Series对象和DataFrame对象，也包括如何导入外部数据、数据抽取，以及数据的增加、修改和删除，还包括数据清洗、索引设置、数据排序与排名等相关基础知识，这些都是在为后期数据处理和数据分析打下良好的基础。</p>
<h2 id="一-Pandas概述"><a href="#一-Pandas概述" class="headerlink" title="一. Pandas概述"></a>一. Pandas概述</h2><p>Pandas是数据分析三大剑客之一，是Python的核心数据分析库，它提供了快速、灵活、明确的数据结构，能够简单、直观、快速地处理各种类型的数据，具体介绍如下所示。</p>
<p>Pandas能够处理以下类型的数据。　</p>
<p>1.与SQL或Excel表类似的数据。　</p>
<p>2.有序和无序（非固定频率）的时间序列数据。　</p>
<p>3.带行、列标签的矩阵数据。</p>
<p>4.任意其他形式的观测、统计数据集。</p>
<p>Pandas提供的两个主要数据结构Series（一维数组结构）与DataFrame（二维数组结构），可以处理金融、统计、社会科学、工程等领域里的大多数典型案例，并且Pandas是基于NumPy开发的，可以与其他第三方科学计算库完美集成。<br>Pandas的功能很多，它的优势如下。　</p>
<p>list1=[0,1,2,3,4,5]</p>
<p>list2=[[0,1,2,3,4,5],[0,1,2,3,4,5]]</p>
<p>1.处理浮点与非浮点数据里的缺失数据，表示为<strong>NaN</strong>。　</p>
<p>2.大小可变，例如插入或删除DataFrame等多维对象的列。</p>
<p>3.自动、显式数据对齐，显式地将对象与一组标签对齐，也可以忽略标签，在Series、DataFrame计算时自动与数据对齐。　</p>
<p>4.强大、灵活的分组统计（groupby）功能，即数据聚合、数据转换。　</p>
<p>5.把Python和NumPy数据结构里不规则、不同索引的数据轻松地转换为DataFrame对象。　</p>
<p>6.智能标签，对大型数据集进行切片、花式索引、子集分解等操作。　</p>
<p>7.直观地合并（merge）、连接（join）数据集。　灵活地重塑（reshape）、透视（pivot）数据集。</p>
<p>8.成熟的导入、导出工具，导入文本文件（CSV等支持分隔符的文件）、Excel文件、数据库等来源的数据，导出Excel文件、文本文件等，利用超快的HDF5格式保存或加载数据。　</p>
<p>9.时间序列：支持日期范围生成、频率转换、移动窗口统计、移动窗口线性回归、日期位移等时间序列功能。</p>
<p>例1.读取excel数据</p>
<p>01 import pandas as pd               #导入pandas 模块<br>02 df=pd.read_excel(‘data.xlsx’)      #读取Excel 文件<br>03 df1=df.head()                      #显示前5 条数据</p>
<h2 id="二-seires-对象"><a href="#二-seires-对象" class="headerlink" title="二. seires 对象"></a>二. seires 对象</h2><p>Pandas是Python数据分析重要的库，而Series和DataFrame是Pandas库中两个重要的对象，也是Pandas中两个重要的数据结构，如图所示。</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018035610974.png" srcset="/img/loading.gif" lazyload alt="image-20211018035610974"><br>本节将主要介绍Series对象。</p>
<h3 id="2-1-图解Series对象"><a href="#2-1-图解Series对象" class="headerlink" title="2.1　图解Series对象"></a>2.1　图解Series对象</h3><p>Series是Python的Pandas库中的一种数据结构，它类似一维数组，由一组数据以及与这组数据相关的标签（即索引)组成，或者仅有一组数据没有索引也可以创建一个简单的Series。Series可以存储整数、浮点数、字符串、Python对象等多种类型的数据。<br>例如，在成绩表（见图3)中包含了Series对象和DataFrame对象，其中“语文”“数学”“英语”3列中的每一列均是一个Series对象，而“语文”“数学”“英语”3列组成了一个DataFrame对象，如图4所示。</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018035821898.png" srcset="/img/loading.gif" lazyload alt="image-20211018035821898"></p>
<p>​                                                                                           图3</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018035900680.png" srcset="/img/loading.gif" lazyload alt="image-20211018035900680"></p>
<p>​                                                                                         图4</p>
<h3 id="2-2-创建一个series对象"><a href="#2-2-创建一个series对象" class="headerlink" title="2.2 创建一个series对象"></a>2.2 创建一个series对象</h3><p>创建Series对象主要使用Pandas的Series()方法，语法如下：</p>
<p>s=pd.Series(data,index=index)</p>
<p>参数说明：　</p>
<p>data：表示数据，支持Python字典、多维数组、标量值（即只有大小，没有方向的量。也就是说，只是一个数值，如s=pd.Series(5)）。　index：表示行标签（索引）。　</p>
<p>返回值：Series对象。</p>
<p>说明<br>当data参数是多维数组时，index长度必须与data长度一致。如果没有指定index参数，则自动创建数值型索引（从0～data数据长度-1）。</p>
<p>【示例02】　在成绩表添加一列“物理”成绩。（示例位置：资源包\MR\Code\03\02）创建一个Series对象，在成绩表中添加一列“物理”成绩。程序代码如下：</p>
<p>01 import pandas as pd<br>02 s1=pd.Series([88,60,75])<br>03 print(s1)</p>
<p>上述举例，如果通过Pandas模块引入Series对象，那么就可以直接在程序中使用Series对象了。主要代码如下：</p>
<p>01 from pandas import Series<br>02 s1=Series([88,60,75])</p>
<h3 id="2-3-手动设置series索引"><a href="#2-3-手动设置series索引" class="headerlink" title="2.3 手动设置series索引"></a>2.3 手动设置series索引</h3><p>创建Series对象时会自动生成整数索引，默认值从0开始至数据长度减1。例如，3.2.1节举例中使用的就是默认索引，如0、1、2。除了使用默认索引，还可以通过index参数手动设置索引。</p>
<p>【示例03】　手动设置索引。（示例位置：资源包\MR\Code\03\03）<br>下面手动设置索引，将3.2.1节添加的“物理”成绩的索引设置为1、2、3，也可以是“明日同学”“高同学”“七月流火”。</p>
<p>程序代码如下：</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018040816095.png" srcset="/img/loading.gif" lazyload alt="image-20211018040816095"></p>
<p>运行程序，控制台输出结果如下：</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018040836315.png" srcset="/img/loading.gif" lazyload alt="image-20211018040836315"></p>
<p>说明<br>上述结果中输出的dtype是DataFrame数据的数据类型，int为整型，后面的数字表示位数。</p>
<h3 id="2-4-series-位置索引"><a href="#2-4-series-位置索引" class="headerlink" title="2.4 series 位置索引"></a>2.4 series 位置索引</h3><h4 id="2-4-1-series位置索引"><a href="#2-4-1-series位置索引" class="headerlink" title="2.4.1 series位置索引"></a>2.4.1 series位置索引</h4><p>位置索引是从0开始数，[0]是Series第一个数，[1]是Series第二个数，以此类推。</p>
<p>【示例04】　通过位置索引获取学生物理成绩。（示例位置：资源包\MR\Code\03\04）获取第一个学生的物理成绩。程序代码如下：</p>
<p>01 import pandas as pd<br>02 s1=pd.Series([88,60,75])<br>03 print(s1[0])<br>运行程序，控制台输出结果如下：</p>
<p>88</p>
<p><strong>注意</strong><br><strong>Series不能使用[-1]定位索引。</strong></p>
<h4 id="2-4-2-series-标签索引"><a href="#2-4-2-series-标签索引" class="headerlink" title="2.4.2 series 标签索引"></a>2.4.2 series 标签索引</h4><p>Series标签索引与位置索引方法类似，用[ ]表示，里面是索引名称，注意index的数据类型是字符串，如果需要获取多个标签索引值，用[[ ]]表示（相当于[ ]中包含一个列表）。</p>
<p>【示例05】　通过标签索引获取学生物理成绩。（示例位置：资源包\MR\Code\03\05）通过标签索引“明日同学”和“七月流火”获取物理成绩，程序代码如下：</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018041305145.png" srcset="/img/loading.gif" lazyload alt="image-20211018041305145"></p>
<h4 id="2-4-3-series-切片索引"><a href="#2-4-3-series-切片索引" class="headerlink" title="2.4.3 series 切片索引"></a>2.4.3 series 切片索引</h4><p>用标签索引做切片，包头包尾（即包含索引开始位置的数据，也包含索引结束位置的数据）。</p>
<p>【示例06】　通过切片获取数据。（示例位置：资源包\MR\Code\03\06）通过标签切片索引“明日同学”至“七月流火”获取数据。程序代码如下：</p>
<p>print(s1[‘明日同学’:’七月流火’])     #通过切片获取索引值</p>
<p>用位置索引做切片，和list列表用法一样，包头不包尾（即包含索引开始位置的数据，不包含索引结束位置的数据）。</p>
<p>【示例07】　通过位置切片获取数据。（示例位置：资源包\MR\Code\03\07）通过位置切片1～4获取数据，程序代码如下：</p>
<p>01  s2=pd.Series([88,60,75,34,68])<br>02  print(s2[1:4])<br>运行程序，控制台输出结果如下：</p>
<p>1  60<br>2  75<br>3  34</p>
<h4 id="2-4-5-获取series索引和值"><a href="#2-4-5-获取series索引和值" class="headerlink" title="2.4.5 获取series索引和值"></a>2.4.5 获取series索引和值</h4><p>获取Series索引和值主要使用Series的index和values方法。</p>
<p>【示例08】　获取物理成绩的索引和值。（示例位置：资源包\MR\Code\03\08）下面使用Series的index和values方法获取物理成绩的索引和值，程序代码如下：</p>
<p>01 import pandas as pd<br>02 s1=pd.Series([88,60,75])<br>03 print(s1.index)<br>04 print(s1.values)<br>运行程序，控制台输出结果如下：</p>
<p>RangeIndex(start=0, stop=3, step=1)<br>[88 60 75]</p>
<h2 id="三-DataFrame对象"><a href="#三-DataFrame对象" class="headerlink" title="三. DataFrame对象"></a>三. DataFrame对象</h2><p>DataFrame是Pandas库中的一种数据结构，它是由多种类型的列组成的二维表数据结构，类似于Excel、SQL或Series对象构成的字典。DataFrame是最常用的Pandas对象，它与Series对象一样支持多种类型的数据。</p>
<h3 id="3-1-图解DataFrame对象"><a href="#3-1-图解DataFrame对象" class="headerlink" title="3.1　图解DataFrame对象"></a>3.1　图解DataFrame对象</h3><p>DataFrame是一个二维表数据结构，由行、列数据组成的表格。DataFrame既有行索引也有列索引，它可以看作是由Series对象组成的字典，不过这些Series对象共用一个索引，如图3.11所示。</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018042136168.png" srcset="/img/loading.gif" lazyload alt="image-20211018042136168"></p>
<p>图3.11　DataFrame结构<br>处理DataFrame表格数据时，用index表示行或用columns表示列更直观。用这种方式迭代DataFrame的列，代码更易读懂。</p>
<p>【示例09】　遍历DataFrame数据。（示例位置：资源包\MR\Code\03\09）遍历DataFrame数据，输出成绩表的每一列数据，程序代码如下：</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018042332305.png" srcset="/img/loading.gif" lazyload alt="image-20211018042332305"></p>
<p>运行程序，控制台输出结果如下：</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018042319399.png" srcset="/img/loading.gif" lazyload alt="image-20211018042319399"></p>
<p>从运行结果得知，上述代码返回的其实是Series，如图3.12所示。Pandas之所以提供多种数据结构，其目的就是为了代码易读、操作更加方便。</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018042510540.png" srcset="/img/loading.gif" lazyload alt="image-20211018042510540"></p>
<h3 id="3-2-创建一个DataFrame对象"><a href="#3-2-创建一个DataFrame对象" class="headerlink" title="3.2 创建一个DataFrame对象"></a>3.2 创建一个DataFrame对象</h3><p>创建DataFrame主要使用Pandas的DataFrame()方法，语法如下：</p>
<p>pandas.DataFrame(data,index,columns,dtype,copy)<br>参数说明：　</p>
<p>data：表示数据，可以是ndarray数组、Series对象、列表、字典等。　</p>
<p>index：表示行标签（索引）。</p>
<p>columns：列标签（索引）。　</p>
<p>dtype：每一列数据的数据类型，其与Python数据类型有所不同，如object数据类型对应的是Python的字符型。</p>
<p>表3.1为Pandas数据类型与Python数据类型的对应表。</p>
<p>category作业，查询datetime64,timedela[ns],category</p>
<p>Timedelta在pandas中是一个表示两个datetime值之间的差(如日,秒和微妙)的类型,2个Datetime数据运算相减得出的结果就是一个Timedelta数据类型</p>
<p>​                                                                                          表3.1　数据类型对应表　</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018042916094.png" srcset="/img/loading.gif" lazyload alt="image-20211018042916094"></p>
<p>copy：用于复制数据。　</p>
<p>返回值：DataFrame。<br>下面通过两种方法来创建DataFrame，即通过二维数组创建和通过字典创建。</p>
<p>1．通过二维数组创建DataFrame【示例10】　通过二维数组创建成绩表。（示例位置：资源包\MR\Code\03\10）<br>通过二维数组创建成绩表，包括语文、数学和英语，程序代码如下：</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018043105059.png" srcset="/img/loading.gif" lazyload alt="image-20211018043105059"></p>
<p>运行程序，控制台输出结果如下：</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018043117683.png" srcset="/img/loading.gif" lazyload alt="image-20211018043117683"></p>
<p>2．通过字典创建DataFrame<br>通过字典创建DataFrame，需要注意：字典中的value值只能是一维数组或单个的简单数据类型，如果是数组，要求所有数组长度一致；如果是单个数据，则每行都添加相同数据。</p>
<p>【示例11】　通过字典创建成绩表。（示例位置：资源包\MR\Code\03\11）通过字典创建成绩表，包括语文、数学、英语和班级，程序代码如下：</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018043238790.png" srcset="/img/loading.gif" lazyload alt="image-20211018043238790"></p>
<p>运行程序，控制台输出结果如下：</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018043309599.png" srcset="/img/loading.gif" lazyload alt="image-20211018043309599"></p>
<p>上述代码中，“班级”的value值是一个单个数据，所以每一行都添加了相同的数据“高一7班”。</p>
<h3 id="3-3-DataFrame重要属性和函数"><a href="#3-3-DataFrame重要属性和函数" class="headerlink" title="3.3 DataFrame重要属性和函数"></a>3.3 DataFrame重要属性和函数</h3><p>DataFrame是Pandas一个重要的对象，它的属性和函数很多，下面先简单了解DataFrame的几个重要属性和函数。重要属性介绍如表3.2所示，重要函数介绍如表3.3所示。</p>
<p>​                                                                                               表3.2　重要属性</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018043520943.png" srcset="/img/loading.gif" lazyload alt="image-20211018043520943"></p>
<p>​                                                                                                  表3.3　重要函数</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018043534263.png" srcset="/img/loading.gif" lazyload alt="image-20211018043534263"></p>
<h3 id="3-4-导入外部数据"><a href="#3-4-导入外部数据" class="headerlink" title="3.4 导入外部数据"></a>3.4 导入外部数据</h3><p>数据分析首先就要有数据。那么，数据类型有多种，本节介绍如何导入不同类型的外部数据。</p>
<h4 id="3-4-1-导入-xls或-xlsx文件"><a href="#3-4-1-导入-xls或-xlsx文件" class="headerlink" title="3.4.1　导入.xls或.xlsx文件"></a>3.4.1　导入.xls或.xlsx文件</h4><p>导入.xls或.xlsx文件主要使用Pandas的read_excel()方法，语法如下：</p>
<p>pandas.read_excel(io,sheet_name=0,header=0,names=None,index_col=None,usecols=None,squeeze=False,<br>dtype=None,engine=None,converters=None,true_values=None,false_values=None,skiprows=None,nrow=None,<br>na_values=None,keep_default_na=True,verbose=False,parse_dates=False,date_parser=None,thousands=None,<br>comment=None,skipfooter=0,conver_float=True,mangle_dupe_cols=True,**kwds)<br>常用参数说明：　</p>
<p>io：字符串，.xls或.xlsx文件路径或类文件对象。　</p>
<p>sheet_name：None、字符串、整数、字符串列表或整数列表，默认值为0。字符串用于工作表名称，整数为索引表示工作表位置，字符串列表或整数列表用于请求多个工作表，为None时获取所有工作表。参数值如表3.4所示。</p>
<p>​                                                                                     表3.4　sheet_name参数值　</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018043941426.png" srcset="/img/loading.gif" lazyload alt="image-20211018043941426"></p>
<p>header：指定作为列名的行，默认值为0，即取第一行的值为列名。数据为除列名以外的数据；若数据不包含列名，则设置header=None。　</p>
<p>names：默认值为None，要使用的列名列表。　</p>
<p>index_col：指定列为索引列，默认值为None，索引0是DataFrame的行标签。</p>
<p>usecols：int、list列表或字符串，默认值为None。　如果为None，则解析所有列。　如果为int，则解析最后一列。　如果为list列表，则解析列号列表的列。　如果为字符串，则表示以逗号分隔的Excel列字母和列范围列表（例如“A:E”或“A,C,E:F”）。范围包括双方。　</p>
<p>squeeze：布尔值，默认值为False，如果解析的数据只包含一列，则返回一个Series。　</p>
<p>dtype：列的数据类型名称或字典，默认值为None。例如{‘a’:np.float64,’b’:np.int32}。　</p>
<p>skiprows：省略指定行数的数据，从第一行开始。　</p>
<p>skipfooter：省略指定行数的数据，从尾部数的行开始。</p>
<p>下面通过示例，详细介绍如何导入.xlsx文件。</p>
<h5 id="1．常规导入导入Excel文件。"><a href="#1．常规导入导入Excel文件。" class="headerlink" title="1．常规导入导入Excel文件。"></a>1．常规导入导入Excel文件。</h5><p>【示例12】　（示例位置：资源包\MR\Code\03\12）导入“1月.xlsx”Excel文件，程序代码如下：</p>
<p>01 import pandas as pd<br>02 df=pd.read_excel(‘1 月.xlsx’)<br>03 df1=df.head()          #输出前5 条数据<br>运行程序，输出前5条数据，结果如图3.13所示。<br>图3.13　1月淘宝销售数据（前5条数据）</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018044223025.png" srcset="/img/loading.gif" lazyload alt="image-20211018044223025"></p>
<p>知识胶囊<br>导入外部数据，必然要涉及路径问题，下面来了解一下相对路径和绝对路径。　</p>
<p><strong>相对路径</strong>：相对路径就是以当前文件为基准进行一级级目录指向被引用的资源文件。以下是常用的表示当前目录和当前目录的父级目录的标识符。　../：表示当前文件所在目录的上一级目录。　./：表示当前文件所在的目录（可以省略）。　/：表示当前文件的根目录（域名映射或硬盘目录）。　如果使用系统默认文件路径\，那么，在Python中则需要在路径最前面加一个r，以避免路径里面的\被转义。　</p>
<p><strong>绝对路径</strong>：绝对路径是文件真正存在的路径，是指从硬盘的根目录（盘符）开始，进行一级级目录指向文件。</p>
<h5 id="2．导入指定的Sheet页"><a href="#2．导入指定的Sheet页" class="headerlink" title="2．导入指定的Sheet页"></a>2．导入指定的Sheet页</h5><p>一个Excel文件包含多个Sheet页，通过设置sheet_name参数就可以导入指定Sheet页的数据。</p>
<p>【示例13】　导入指定Sheet页的数据。（示例位置：资源包\MR\Code\03\13）一个Excel文件包含多家店铺的销售数据，导入其中一家店铺（莫寒）的销售数据，如图3.14所示。<br>图3.14　原始数据</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018044701218.png" srcset="/img/loading.gif" lazyload alt="image-20211018044701218"></p>
<p>程序代码如下：</p>
<p>01 import pandas as pd<br>02 df=pd.read_excel(‘1 月.xlsx’,sheet_name=’莫寒’)<br>03 df1=df.head()          #输出前5条数据<br>运行程序，输出前5条数据，结果如图3.15所示。<br>除了指定Sheet页的名字，还可以指定Sheet页的顺序，从0开始。例如，sheet_name=0表示导入第一个Sheet页的数据，sheet_name=1表示导入第二个Sheet页的数据，以此类推。<br>如果不指定sheet_name参数，则默认导入第一个Sheet页的数据。</p>
<h5 id="3．通过行、列索引导入指定行、列数据"><a href="#3．通过行、列索引导入指定行、列数据" class="headerlink" title="3．通过行、列索引导入指定行、列数据"></a>3．通过行、列索引导入指定行、列数据</h5><p>DataFrame是二维数据结构，因此它既有行索引又有列索引。当导入Excel数据时，行索引会自动生成，如0、1、2；而列索引则默认将第0行作为列索引（如A,B,…,J）。DataFrame行、列索引的示意图如图3.16所示。</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018044837800.png" srcset="/img/loading.gif" lazyload alt="image-20211018044837800"></p>
<p>​                                                  </p>
<p>​                                                                            图3.15　导入指定的Sheet页（前5条数据） </p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018044932996.png" srcset="/img/loading.gif" lazyload alt="image-20211018044932996"></p>
<p>​                                                                                图3.16　DataFrame行、列索引示意图</p>
<p>【示例14】　指定行索引导入Excel数据。（示例位置：资源包\MR\Code\03\14）<br>如果通过指定行索引导入Excel数据，则需要设置index_col参数。下面将“买家会员名”作为行索引（位于第0列），导入Excel数据，程序代码如下：</p>
<p>01 import pandas as pd<br>02 df1=pd.read_excel(‘1 月.xlsx’,index_col=0)     #“买家会员名”为行索引<br>03 df1=df1.head()                                 #输出前5条数据<br>运行程序，输出结果如图3.17所示。</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018045103681.png" srcset="/img/loading.gif" lazyload alt="image-20211018045103681"></p>
<p>图3.17　通过指定行索引导入Excel数据<br>如果通过指定列索引导入Excel数据，则需要设置header参数，主要代码如下：</p>
<p>df2=pd.read_excel(‘1月.xlsx’,header=1)        #设置第1行为列索引</p>
<p>运行程序，输出结果如图3.18所示。<br>如果将数字作为列索引，可以设置header参数为None，主要代码如下：</p>
<p>df3=pd.read_excel(‘1月.xlsx’,header=None)    #列索引为数字</p>
<p>运行程序，输出结果如图3.19所示。</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018045218250.png" srcset="/img/loading.gif" lazyload alt="image-20211018045218250"></p>
<p>图3.18　通过指定列索引导入Excel数据</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018045231796.png" srcset="/img/loading.gif" lazyload alt="image-20211018045231796"></p>
<p>图3.19　指定列索引<br>那么，为什么要指定索引呢？因为通过索引可以快速地检索数据，例如df3[0]，就可以快速检索到“买家会员名”这一列数据。</p>
<h5 id="4-导入指定列数据"><a href="#4-导入指定列数据" class="headerlink" title="4.导入指定列数据"></a>4.导入指定列数据</h5><p>一个Excel往往包含多列数据，如果只需要其中的几列，可以通过usecols参数指定需要的列，从0开始（表示第1列，以此类推）。</p>
<p>【示例15】　导入第1列数据。（示例位置：资源包\MR\Code\03\15）下面导入第1列数据（索引为0），程序代码如下：</p>
<p>01 import pandas as pd<br>02 df1=pd.read_excel(‘1 月.xlsx’,usecols=[0])       #导入第1列<br>03 df1.head()<br>运行程序，输出结果如图3.20所示。<br>如果导入多列，可以在列表中指定多个值。例如，导入第1列和第4列，主要代码如下：</p>
<p>df2=pd.read_excel(‘1月.xlsx’,usecols=[0,3])<br>也可以指定列名称，主要代码如下：</p>
<p>df3=pd.read_excel(‘1月.xlsx’,usecols=[‘买家会员名’,’宝贝标题’])<br>运行程序，输出结果如图3.21所示。</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018045614397.png" srcset="/img/loading.gif" lazyload alt="image-20211018045614397"></p>
<p>​                                                                                               图3.20　导入第1列</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018045541729.png" srcset="/img/loading.gif" lazyload alt="image-20211018045541729"></p>
<p>​                                                                                     图3.21　导入第1列和第4列数据</p>
<h4 id="3-4-2-导入-csv文件"><a href="#3-4-2-导入-csv文件" class="headerlink" title="3.4.2　导入.csv文件"></a>3.4.2　导入.csv文件</h4><p>导入.csv文件主要使用Pandas的read_csv()方法，语法如下：</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018045855117.png" srcset="/img/loading.gif" lazyload alt="image-20211018045855117">常用参数说明：　</p>
<p>filepath_or_buffer：字符串，文件路径，也可以是URL链接。　</p>
<p>sep、delimiter：字符串，分隔符。</p>
<p>header：指定作为列名的行，默认值为0，即取第1行的值为列名。数据为除列名以外的数据；若数据不包含列名，则设置header=None。　</p>
<p>names：默认值为None，要使用的列名列表。　</p>
<p>index_col：指定列为索引列，默认值为None，索引0是DataFrame的行标签。　</p>
<p>usecols：int、list列表或字符串，默认值为None。　如果为None，则解析所有列。　如果为int，则解析最后一列。　如果为list列表，则解析列号列表的列。　如果为字符串，则表示以逗号分隔的Excel列字母和列范围列表（例如“A:E”或“A,C,E:F”）。范围包括双方。　dtype：列的数据类型名称或字典，默认值为None。例如{‘a’:np.float64,’b’:np.int32}。　</p>
<p>parse_dates：布尔类型值、int类型值的列表、列表或字典，默认值为False。可以通过parse_dates参数直接将某列转换成datetime64日期类型。例如，df1=pd.read_csv(‘1月.csv’, parse_dates=[‘订单付款时间’])。　</p>
<p>​        parse_dates为True时，尝试解析索引。　</p>
<p>​        parse_dates为int类型值组成的列表时，如[1,2,3]，则解析1、2、3列的值作为独立的日期列。　</p>
<p>​        parse_date为列表组成的列表，如[[1,3]]，则将1、3列合并，作为一个日期列使用。　</p>
<p>​        parse_date为字典时，如{‘总计’：[1, 3]}，则将1、3列合并，合并后的列名为“总计”。　</p>
<p>encoding：字符串，默认值为None，文件的编码格式。Python常用的编码格式是UTF-8。　返回值：返回一个DataFrame。</p>
<p>【示例16】　导入.csv文件。（示例位置：资源包\MR\Code\03\16）导入.csv文件，程序代码如下：</p>
<p>01 import pandas as pd<br>02 df1=pd.read_csv(‘1月.csv’<strong>,encoding=</strong>‘gbk’)        #导入.csv文件，并指定编码格式<br>03 df1=df1.head()                                   #输出前5条数据<br>运行程序，输出结果如图3.22所示。</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018050346464.png" srcset="/img/loading.gif" lazyload alt="image-20211018050346464">                                                  </p>
<p>​                                                                                            图3.22　导入.csv文件</p>
<p>注意<br>上述代码中指定了编码格式，即encoding=’gbk’。Python常用的编码格式是UTF-8和gbk，默认编码格式为UTF-8。导入.csv文件时，需要通过encoding参数指定编码格式。当将Excel文件另存为.csv文件时，默认编码格式为gbk，此时当编写代码导入.csv文件时，就需要设置编码格式为gbk，与源文件编码格式保持一致；否则会提示错误。</p>
<h4 id="3-4-3-导入-txt文本文件"><a href="#3-4-3-导入-txt文本文件" class="headerlink" title="3.4.3　导入.txt文本文件"></a>3.4.3　导入.txt文本文件</h4><p>导入.txt文件同样使用Pandas的read_csv()方法，不同的是需要指定sep参数（如制表符\t）。read_csv()方法读取.txt文件返回一个DataFrame，像表格一样的二维数据结构，如图3.23所示。</p>
<p>【示例17】　导入.txt文件。（示例位置：资源包\MR\Code\03\17）<br>下面使用read_csv()方法导入1月.txt文件，主要代码如下：</p>
<p>01 import pandas as pd<br>02 df1=pd.read_csv(‘1月.txt’,sep=’\t’,encoding=’gbk’)<br>03 print(df1.head())<br>运行程序，输出结果如图3.24所示。</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018050613488-16345047782181.png" srcset="/img/loading.gif" lazyload alt="image-20211018050613488"></p>
<p>​                                                                                                        图3.23　.txt文件形式</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018050642828.png" srcset="/img/loading.gif" lazyload alt="image-20211018050642828"></p>
<p>​                                                                                                         图3.24　导入.txt文本</p>
<h4 id="3-4-4-导入HTML网页"><a href="#3-4-4-导入HTML网页" class="headerlink" title="3.4.4　导入HTML网页"></a>3.4.4　导入HTML网页</h4><p>导入HTML网页数据主要使用Pandas的read_html()方法，该方法用于导入带有table标签的网页表格数据，语法如下：</p>
<p>pandas.read_html(io,match=’.+’,flavor=None,header=None,index_col=None,skiprows=None,attrs=None,parse_<br>dates=False,thousands=’,’,encoding=None,decimal=’.’,converters=None,na_values=None,keep_default_na=True,<br>displayed_only=True)<br>常用参数说明：　</p>
<p>io：字符串，文件路径，也可以是URL链接。网址不接受https，可以尝试去掉https中的s后爬取，如<a target="_blank" rel="noopener" href="http://www.mingribook.com./">http://www.mingribook.com。</a></p>
<p>match：正则表达式，返回与正则表达式匹配的表格。　</p>
<p>flavor：解析器默认为lxml。　</p>
<p>header：指定列标题所在的行，列表list为多重索引。　</p>
<p>index_col：指定行标题对应的列，列表list为多重索引。　</p>
<p>encoding：字符串，默认为None，文件的编码格式。　</p>
<p>返回值：返回一个DataFrame。<br>使用read_html()方法前，首先要确定网页表格是否为table类型。例如，NBA球员薪资网页（<a target="_blank" rel="noopener" href="http://www.espn.com/nba/salaries%EF%BC%89%EF%BC%8C%E5%8F%B3%E5%87%BB%E8%AF%A5%E7%BD%91%E9%A1%B5%E4%B8%AD%E7%9A%84%E8%A1%A8%E6%A0%BC%EF%BC%8C%E5%9C%A8%E5%BC%B9%E5%87%BA%E7%9A%84%E5%BF%AB%E6%8D%B7%E8%8F%9C%E5%8D%95%E4%B8%AD%E9%80%89%E6%8B%A9%E2%80%9C%E6%A3%80%E6%9F%A5%E5%85%83%E7%B4%A0%E2%80%9D%E5%91%BD%E4%BB%A4%EF%BC%8C%E6%9F%A5%E7%9C%8B%E4%BB%A3%E7%A0%81%E4%B8%AD%E6%98%AF%E5%90%A6%E5%90%AB%E6%9C%89%E8%A1%A8%E6%A0%BC%E6%A0%87%E7%AD%BE">http://www.espn.com/nba/salaries），右击该网页中的表格，在弹出的快捷菜单中选择“检查元素”命令，查看代码中是否含有表格标签</a><table>…</table>的字样，如图3.25所示。确定后才可以使用read_html()方法。</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018051003748.png" srcset="/img/loading.gif" lazyload alt="image-20211018051003748"></p>
<p>​                                                                            图3.25　<table>…</table>表格标签</p>
<p>【示例18】　导入NBA球员薪资数据。（示例位置：资源包\MR\Code\03\18）<br>下面使用read_html()方法导入NBA球员薪资数据，程序代码如下：</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018051015470.png" srcset="/img/loading.gif" lazyload alt="image-20211018051015470"></p>
<p>运行程序，输出结果如图3.26所示。</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018051117577.png" srcset="/img/loading.gif" lazyload alt="image-20211018051117577"></p>
<p>​                                                                                              图3.26　导入网页数据注意<br>运行程序，如果出现ImportError: lxml not found, please install it错误提示信息，则需要安装lxml模块。</p>
<h3 id="3-5-数据抽取"><a href="#3-5-数据抽取" class="headerlink" title="3.5　数据抽取"></a>3.5　数据抽取</h3><p>数据分析过程中，并不是所有的数据都是我们想要的，此时可以抽取部分数据，主要使用DataFrame对<strong>象的loc属性和iloc属性</strong>，示意图如图3.27所示。</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018051225461.png" srcset="/img/loading.gif" lazyload alt="image-20211018051225461">          </p>
<pre><code class="hljs">                                                                                     图3.27　loc属性和iloc属性示意图
</code></pre>
<p>对象的loc属性和iloc属性都可以抽取数据，区别如下。　</p>
<p>loc属性：以列名（columns）和行名（index）作为参数，当只有一个参数时，默认是行名，即抽取整行数据，包括所有列，如df.loc[‘A’]。　</p>
<p>iloc属性：以行和列位置索引（即0，1，2，…)作为参数，0表示第1行，1表示第2行，以此类推。当只有一个参数时，默认是行索引，即抽取整行数据，包括所有列。如抽取第1行数据，df.iloc[0]。</p>
<h4 id="3-5-1-抽取一行数据"><a href="#3-5-1-抽取一行数据" class="headerlink" title="3.5.1　抽取一行数据"></a>3.5.1　抽取一行数据</h4><p>抽取一行数据主要使用loc属性。【</p>
<p>示例19】　抽取一行考试成绩数据。（示例位置：资源包\MR\Code\03\19）抽取一行名为“明日”的考试成绩数据（包括所有列），程序代码如下：</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018051358694.png" srcset="/img/loading.gif" lazyload alt="image-20211018051358694">运行程序，输出结果如图3.28所示。<br>使用iloc属性抽取第1行数据，指定行索引即可，如df.iloc[0]，输出结果同图3.28一样。</p>
<p>[1,2,2,3]</p>
<p>[[1,2,3,4]]</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018051441548.png" srcset="/img/loading.gif" lazyload alt="image-20211018051441548"></p>
<p>​                                                                                                                图3.28　抽取一行数据</p>
<h4 id="3-5-2-抽取多行数据"><a href="#3-5-2-抽取多行数据" class="headerlink" title="3.5.2　抽取多行数据"></a>3.5.2　抽取多行数据</h4><p>1．抽取任意多行数据<br><strong>通过loc属性和iloc属性指定行名和行索引即可实现抽取任意多行数据。</strong></p>
<p>【示例20】　抽取多行考试成绩数据。（示例位置：资源包\MR\Code\03\20）抽取行名为“明日”和“高袁圆”（即第1行和第3行数据）的考试成绩数据，可以使用loc属性，也可以使用iloc属性，其输出结果都是一样的，主要代码如下：</p>
<p>01 df1=df.loc[[‘明日’,’高袁圆’]]<br>02 df1=df.iloc[[0,2]]<br>运行程序，输出结果如图3.29所示。</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018051606515.png" srcset="/img/loading.gif" lazyload alt="image-20211018051606515"></p>
<p>​                                                                                                图3.29　抽取多行数据<br>2．抽取连续任意多行数据<br>在loc属性和iloc属性中合理地使用冒号（:），即可抽取连续任意多行数据。</p>
<p>【示例21】　抽取连续几个学生的考试成绩。（示例位置：资源包\MR\Code\03\21）抽取连续几个学生的考试成绩，主要代码如下：</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018051735968.png" srcset="/img/loading.gif" lazyload alt="image-20211018051735968"></p>
<p>运行程序，控制台输出结果如图3.30所示。</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018051746750.png" srcset="/img/loading.gif" lazyload alt="image-20211018051746750"></p>
<p>​                                                                                 图3.30　抽取连续任意多行数据</p>
<h4 id="3-5-3-抽取指定列数据"><a href="#3-5-3-抽取指定列数据" class="headerlink" title="3.5.3　抽取指定列数据"></a>3.5.3　抽取指定列数据</h4><p>抽取指定列数据，可以直接使用列名，也可以使用loc属性和iloc属性。<br>1．直接使用列名【示例22】　抽取“语文”和“数学”的考试成绩。（示例位置：资源包\MR\Code\03\22）<br>抽取列名为“语文”和“数学”的考试成绩数据，程序代码如下：</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018051846594.png" srcset="/img/loading.gif" lazyload alt="image-20211018051846594"></p>
<p>运行程序，输出结果如图3.31所示。</p>
<p>2．使用loc属性和iloc属性<br>前面介绍loc属性和iloc属性均有两个参数：第一个参数代表行；第二个参数代表列。那么这里抽取指定列数据时，行参数不能省略。</p>
<p>【示例23】　抽取指定学科的考试成绩。（示例位置：资源包\MR\Code\03\23）<br>下面使用loc属性和iloc属性抽取指定列数据，主要代码如下：</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018052009426.png" srcset="/img/loading.gif" lazyload alt="image-20211018052009426"></p>
<p>运行程序，控制台输出结果如图3.32所示。</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018052021825.png" srcset="/img/loading.gif" lazyload alt="image-20211018052021825"></p>
<p>​                                                                                      图3.31　直接使用列名</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018052041459.png" srcset="/img/loading.gif" lazyload alt="image-20211018052041459"></p>
<p>​                                                                                          图3.32　loc属性和iloc属性</p>
<h4 id="3-5-4-抽取指定行、列数据"><a href="#3-5-4-抽取指定行、列数据" class="headerlink" title="3.5.4　抽取指定行、列数据"></a>3.5.4　抽取指定行、列数据</h4><p>抽取指定行、列数据主要使用loc属性和iloc属性，这两个方法的两个参数都指定就可以实现指定行、列数据的抽取。</p>
<p>【示例24】　抽取指定学科和指定学生的考试成绩。（示例位置：资源包\MR\Code\03\24）使用loc属性和iloc属性抽取指定行、列数据，程序代码如下：</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018052200474.png" srcset="/img/loading.gif" lazyload alt="image-20211018052200474"></p>
<p>运行程序，控制台输出结果如图3.33所示。</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018052214525.png" srcset="/img/loading.gif" lazyload alt="image-20211018052214525"></p>
<pre><code class="hljs">                                                                               图3.33　抽取指定行、列数据
</code></pre>
<p>在上述结果中，第一个输出结果是一个数，不是数据，是由于“df.loc[‘七月流火’,’英语’]”没有使用方括号[]，导致输出的数据不是DataFrame类型。</p>
<h4 id="3-5-5-按指定条件抽取数据"><a href="#3-5-5-按指定条件抽取数据" class="headerlink" title="3.5.5　按指定条件抽取数据"></a>3.5.5　按指定条件抽取数据</h4><p>DataFrame对象实现数据查询有以下3种方式。　取其中的一个元素.iat[x,x]。　基于位置的查询，如.iloc[]、iloc[2,1]。　基于行、列名称的查询，如.loc[x]。</p>
<p>【示例25】　抽取指定学科和指定分数的数据。（示例位置：资源包\MR\Code\03\25）抽取语文成绩大于105，数学成绩大于88的数据，程序代码如下：</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018052322850.png" srcset="/img/loading.gif" lazyload alt="image-20211018052322850"></p>
<p>运行程序，输出结果如图3.34所示。</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018052523463.png" srcset="/img/loading.gif" lazyload alt="image-20211018052523463">   </p>
<p>​                                                                                             图3.34　按指定条件抽取数据</p>
<h3 id="3-6-数据的增加、修改和删除"><a href="#3-6-数据的增加、修改和删除" class="headerlink" title="3.6　数据的增加、修改和删除"></a>3.6　数据的增加、修改和删除</h3><p>本节主要介绍如何操纵DataFrame对象中的各种数据。例如，数据的增加、修改和删除。</p>
<h4 id="3-6-1-增加数据"><a href="#3-6-1-增加数据" class="headerlink" title="3.6.1　增加数据"></a>3.6.1　增加数据</h4><p>DataFrame对象增加数据主要包括列数据增加和行数据增加。首先看一下原始数据，如图3.35所示。</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018052637063.png" srcset="/img/loading.gif" lazyload alt="image-20211018052637063"></p>
<p>图3.35　原始数据</p>
<h5 id="1．按列增加数据"><a href="#1．按列增加数据" class="headerlink" title="1．按列增加数据"></a>1．按列增加数据</h5><p>按列增加数据，可以通过以下3种方式实现。<br>（1）直接为DataFrame对象赋值</p>
<p>【示例26】　增加一列“物理”成绩。（示例位置：资源包\MR\Code\03\26）<br>增加一列“物理”成绩，程序代码如下：</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018052702267.png" srcset="/img/loading.gif" lazyload alt="image-20211018052702267"></p>
<p>运行程序，输出结果如图3.36所示。</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018052756371.png" srcset="/img/loading.gif" lazyload alt="image-20211018052756371"></p>
<p>​                                                                                   图3.36　按列增加数据<br>（2）使用loc属性在DataFrame对象的最后增加一列</p>
<p>【示例27】　使用loc属性增加一列“物理”成绩。（示例位置：资源包\MR\Code\03\27）使用loc属性在DataFrame对象的最后增加一列。例如，增加“物理”一列，主要代码如下：</p>
<p>df.loc[:,’物理’] = [88,79,60,50]<br>在DataFrame对象最后增加一列“物理”，其值为等号右边数据。</p>
<p>（3）在指定位置插入一列<br>在指定位置插入一列，主要使用insert()方法。</p>
<p>【示例28】　在第1列后面插入“物理”成绩。（示例位置：资源包\MR\Code\03\28）<br>例如，在第1列后面插入“物理”，其值为wl的数值，主要代码如下：</p>
<p>01 wl =[88,79,60,50]<br>02 df.insert(1,’物理’,wl)<br>运行程序，输出结果如图3.37所示。</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018052920670.png" srcset="/img/loading.gif" lazyload alt="image-20211018052920670"></p>
<p>​                                                                                                图3.37　使用insert()方法增加一列</p>
<h5 id="2．按行增加数据"><a href="#2．按行增加数据" class="headerlink" title="2．按行增加数据"></a>2．按行增加数据</h5><p>按行增加数据，可以通过以下两种方式实现。<br>（1）增加一行数据<br>增加一行数据主要使用loc属性实现。</p>
<p>【示例29】　在成绩表中增加一行数据。（示例位置：资源包\MR\Code\03\29）在成绩表中增加一行数据，即“钱多多”同学的成绩，主要代码如下：</p>
<p>df.loc[‘钱多多’] = [100,120,99]<br>（2）增加多行数据</p>
<p>增加多行数据主要使用<strong>字典</strong>结合**append()**方法实现。</p>
<p>【示例30】　在原有数据中增加几名同学的考试成绩。（示例位置：资源包\MR\Code\03\30）在原有数据中增加“钱多多”“童年”“无名”同学的考试成绩，主要代码如下：</p>
<p>01 df_insert=pd.DataFrame({‘语文’:[100,123,138],’数学’:[99,142,60],’英语’:[98,139,99]},index = [‘钱多多’,’童年’,’无名’])<br>02 df1 = df.append(df_insert)<br>运行程序，输出结果分别如图3.38和图3.39所示。</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018053145141.png" srcset="/img/loading.gif" lazyload alt="image-20211018053145141"></p>
<p>​                                                                                       图3.38　增加一行数据</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018053204251.png" srcset="/img/loading.gif" lazyload alt="image-20211018053204251"></p>
<p>​                                                                                        图3.39　增加多行数据</p>
<h4 id="3-6-2-修改数据"><a href="#3-6-2-修改数据" class="headerlink" title="3.6.2　修改数据"></a>3.6.2　修改数据</h4><p>修改数据包括行、列标题和数据的修改，首先看一下原始数据，如图3.40所示。</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018053230905.png" srcset="/img/loading.gif" lazyload alt="image-20211018053230905"></p>
<p>​                                                                                               图3.40　原始数据</p>
<h5 id="1．修改列标题"><a href="#1．修改列标题" class="headerlink" title="1．修改列标题"></a>1．修改列标题</h5><p>修改列标题主要使用DataFrame对象的cloumns属性，直接赋值即可。</p>
<p>【示例31】　修改“数学”的列名。（示例位置：资源包\MR\Code\03\31）将“数学”修改为“数学（上）”，主要代码如下：</p>
<p>df.columns=[‘语文’,’数学（上）’,’英语’]</p>
<p>上述代码中，即使只修改“数学”为“数学（上）”，但是也<strong>要将所有列的标题全部写上；</strong>否则将报错。<br>下面再介绍一种方法，使用DataFrame对象的rename()方法修改列标题。</p>
<p>【示例32】　修改多个学科的列名。（示例位置：资源包\MR\Code\03\32）将“语文”修改为“语文（上）”、“数学”修改为“数学（上）”、“英语”修改为“英语（上）”，主要代码如下：</p>
<p>df.rename(columns = {‘语文’:’语文（上）’,’数学’:’数学（上）’,’英语’:’英语（上）’},inplace = True)</p>
<p>上述代码中，参数inplace为True，表示直接修改df；否则，不修改df，只返回修改后的数据。<br>运行程序，输出结果分别如图3.41和图3.42所示。</p>
<h5 id="2．修改行标题"><a href="#2．修改行标题" class="headerlink" title="2．修改行标题"></a>2．修改行标题</h5><p>修改行标题主要使用DataFrame对象的index属性，直接赋值即可。</p>
<p>【示例33】　将行标题统一修改为数字编号。（示例位置：资源包\MR\Code\03\33）<br>将行标题统一修改为数字编号，主要代码如下：</p>
<p>df.index=list(‘1234’)</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018053500036.png" srcset="/img/loading.gif" lazyload alt="image-20211018053500036"></p>
<p>​                                                                                         图3.41　修改列标题1</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018053517247.png" srcset="/img/loading.gif" lazyload alt="image-20211018053517247"></p>
<p>​                                                                                                 图3.42　修改列标题2</p>
<p>使用DataFrame对象的rename()方法也可以修改行标题。例如，将行标题统一修改为数字编号，主要代码如下：</p>
<p>df.rename({‘明日’:1,’七月流火’:2,’高袁圆’:3,’二月二’:4},axis=0,inplace = True)</p>
<h5 id="3．修改数据"><a href="#3．修改数据" class="headerlink" title="3．修改数据"></a>3．修改数据</h5><p>修改数据主要使用DataFrame对象的loc属性和iloc属性。</p>
<p>【示例34】　修改学生成绩数据。（示例位置：资源包\MR\Code\03\34）<br>（1）修改整行数据<br>例如，修改“明日”同学的各科成绩，主要代码如下：</p>
<p>df.loc[‘明日’]=[120,115,109]<br>如果各科成绩均加10分，可以直接在原有值上加10，主要代码如下：</p>
<p>df.loc[‘明日’]=df.loc[‘明日’]+10<br>（2）修改整列数据<br>例如，修改所有同学的“语文”成绩，主要代码如下：</p>
<p>df.loc[:,’语文’]=[115,108,112,118]<br>（3）修改某一数据</p>
<p>例如，修改“明日”同学的“语文”成绩，主要代码如下：</p>
<p>df.loc[‘明日’,’语文’]=115<br>（4）使用iloc属性修改数据<br>通过iloc属性指定行、列位置实现修改数据，主要代码如下：</p>
<p>01 df.iloc[0,0]=115                        #修改某一数据<br>02 df.iloc[:,0]=[115,108,112,118]          #修改整列数据<br>03 df.iloc[0,:]=[120,115,109]              #修改整行数据</p>
<h4 id="3-6-3-删除数据"><a href="#3-6-3-删除数据" class="headerlink" title="3.6.3　删除数据"></a>3.6.3　删除数据</h4><p>删除数据主要使用DataFrame对象的drop()方法。语法如下：</p>
<p>DataFrame.drop(labels=None, axis=0, index=None, columns=None, level=None, inplace=False, errors=’raise’)<br>参数说明：　</p>
<p>labels：表示行标签或列标签。　</p>
<p>axis：axis = 0，表示按行删除；</p>
<p>​            axis = 1，表示按列删除。默认值为0，即按行删除。　</p>
<p>index：删除行，默认值为None。　</p>
<p>columns：删除列，默认值为None。</p>
<p>level：针对有两级索引的数据。level = 0，表示按第1级索引删除整行；level = 1表示按第2级索引删除整行，默认值为None。　inplace：可选参数，对原数组做出修改并返回一个新数组。默认值为False，如果值为True，那么原数组直接就被替换。　</p>
<p>errors：参数值为ignore或raise，默认值为raise，如果值为ignore（忽略），则取消错误。</p>
<h5 id="1．删除行、列数据"><a href="#1．删除行、列数据" class="headerlink" title="1．删除行、列数据"></a>1．删除行、列数据</h5><p>【示例35】　删除学生成绩数据。（示例位置：资源包\MR\Code\03\35）<br>删除指定的学生成绩数据，主要代码如下：</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018054027938.png" srcset="/img/loading.gif" lazyload alt="image-20211018054027938"></p>
<h5 id="2．删除特定条件的行"><a href="#2．删除特定条件的行" class="headerlink" title="2．删除特定条件的行"></a>2．删除特定条件的行</h5><p>删除满足特定条件的行，首先找到满足该条件的行索引，然后再使用drop()方法将其删除。</p>
<p>【示例36】　删除符合条件的学生成绩数据。（示例位置：资源包\MR\Code\03\36）<br>删除“数学”成绩中包含88的行、“语文”成绩中小于110的行，主要代码如下：</p>
<p>01 df.drop(index=df[df[‘数学’].<strong>isin</strong>([88])].index[0],inplace=True)      #删除“数学”成绩中包含88的行<br>02 df.drop(index=df[df[‘语文’]&lt;110].index[0],inplace=True)             #删除“语文”成绩中小于110的行说明<br>以上代码中的方法都可以实现删除指定的行、列数据，读者选择一种即可。</p>
<h3 id="3-7-数据清洗"><a href="#3-7-数据清洗" class="headerlink" title="3.7　数据清洗"></a>3.7　数据清洗</h3><h4 id="3-7-1-缺失值查看与处理"><a href="#3-7-1-缺失值查看与处理" class="headerlink" title="3.7.1　缺失值查看与处理"></a>3.7.1　缺失值查看与处理</h4><p>缺失值是指由于某种原因导致数据为空，这种情况一般有不处理、删除、填充／替换、插值（以均值／中位数／众数等填补）这4种处理方式。</p>
<h5 id="1．缺失值查看"><a href="#1．缺失值查看" class="headerlink" title="1．缺失值查看"></a>1．缺失值查看</h5><p>首先需要找到缺失值，主要使用DataFrame对象的info()方法。</p>
<p>【示例37】　查看数据概况。（示例位置：资源包\MR\Code\03\37）以淘宝销售数据为例，首先输出数据，然后使用info()方法查看数据，程序代码如下：</p>
<p>01 import pandas as pd<br>02 df=pd.read_excel(‘TB2018.xls’)<br>03 print(df)<br>04 print(df.info())</p>
<p>运行程序，控制台输出结果如图3.43所示。</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018054304916.png" srcset="/img/loading.gif" lazyload alt="image-20211018054304916"></p>
<p>图3.43　缺失值查看<br>在Python中，缺失值一般用NaN表示，如图3.43所示。通过info()方法可看到“买家会员名”“买家实际支付金额”“宝贝标题”“订单付款时间”的非空数量是10，而“宝贝总数量”和“类别”的非空数量是8，那么说明这两项存在空值。</p>
<p>【示例38】　判断数据是否存在缺失值。（示例位置：资源包\MR\Code\03\38）<br>接下来，判断数据是否存在缺失值还可以使用isnull()方法和notnull()方法，主要代码如下：</p>
<p>01  print(df.isnull())<br>02  print(df.notnull())<br>运行程序，控制台输出结果如图3.44所示。</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018054406384.png" srcset="/img/loading.gif" lazyload alt="image-20211018054406384"></p>
<p>​                                                                                              图3.44　判断缺失值<br>使用isnull()方法缺失值返回True，非缺失值返回False；而notnull()方法与isnull()方法正好相反，缺失值返回False，非缺失值返回True。<br>如果使用df[df.isnull() == False]，</p>
<p>则会将所有非缺失值的数据找出来，只针对Series对象。</p>
<h5 id="2．缺失值删除处理"><a href="#2．缺失值删除处理" class="headerlink" title="2．缺失值删除处理"></a>2．缺失值删除处理</h5><p>通过前面的判断得知数据缺失情况，下面将缺失值删除，主要使用dropna()方法，该方法用于删除含有缺失值的行，主要代码如下：</p>
<p>df1=df.dropna()<br>运行程序，输出结果如图3.45所示。说明<br>有些时候数据可能存在整行为空的情况，此时可以在dropna()方法中指定参数how=’all’，删除所有空行。</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018054531853.png" srcset="/img/loading.gif" lazyload alt="image-20211018054531853"></p>
<p>​                                                                                   图3.45　缺失值删除处理1<br>从运行结果得知：dropna()方法将所有包含缺失值的数据全部删除了。那么，此时如果我们认为有些数据虽然存在缺失值，但是不影响数据分析，那么可以使用以下方法处理。例如，上述数据中只保留“宝贝总数量”不存在缺失值的数据，而类别是否缺失不关注，则可以使用notnull()方法判断，主要代码如下：</p>
<p>df2=df[df[‘宝贝总数量’].notnull()]<br>运行程序，输出结果如图3.46所示。</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018054627170.png" srcset="/img/loading.gif" lazyload alt="image-20211018054627170"></p>
<p>图3.46　缺失值删除处理2</p>
<h5 id="3．缺失值填充处理"><a href="#3．缺失值填充处理" class="headerlink" title="3．缺失值填充处理"></a>3．缺失值填充处理</h5><p>对于缺失数据，如果比例高于30%可以选择放弃这个指标，做删除处理；低于30%尽量不要删除，而是选择将这部分数据填充，一般以0、均值、众数（大多数）填充。DataFrame对象中的fillna()函数可以实现填充缺失数据，pad/ffill表示用前一个非缺失值去填充该缺失值；backfill/bfill表示用下一个非缺失值填充该缺失值；None用于指定一个值去替换缺失值。</p>
<p>【示例39】　将NaN填充为0。（示例位置：资源包\MR\Code\03\39）对于用于计算的数值型数据如果为空，可以选择用0填充。例如，将“宝贝总数量”为空的数据填充为0，主要代码如下：</p>
<p>df[‘宝贝总数量’] = df[‘宝贝总数量’].fillna(0)<br>运行程序，输出结果如图3.47所示。</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018054749852.png" srcset="/img/loading.gif" lazyload alt="image-20211018054749852"></p>
<p>​                                                                                                图3.47　缺失值填充处理</p>
<h4 id="3-7-2-重复值处理"><a href="#3-7-2-重复值处理" class="headerlink" title="3.7.2　重复值处理"></a>3.7.2　重复值处理</h4><p>对于数据中存在的重复数据，包括重复的行或者几行中某几列的值重复一般做删除处理，主要使用DataFrame对象的drop_duplicates()方法。</p>
<p>【示例40】　处理淘宝电商销售数据中的重复数据。（示例位置：资源包\MR\Code\03\40）下面以“1月.xlsx”淘宝销售数据为例，对其中的重复数据进行处理。<br>（1）判断每一行数据是否重复（完全相同），主要代码如下：</p>
<p>df1.duplicated()<br>如果返回值为False表示不重复，返回值为True表示重复。<br>（2）去除全部的重复数据，主要代码如下：</p>
<p>df1.drop_duplicates()<br>（3）去除指定列的重复数据，主要代码如下：</p>
<p>df1.drop_duplicates([‘买家会员名’])<br>（4）保留重复行中的最后一行，主要代码如下：</p>
<p>df1.drop_duplicates([‘买家会员名’],keep=’last’)</p>
<p>说明<br>以上代码中参数keep的值有3个。当keep=’first’表示保留第一次出现的重复行，是默认值；当keep为另外两个取值，即last和False时，分别表示保留最后一次出现的重复行和去除所有重复行。<br>（5）直接删除，保留一个副本，主要代码如下：</p>
<p>df1.drop_duplicates([‘买家会员名’,’买家支付宝账号’],inplace=Fasle)<br>inplace=True表示直接在原来的DataFrame上删除重复项，而默认值False表示删除重复项后生成一个副本。</p>
<h4 id="3-7-3-异常值的检测与处理"><a href="#3-7-3-异常值的检测与处理" class="headerlink" title="3.7.3　异常值的检测与处理"></a>3.7.3　异常值的检测与处理</h4><p>首先了解一下什么是异常值。在数据分析中异常值是指超出或低于正常范围的值，如年龄大于200、身高大于3米、宝贝总数量为负数等类似数据。那么这些数据如何检测呢？主要有以下几种方法。<br>（1）根据给定的数据范围进行判断，不在范围内的数据视为异常值。<br>（2）均方差。<br>在统计学中，如果一个数据分布近似正态分布（数据分布的一种形式，正态分布的概率密度函数曲线呈钟形，两头低、中间高、左右对称，因此人们又经常称之为钟形曲线），那么大约68%的数据值会在均值的一个标准差范围内，大约95%会在两个标准差范围内，大约99.7%会在3个标准差范围内。<br>（3）箱形图。<br>箱形图是显示一组数据分散情况资料的统计图。它可以将数据通过四分位数的形式进行图形化描述。箱形图通过上限和下限作为数据分布的边界。任何高于上限或低于下限的数据都可以认为是异常值，如图3.48所示。</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018055103761.png" srcset="/img/loading.gif" lazyload alt="image-20211018055103761"></p>
<p>​                                                                                            图3.48　箱形图说明<br>有关箱形图的介绍以及如何通过箱形图识别异常值可参见第6章。<br>了解了异常值的检测，接下来介绍如何处理异常值，主要包括以下几种处理方式。<br>（1）最常用的方式是删除。<br>（2）将异常值当缺失值处理，以某个值填充。<br>（3）将异常值当特殊情况进行分析，研究异常值出现的原因。</p>
<h3 id="3-8-索引设置"><a href="#3-8-索引设置" class="headerlink" title="3.8 索引设置"></a>3.8 索引设置</h3><p>索引能够快速查询数据，本节主要介绍索引的作用以及索引的应用。</p>
<h4 id="3-8-1-索引的作用"><a href="#3-8-1-索引的作用" class="headerlink" title="3.8.1　索引的作用"></a>3.8.1　索引的作用</h4><p>索引的作用相当于图书的目录，可以根据目录中的页码快速找到所需的内容。Pandas索引的作用如下。　更方便查询数据。　使用索引可以提升查询性能。　如果索引是唯一的，Pandas会使用哈希表优化，查找数据的时间复杂度为O(1)。　如果索引不是唯一的，但是有序，Pandas会使用二分查找算法，查找数据的时间复杂度为O(logN)。　如果索引是完全随机的，那么每次查询都要扫描数据表，查找数据的时间复杂度为O(N)。　自动的数据对齐功能，示意图如图3.49所示。</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018113947441.png" srcset="/img/loading.gif" lazyload alt="image-20211018113947441"></p>
<p>​                                                                                    图3.49　自动数据对齐示意图<br>实现上述效果，程序代码如下：</p>
<p>01 import pandas as pd<br>02 s1 = pd.Series([10,20,30],index= list(“abc”))<br>03 s2 = pd.Series([2,3,4],index=list(“bcd”))<br>04 print(s1 + s2)　强大的数据结构。　基于分类数的索引，提升性能。　多维索引，用于groupby多维聚合结果等。　时间类型索引，强大的日期和时间的方法支持。</p>
<h4 id="3-8-2-重新设置索引"><a href="#3-8-2-重新设置索引" class="headerlink" title="3.8.2　重新设置索引"></a>3.8.2　重新设置索引</h4><p>Pandas有一个很重要的方法是reindex()，它的作用是创建一个适应新索引的新对象。语法如下：</p>
<p>DataFrame.reindex(labels = None,index = None,columns = None,axis = None,method = None,copy = True,level =<br>None,fill_value = nan,limit = None,tolerance = None)<br>常用参数说明：　</p>
<p>labels：标签，可以是数组，默认值为None（无）。　</p>
<p>index：行索引，默认值为None。　</p>
<p>columns：列索引，默认值为None。</p>
<p>axis：轴，axis=0表示行，axis=1表示列。默认值为None。　</p>
<p>method：默认值为None，重新设置索引时，选择插值（一种填充缺失数据的方法）方法，其值可以是None、bfill/backfill（向后填充）、ffill/pad（向前填充）等。　</p>
<p>fill_value：缺失值要填充的数据。如缺失值不用NaN填充，而用0填充，则设置fill_value=0即可。</p>
<h5 id="1．对Series对象重新设置索引"><a href="#1．对Series对象重新设置索引" class="headerlink" title="1．对Series对象重新设置索引"></a>1．对Series对象重新设置索引</h5><p>【示例41】　重新设置物理成绩的索引。（示例位置：资源包\MR\Code\03\41）<br>在3.2.3节已经建立了一组学生的物理成绩，下面重新设置索引，程序代码如下：</p>
<p>01 import pandas as pd<br>02 s1=pd.Series([88,60,75],index=[1,2,3])<br>03 print(s1)<br>04 print(s1.reindex([1,2,3,4,5]))<br>运行程序，控制台输出结果对比如图3.50和图3.51所示。</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018124142285.png" srcset="/img/loading.gif" lazyload alt="image-20211018124142285"></p>
<p>​                                                                                                              图3.50　原数据</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018124200693.png" srcset="/img/loading.gif" lazyload alt="image-20211018124200693"></p>
<p>​                                                                                                 图3.51　重新设置索引<br>从运行结果得知：reindex()方法根据新索引进行了重新排序，并且对缺失值自动填充NaN。如果不想用NaN填充，则可以为fill_value参数指定值，如0，主要代码如下：</p>
<p>s1.reindex([1,2,3,4,5],fill_value=0)<br>而对于一些有一定顺序的数据，我们可能需要插值（插值是一种填充缺失数据的方法）来填充缺失的数据，可以使用method参数。</p>
<p>【示例42】　向前和向后填充数据。（示例位置：资源包\MR\Code\03\42）向前填充（和前面数据一样）、向后填充（和后面数据一样），主要代码如下：</p>
<p>01 print(s1.reindex([1,2,3,4,5],method=’ffill’))   #向前填充<br>02 print(s1.reindex([1,2,3,4,5],method=’bfill’))   #向后填充</p>
<h5 id="2．对DataFrame对象重新设置索引"><a href="#2．对DataFrame对象重新设置索引" class="headerlink" title="2．对DataFrame对象重新设置索引"></a>2．对DataFrame对象重新设置索引</h5><p>对于DataFrame对象，reindex()方法用于修改行索引和列索引。</p>
<p>【示例43】　创建成绩表并重新设置索引。（示例位置：资源包\MR\Code\03\43）通过二维数组创建成绩表，程序代码如下：</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018124525086.png" srcset="/img/loading.gif" lazyload alt="image-20211018124525086">通过reindex()方法重新设置行索引，主要代码如下：</p>
<p>df.reindex([‘mr001’,’mr002’,’mr003’,’mr004’,’mr005’])<br>通过reindex()方法重新设置列索引，主要代码如下：</p>
<p>df.reindex(columns=[‘语文’,’物理’,’数学’,’英语’])<br>通过reindex()方法重新设置行索引和列索引，主要代码如下：</p>
<p>df.reindex(index=[‘mr001’,’mr002’,’mr003’,’mr004’,’mr005’],columns=[‘语文’,’物理’,’数学’,’英语’])<br>运行程序，控制台输出结果分别为原始数据（见图3.52）、重新设置行索引（见图3.53）、重新设置列索引（见图3.54）、重新设置行、列索引（见图3.55）。</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018124708302.png" srcset="/img/loading.gif" lazyload alt="image-20211018124708302"></p>
<p>​                                                                                                  图3.52　原始数据</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018124737241.png" srcset="/img/loading.gif" lazyload alt="image-20211018124737241"></p>
<p>​                                                                                                 图3.53　重新设置行索引</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018124821931.png" srcset="/img/loading.gif" lazyload alt="image-20211018124821931"></p>
<p>​                                                                                                   图3.54　重新设置列索引</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018124905647.png" srcset="/img/loading.gif" lazyload alt="image-20211018124905647"></p>
<h4 id="3-8-3-设置某列为行索引"><a href="#3-8-3-设置某列为行索引" class="headerlink" title="3.8.3　设置某列为行索引"></a>3.8.3　设置某列为行索引</h4><p>设置某列为行索引主要使用set_index()方法。</p>
<p>【示例44】　设置“买家会员名”为行索引。（示例位置：资源包\MR\Code\03\44）<br>首先，导入“1月.xlsx”Excel文件，程序代码如下：</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018125022369.png" srcset="/img/loading.gif" lazyload alt="image-20211018125022369"></p>
<p>运行程序，输出结果如图3.56所示。<br>此时默认行索引为0、1、2、3、4，下面将“买家会员名”作为行索引，主要代码如下：</p>
<p>df2=df.set_index([‘买家会员名’])<br>运行程序，输出结果如图3.57所示。</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018125215478.png" srcset="/img/loading.gif" lazyload alt="image-20211018125215478"></p>
<p>​                                                                                                图3.56　1月淘宝销售数据（部分数据）</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018125235811.png" srcset="/img/loading.gif" lazyload alt="image-20211018125235811"></p>
<p>​                                                                                                       图3.57　设置“买家会员名”为索引<br>如果在set_index()方法中传入参数drop=True，则会删除“买家会员名”；如果传入drop=False，则会保留“买家会员名”。默认为False。</p>
<h4 id="3-8-4-数据清洗后重新设置连续的行索引"><a href="#3-8-4-数据清洗后重新设置连续的行索引" class="headerlink" title="3.8.4　数据清洗后重新设置连续的行索引"></a>3.8.4　数据清洗后重新设置连续的行索引</h4><p>在对Dataframe对象进行数据清洗后，例如去掉含NaN的行之后，发现行索引还是原来的行索引，对比效果如图3.58和图3.59所示。</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018125500556.png" srcset="/img/loading.gif" lazyload alt="image-20211018125500556"></p>
<p>​                                                                                            图3.58　原数据</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018125521969.png" srcset="/img/loading.gif" lazyload alt="image-20211018125521969"></p>
<p>​                                                                           图3.59　数据清洗后还是原来的索引</p>
<p>【示例45】　删除数据后重新设置索引。（示例位置：资源包\MR\Code\03\45）</p>
<p>如果要重新设置索引可以使用reset_index()方法，在删除缺失数据后重新设置索引，主要代码如下：</p>
<p>df2=df.dropna().reset_index(drop=True)<br>运行程序，输出结果如图3.60所示。</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018125620746.png" srcset="/img/loading.gif" lazyload alt="image-20211018125620746"></p>
<p>​                                                                           图3.60　数据清洗后重新设置连续的行索引<br>另外，对于分组统计后的数据，有时也需要重新设置连续的行索引，方法同上。</p>
<h3 id="3-9-数据排序与排名"><a href="#3-9-数据排序与排名" class="headerlink" title="3.9　数据排序与排名"></a>3.9　数据排序与排名</h3><p>本节主要介绍数据的各种排序和排名方法。</p>
<h4 id="3-9-1-数据排序"><a href="#3-9-1-数据排序" class="headerlink" title="3.9.1　数据排序"></a>3.9.1　数据排序</h4><p>DataFrame数据排序主要使用sort_values()方法，该方法类似于SQL中的ORDER BY。sort_values()方法可以根据指定行／列进行排序，语法如下：</p>
<p>DataFrame.sort_values(by,axis=0,ascending=True,inplace=False,kind=’quicksort’,na_position=’last’,ignore_<br>index=False)<br>参数说明：　</p>
<p>by：要排序的名称列表。</p>
<p>axis：轴，axis=0表示行，axis=1表示列。默认值为0，即按行排序。　</p>
<p>ascending：升序或降序排序，布尔值，指定多个排序可以使用布尔值列表。默认值为True。　</p>
<p>inplace：布尔值，默认值为False，如果值为True，则就地排序。　</p>
<p>kind：指定排序算法，值为quicksort（快速排序）、mergesort（混合排序）或heapsort（堆排），默认值为quicksort。　na_position：空值（NaN）的位置，值为first空值在数据开头，值为last空值在数据最后，默认值为last。　</p>
<p>ignore_index：布尔值，是否忽略索引，值为True标记索引（从0开始按顺序的整数值），值为False则忽略索引。</p>
<h5 id="1．按一列数据排序"><a href="#1．按一列数据排序" class="headerlink" title="1．按一列数据排序"></a>1．按一列数据排序</h5><p>【示例46】　按“销量”降序排序。（示例位置：资源包\MR\Code\03\46）<br>按“销量”降序排序，排序对比效果如图3.61和图3.62所示。</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018125836428.png" srcset="/img/loading.gif" lazyload alt="image-20211018125836428"></p>
<p>​                                                                                                     图3.61　原始数据</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018130000864.png" srcset="/img/loading.gif" lazyload alt="image-20211018130000864"></p>
<p>​                                                                                图3.62　按“销量”降序排序实用技巧<br>Spyder变量浏览窗口本身也支持数据排序，单击需要排序的列即可实现升序或降序排序。<br>程序代码如下：</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018130020866.png" srcset="/img/loading.gif" lazyload alt="image-20211018130020866"></p>
<h5 id="2．按多列数据排序"><a href="#2．按多列数据排序" class="headerlink" title="2．按多列数据排序"></a>2．按多列数据排序</h5><p>多列排序是按照给定列的先后顺序进行排序的。</p>
<p>【示例47】　按照“图书名称”和“销量”降序排序。（示例位置：资源包\MR\Code\03\47）<br>按照“图书名称”和“销量”降序排序，首先按“图书名称”降序排序，然后再按“销量”降序排序，排序后的效果如图3.63所示。</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018130140068.png" srcset="/img/loading.gif" lazyload alt="image-20211018130140068"></p>
<p>​                                                                图3.63　按照“图书名称”和“销量”降序排序<br>主要代码如下：</p>
<p>df1=df.sort_values(by=[‘图书名称’,’销量’])</p>
<h5 id="3．对统计结果排序"><a href="#3．对统计结果排序" class="headerlink" title="3．对统计结果排序"></a>3．对统计结果排序</h5><p>【示例48】　对分组统计数据进行排序。（示例位置：资源包\MR\Code\03\48）</p>
<p>按“类别”分组统计销量并进行降序排序，统计排序后的效果如图3.64所示。</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018130240441.png" srcset="/img/loading.gif" lazyload alt="image-20211018130240441"></p>
<p>​                                                                                 图3.64　按“类别”分组统计销量并降序排序<br>主要代码如下：</p>
<p>01 df1=df.groupby([“类别”])[“销量”].sum().reset_index()</p>
<p>2 df2=df1.sort_values(by=’销量’,ascending=False)</p>
<h5 id="4．按行数据排序"><a href="#4．按行数据排序" class="headerlink" title="4．按行数据排序"></a>4．按行数据排序</h5><p>【示例49】　按行数据排序。（示例位置：资源包\MR\Code\03\49）<br>按行排序，主要代码如下：</p>
<p>df=dfrow.sort_values(by=0,ascending=True,axis=1)注意<br>按行排序的数据类型要一致，否则会出现错误提示。</p>
<h4 id="3-9-2-数据排名"><a href="#3-9-2-数据排名" class="headerlink" title="3.9.2　数据排名"></a>3.9.2　数据排名</h4><p>排名是根据Series对象或DataFrame的某几列的值进行排名的，主要使用rank()方法，语法如下：</p>
<p>DataFrame.rank(axis=0,method=’average’,numeric_only=None,na_option=’keep’,ascending=True,pct=False)<br>参数说明：　</p>
<p>axis：轴，axis=0表示行，axis=1表示列。默认值为0，即按行排序。　</p>
<p>method：表示在具有相同值的情况下所使用的排序方法。设置值如下。　</p>
<p>average：默认值，平均排名。</p>
<p>min：最小值排名。　</p>
<p>max：最大值排名。　</p>
<p>first：按值在原始数据中的出现顺序分配排名。　</p>
<p>dense：密集排名，类似最小值排名，但是排名每次只增加1，即排名相同的数据只占一个名次。　</p>
<p>numeric_only：对于DataFrame对象，如果设置值为True，则只对数字列进行排序。　</p>
<p>na_option：空值的排序方式，设置值如下。　</p>
<p>keep：保留，将空值等级赋值给NaN值。　</p>
<p>top：如果按升序排序，则将最小排名赋值给NaN值。　</p>
<p>bottom：如果按升序排序，则将最大排名赋值给NaN值。　</p>
<p>ascending：升序或降序排序，布尔值，指定多个排序可以使用布尔值列表。默认值为True。　</p>
<p>pct：布尔值，是否以百分比形式返回排名。默认值为False。</p>
<p>1．顺序排名</p>
<p>【示例50】　对产品销量按顺序进行排名。（示例位置：资源包\MRCode\03\50）<br>下面对销量相同的产品，按照出现的顺序排名，程序代码如下：</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018130818619.png" srcset="/img/loading.gif" lazyload alt="image-20211018130818619"></p>
<p>程序运行结果如图3.65所示。<br>2．平均排名</p>
<p>【示例51】　对产品销量进行平均排名。（示例位置：资源包\MR\Code\03\51）<br>现在对销量相同的产品，按照顺序排名的平均值作为平均排名，主要代码如下：</p>
<p>01 df[‘平均排名’]=df[‘销量’].rank(ascending=False)</p>
<p>02 df1=df[[‘图书名称’,’销量’,’平均排名’]]<br>程序运行结果如图3.66所示。<br>3．最小值排名<br>排名相同的，按顺序排名取最小值作为排名，主要代码如下：</p>
<p>df[‘最小值排名’]=df[‘销量’].rank(method=”min”,ascending=False)<br>4．最大值排名<br>排名相同的，按顺序排名取最大值作为排名，主要代码如下：</p>
<p>df[‘最大值排名’]=df[‘销量’]rank(method=”max”,ascending=False)</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018131022583.png" srcset="/img/loading.gif" lazyload alt="image-20211018131022583"></p>
<p>​                                                                  图3.65　销量相同按出现的先后顺序排名</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018131037838.png" srcset="/img/loading.gif" lazyload alt="image-20211018131037838"></p>
<p>​                                                                   图3.66　销量相同按顺序排名的平均值排名</p>
<h3 id="3-10-小结"><a href="#3-10-小结" class="headerlink" title="3.10　小结"></a>3.10　小结</h3><p>本章介绍了Pandas数据处理的基本知识，从最初的数据来源开始（创建DataFrame数据或导入外部数据）到数据抽取、数据增删改操作、数据清洗、索引，再到数据排序，常用的数据处理操作基本都涉及了，通过本章的学习基本能够独立完成一些简单的数据处理工作。</p>
<h1 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h1><h2 id="4-1-数据计算"><a href="#4-1-数据计算" class="headerlink" title="4.1 数据计算"></a>4.1 数据计算</h2><p>Pandas提供了大量的数据计算函数，可以实现求和、求均值、求最大值、求最小值、求中位数、求众数、求方差、标准差等，从而使得数据统计变得简单高效。</p>
<h3 id="4-1-1求和函数（sum"><a href="#4-1-1求和函数（sum" class="headerlink" title="4.1.1求和函数（sum())"></a>4.1.1求和函数（sum())</h3><p>DataFrame.sum(axis=None, skipna=None, level=None, numeric_only=None, min_count=0, **kwargs)<br>参数说明：　</p>
<p>axis：axis=1表示行，axis=0表示列，默认值为None（无）。　skipna：布尔型，表示计算结果是否排除NaN/Null值，默认值为None。</p>
<p>level：表示索引层级，默认值为None。　</p>
<p>numeric_only：仅数字，布尔型，默认值为None。　</p>
<p>min_count：表示执行操作所需的数目，整型，默认值为0。　**kwargs：要传递给函数的附加关键字参数。　</p>
<p>返回值：返回Series对象或DataFrame对象。行或列求和数据。</p>
<p>【示例01】　计算语文、数学和英语三科的总成绩。（示例位置：资源包\MR\Code\04\01）<br>首先，创建一组DataFrame类型的数据，包括语文、数学和英语三科的成绩，如图4.1所示。<br>程序代码如下：</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/学习记录/专高三/讲义Pandas统计分析/image-20211020032035450.png" srcset="/img/loading.gif" lazyload alt="image-20211020032035450">下面使用sum()函数计算三科的总成绩，代码如下：</p>
<p>df[‘总成绩’]=df.sum(axis=1)</p>
<p>运行程序，输出结果如图4.2所示。</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/学习记录/专高三/讲义Pandas统计分析/image-20211020032210845.png" srcset="/img/loading.gif" lazyload alt="image-20211020032210845"></p>
<p>​                                        图4.1　DataFrame数据</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/学习记录/专高三/讲义Pandas统计分析/image-20211020032230748.png" srcset="/img/loading.gif" lazyload alt="image-20211020032230748"></p>
<p>​                                  图4.2　sum()函数计算三科的总成绩</p>
<h3 id="4-1-2-求均值（mean-函数）"><a href="#4-1-2-求均值（mean-函数）" class="headerlink" title="4.1.2　求均值（mean()函数）"></a>4.1.2　求均值（mean()函数）</h3><p>DataFrame.mean(axis=None, skipna=None, level=None, numeric_only=None, kwargs)<br>参数说明：　</p>
<p>axis：axis=1表示行，axis=0表示列，默认值为None（无）。　</p>
<p>skipna：布尔型，表示计算结果是否排除NaN/Null值，默认值为None。　</p>
<p>level：表示索引层级，默认值为None。　</p>
<p>numeric_only：仅数字，布尔型，默认值为None。　</p>
<p>kwargs：要传递给函数的附加关键字参数。　</p>
<p>返回值：返回Series对象或DataFrame对象。行或列平均值数据。</p>
<p>【示例02】　计算语文、数学和英语各科的平均分。（示例位置：资源包\MR\Code\04\02）<br>计算语文、数学和英语各科成绩的平均值，程序代码如下：</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/学习记录/专高三/讲义Pandas统计分析/image-20211020032641368.png" srcset="/img/loading.gif" lazyload alt="image-20211020032641368"></p>
<p>运行程序，输出结果如图4.3所示。</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020032714762.png" srcset="/img/loading.gif" lazyload alt="image-20211020032714762"></p>
<p>​                             图4.3　mean()函数计算三科成绩的平均值<br>从运行结果得知：语文平均分109，数学平均分107，英语平均分114.667。</p>
<h3 id="4-1-3-求最大值（max-函数）"><a href="#4-1-3-求最大值（max-函数）" class="headerlink" title="4.1.3　求最大值（max()函数）"></a>4.1.3　求最大值（max()函数）</h3><p>在Python中通过调用DataFrame对象的max()函数实现行／列数据最大值运算，语法如下：</p>
<p>DataFrame.max(axis=None, skipna=None, level=None, numeric_only=None, **kwargs)<br>参数说明：　**</p>
<p>**axis：axis=1表示行，axis=0表示列，默认值为None（无）。　skipna：布尔型，表示计算结果是否排除NaN/Null值，默认值为None。　</p>
<p>**level：表示索引层级，默认值为None。　</p>
<p>**numeric_only：仅数字，布尔型，默认值为None。　</p>
<p>kwargs：要传递给函数的附加关键字参数。　</p>
<p>返回值：返回Series对象或DataFrame对象。行或列最大值数据。</p>
<p>【示例03】　计算语文、数学和英语各科的最高分。（示例位置：资源包\MR\Code\04\03）<br>计算语文、数学和英语各科成绩的最大值，程序代码如下：</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/学习记录/专高三/讲义Pandas统计分析/image-20211020032850843.png" srcset="/img/loading.gif" lazyload alt="image-20211020032850843"></p>
<p>运行程序，输出结果如图4.4所示。</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/学习记录/专高三/讲义Pandas统计分析/image-20211020033031795.png" srcset="/img/loading.gif" lazyload alt="image-20211020033031795"></p>
<p>​                       图4.4　max()函数计算三科成绩的最大值</p>
<p>4.1.4　求最小值（min()函数）<br>在Python中通过调用DataFrame对象的min()函数实现行／列数据最小值运算，语法如下：</p>
<p>DataFrame.min(axis=None, skipna=None, level=None, numeric_only=None, **kwargs)<br>参数说明：　**</p>
<p>**axis：axis=1表示行，axis=0表示列，默认值为None（无）。　skipna：布尔型，表示计算结果是否排除NaN/Null值，默认值为None。　</p>
<p>**level：表示索引层级，默认值为None。　</p>
<p>**numeric_only：仅数字，布尔型，默认值为None。　</p>
<p>kwargs：要传递给函数的附加关键字参数。　</p>
<p>返回值：返回Series对象或DataFrame对象。行或列最小值数据。</p>
<p>【示例04】　计算语文、数学和英语各科的最低分。（示例位置：资源包\MR\Code\04\04）<br>计算语文、数学和英语各科成绩的最小值，程序代码如下：</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/学习记录/专高三/讲义Pandas统计分析/image-20211020033254349.png" srcset="/img/loading.gif" lazyload alt="image-20211020033254349"></p>
<p>运行程序，输出结果如图4.5所示。</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/学习记录/专高三/讲义Pandas统计分析/image-20211020033314763.png" srcset="/img/loading.gif" lazyload alt="image-20211020033314763"></p>
<h3 id="4-1-5-求中位数（median-函数）"><a href="#4-1-5-求中位数（median-函数）" class="headerlink" title="4.1.5　求中位数（median()函数）"></a>4.1.5　求中位数（median()函数）</h3><p>中位数又称中值，是统计学专有名词，是指按顺序排列的一组数据中位于中间位置的数，其不受异常值的影响。例如，年龄23、45、35、25、22、34、28这7个数，中位数就是排序后位于中间的数字，即28；而年龄23、45、35、25、22、34、28、27这8个数，中位数则是排序后位于中间两个数的平均值，即27.5。在Python中直接调用DataFrame对象的median()函数就可以轻松实现中位数的运算，语法如下：</p>
<p>DataFrame.median(axis=None,skipna=None,level=None,numeric_only=None,**kwargs)<br>参数说明：　**</p>
<p>**axis：axis=1表示行，axis=0表示列，默认值为None（无）。　skipna：布尔型，表示计算结果是否排除NaN/Null值，默认值为None。　</p>
<p>**level：表示索引层级，默认值为None。　</p>
<p>**numeric_only：仅数字，布尔型，默认值为None。　</p>
<p>kwargs：要传递给函数的附加关键字参数。　</p>
<p>返回值：返回Series对象或DataFrame对象。</p>
<p>【示例05】　计算学生各科成绩的中位数1。（示例位置：资源包\MR\Code\04\05）<br>下面给出一组数据（3条记录），然后使用median()函数计算语文、数学和英语各科成绩的中位数，程序代码如下：</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/学习记录/专高三/讲义Pandas统计分析/image-20211020033458773.png" srcset="/img/loading.gif" lazyload alt="image-20211020033458773"></p>
<p>运行程序，控制台输出结果如下：</p>
<p>语文    130.0数学    120.0英语    130.0</p>
<p>【示例06】　计算学生各科成绩的中位数2。（示例位置：资源包\MR\Code\04\06）<br>下面再给出一组数据（4条记录），同样使用median()函数计算语文、数学和英语各科成绩的中位数，程序代码如下：</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/学习记录/专高三/讲义Pandas统计分析/image-20211020033625031.png" srcset="/img/loading.gif" lazyload alt="image-20211020033625031"></p>
<p>运行程序，控制台输出结果如下：</p>
<p>语文    121.5数学    121.5英语    120.0</p>
<h3 id="4-1-6-求众数（mode-函数）"><a href="#4-1-6-求众数（mode-函数）" class="headerlink" title="4.1.6　求众数（mode()函数）"></a>4.1.6　求众数（mode()函数）</h3><p>什么是众数？众数的众字有多的意思，顾名思义，众数就是一组数据中出现最多的数称为众数，它代表了数据的一般水平。<br>在Python中通过调用DataFrame对象的mode()函数可以实现众数运算，语法如下：</p>
<p>DataFrame.mode(axis=0,numeric_only=False,dropna=True)<br>参数说明：　</p>
<p>axis：axis=1表示行，axis=0表示列，默认值为0。　</p>
<p>numeric_only：仅数字，布尔型，默认值为False。如果值为True，则仅适用于数字列。　</p>
<p>dropna：是否删除缺失值，布尔型，默认值为True。　</p>
<p>返回值：返回Series对象或DataFrame对象。<br>首先看一组原始数据，如图4.6所示。</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020033849240.png" srcset="/img/loading.gif" lazyload alt="image-20211020033849240"></p>
<p>【示例07】　计算学生各科成绩的众数。（示例位置：资源包\MR\Code\04\07）<br>计算语文、数学和英语三科成绩的众数、每一行的众数和“数学”成绩的众数，程序代码如下：</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020034005721.png" srcset="/img/loading.gif" lazyload alt="image-20211020034005721"></p>
<p>三科成绩的众数：<br>每一行的众数：</p>
<p>0  110<br>1  130<br>2  130<br>数学成绩的众数：</p>
<p>0  120</p>
<h3 id="4-1-7-求方差（var-函数）"><a href="#4-1-7-求方差（var-函数）" class="headerlink" title="4.1.7　求方差（var()函数）"></a>4.1.7　求方差（var()函数）</h3><p>方差用于衡量一组数据的离散程度，即各组数据与它们的平均数的差的平方，那么我们用这个结果来衡量这组数据的波动大小，并把它叫作这组数据的方差，方差越小越稳定。通过方差可以了解一个问题的波动性。下面简单介绍下方差的意义，相信通过一个简单的举例您就会了解。<br>例如，某校两名同学的物理成绩都很优秀，而参加物理竞赛的名额只有一个，那么选谁去获得名次的机率更大呢？于是根据历史数据计算出了两名同学的平均成绩，但结果是实力相当，平均成绩都是107.6，怎么办呢？这时让方差帮决定，看看谁的成绩更稳定。首先汇总物理成绩，如图4.7所示。</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020034219502.png" srcset="/img/loading.gif" lazyload alt="image-20211020034219502"></p>
<p>​                                            图4.7　物理成绩<br>通过方差对比两名同学物理成绩的波动，如图4.8所示。</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020034235082.png" srcset="/img/loading.gif" lazyload alt="image-20211020034235082"></p>
<p>​                                                   图4.8　方差<br>接着来看一下总体波动（方差和），“小黑”的数据是73.2，“小白”的数据是949.2，很明显“小黑”的物理成绩波动较小，发挥更稳定，所以应该选“小黑”参加物理竞赛。<br>以上举例就是方差的意义。大数据时代，它能够帮助我们解决很多身边的问题、协助我们做出合理的决策。<br>在Python中通过调用DataFrame对象的var()函数可以实现方差运算，语法如下：</p>
<p><strong>DataFrame.var(axis=None,skipna=None,level=None,ddof=1,numeric_only=None,kwargs)</strong><br>参数说明：　</p>
<p>axis：axis=1表示行，axis=0表示列，默认值为None（无）。　skipna：布尔型，表示计算结果是否排除NaN/Null值，默认值为None。　</p>
<p>level：表示索引层级，默认值为None。　</p>
<p>ddof：整型，默认值为1。自由度，计算中使用的除数是N-ddof，其中N表示元素的数量。　</p>
<p>numeric_only：仅数字，布尔型，默认值为None。　</p>
<p>kwargs：要传递给函数的附加关键字参数。　</p>
<p>返回值：返回Series对象或DataFrame对象。</p>
<p>【示例08】　通过方差判断谁的物理成绩更稳定。（示例位置：资源包\MR\Code\04\08）<br>计算“小黑”和“小白”物理成绩的方差，程序代码如下：</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020034435272.png" srcset="/img/loading.gif" lazyload alt="image-20211020034435272"></p>
<p>运行程序，控制台输出结果如下：</p>
<p>小黑     18.3小白    237.3<br>从运行结果得知：“小黑”的物理成绩波动较小，发挥更稳定。这里需要注意的是，Pandas中计算的方差为无偏样本方差（即方差和／样本数-1），NumPy中计算的方差就是样本方差本身（即方差和／样本数）。</p>
<h3 id="4-1-8-标准差（数据标准化std-函数）"><a href="#4-1-8-标准差（数据标准化std-函数）" class="headerlink" title="4.1.8　标准差（数据标准化std()函数）"></a>4.1.8　标准差（数据标准化std()函数）</h3><p>标准差又称均方差，是方差的平方根，用来表示数据的离散程度。<br>在Python中通过调用DataFrame对象的std()函数求标准差，语法如下：</p>
<p>DataFrame.std(axis=None,skipna=None,level=None,ddof=1,numeric_only=None,**kwargs)<br>std()函数的参数与var()函数一样，这里不再赘述。</p>
<p>【示例09】　计算各科成绩的标准差。（示例位置：资源包\MR\Code\04\09）<br>使用std()函数计算标准差，程序代码如下：</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020034453875.png" srcset="/img/loading.gif" lazyload alt="image-20211020034453875"></p>
<p>运行程序，控制台输出结果如下：</p>
<p>语文    11.547005数学     5.773503英语    11.5547005</p>
<h3 id="4-1-9-求分位数（quantile-函数）"><a href="#4-1-9-求分位数（quantile-函数）" class="headerlink" title="4.1.9　求分位数（quantile()函数）"></a>4.1.9　求分位数（quantile()函数）</h3><p>分位数也称分位点，它以概率依据将数据分割为几个等份，常用的有中位数（即二分位数）、四分位数、百分位数等。分位数是数据分析中常用的一个统计量，经过抽样得到一个样本值。例如，经常会听老师说：“这次考试竟然有20%的同学不及格！”，那么这句话就体现了分位数的应用。在Python中通过调用DataFrame对象的quantile()函数求分位数，语法如下：</p>
<p><strong>DataFrame.quantile(q=0.5,axis=0,numeric_only=True, interpolation=’linear’)</strong><br>参数说明：　</p>
<p>q：浮点型或数组，默认为0.5（50%分位数），其值为0～1。　</p>
<p>axis：axis=1表示行，axis=0表示列。默认值为0。　</p>
<p>numeric_only：仅数字，布尔型，默认值为True。　</p>
<p>interpolation：内插值，可选参数[{‘linear’,‘lower’,‘higher’,‘midpoint’,‘nearest’}]用于指定要使用的插值方法，当期望的分位数为数据点i～j时。　</p>
<p>​    linear’：i+(j-i)×分数，其中分数是指数被i和j包围的小数部分。　</p>
<p>​    lower：i。　</p>
<p>​    higher：j。　</p>
<p>​    nearest：i或j二者以最近者为准。　</p>
<p>​    midpoint：(i+j)/2。　</p>
<p>返回值：返回Series或DataFrame对象。</p>
<p>【示例10】　通过分位数确定被淘汰的35%的学生。（示例位置：资源包\MR\Code\04\10）<br>以学生成绩为例，数学成绩分别为120、89、98、78、65、102、112、56、79、45的10名同学，现根据分数淘汰35%的学生，该如何处理？首先使用quantile()函数计算35%的分位数，然后将学生成绩与分位数比较，筛选小于等于分位数的学生，程序代码如下：</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020035437337.png" srcset="/img/loading.gif" lazyload alt="image-20211020035437337"></p>
<p>运行程序，控制台输出结果如下：</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020035513992.png" srcset="/img/loading.gif" lazyload alt="image-20211020035513992"></p>
<p>从运行结果得知：即将被淘汰的学生有4名，分数分别为78、65、56和45。</p>
<p>【示例11】　计算日期、时间和时间增量数据的分位数。（示例位置：资源包\MR\Code\04\11）<br>如果参数numeric_only=False，将计算日期、时间和时间增量数据的分位数，程序代码如下：<br>运行程序，控制台输出结果如下：</p>
<p>A                  1.5<br>B 2019-07-02 12:00:00<br>C          1 days 12:00:00<br>Name: 0.5, dtype: object</p>
<h2 id="4-2-数据格式化"><a href="#4-2-数据格式化" class="headerlink" title="4.2　数据格式化"></a>4.2　数据格式化</h2><p>在进行数据处理时，尤其是在数据计算中应用求均值（mean()函数）后，发现结果中的小数位数增加了许多。此时就需要对数据进行格式化，以增加数据的可读性。例如，保留小数点位数、百分号、千位分隔符等。首先来看一组数据，如图4.9所示。</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020035851798.png" srcset="/img/loading.gif" lazyload alt="image-20211020035851798"></p>
<p>​                                         图4.9　原始数据</p>
<h3 id="4-2-1-设置小数位数"><a href="#4-2-1-设置小数位数" class="headerlink" title="4.2.1　设置小数位数"></a>4.2.1　设置小数位数</h3><p>设置小数位数主要使用DataFrame对象的round()函数，该函数可以实现四舍五入，而它的decimals参数则用于设置保留小数的位数，设置后数据类型不会发生变化，依然是浮点型。语法如下：</p>
<p>DataFrame.round(decimals=0, *args, **kwargs)　**</p>
<p>decimals：每一列四舍五入的小数位数，整型、字典或Series对象。如果是整数，则将每一列四舍五入到相同的位置。否则，将字典和Series舍入到可变数目的位置；如果小数是类似于字典的，那么列名应该在键中；如果小数是级数，列名应该在索引中。没有包含在小数中的任何列都将保持原样。非输入列的小数元素将被忽略。　</p>
<p>args：附加的关键字参数。　</p>
<p>kwargs：附加的关键字参数。　</p>
<p>返回值：返回DataFrame对象。</p>
<p>【示例12】　四舍五入保留指定的小数位数。（示例位置：资源包\MR\Code\04\12）<br>使用round()函数四舍五入保留小数位数，程序代码如下：</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020040002742.png" srcset="/img/loading.gif" lazyload alt="image-20211020040002742"></p>
<p>运行程序，控制台输出结果如下：</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020040023289.png" srcset="/img/loading.gif" lazyload alt="image-20211020040023289"></p>
<p>当然，保留小数位数也可以用自定义函数，例如，为DataFrame对象中的各个浮点值保留两位小数，主要代码如下：</p>
<p>df.applymap(lambda x: ‘%.2f’%x)</p>
<p>注意<br>经过自定义函数处理过的数据将不再是浮点型而是对象型，如果后续计算需要数据，则应先进行数据类型转换。</p>
<h3 id="4-2-2-设置百分比"><a href="#4-2-2-设置百分比" class="headerlink" title="4.2.2　设置百分比"></a>4.2.2　设置百分比</h3><p>在数据分析过程中，有时需要百分比数据。那么，利用自定义函数将数据进行格式化处理，处理后的数据就可以从浮点型转换成带指定小数位数的百分比数据，主要使用apply()函数与format()函数。</p>
<p>【示例13】　将指定数据格式化为百分比数据。（示例位置：资源包\MR\Code\04\13）<br>将A1列的数据格式化为百分比数据，程序代码如下：</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020040234891.png" srcset="/img/loading.gif" lazyload alt="image-20211020040234891"></p>
<p>运行程序，控制台输出结果如下：</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020040335780.png" srcset="/img/loading.gif" lazyload alt="image-20211020040335780"></p>
<h3 id="4-2-3-设置千位分隔符"><a href="#4-2-3-设置千位分隔符" class="headerlink" title="4.2.3　设置千位分隔符"></a>4.2.3　设置千位分隔符</h3><p>由于业务需要，有时需要将数据格式化为带千位分隔符的数据。那么，处理后的数据将不再是浮点型而是对象型。</p>
<p>【示例14】　将金额格式化为带千位分隔符的数据。（示例位置：资源包\MR\Code\04\14）<br>将图书销售码洋格式化为带千位分隔符的数据，程序代码如下：</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020040604750.png" srcset="/img/loading.gif" lazyload alt="image-20211020040604750"></p>
<p>运行程序，控制台输出结果如下：</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020040623599.png" srcset="/img/loading.gif" lazyload alt="image-20211020040623599"></p>
<p>注意<br>设置千位分隔符后，对于程序来说，这些数据将不再是数值型，而是数字和逗号组成的字符串，如果由于程序需要再变成数值型就会很麻烦，因此设置千位分隔符要慎重。</p>
<h2 id="4-3-数据分组统计"><a href="#4-3-数据分组统计" class="headerlink" title="4.3　数据分组统计"></a>4.3　数据分组统计</h2><p>本节主要介绍分组统计函数groupby()的各种应用。</p>
<h3 id="4-3-1-分组统计groupby-函数"><a href="#4-3-1-分组统计groupby-函数" class="headerlink" title="4.3.1　分组统计groupby()函数"></a>4.3.1　分组统计groupby()函数</h3><p>对数据进行分组统计，主要使用DataFrame对象的groupby()函数，其功能如下。<br>（1）根据给定的条件将数据拆分成组。</p>
<p>（2）每个组都可以独立应用函数（如求和函数sum()、求平均值函数mean()等）。<br>（3）将结果合并到一个数据结构中。<br>groupby()函数用于将数据按照一列或多列进行分组，一般与计算函数结合使用，实现数据的分组统计，语法如下：</p>
<p><strong>DataFrame.groupby(by=None,axis=0,level=None,as_index=True,sort=True,group_keys=True,squeeze=False,observed=False)</strong></p>
<p>参数说明：　</p>
<p>by：映射、字典或Series对象、数组、标签或标签列表。如果by是一个函数，则对象索引的每个值都调用它；如果传递了一个字典或Series对象，则使用该字典或Series对象值来确定组；如果传递了数组ndarray，则按原样使用这些值来确定组。　</p>
<p>axis：axis=1表示行，axis=0表示列。默认值为0。　</p>
<p>level：表示索引层级，默认值为None（无）。　</p>
<p>as_index：布尔型，默认值为True，返回以组标签为索引的对象。　sort：对组进行排序，布尔型，默认值为True。　</p>
<p>group_keys：布尔型，默认值为True，调用apply()函数时，将分组的键添加到索引以标识片段。　</p>
<p>squeeze：布尔型，默认值为False。如果可能，减少返回类型的维度；否则返回一致类型。　</p>
<p>observed： <em>bool, default False</em> 布尔型, 观察者, 默认为False。当以石斑鱼为分类时，才会使用该参数。如果参数值为True，则仅显示分类石斑鱼的观测值；如果参数值为False，则显示分类石斑鱼的所有值。</p>
<p>返回值：返回DataFrameGroupBy，返回包含有关组的信息的groupby对象。</p>
<h4 id="1．按照一列分组统计"><a href="#1．按照一列分组统计" class="headerlink" title="1．按照一列分组统计"></a>1．按照一列分组统计</h4><p>【示例15】　根据“一级分类”统计订单数据。（示例位置：资源包\MR\Code\04\15）<br>按照图书“一级分类”对订单数据进行分组统计求和，程序代码如下：</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020042705196.png" srcset="/img/loading.gif" lazyload alt="image-20211020042705196"></p>
<p>运行程序，输出结果如图4.10所示。</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020042744863.png" srcset="/img/loading.gif" lazyload alt="image-20211020042744863"></p>
<p>​                                 图4.10　按照一列分组统计</p>
<h4 id="2．按照多列分组统计"><a href="#2．按照多列分组统计" class="headerlink" title="2．按照多列分组统计"></a>2．按照多列分组统计</h4><p>多列分组统计，以列表形式指定列。</p>
<p>【示例16】　根据两级分类统计订单数据。（示例位置：资源包\MR\Code\04\16）<br>按照图书“一级分类”和“二级分类”对订单数据进行分组统计求和，主要代码如下：</p>
<p>01 #抽取数据<br>02 df1=df[[‘一级分类’,’二级分类’,’7天点击量’,’订单预定’]]<br>03 df1=df1.groupby([‘一级分类’,’二级分类’]).sum()    #分组统计求和</p>
<p>运行程序，输出结果如图4.11所示。</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020042906442.png" srcset="/img/loading.gif" lazyload alt="image-20211020042906442"></p>
<p>​                                    图4.11　按照多列分组统计</p>
<h4 id="3．分组并按指定列进行数据计算"><a href="#3．分组并按指定列进行数据计算" class="headerlink" title="3．分组并按指定列进行数据计算"></a>3．分组并按指定列进行数据计算</h4><p>前面介绍的分组统计是按照所有列进行汇总计算的，那么如何按照指定列汇总计算呢？</p>
<p>【示例17】　统计各编程语言的7天点击量。（示例位置：资源包\MR\Code\04\17）<br>统计各编程语言的7天点击量，首先按“二级分类”分组，然后抽取“7天点击量”列并对该列进行求和运算，主要代码如下：</p>
<p>df1=df1.groupby(‘二级分类’)[‘7天点击量’].sum()<br>运行程序，输出结果如图4.12所示。</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020043023795.png" srcset="/img/loading.gif" lazyload alt="image-20211020043023795"></p>
<p>图4.12　分组并按指定列进行数据计算</p>
<h3 id="4-3-2-对分组数据进行迭代"><a href="#4-3-2-对分组数据进行迭代" class="headerlink" title="4.3.2　对分组数据进行迭代"></a>4.3.2　对分组数据进行迭代</h3><p>通过for循环对分组统计数据进行迭代（遍历分组数据）。</p>
<p>【示例18】　迭代一级分类的订单数据。（示例位置：资源包\MR\Code\04\18）<br>按照“一级分类”分组，并输出每一分类中的订单数据，主要代码如下：</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020043149194.png" srcset="/img/loading.gif" lazyload alt="image-20211020043149194"></p>
<p>运行程序，控制台输出结果如图4.13所示。<br>上述代码中，name是groupby()函数中“一级分类”的值，group是分组后的数据。如果groupby()函数对多列进行分组，那么需要在for循环中指定多列。</p>
<p>【示例19】　迭代两级分类的订单数据。（示例位置：资源包\MR\Code\04\19）<br>迭代“一级分类”和“二级分类”的订单数据，主要代码如下：</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020043219251.png" srcset="/img/loading.gif" lazyload alt="image-20211020043219251"></p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020043328145.png" srcset="/img/loading.gif" lazyload alt="image-20211020043328145"></p>
<p>​                          图4.13　对分组数据进行迭代</p>
<h3 id="4-3-3-对分组的某列或多列使用聚合函数（agg-函数）"><a href="#4-3-3-对分组的某列或多列使用聚合函数（agg-函数）" class="headerlink" title="4.3.3　对分组的某列或多列使用聚合函数（agg()函数）"></a>4.3.3　对分组的某列或多列使用聚合函数（agg()函数）</h3><p>Python也可以实现像SQL中的分组聚合运算操作，主要通过groupby()函数与agg()函数实现。【示例20】　对分组统计结果使用聚合函数。（示例位置：资源包\MR\Code\04\20）<br>按“一级分类”分组统计“7天点击量”“订单预定”的平均值和总和，主要代码如下：</p>
<p>print(df1.groupby(‘一级分类’).agg([‘mean’,’sum’]))<br>运行程序，控制台输出结果如图4.14所示。</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020043531227.png" srcset="/img/loading.gif" lazyload alt="image-20211020043531227"></p>
<p>​                 图4.14　分组统计“7天点击量”“订单预定”的平均值和总和</p>
<p>【示例21】　针对不同的列使用不同的聚合函数。（示例位置：资源包\MR\Code\04\21）<br>在上述示例中，还可以针对不同的列使用不同的聚合函数。例如，按“一级分类”分组统计“7天点击量”的平均值和总和、“订单预定”的总和，主要代码如下：</p>
<p>print(df1.groupby(‘一级分类’).agg({‘7天点击量’:[‘mean’,’sum’], ‘订单预定’:[‘sum’]}))<br>运行程序，控制台输出结果如图4.15所示。</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020043554534.png" srcset="/img/loading.gif" lazyload alt="image-20211020043554534"></p>
<p>​           图4.15　分组统计“7天点击量”的平均值和总和、“订单预定”的总和</p>
<p>【示例22】　通过自定义函数实现分组统计。（示例位置：资源包\MR\Code\04\22）<br>通过自定义函数也可以实现数据分组统计。例如，统计1月份销售数据中，购买次数最多的产品，主要代码如下：</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020043631773.png" srcset="/img/loading.gif" lazyload alt="image-20211020043631773"></p>
<p>运行程序，控制台输出结果如图4.16所示。</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020043647886.png" srcset="/img/loading.gif" lazyload alt="image-20211020043647886"></p>
<p>​                             图4.16　统计购买次数最多的产品</p>
<p>从运行结果得知：“零基础学Python”是用户购买次数最多的产品。实用技巧<br>在图4.16显示的输出结果中可以看到，lambda()函数名称<lambda>被输出出来，看上去不是很美观，那么如何去掉它？方法是使用__name__方法修改函数名称，主要代码如下：</lambda></p>
<p>max.<strong>name</strong> = “购买次数最多”<br>运行程序，控制台输出结果如图4.17所示。</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020043747160.png" srcset="/img/loading.gif" lazyload alt="image-20211020043747160"></p>
<p>​                         图4.17　使用__name__方法修改函数名称</p>
<h3 id="4-3-4-通过字典和Series对象进行分组统计"><a href="#4-3-4-通过字典和Series对象进行分组统计" class="headerlink" title="4.3.4　通过字典和Series对象进行分组统计"></a>4.3.4　通过字典和Series对象进行分组统计</h3><h4 id="1．通过字典进行分组统计"><a href="#1．通过字典进行分组统计" class="headerlink" title="1．通过字典进行分组统计"></a>1．通过字典进行分组统计</h4><p>首先创建字典建立对应关系，然后将字典传递给groupby()函数从而实现数据分组统计。</p>
<p>【示例23】　通过字典分组统计“北上广”销量。（示例位置：资源包\MR\Code\04\23）<br>统计各地区销量，业务要求将“北京”“上海”“广州”3个一线城市放在一起统计。那么首先创建一个字典将“北京出库销量”“上海出库销量”“广州出库销量”都对应“北上广”；然后使用groupby()函数进行分组统计。主要代码如下：</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020043824543.png" srcset="/img/loading.gif" lazyload alt="image-20211020043824543"></p>
<p>运行程序，控制台输出结果如图4.18所示。</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020043847244.png" srcset="/img/loading.gif" lazyload alt="image-20211020043847244"></p>
<p>​                                 图4.18　通过字典进行分组统计</p>
<h4 id="2．通过Series对象进行分组统计"><a href="#2．通过Series对象进行分组统计" class="headerlink" title="2．通过Series对象进行分组统计"></a>2．通过Series对象进行分组统计</h4><p>通过Series对象进行分组统计与字典的方法类似。</p>
<p>【示例24】　通过Series对象分组统计“北上广”销量。（示例位置：资源包\MR\Code\04\24）<br>首先，创建一个Series对象，主要代码如下：</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020043933019.png" srcset="/img/loading.gif" lazyload alt="image-20211020043933019"></p>
<p>运行程序，输出结果如图4.19所示。<br>然后，将Series对象传递给groupby()函数实现数据分组统计，主要代码如下：</p>
<p>01  df1=df.groupby(s1,axis=1).sum()<br>02  print(df1)<br>运行程序，控制台输出结果如图4.20所示。</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020043959963.png" srcset="/img/loading.gif" lazyload alt="image-20211020043959963"></p>
<p>​                             图4.19　通过Series对象进行分组统计</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020044040014.png" srcset="/img/loading.gif" lazyload alt="image-20211020044040014"></p>
<p>​                             图4.20　分组统计结果</p>
<h2 id="4-4-数据移位"><a href="#4-4-数据移位" class="headerlink" title="4.4　数据移位"></a>4.4　数据移位</h2><p>什么是数据移位？例如，分析数据时需要上一条数据怎么办？当然是移动至上一条，从而得到该条数据，这就是数据移位。在Pandas中，使用shift()方法可以获得上一条数据，该方法返回向下移位后的结果，从而得到上一条数据。例如，获取某学生上一次英语成绩，如图4.21所示。</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020044117875.png" srcset="/img/loading.gif" lazyload alt="image-20211020044117875"></p>
<p>​                              图4.21　获取学生上一次英语成绩<br>shift()方法是一个非常有用的方法，用于数据位移与其他方法结合，能实现很多难以想象的功能，语法格式如下：</p>
<p>DataFrame.shift(periods=1, freq=None, axis=0)<br>参数说明：　</p>
<p>periods：表示移动的幅度，可以是正数，也可以是负数，默认值是1，1表示移动一次。注意这里移动的都是数据，而索引是不移动的，移动之后是没有对应值的，赋值为NaN。　</p>
<p>freq：可选参数，默认值为None，只适用于时间序列，如果这个参数存在，那么会按照参数值移动时间索引，而数据值没有发生变化。　</p>
<p>axis：axis=1表示行，axis=0表示列。默认值为0。</p>
<p>【示例25】　统计学生英语周测成绩的升降情况。（示例位置：资源包\MR\Code\04\25）<br>使用shift()方法统计学生每周英语测试成绩的升降情况，程序代码如下：</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020044313140.png" srcset="/img/loading.gif" lazyload alt="image-20211020044313140"></p>
<p>运行程序，控制台输出结果如图4.22所示。<br>从运行结果得知：第2次比第1次下降5分，第3次比第2次下降6分，第4次比第3次提升21分，第5次比第4次下降5分。<br>这里再扩展下，通过10次周测来一看下学生整体英语成绩的升降情况，如图4.23和图4.24所示。</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020044330897.png" srcset="/img/loading.gif" lazyload alt="image-20211020044330897"></p>
<p>​                                     图4.22　英语升降情况</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020044547566.png" srcset="/img/loading.gif" lazyload alt="image-20211020044547566"></p>
<p>​                               图4.23　10次周测英语成绩升降情况</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020044603814.png" srcset="/img/loading.gif" lazyload alt="image-20211020044603814"></p>
<p>​                     图4.24　图表展示英语成绩升降情况</p>
<p>说明</p>
<p>有关图表的知识将在第6章介绍，这里先简单了解。</p>
<p>shift()方法还有很多方面的应用。例如这样一个场景：分析股票数据，获取的股票数据中有股票的实时价格，也有每日的收盘价“close”，此时需要将实时价格和上一个工作日的收盘价进行对比，那么通过shift()方法就可以轻松解决。shift()方法还可以应用于时间序列，感兴趣的读者可以在学习完成后续章节进行尝试和探索。</p>
<h2 id="4-5-数据转换"><a href="#4-5-数据转换" class="headerlink" title="4.5　数据转换"></a>4.5　数据转换</h2><p>数据转换一般包括一列数据转换为多列数据、行列转换、DataFrame转换为字典、DataFrame转换为列表和DataFrame转换为元组等。</p>
<h3 id="4-5-1-一列数据转换为多列数据"><a href="#4-5-1-一列数据转换为多列数据" class="headerlink" title="4.5.1　一列数据转换为多列数据"></a>4.5.1　一列数据转换为多列数据</h3><p>一列数据转换为多列数据的情况在日常工作中经常会用到，从各种系统中导出的订单号、名称、地址很多都是复合组成的（即由多项内容组成），那么，这些列在查找、统计、合并时就没办法使用，需要将它们拆分开。例如，地址信息由省市区街道门牌号等信息组成，如果按省、市或区统计数据，就需要将地址信息中的“省”“市”“区”拆分开，此时就应用到了一列数据转多列数据，通常使用以下方法。</p>
<h4 id="1．split-方法"><a href="#1．split-方法" class="headerlink" title="1．split()方法"></a>1．split()方法</h4><p>Pandas的DataFrame对象中的str.split()内置方法可以实现分割字符串，语法如下：</p>
<p>Series.str.split(pat=None, n=-1, expand=False)<br>参数说明：　</p>
<p>pat：字符串、符号或正则表达式，字符串分割的依据，默认以空格分割字符串。　</p>
<p>n：整型，分割次数，默认值是-1，0或-1都将返回所有拆分。　</p>
<p>expand：布尔型，分割后的结果是否转换为DataFrame，默认值是False。　</p>
<p>返回值：系列、索引、DataFrame或多重索引。<br>首先，我们来看一组淘宝销售订单数据（部分数据），如图4.25所示。</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020044753477.png" srcset="/img/loading.gif" lazyload alt="image-20211020044753477"></p>
<p>图4.25　淘宝销售订单数据（部分数据）<br>从图4-25中数据得知：不仅“收货地址”是复合的，“宝贝标题”也是复合的，即由多种产品组成。</p>
<p>【示例26】　分割“收货地址”数据中的“省、市、区”。（示例位置：资源包\MR\Code\04\26）<br>使用split()方法先对“收货地址”进行分割，程序代码如下：</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020044817707.png" srcset="/img/loading.gif" lazyload alt="image-20211020044817707"></p>
<p>运行程序，输出结果如图4.26所示。</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020044931041.png" srcset="/img/loading.gif" lazyload alt="image-20211020044931041"></p>
<p>​                                  图4.26　分割后的收货地址</p>
<h4 id="2．join-方法与split-方法结合"><a href="#2．join-方法与split-方法结合" class="headerlink" title="2．join()方法与split()方法结合"></a>2．join()方法与split()方法结合</h4><p>【示例27】　以逗号分隔多种产品数据。（示例位置：资源包\MR\Code\04\27）<br>通过join()方法与split()方法结合，以逗号“,”分隔“宝贝标题”，主要代码如下：</p>
<p>df = df.join(df[‘宝贝标题’].str.split(‘, ‘, expand=True))</p>
<p>运行程序，输出结果如图4.27所示。</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020044959881.png" srcset="/img/loading.gif" lazyload alt="image-20211020044959881"></p>
<p>​                                   图4.27　分隔后的“宝贝标题”<br>从运行结果得知：“宝贝标题”中含有多种产品的数据被拆分开，这样操作便于日后对每种产品的销量进行统计。<br>将DataFrame中的tuple（元组）类型数据分隔成多列</p>
<p>【示例28】　对元组数据进行分隔。（示例位置：资源包\MR\Code\04\28）<br>首先，创建一组包含元组的数据，程序代码如下：</p>
<p>01  import pandas as pd<br>02  df = pd.DataFrame({‘a’:[1,2,3,4,5], ‘b’:[(1,2), (3,4),(5,6),(7,8),(9,10)]})<br>03  print(df)</p>
<p>然后，使用apply()函数对元组进行分隔，主要代码如下：</p>
<p>df[[‘b1’, ‘b2’]] = df[‘b’].apply(pd.Series)<br>或者使用join()方法结合apply()函数，主要代码如下：</p>
<p>df= df.join(df[‘b’].apply(pd.Series))<br>运行程序，控制台输出原始数据如图4.28所示，结果如图4.29和图4.30所示。</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020045110497.png" srcset="/img/loading.gif" lazyload alt="image-20211020045110497"></p>
<p>​                                            图4.28　原始数据</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020045122797.png" srcset="/img/loading.gif" lazyload alt="image-20211020045122797"></p>
<p>​                             图4.29　apply()函数分隔元组</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020045146968.png" srcset="/img/loading.gif" lazyload alt="image-20211020045146968"></p>
<p>​                       图4.30　join()方法结合apply()函数分隔元组</p>
<h3 id="4-5-2-行列转换"><a href="#4-5-2-行列转换" class="headerlink" title="4.5.2　行列转换"></a>4.5.2　行列转换</h3><p>在Pandas处理数据过程中，有时需要对数据进行行列转换或重排，主要使用stack()方法、unstack()方法和pivot()方法，下面介绍这3种方法的应用。</p>
<h4 id="1．stack-方法"><a href="#1．stack-方法" class="headerlink" title="1．stack()方法"></a>1．stack()方法</h4><p>stack()方法用于将原来的列索引转换成最内层的行索引，转换效果对比示意图如图4.31所示。</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020045215351.png" srcset="/img/loading.gif" lazyload alt="image-20211020045215351"></p>
<p>​                               图4.31　转换效果对比示意图<br>stack()方法的语法如下：</p>
<p>DataFrame.stack(level=-1, dropna=True)<br>参数说明：　</p>
<p>level：索引层级，定义为一个索引或标签，或索引或标签列表，默认值是-1。　</p>
<p>dropna：布尔型，默认值是True，　</p>
<p>返回值：DataFrame对象或Series对象。</p>
<p>【示例29】　对英语成绩表进行行列转换。（示例位置：资源包\MR\Code\04\29）<br>将学生英语成绩表进行行列转换，程序代码如下：</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020045321517.png" srcset="/img/loading.gif" lazyload alt="image-20211020045321517"></p>
<h4 id="2．unstack-方法"><a href="#2．unstack-方法" class="headerlink" title="2．unstack()方法"></a>2．unstack()方法</h4><p>unstack()方法与stack()方法相反，它是stack()方法的逆操作，即将最内层的行索引转换成列索引，转换效果对比如图4.32所示。</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020045341690.png" srcset="/img/loading.gif" lazyload alt="image-20211020045341690"></p>
<p>​                   图4.32　unstack()方法转换数据示意图<br>unstack()方法的语法如下：</p>
<p>DataFrame.unstack(level=-1, fill_value=None)<br>参数说明：　</p>
<p>level：索引层级，定义为一个索引或标签，或索引或标签列表，默认值是-1。　</p>
<p>fill_value：整型、字符串或字典，如果unstack()方法产生丢失值，则用这个值替换NaN。　返回值：DataFrame对象或Series对象。</p>
<p>【示例30】　使用unstack()方法转换学生成绩表。（示例位置：资源包\MR\Code\04\30）<br>同样转换学生成绩表，主要代码如下：</p>
<p>01 df=pd.read_excel(‘grade.xls’,sheet_name=’英语2’)      #导入Excel文件<br>02 df = df.set_index([‘班级’,’序号’,’Unnamed: 2’])       #设置多级索引<br>03 print(df.unstack())<br>unstack()方法中有一个参数可以指定转换第几层索引，例如，unstack(0)就是把第一层行索引转换为列索引，默认是将最内层索引转换为列索引。</p>
<h4 id="3．pivot-方法"><a href="#3．pivot-方法" class="headerlink" title="3．pivot()方法"></a>3．pivot()方法</h4><p>pivot()方法针对列的值，即指定某列的值作为行索引，指定某列的值作为列索引，然后再指定哪些列作为索引对应的值。unstack()方法针对索引进行操作，pivot()方法针对值进行操作。但实际上，二者的功能往往可以互相实现。<br>pivot()方法的语法如下：</p>
<p>DataFrame.pivot(index=None, columns=None, values=None)<br>参数说明：　</p>
<p>index：字符串或对象，可选参数。列用于创建新DataFrame数据的索引。如果没有，则使用现有索引。　</p>
<p>columns：字符串或对象，列用于创建新DataFrame的列。　</p>
<p>values：列用于填充新DataFrame的值，如果未指定，则将使用所有剩余的列，结果将具有分层索引列。　</p>
<p>返回值：DataFrame对象或Series对象。</p>
<p>【示例31】　使用pivot()方法转换学生成绩表。（示例位置：资源包\MR\Code\04\31）<br>使用pivot()方法转换学生成绩表，主要代码如下：</p>
<p>01 df=pd.read_excel(‘grade.xls’,sheet_name=’英语3’)         #导入Excel文件<br>02 df1=df.pivot(index=’序号’,columns=’班级’,values=’得分’)<br>运行程序，输出结果如图4.33所示。</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020045550818.png" srcset="/img/loading.gif" lazyload alt="image-20211020045550818"></p>
<p>图4.33　使用pivot()方法转换学生成绩表</p>
<h3 id="4-5-3-DataFrame转换为字典"><a href="#4-5-3-DataFrame转换为字典" class="headerlink" title="4.5.3　DataFrame转换为字典"></a>4.5.3　DataFrame转换为字典</h3><p>DataFrame转换为字典主要使用DataFrame对象的to_dict()方法，以索引作为字典的键（key），以列作为字典的值（value）。例如，有一个DataFrame对象（索引为“类别”、列为“数量”），通过to_dict()方法就会生成一个字典，示意图如图4.34所示。如果DataFrame对象包含两列，那么to_dict()方法就会生成一个两层的字典（dict），第一层是列名作为字典的键（key），第二层以索引列的值作为字典的键（key），以列值作为字典的值（value）。</p>
<p>【示例32】　将Excel销售数据转换为字典。（示例位置：资源包\MR\Code\04\32）<br>使用to_dict()方法将按“宝贝标题”分组统计后的部分数据转换为字典，程序代码如下：</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020045613721.png" srcset="/img/loading.gif" lazyload alt="image-20211020045613721"></p>
<p>运行程序，控制台输出结果如图4.35所示。</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020045643137.png" srcset="/img/loading.gif" lazyload alt="image-20211020045643137"></p>
<p>​                       图4.34　DataFrame转换为字典示意图</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020045702961.png" srcset="/img/loading.gif" lazyload alt="image-20211020045702961"></p>
<p>​                           图4.35　DataFrame转换为字典</p>
<h3 id="4-5-4-DataFrame转换为列表"><a href="#4-5-4-DataFrame转换为列表" class="headerlink" title="4.5.4　DataFrame转换为列表"></a>4.5.4　DataFrame转换为列表</h3><p>DataFrame转换为列表主要使用DataFrame对象的tolist()方法。</p>
<p>【示例33】　将电商数据转换为列表。（示例位置：资源包\MR\Code\04\33）<br>将淘宝销售数据中的“买家会员名”转换为列表，程序代码如下：</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020045737401.png" srcset="/img/loading.gif" lazyload alt="image-20211020045737401"></p>
<p>运行程序，控制台输出结果如图4.36所示。</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020045806297.png" srcset="/img/loading.gif" lazyload alt="image-20211020045806297"></p>
<p>图4.36　DataFrame转换为列表</p>
<h3 id="4-5-5-DataFrame转换为元组"><a href="#4-5-5-DataFrame转换为元组" class="headerlink" title="4.5.5　DataFrame转换为元组"></a>4.5.5　DataFrame转换为元组</h3><p>DataFrame转换为元组，首先通过循环语句按行读取DataFrame数据，然后使用元组函数tuple()将其转换为元组。</p>
<p>【示例34】　将Excel数据转换为元组。（示例位置：资源包\MR\Code\04\34）<br>将Excel表中的人物关系部分数据转换成元组，程序代码如下：</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020045832962.png" srcset="/img/loading.gif" lazyload alt="image-20211020045832962"></p>
<p>运行程序，控制台输出结果如图4.37所示。</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020045913740.png" srcset="/img/loading.gif" lazyload alt="image-20211020045913740"></p>
<p>​                            图4.37　DataFrame转换为元组</p>
<h3 id="4-5-6-Excel转换为HTML网页格式"><a href="#4-5-6-Excel转换为HTML网页格式" class="headerlink" title="4.5.6　Excel转换为HTML网页格式"></a>4.5.6　Excel转换为HTML网页格式</h3><p>日常工作中，有时会涉及财务数据的处理，而Excel应用最为广泛，但是对于展示数据来说，Excel并不友好，如果你想用其他格式的文件来向用户展示，那么，HTML网页格式是不错的选择。首先使用read_excel()方法导入Excel文件，然后使用to_html()方法将DataFrame数据导出为HTML格式，这样便实现了Excel转换为HTML格式。</p>
<p>【示例35】　将Excel订单数据转换为HTML网页格式。（示例位置：资源包\MR\Code\04\35）<br>将淘宝部分订单数据转换为HTML网页格式，效果如图4.38所示。</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020045939834.png" srcset="/img/loading.gif" lazyload alt="image-20211020045939834"></p>
<p>​                              图4.38　Excel转换为HTML网页格式<br>程序代码如下：</p>
<p>01 import pandas as pd<br>02 df=pd.read_excel(‘mrbooks.xls’)<br>03 df.to_html(‘mrbook.html’,header = True,index = False)</p>
<h2 id="4-6-数据合并"><a href="#4-6-数据合并" class="headerlink" title="4.6　数据合并"></a>4.6　数据合并</h2><p>DataFrame数据合并主要使用merge()方法和concat()方法。</p>
<h3 id="4-6-1-数据合并（merge-方法）"><a href="#4-6-1-数据合并（merge-方法）" class="headerlink" title="4.6.1　数据合并（merge()方法）"></a>4.6.1　数据合并（merge()方法）</h3><p>Pandas模块的merge()方法是按照两个DataFrame对象列名相同的列进行连接合并，两个DataFrame对象必须具有同名的列。merge()方法的语法如下：</p>
<p>pandas.merge(right,how=’inner’,on=None,left_on=None,right_on=None,left_index=False,right_index=False,sort=False,suffixes=(‘_x’,’_y’),copy=True,indicator=False,validate=None)<br>参数说明：　</p>
<p>right：合并对象，DataFrame对象或Series对象。　</p>
<p>how：合并类型，参数值可以是left（左合并）、right（右合并）、outer（外部合并）或inner（内部合并），默认值为inner。各个值的说明如下。　</p>
<p>​        left：只使用来自左数据集的键，类似于SQL左外部联接，保留键的顺序。　</p>
<p>​        right：只使用来自右数据集的键，类似于SQL右外部联接，保留键的顺序。　</p>
<p>​        outer：使用来自两个数据集的键，类似于SQL外部联接，按字典顺序对键进行排序。　</p>
<p>​        inner：使用来自两个数据集的键的交集，类似于SQL内部连接，保持左键的顺序。</p>
<p>on：标签、列表或数组，默认值为None。DataFrame对象连接的列或索引级别名称。也可以是DataFrame对象长度的数组或数组列表。</p>
<p>left_on：标签、列表或数组，默认值为None。要连接的左数据集的列或索引级名称，也可以是左数据集长度的数组或数组列表。　</p>
<p>right_on：标签、列表或数组，默认值为None。要连接的右数据集的列或索引级名称，也可以是右数据集长度的数组或数组列表。　</p>
<p>left_index：布尔型，默认值为False。使用左数据集的索引作为连接键。如果是多重索引，则其他数据中的键数（索引或列数）必须匹配索引级别数。</p>
<p>right_index：布尔型，默认值为False，使用右数据集的索引作为连接键。　</p>
<p>sort：布尔型，默认值为False，在合并结果中按字典顺序对连接键进行排序。如果值为False，则连接键的顺序取决于连接类型how参数。　suffixes：元组类型，默认值为(‘_x’,’_y’)。当左侧数据集和右侧数据集的列名相同时，数据合并后列名将带上“_x”和“_y”后缀。　</p>
<p>copy：是否复制数据，默认值为True。如果值为False，则不复制数据。　</p>
<p>indicator：布尔型或字符串，默认值为False。如果值为True，则添加一个列以输出名为_Merge的DataFrame对象，其中包含每一行的信息。如果是字符串，将向输出的DataFrame对象中添加包含每一行信息的列，并将列命名为字符型的值。　</p>
<p>validate：字符串，检查合并数据是否为指定类型。可选参数，其值说明如下。　one_to_one或“1:1”：检查合并键在左、右数据集中是否都是唯一的。　one_to_many或“1:m”：检查合并键在左数据集中是否唯一。　many_to_one或“m:1”：检查合并键在右数据集中是否唯一。　many_to_many或“m:m”：允许，但不检查。　</p>
<p>返回值：DataFrame对象，两个合并对象的数据集。</p>
<h4 id="1．常规合并"><a href="#1．常规合并" class="headerlink" title="1．常规合并"></a>1．常规合并</h4><p>【示例36】　合并学生成绩表。（示例位置：资源包\MR\Code\04\36）<br>假设一个DataFrame对象包含了学生的“语文”“数学”“英语”成绩，而另一个DataFrame对象则包含了学生的“体育”成绩，现在将它们合并，示意图如图4.39所示。</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020050304612.png" srcset="/img/loading.gif" lazyload alt="image-20211020050304612"></p>
<p>​                 图4.39　数据合并效果对比示意图<br>程序代码如下：</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020050326358.png" srcset="/img/loading.gif" lazyload alt="image-20211020050326358"></p>
<p>运行程序，控制台输出结果如图4.40所示。</p>
<p>【示例37】　通过索引合并数据。（示例位置：资源包\MR\Code\04\37）<br>如果通过索引列合并，则需要设置right_index参数和left_index参数值为True。例如，上述举例，通过列索引合并，主要代码如下：</p>
<p>01 df_merge=pd.merge(df1,df2,right_index=True,left_index=True)<br>02 print(df_merge)<br>运行程序，控制台输出结果如图4.41所示。</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020050352118.png" srcset="/img/loading.gif" lazyload alt="image-20211020050352118"></p>
<p>​                           图4.40　合并结果</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020050412167.png" srcset="/img/loading.gif" lazyload alt="image-20211020050412167"></p>
<p>​                            图4.41　通过索引列合并</p>
<p>【示例38】　对合并数据去重。（示例位置：资源包\MR\Code\04\38）<br>从图4.41中的运行结果得知：数据中存在重复列（如编号），如果不想要重复列，可以设置按指定列和列索引合并数据，主要代码如下：</p>
<p>df_merge=pd.merge(df1,df2,on=’编号’,left_index=True,right_index=True)</p>
<p>还可以通过how参数解决这一问题。例如，设置该参数值为left，就是让df1保留所有的行列数据，df2则根据df1的行列进行补全，主要代码如下：</p>
<p>df_merge=pd.merge(df1,df2,on=’编号’,how=’left’)<br>运行程序，控制台输出结果如图4.42所示。</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020050506047.png" srcset="/img/loading.gif" lazyload alt="image-20211020050506047"></p>
<p>图4.42　合并结果</p>
<h4 id="2．多对一的数据合并"><a href="#2．多对一的数据合并" class="headerlink" title="2．多对一的数据合并"></a>2．多对一的数据合并</h4><p>多对一是指两个数据集（df1、df2）的共有列中的数据不是一对一的关系，例如，df1中的“编号”是唯一的，而df2中的“编号”有重复的编号，类似这种就是多对一的关系，示意图如图4.43所示。【示例39】　根据共有列进行合并数据。（示例位置：资源包\MR\Code\04\39）<br>根据共有列中的数据进行合并，df2根据df1的行列进行补全，程序代码如下：</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020050528714.png" srcset="/img/loading.gif" lazyload alt="image-20211020050528714"></p>
<p>运行程序，控制台输出结果如图4.44所示。</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020050545631.png" srcset="/img/loading.gif" lazyload alt="image-20211020050545631"></p>
<p>​                                     图4.43　多对一合并示意图</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020050604101.png" srcset="/img/loading.gif" lazyload alt="image-20211020050604101"></p>
<p>​                                  图4.44　合并结果</p>
<h4 id="3．多对多的数据合并"><a href="#3．多对多的数据合并" class="headerlink" title="3．多对多的数据合并"></a>3．多对多的数据合并</h4><p>多对多是指两个数据集（df1、df2）的共有列中的数据不全是一对一的关系，都有重复数据，例如“编号”，示图如图4.45所示。</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020050702131.png" srcset="/img/loading.gif" lazyload alt="image-20211020050702131"></p>
<p>​                                    图4.45　多对多示意图</p>
<p>【示例40】　合并数据并相互补全。（示例位置：资源包\MR\Code\04\40）<br>根据共有列中的数据进行合并，df2、df1相互补全，程序代码如下：</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020050733884.png" srcset="/img/loading.gif" lazyload alt="image-20211020050733884"></p>
<p>运行程序，控制台输出结果如图4.46所示。</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020050749641.png" srcset="/img/loading.gif" lazyload alt="image-20211020050749641"></p>
<p>​                                               图4.46　合并结果</p>
<h3 id="4-6-2-数据合并（concat-方法）"><a href="#4-6-2-数据合并（concat-方法）" class="headerlink" title="4.6.2　数据合并（concat()方法）"></a>4.6.2　数据合并（concat()方法）</h3><p>concat()方法可以根据不同的方式将数据合并，语法如下：</p>
<p>pandas.concat(objs,axis=0,join=’outer’,ignore_index: bool = False, keys=None, levels=None, names=None,<br>verify_integrity: bool = False, sort: bool = False, copy: bool = True)<br>参数说明：　</p>
<p>objs：Series、DataFrame或Panel对象的序列或映射。如果传递一个字典，则排序的键将用作键参数。　</p>
<p>axis：axis=1表示行，axis=0表示列。默认值为0。　</p>
<p>join：值为inner（内连接）或outer（外连连接），处理其他轴上的索引方式。默认值为outer。　</p>
<p>ignore_index：布尔值，默认值为False，保留索引，索引值为0，…，n-1。如果值为True，则忽略索引。　</p>
<p>keys：序列，默认值为None。使用传递的键作为最外层构建层次索引。如果为多索引，应该使用元组。　</p>
<p>levels：序列列表，默认值为None。用于构建MultiIndex的特定级别（唯一值）；否则，它们将从键推断。　</p>
<p>names：list列表，默认值为None。结果层次索引中的级别的名称。　verify_integrity：布尔值，默认值为False。检查新连接的轴是否包含重复项。　</p>
<p>sort：布尔值，默认值为True（1.0.0以后版本默认值为False，即不排序）。如果连接为外连接（join=’outer’），则对未对齐的非连接轴进行排序；如果连接为内连接（join=’inner’），则该参数不起作用。</p>
<p>copy：是否复制数据，默认值为True，如果值为False，则不复制数据。</p>
<p>下面介绍concat()方法不同的合并方式，其中dfs代表合并后的DataFrame对象，df1、df2等代表单个DataFrame对象，result代表合并后的结果（DataFrame对象）。</p>
<h4 id="1．相同字段的表首尾相接"><a href="#1．相同字段的表首尾相接" class="headerlink" title="1．相同字段的表首尾相接"></a>1．相同字段的表首尾相接</h4><p>表结构相同的数据将直接合并，表首尾相接，主要代码如下：</p>
<p>01  dfs= [df1, df2, df3]<br>02  result = pd.concat(dfs)<br>例如，表df1、df2和df3结构相同，如图4.47所示。合并后的效果如图4.48所示。如果想要在合并数据时标记源数据来自哪张表，则需要在代码中加入参数keys，例如表名分别为“1月”“2月”“3月”，合并后的效果如图4.49所示。</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020051001176.png" srcset="/img/loading.gif" lazyload alt="image-20211020051001176"></p>
<p>​                          图4.47　3张相同字段的表</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020051019220.png" srcset="/img/loading.gif" lazyload alt="image-20211020051019220"></p>
<p>​                                     图4.48　首尾相接合并后的效果</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020051035379.png" srcset="/img/loading.gif" lazyload alt="image-20211020051035379"></p>
<p>​                        图4.49　合并后带标记（月份）的效果<br>主要代码如下：</p>
<p>result = pd.concat(dfs, keys=[‘1月’, ‘2月’, ‘3月’])</p>
<h4 id="2．横向表合并（行对齐）"><a href="#2．横向表合并（行对齐）" class="headerlink" title="2．横向表合并（行对齐）"></a>2．横向表合并（行对齐）</h4><p>当合并的数据列名称不一致时，可以设置参数axis=1，concat()方法将按行对齐，然后将不同列名的两组数据进行合并，缺失的数据用NaN填充，df1和df4合并前后效果如图4.50和图4.51所示。</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020051057217.png" srcset="/img/loading.gif" lazyload alt="image-20211020051057217"></p>
<p>​                        图4.50　横向表合并前</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020051113896.png" srcset="/img/loading.gif" lazyload alt="image-20211020051113896"></p>
<p>​                            图4.51　横向表合并后<br>主要代码如下：</p>
<p>result = pd.concat([df1, df4], axis=1)</p>
<h4 id="3．交叉合并"><a href="#3．交叉合并" class="headerlink" title="3．交叉合并"></a>3．交叉合并</h4><p>交叉合并，需要在代码中加上join参数，如果值为inner，结果是两张表的交集；如果值为outer，结果是两张表的并集。例如两张表交集，表df1和df4合并前后的效果如图4.52和图4.53所示。</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020051227829.png" srcset="/img/loading.gif" lazyload alt="image-20211020051227829"></p>
<p>​                                   图4.52　交叉合并前</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020051243654.png" srcset="/img/loading.gif" lazyload alt="image-20211020051243654"></p>
<p>​                                       图4.53　交叉合并后<br>主要代码如下：</p>
<p>result = pd.concat([df1, df4], axis=1, join=’inner’)</p>
<h4 id="4．指定表对齐数据（行对齐）"><a href="#4．指定表对齐数据（行对齐）" class="headerlink" title="4．指定表对齐数据（行对齐）"></a>4．指定表对齐数据（行对齐）</h4><p>如果指定参数join_axes，就可以指定根据哪张表来对齐数据。例如，根据df4对齐数据，就会保留表df4的数据，然后将表df1的数据与之合并，行数不变，合并前后的效果与如图4.54和图4.55所示。</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020051305083.png" srcset="/img/loading.gif" lazyload alt="image-20211020051305083"></p>
<p>​                          图4.54　指定表对齐数据合并前</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020051320918.png" srcset="/img/loading.gif" lazyload alt="image-20211020051320918"></p>
<p>​                           图4.55　指定表对齐数据合并后<br>主要代码如下：</p>
<p>result = pd.concat([df1, df4], axis=1, join_axes=[df4.index])</p>
<h2 id="4-7-数据导出"><a href="#4-7-数据导出" class="headerlink" title="4.7　数据导出"></a>4.7　数据导出</h2><h3 id="4-7-1-导出为-xlsx文件"><a href="#4-7-1-导出为-xlsx文件" class="headerlink" title="4.7.1　导出为.xlsx文件"></a>4.7.1　导出为.xlsx文件</h3><p>导出数据为Excel，主要使用DataFrame对象的to_excel()方法，语法如下：</p>
<p>DataFrame.to_excel(excel_writer,sheet_name=’Sheet1’,na_rep=’’,float_format=None,columns=None,header=True,<br>index=True,index_label=None,startrow=0,startcol=0,engine=None,merge_cells=True, encoding=None, inf_rep=’inf’,<br>verbose=True, freeze_panes=None)<br>参数说明：　</p>
<p>excel_writer：字符串或ExcelWriter对象。　</p>
<p>sheet_name：字符串，默认值为Sheet1，包含DataFrame的表的名称。　</p>
<p>na_rep：字符串，默认值为’ ‘。缺失数据的表示方式。　</p>
<p>float_format：字符串，默认值为None，格式化浮点数的字符串。　columns：序列，可选参数，要编辑的列。　</p>
<p>header：布尔型或字符串列表，默认值为True。列名称，如果给定字符串列表，则表示它是列名称的别名。　</p>
<p>index：布尔型，默认值为True，行名（索引）。　</p>
<p>index_label：字符串或序列，默认值为None。如果需要，可以使用索引列的列标签；如果没有给出，标题和索引为True，则使用索引名称；如果数据文件使用多索引，则需使用序列。</p>
<p>startrow：指定从哪一行开始写入数据。　</p>
<p>startcol：指定从哪一列开始写入数据。　</p>
<p>engine：字符串，默认值为None，指定要使用的写引擎，如openpyxl或xlsxwriter。也可以通过io.excel.xlsx.writer、io.excel.xls.writer和io.excel.xlsm.writer进行设置。　</p>
<p>merge_cells：布尔型，默认值为True。　</p>
<p>encoding：指定Excel文件的编码方式，默认值为None。　</p>
<p>inf_rep：字符串，默认值为“正”，表示无穷大。　</p>
<p>verbose：布尔型，默认值为True。在错误日志中显示更多信息。　freeze_panes：整数的元组，长度2，默认值为None。指定要冻结的行列。</p>
<p>【示例41】　将处理后的数据导出为Excel文件。（示例位置：资源包\MR\Code\04\41）<br>将数据合并后的结果导出为Excel文件，主要代码如下：</p>
<p>df_merge.to_excel(‘merge.xlsx’)<br>运行程序，数据将导出为Excel文件，如图4.56所示。</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020051510137.png" srcset="/img/loading.gif" lazyload alt="image-20211020051510137"></p>
<p>​                         图4.56　导出为Excel文件</p>
<p>上述举例，如果需要指定Sheet页名称，可以通过sheet_name参数指定，主要代码如下：</p>
<p>df1.to_excel(‘df1.xlsx’,sheet_name=’df1’)</p>
<h3 id="4-7-2-导出为-csv文件"><a href="#4-7-2-导出为-csv文件" class="headerlink" title="4.7.2　导出为.csv文件"></a>4.7.2　导出为.csv文件</h3><p>导出数据为.csv文件，主要使用DataFrame对象的to_csv()方法，语法如下：</p>
<p>DataFrame.to_csv(path_or_buf=None,sep=’,’,na_rep=’’,float_format=None,columns=None,header=True,index=<br>True,index_label=None,mode=’w’,encoding=None,compression=’infer’,quoting=None,quotechar=’”‘,line_terminator=<br>None,chunksize=None,date_format=None,doublequote=True, escapechar=None, decimal=’.’,errors=’strict’)<br>参数说明：　</p>
<p>path_or_buf：要保存的路径及文件名。　</p>
<p>sep：分隔符，默认值为”,”。　</p>
<p>na_rep：指定空值的输出方式，默认值为空字符串。　</p>
<p>float_format：浮点数的输出格式，要用双引号括起来。　</p>
<p>columns：指定要导出的列，用列名列表表示，默认值为None。　</p>
<p>header：是否输出列名，默认值为True。　</p>
<p>index：是否输出索引，默认值为True。　</p>
<p>index_label：索引列的列名，默认值为None。　</p>
<p>mode：Python写入模式，默认值为w。　</p>
<p>encoding：编码方式，默认值为utf-8。　</p>
<p>compression：压缩模式，默认值为infer。　</p>
<p>quoting：导出.csv文件是否用引号，默认值为0，表示不加双引号；如果值为1，则每个字段都会加上引号，数值也会被当作字符串看待。</p>
<p>quotechar：引用字符，当quoting=1时可以指定引号字符为双引号（” “）或单引号（’ ‘）。　</p>
<p>line_terminator：换行符，默认值为\n。</p>
<p>chunksize：一次写入.csv文件的行数，当DataFrame对象数据特别大时需要分批写入。　</p>
<p>date_format：日期输出格式。　</p>
<p>doublequote：是否添加双引用符，默认值为True。　</p>
<p>escapechar：设置转义字符。　</p>
<p>decimal：可识别十进制分隔符的字符。　</p>
<p>errors：指定如何处理编码和解码错误，默认值为strict（严格的）。</p>
<p>【示例42】　将处理后的数据导出为.csv文件。（示例位置：资源包\MR\Code\04\42）<br>下面介绍to_csv()方法常用功能，举例如下，df为DataFrame对象。<br>（1）相对位置，保存在程序所在路径下，代码如下：</p>
<p>df.to_csv(‘Result.csv’)<br>（2）绝对位置，代码如下：</p>
<p>df.to_csv(‘d:\Result.csv’)<br>（3）分隔符。使用问号（？）分隔符分隔需要保存的数据，代码如下：</p>
<p>df.to_csv(‘Result.csv’,sep=’?’)<br>（4）替换空值，缺失值保存为NA，代码如下：</p>
<p>df.to_csv(‘Result1.csv’,na_rep=’NA’)<br>（5）格式化数据，保留两位小数，代码如下：</p>
<p>df.to_csv(‘Result1.csv’,float_format=’%.2f’)<br>（6）保留某列数据，保存索引列和name列，代码如下：</p>
<p>df.to_csv(‘Result.csv’,columns=[‘name’])<br>（7）是否保留列名，不保留列名，代码如下：</p>
<p>df.to_csv(‘Result.csv’,header=False)<br>（8）是否保留行索引，不保留行索引，代码如下：</p>
<p>df.to_csv(‘Result.csv’,index=False)</p>
<h3 id="4-7-3-导出多个Sheet"><a href="#4-7-3-导出多个Sheet" class="headerlink" title="4.7.3　导出多个Sheet"></a>4.7.3　导出多个Sheet</h3><p>导出多个Sheet，应首先使用pd.ExcelWriter()方法打开一个Excel文件，然后再使用to_excel()方法导出指定的Sheet。</p>
<p>【示例43】　导出Excel中多个Sheet页的数据。（示例位置：资源包\MR\Code\04\43）<br>导出指定Sheet页中的数据，主要代码如下：</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020051720411.png" srcset="/img/loading.gif" lazyload alt="image-20211020051720411"></p>
<h2 id="4-8-日期数据处理"><a href="#4-8-日期数据处理" class="headerlink" title="4.8　日期数据处理"></a>4.8　日期数据处理</h2><h3 id="4-8-1-DataFrame的日期数据转换"><a href="#4-8-1-DataFrame的日期数据转换" class="headerlink" title="4.8.1　DataFrame的日期数据转换"></a>4.8.1　DataFrame的日期数据转换</h3><p>日常工作中，有一个非常麻烦的事情就是日期的格式可以有很多种表达，我们看到同样是2020年2月14日，可以有很多种格式，如图4.57所示。那么，我们需要先将这些格式统一后才能进行后续的工作。Pandas提供了to_datetime()方法可以帮助我们解决这一问题。<br>to_datetime()方法可以用来批量处理日期数据转换，对于处理大数据非常实用和方便，它可以将日期数据转换成你需要的各种格式。例如，将2/14/20和14-2-2020转换为日期格式2020-02-14。to_datetime()方法的语法如下：</p>
<p>pandas.to_datetime(arg,errors=’ignore’,dayfirst=False,yearfirst=False,utc=None,box=True,format=None,exact=<br>True,unit=None,infer_datetime_format=False,origin=’unix’,cache=False)<br>参数说明：　</p>
<p>arg：字符串、日期时间、字符串数组。　</p>
<p>errors：值为ignore、raise或coerce，具体说明如下，默认值为ignore，即忽略错误。　</p>
<p>ignore：无效的解析将返回原值。　</p>
<p>raise：无效的解析将引发异常。　</p>
<p>coerce：无效的解析将被设置为NaT，即无法转换为日期的数据将被转换为NaT。　</p>
<p>dayfirst：第一个为天，布尔型，默认值为False。例如02/09/2020，如果值为True，则解析日期的第一个为天，即2020-09-02；如果值为False，则解析日期与原日期一致，即2020-02-09。　</p>
<p>yearfirst：第一个为年，布尔型，默认值为False。例如14-Feb-20，如果值为True，则解析日期的第一个为年，即2014-02-20；如果值为False，则解析日期与原日期一致，即2020-02-14。　</p>
<p>utc：默认值为None。返回utc即协调世界时间。　</p>
<p>box：布尔值，默认值为True，如果值为True，则返回DatetimeIndex；如果值为False，则返回ndarray。　</p>
<p>format：格式化显示时间的格式。字符串，默认值为None。　</p>
<p>exact：布尔值，默认值为True。如果为True，则要求格式完全匹配；如果为False，则允许格式与目标字符串中的任何位置匹配。　</p>
<p>unit：默认值为None，参数的单位（D、s、、ms、μs、ns）表示时间的单位。　</p>
<p>infer_datetime_format：默认值为False。如果没有格式，则尝试根据第一个日期时间字符串推断格式。　</p>
<p>origin：默认值为unix。定义参考日期。数值将被解析为单位数。　</p>
<p>cache：默认值为False。如果值为True，则使用唯一、转换日期的缓存应用日期时间转换。在解析重复日期字符串，特别是带有时区偏移的字符串时，可能会产生明显的加速。只有在至少有50个值时才使用缓存。越界值的存在将使缓存不可用，并可能减慢解析速度。　</p>
<p>返回值：日期时间。</p>
<p>【示例44】　将各种日期字符串转换为指定的日期格式。（示例位置：资源包\MR\Code\04\44）<br>将2020年2月14日的各种格式转换为日期格式，程序代码如下：</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020051913944.png" srcset="/img/loading.gif" lazyload alt="image-20211020051913944"></p>
<p>运行程序，控制台输出结果如图4.58所示。</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020051928130.png" srcset="/img/loading.gif" lazyload alt="image-20211020051928130"></p>
<p>​                   图4.57　日期的多种格式转换</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020051944812.png" srcset="/img/loading.gif" lazyload alt="image-20211020051944812"></p>
<p>​                 图4.58　2020年2月14日的各种格式转换为日期格式<br>还可以实现从DataFrame对象中的多列，如年、月、日各列组合成一列日期。键值是常用的日期缩略语。</p>
<p>组合要求：　</p>
<p>必选：year、month、day。　</p>
<p>可选：hour、minute、second、millisecond（毫秒）、microsecond（微秒）、nanosecond（纳秒）。</p>
<p>【示例45】　将一组数据组合为日期数据。（示例位置：资源包\MR\Code\04\45）<br>将一组数据组合为日期数据，主要代码如下：<br>运行程序，控制台输出结果如图4.59所示。</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020052022697.png" srcset="/img/loading.gif" lazyload alt="image-20211020052022697"></p>
<p>​                                        图4.59　日期组合</p>
<h3 id="4-8-2-dt对象的使用"><a href="#4-8-2-dt对象的使用" class="headerlink" title="4.8.2　dt对象的使用"></a>4.8.2　dt对象的使用</h3><p>dt对象是Series对象中用于获取日期属性的一个访问器对象，通过它可以获取日期中的年、月、日、星期数、季节等，还可以判断日期是否处在年底。语法如下：</p>
<p>  Series.dt()<br>参数说明：　</p>
<p>返回值：返回与原始系列相同的索引系列。如果Series不包含类日期值，则引发错误。　</p>
<p>dt对象提供了year、month、day、dayofweek、dayofyear、is_leap_year、quarter、weekday_name等属性和方法。</p>
<p>例如，year可以获取“年”、month可以获取“月”、quarter可以直接得到每个日期分别是第几个季度，weekday_name可以直接得到每个日期对应的是周几。</p>
<p>【示例46】　获取日期中的年、月、日、星期数等。（示例位置：资源包\MR\Code\04\46）<br>使用dt对象获取日期中的年、月、日、星期数、季节等。<br>（1）获取年、月、日，代码如下：</p>
<p>df[‘年’],df[‘月’],df[‘日’]=df[‘日期’].dt.year,df[‘日期’].dt.month,df[‘日期’].dt.day<br>（2）从日期判断出所处星期数，代码如下：</p>
<p>df[‘星期几’]=df[‘日期’].dt.day_name()<br>（3）从日期判断所处季度，代码如下：</p>
<p>df[‘季度’]=df[‘日期’].dt.quarter<br>（4）从日期判断是否为年底最后一天，代码如下：</p>
<p>df[‘是否年底’]=df[‘日期’].dt.is_year_end<br>运行程序，控制台输出结果如图4.60所示。</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020052128703.png" srcset="/img/loading.gif" lazyload alt="image-20211020052128703"></p>
<p>​                               图4.60　dt对象日期转换</p>
<h3 id="4-8-3-获取日期区间的数据"><a href="#4-8-3-获取日期区间的数据" class="headerlink" title="4.8.3　获取日期区间的数据"></a>4.8.3　获取日期区间的数据</h3><p>获取日期区间的数据的方法是直接在DataFrame对象中输入日期或日期区间，但前提必须设置日期为索引，举例如下。　</p>
<p>获取2018年的数据。</p>
<p>df1[‘2018’]　</p>
<p>获取2017—2018年的数据。</p>
<p>df1[‘2017’:’2018’]　</p>
<p>获取某月（2018年7月）的数据。</p>
<p>df1[‘2018-07’]　</p>
<p>获取具体某天（2018年5月6日）的数据。</p>
<p>df1[‘2018-05-06’:’2018-05-06’]</p>
<p>【示例47】　获取指定日期区间的订单数据。（示例位置：资源包\MR\Code\04\47）<br>获取2018年5月11日至6月10日的订单，结果如图4.61所示。<br>程序代码如下：</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020052236563.png" srcset="/img/loading.gif" lazyload alt="image-20211020052236563"></p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020052256160.png" srcset="/img/loading.gif" lazyload alt="image-20211020052256160"></p>
<p>​            图4.61　2018年5月11日至6月10日的订单（省略部分数据）</p>
<h3 id="4-8-4-按不同时期统计并显示数据"><a href="#4-8-4-按不同时期统计并显示数据" class="headerlink" title="4.8.4　按不同时期统计并显示数据"></a>4.8.4　按不同时期统计并显示数据</h3><h4 id="1．按时期统计数据"><a href="#1．按时期统计数据" class="headerlink" title="1．按时期统计数据"></a>1．按时期统计数据</h4><p>按时期统计数据主要通过DataFrame对象的resample()方法结合数据计算函数实现。resample()方法主要应用于时间序列频率转换和重采样，它可以从日期中获取年、月、日、星期、季节等，结合数据计算函数就可以实现按年、月、日、星期或季度等不同时期统计数据。举例如下所示。<br>（1）按年统计数据，代码如下：</p>
<p>df1=df1.resample(‘AS’).sum()<br>（2）按季度统计数据，代码如下：</p>
<p>df2.resample(‘Q’).sum()<br>（3）按月度统计数据，代码如下：</p>
<p>df1.resample(‘M’).sum()<br>（4）按星期统计数据，代码如下：</p>
<p>df1.resample(‘W’).sum()<br>（5）按天统计数据，代码如下：</p>
<p>df1.resample(‘D’).sum()</p>
<p>实用技巧<br>按日期统计数据过程中，可能会出现如图4.62所示的错误提示。</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020052356675.png" srcset="/img/loading.gif" lazyload alt="image-20211020052356675"></p>
<p>图4.62　错误提示</p>
<p>完整错误描述：<br>TypeError: Only valid with DatetimeIndex, TimedeltaIndex or PeriodIndex, but got an instance of’Index’<br>出现上述错误，是由于resample()函数要求索引必须为日期型。<br>解决方法：将数据的索引转换为datetime类型，主要代码如下：</p>
<p>df1.index = pd.to_datetime(df1.index)</p>
<h4 id="2．按时期显示数据"><a href="#2．按时期显示数据" class="headerlink" title="2．按时期显示数据"></a>2．按时期显示数据</h4><p>DataFrame对象的to_period()方法可以将时间戳转换为时期，从而实现按时期显示数据，前提是日期必须设置为索引。语法如下：</p>
<p>DataFrame.to_period(freq=None, axis=0, copy=True)<br>参数说明：　</p>
<p>freq：字符串，周期索引的频率，默认值为None。　</p>
<p>axis：行列索引，axis=0表示行索引，axis=1表示列索引。默认值为0，即表示行索引。　</p>
<p>copy：是否复制数据，默认值为True，如果值为False，则不复制数据。　返回值：带周期索引的时间序列。</p>
<p>【示例48】　从日期中获取不同的时期。（示例位置：资源包\MR\Code\04\48）<br>从日期中获取不同的时期，主要代码如下：</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020052452293.png" srcset="/img/loading.gif" lazyload alt="image-20211020052452293"></p>
<h4 id="3．按时期统计并显示数据"><a href="#3．按时期统计并显示数据" class="headerlink" title="3．按时期统计并显示数据"></a>3．按时期统计并显示数据</h4><p>（1）按年统计并显示数据，代码如下：</p>
<p>df2.resample(‘AS’).sum().to_period(‘A’)<br>控制台输出结果如图4.63所示。<br>（2）按季度统计并显示数据，代码如下：</p>
<p>Q_df=df2.resample(‘Q’).sum().to_period(‘Q’)</p>
<p>控制台输出结果如图4.64所示。</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020052536700.png" srcset="/img/loading.gif" lazyload alt="image-20211020052536700"></p>
<p>​                            图4.63　按年统计并显示数据</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020052550813.png" srcset="/img/loading.gif" lazyload alt="image-20211020052550813"></p>
<p>​                      图4.64　按季度统计并显示数据<br>（3）按月统计并显示数据，代码如下：</p>
<p>df2.resample(‘M’).sum().to_period(‘M’)<br>控制台输出结果如图4.65所示。<br>（4）按星期统计并显示数据（前5条数据），代码如下：</p>
<p>df2.resample(‘W’).sum().to_period(‘W’).head()<br>控制台输出结果如图4.66所示。</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020052622774.png" srcset="/img/loading.gif" lazyload alt="image-20211020052622774"></p>
<p>​                          图4.65　按月统计并显示数据</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020052640893.png" srcset="/img/loading.gif" lazyload alt="image-20211020052640893"></p>
<p>​                      图4.66　按星期统计并显示数据</p>
<h2 id="4-9-时间序列"><a href="#4-9-时间序列" class="headerlink" title="4.9　时间序列"></a>4.9　时间序列</h2><h3 id="4-9-1-重采样（Resample-方法）"><a href="#4-9-1-重采样（Resample-方法）" class="headerlink" title="4.9.1　重采样（Resample()方法）"></a>4.9.1　重采样（Resample()方法）</h3><p>通过前面的学习，我们学会了如何生成不同频率的时间索引，按小时、按天、按周、按月等，如果想对数据做不同频率的转换，该怎么办？在Pandas中对时间序列的频率的调整称为重新采样，即将时间序列从一个频率转换到另一个频率的处理过程。例如，每天一个频率转换为每5天一个频率，如图4.67所示。</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020052720517.png" srcset="/img/loading.gif" lazyload alt="image-20211020052720517"></p>
<p>​                                       图4.67　时间频率<br>重采样主要使用resample()方法，该方法用于对常规时间序列重新采样和频率转换，包括降采样和升采样两种。首先了解下resample()方法，语法如下：</p>
<p>DataFrame.resample(rule,how=None,axis=0,fill_method=None,closed=None,label=None,convention=’start’,kind=<br>None,loffset=None,limit=None,base=0,on=None,level=None)<br>参数说明：　</p>
<p>rule：字符串，偏移量表示目标字符串或对象转换。　</p>
<p>how：用于产生聚合值的函数名或数组函数。例如mean、ohlc和np.max等，默认值为mean，其他常用的值为first、last、median、max和min。　</p>
<p>axis：整型，表示行列，axis=0表示列，axis=1表示行。默认值为0，即表示列。　fill_method：升采样时所使用的填充方法，ffill()方法（用前值填充）或bfill()方法（用后值填充），默认值为None。　</p>
<p>closed：降采样时，时间区间的开和闭，与数学里区间的概念一样，其值为right或left，right表示左开右闭（即左边值不包括在内），left表示左闭右开（即右边值不包括在内），默认值为right左开右闭。　</p>
<p>label：降采样时，如何设置聚合值的标签。例如，10:30—10:35会被标记成10:30还是10:35，默认值为None。　</p>
<p>convention：当重采样时，将低频率转换到高频率所采用的约定，其值为start或end，默认值为start。　</p>
<p>kind：聚合到时期（period）或时间戳（timestamp），默认聚合到时间序列的索引类型，默认值为None。　</p>
<p>loffset：聚合标签的时间校正值，默认值为None。例如，-1s或Second(-1)用于将聚合标签调早1秒。　</p>
<p>limit：向前或向后填充时，允许填充的最大时期数，默认值为None。</p>
<p>　base：整型，默认值为0。对于均匀细分1天的频率，聚合间隔的“原点”。例如，对于5min频率，base的范围可以是0～4。　on：字符串，可选参数，默认值为None。对DataFrame对象使用列代替索引进行重新采样。列必须与日期时间类似。　</p>
<p>level：字符串或整型，可选参数，默认值为None。用于多索引，重新采样的级别名称或级别编号，级别必须与日期时间类似。　</p>
<p>返回值：重新采样对象。</p>
<p>【示例49】　一分钟的时间序列转换为3分钟的时间序列。（示例位置：资源包\MR\Code\04\49）<br>首先创建一个包含9个一分钟的时间序列，然后使用resample()方法转换为3分钟的时间序列，并对索引列进行求和计算，如图4.68所示。</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020052840027.png" srcset="/img/loading.gif" lazyload alt="image-20211020052840027"></p>
<p>​                          图4.68　时间序列转换<br>程序代码如下：</p>
<p>01  import pandas as pd<br>02  index = pd.date_range(‘02/02/2020’, periods=9, freq=’T’)</p>
<p>03  series = pd.Series(range(9), index=index)<br>04  print(series)<br>05  print(series.resample(‘3T’).sum())</p>
<h3 id="4-9-2-降采样处理"><a href="#4-9-2-降采样处理" class="headerlink" title="4.9.2　降采样处理"></a>4.9.2　降采样处理</h3><p>降采样是周期由高频率转向低频率。例如，将5min股票交易数据转换为日交易，按天统计的销售数据转换为按周统计。<br>数据降采样会涉及数据的聚合。例如，天数据变成周数据，那么就要对1周7天的数据进行聚合，聚合的方式主要包括求和、求均值等。例如，淘宝店铺每天销售数据（部分数据），如图4.69所示。</p>
<p>【示例50】　按周统计销售数据。（示例位置：资源包\MR\Code\04\50）<br>使用resample()方法来做降采样处理，频率为“周”，也就是将上述销售数据处理为每周（每7天）求和一次数据，程序代码如下：</p>
<p>01 import pandas as pd<br>02 df=pd.read_excel(‘time.xls’)<br>03 df1 = df.set_index(‘订单付款时间’)  #设置“订单付款时间”为索引<br>04 print(df1.resample(‘W’).sum().head())<br>运行程序，控制台输出结果如图4.70所示。<br>在参数说明中，我们列出了closed参数的解释，如果把closed参数值设置为left，结果如图4.71所示。</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020052938423.png" srcset="/img/loading.gif" lazyload alt="image-20211020052938423"></p>
<p>​              图4.69　淘宝店铺每天销售数据（部分数据）</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020053019859.png" srcset="/img/loading.gif" lazyload alt="image-20211020053019859"></p>
<p>​                                       图4.70　周数据统计1</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020053036196.png" srcset="/img/loading.gif" lazyload alt="image-20211020053036196"></p>
<p>​                              图4.71　周数据统计2</p>
<h3 id="4-9-3-升采样处理"><a href="#4-9-3-升采样处理" class="headerlink" title="4.9.3　升采样处理"></a>4.9.3　升采样处理</h3><p>升采样是周期由低频率转向高频率。将数据从低频率转换到高频率时，就不需要聚合了，将其重采样到日频率，默认会引入缺失值。<br>例如，原来是按周统计的数据，现在变成按天统计。升采样会涉及数据的填充，根据填充的方法不同，填充的数据也不同。下面介绍3种填充方法。　不填充。空值用NaN代替，使用asfreq()方法。　用前值填充。用前面的值填充空值，使用ffill()方法或者pad()方法。为了方便记忆，ffill()方法可以使用它的第一个字母“f”代替，代表forward，向前的意思。　用后值填充，使用bfill()方法，可以使用字母“b”代替，代表back，向后的意思。</p>
<p>【示例51】　每6小时统计一次数据。（示例位置：资源包\MR\Code\04\51）<br>下面创建一个时间序列，起始日期是2020-02-02，一共两天，每天对应的数值分别是1和2，通过升采样处理为每6小时统计一次数据，空值以不同的方式填充，程序代码如下：</p>
<p>01  import pandas as pd<br>02  import numpy as np<br>03  rng = pd.date_range(‘20200202’, periods=2)<br>04  s1 = pd.Series(np.arange(1,3), index=rng)</p>
<p>05  s1_6h_asfreq = s1.resample(‘6H’).asfreq()</p>
<p>06  print(s1_6h_asfreq)</p>
<p>07  s1_6h_pad = s1.resample(‘6H’).pad()<br>08  print(s1_6h_pad)</p>
<p>09  s1_6h_ffill = s1.resample(‘6H’).ffill()<br>10  print(s1_6h_ffill)</p>
<p>11  s1_6h_bfill = s1.resample(‘6H’).bfill()<br>12  print(s1_6h_bfill)<br>运行程序，控制台输出结果如图4.72所示。</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020053124798.png" srcset="/img/loading.gif" lazyload alt="image-20211020053124798"></p>
<p>​                          图4.72　6小时数据统计</p>
<h3 id="4-9-4-时间序列数据汇总（ohlc-函数）"><a href="#4-9-4-时间序列数据汇总（ohlc-函数）" class="headerlink" title="4.9.4　时间序列数据汇总（ohlc()函数）"></a>4.9.4　时间序列数据汇总（ohlc()函数）</h3><p>在金融领域，经常会看到开盘（open）、收盘（close）、最高价（high）和最低价（low）数据，而在Pandas中经过重新采样的数据也可以实现这样的结果，通过调用ohlc()函数得到数据汇总结果，即开始值（open）、结束值（close）、最高值（high）和最低值（low）。ohlc()函数的语法如下：</p>
<p>resample.ohlc()<br>ohlc()函数返回DataFrame对象，每组数据的open（开）、high（高）、low（低）和close（关）值。</p>
<p>【示例52】　统计数据的open、high、low和close值。（示例位置：资源包\MR\Code\04\52）<br>下面是一组5分钟的时间序列，通过ohlc()函数获取该时间序列中每组时间的开始值、最高值、最低值和结束值，程序代码如下：</p>
<p>01  import pandas as pd<br>02  import numpy as np<br>03  rng = pd.date_range(‘2/2/2020’,periods=12,freq=’T’)<br>04  s1 = pd.Series(np.arange(12),index=rng)<br>05  print(s1.resample(‘5min’).ohlc())<br>运行程序，控制台输出结果如图4.73所示。</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020053212045.png" srcset="/img/loading.gif" lazyload alt="image-20211020053212045"></p>
<p>​                          图4.73　时间序列数据汇总</p>
<h3 id="4-9-5-移动窗口数据计算（rolling-函数）"><a href="#4-9-5-移动窗口数据计算（rolling-函数）" class="headerlink" title="4.9.5　移动窗口数据计算（rolling()函数）"></a>4.9.5　移动窗口数据计算（rolling()函数）</h3><p>通过重采样可以得到想要的任何频率的数据，但是这些数据也是一个时点的数据，那么就存在这样一个问题：时点的数据波动较大，某一点的数据就不能很好地表现它本身的特性，于是就有了“移动窗口”的概念，简单地说，为了提升数据的可靠性，将某个点的取值扩大到包含这个点的一段区间，用区间来进行判断，这个区间就是窗口。<br>下面举例说明，图4.74显示了移动窗口数据示意图，其中时间序列代表1号到15号每天的销量数据，接下来以3天为一个窗口，将该窗口从左至右依次移动，统计出3天的平均值作为这个点的值，如3号的销量是1号、2号和3号的平均值。</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020053234231.png" srcset="/img/loading.gif" lazyload alt="image-20211020053234231"></p>
<p>​                      图4.74　移动窗口数据示意图<br>通过上述示意图相信您已经理解了移动窗口，在Pandas中可以通过rolling()函数实现移动窗口数据的计算，语法如下：</p>
<p>DataFrame.rolling(window, min_periods=None, center=False, win_type=None, on=None, axis=0, closed=None)</p>
<p>参数说明：　</p>
<p>window：时间窗口的大小，有两种形式，即int或offset。如果使用int，则数值表示计算统计量的观测值的数量，即向前几个数据；如果使用offset，则表示时间窗口的大小。　</p>
<p>min_periods：每个窗口最少包含的观测值数量，小于这个值的窗口结果为NA。值可以是int，默认值为None。offset情况下，默认值为1。</p>
<p>center：把窗口的标签设置为居中。布尔型，默认值为False，居右。</p>
<p>win_type：窗口的类型。截取窗的各种函数。字符串类型，默认值为None。　</p>
<p>on：可选参数。对于DataFrame对象，是指定要计算移动窗口的列，值为列名。　</p>
<p>axis：整型，axis=0表示列，axis=1表示行。默认值为0，即对列进行计算。　</p>
<p>closed：定义区间的开闭，支持int类型的窗口。对于offset类型默认是左开右闭（默认值为right）。可以根据情况指定left。　</p>
<p>返回值：为特定操作而生成的窗口或移动窗口子类。</p>
<p>【示例53】　创建淘宝每日销量数据。（示例位置：资源包\MR\Code\04\53）<br>首先创建一组淘宝每日销量数据，程序代码如下：</p>
<p>01  import pandas as pd<br>02  index=pd.date_range(‘20200201’,’20200215’)<br>03  data=[3,6,7,4,2,1,3,8,9,10,12,15,13,22,14]<br>04  s1_data=pd.Series(data,index=index)<br>05  print(s1_data)<br>运行程序，控制台输出结果如图4.75所示。</p>
<p>【示例54】　使用rolling()函数计算3天的均值。（示例位置：资源包\MR\Code\04\54）</p>
<p>下面使用rolling()函数计算2020-02-01至2020-02-15中每3天的均值，窗口个数为3，代码如下：</p>
<p>s1_data.rolling(3).mean()<br>运行程序，看下rolling()函数是如何计算的？在图4.76中，当窗口开始移动时，第一个时间点2020-02-01和第二个时间点2020-02-02的数值为空，这是因为窗口个数为3，它们前面有空数据，所以均值为空；而到第三个时间点2020-02-03时，它前面的数据是2020-02-01至2020-02-03，所以3天的均值是5.333333；以此类推。</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020053403924.png" srcset="/img/loading.gif" lazyload alt="image-20211020053403924"></p>
<p>​                                     图4.75　原始数据</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020053419587.png" srcset="/img/loading.gif" lazyload alt="image-20211020053419587"></p>
<p>​                       图4.76　2020-02-01至2020-02-15移动窗口均值1</p>
<p>【示例55】　用当天的数据代表窗口数据。（示例位置：资源包\MR\Code\04\55）<br>在计算第一个时间点2020-02-01的窗口数据时，虽然数据不够窗口长度3，但是至少有当天的数据，那么能否用当天的数据代表窗口数据呢？答案是肯定的，通过设置min_periods参数即可，它表示窗口最少包含的观测值，小于这个值的窗口长度显示为空，等于或大于时都有值，主要代码如下：</p>
<p>s1_data.rolling(3,min_periods=1).mean()</p>
<p>运行程序，对比效果如图4.77所示。<br>上述举例，我们再扩展下，通过图表观察原始数据与移动窗口数据的平稳性，如图4.78所示。其中实线代表移动窗口数据，其走向更平稳，这也是学习移动窗口rolling()函数的原因。</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020053518298.png" srcset="/img/loading.gif" lazyload alt="image-20211020053518298"></p>
<p>​                 图4.77　2020-02-01至2020-02-15移动窗口均值2</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020053531782.png" srcset="/img/loading.gif" lazyload alt="image-20211020053531782"></p>
<p>​                     图4.78　移动窗口数据的平稳性说明<br>虚线代表原始数据，实线代表移动窗口数据。</p>
<h2 id="4-10-综合应用"><a href="#4-10-综合应用" class="headerlink" title="4.10　综合应用"></a>4.10　综合应用</h2><h3 id="4-10-1-案例1：Excel多表合并"><a href="#4-10-1-案例1：Excel多表合并" class="headerlink" title="4.10.1　案例1：Excel多表合并"></a>4.10.1　案例1：Excel多表合并</h3><p>案例位置：资源包\MR\Code\04\example\01<br>在日常工作中，几乎我们每天都有大量的数据需要处理，桌面上总是布满密密麻麻的Excel表，这样看上去非常凌乱，其实我们完全可以将其中类别相同的Excel表合并到一起，这样不但不会丢失数据，而且还可以有效地分析数据。下面使用concat()方法将指定文件夹内的所有Excel表合并，程序代码如下：</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020053607260.png" srcset="/img/loading.gif" lazyload alt="image-20211020053607260"></p>
<h3 id="4-10-2-案例2：股票行情数据分析"><a href="#4-10-2-案例2：股票行情数据分析" class="headerlink" title="4.10.2　案例2：股票行情数据分析"></a>4.10.2　案例2：股票行情数据分析</h3><p>案例位置：资源包\MR\Code\04\example\02<br>股票数据包括开盘价、收盘价、最高价、最低价、成交量等多个指标。其中，收盘价是当日行情的标准，也是下一个交易日开盘价的依据，可以预测未来证券市场行情，因此当投资者对行情分析时，一般采用收盘价作为计算依据。<br>下面使用rolling()函数计算某股票20天、50天和200天的收盘价均值并生成走势图（也称K线图），如图4.79所示。</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020053723586.png" srcset="/img/loading.gif" lazyload alt="image-20211020053723586"></p>
<p>​                                       图4.79　股票行情分析</p>
<p>程序代码如下：</p>
<p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020053800663.png" srcset="/img/loading.gif" lazyload alt="image-20211020053800663"></p>
<p>实用技巧<br>默认情况下，图表嵌入控制台（IPython console）中并以静态方式显示，无法进行移动、放大、缩小等操作。此时需要在工具中的首选项窗口进行设置，方法为选择Tools→Preferences命令，打开Preferences（首选项）窗口，在左侧列表中选择IPython console（IPython控制台），在右侧窗口选择Graphics（图形）选项卡，然后在Backend（后端）下拉列表框中选择Automatic（自动）或者Qt5，单击Apply（应用）按钮。设置完成后重新启动Spyder才生效。</p>
<h2 id="4-11-小结"><a href="#4-11-小结" class="headerlink" title="4.11　小结"></a>4.11　小结</h2><p>本章是Pandas的进阶学习，有一定难度，但同时也更能够体现Pandas的强大之处，不仅可以完成数据处理工作，而且还能够实现数据的统计分析。Pandas提供的大量函数使统计分析工作变得简单高效。别具特色的“数据位移”是一个非常有用的方法，与其他方法结合，能够实现很多难以想象的功能，数据转换将DataFrame与Python数据类型之间进行灵活转换。不仅如此，对于日期数据的处理、时间序列也都提供了专门的函数和方法，使得量化数据得心应手。</p>

              
            </div>
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/" class="category-chain-item">数据分析</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/">#数据分析</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Pandas统计分析</div>
      <div>http://example.com/2020/02/19/shujufenxi/Pandas统计分析/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>温酒斩华雄</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2020年2月19日</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>更新于</div>
          <div>2020年2月19日</div>
        </div>
      
      <div class="license-meta-item">
        <div>许可协议</div>
        <div>
          
            
            
              <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
              <span class="hint--top hint--rounded" aria-label="BY - 署名">
                <i class="iconfont icon-by"></i>
              </span>
              </a>
            
          
        </div>
      </div>
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2020/02/21/shujufenxi/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8Pyechars/" title="数据可视化分析图表Pyechars">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">数据可视化分析图表Pyechars</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2019/10/20/react/redux%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/" title="redux实现原理">
                        <span class="hidden-mobile">redux实现原理</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  <article id="comments" lazyload>
    

  </article>


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  






    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> <div>来喽博客 | 记录学习成长的过程</div> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    
  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  

  

  

  

  

  

  




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.0/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script>
  (function() {
    var enableLang = CONFIG.code_language.enable && CONFIG.code_language.default;
    var enableCopy = CONFIG.copy_btn;
    if (!enableLang && !enableCopy) {
      return;
    }

    function getBgClass(ele) {
      return Fluid.utils.getBackgroundLightness(ele) >= 0 ? 'code-widget-light' : 'code-widget-dark';
    }

    var copyTmpl = '';
    copyTmpl += '<div class="code-widget">';
    copyTmpl += 'LANG';
    copyTmpl += '</div>';
    jQuery('.markdown-body pre').each(function() {
      var $pre = jQuery(this);
      if ($pre.find('code.mermaid').length > 0) {
        return;
      }
      if ($pre.find('span.line').length > 0) {
        return;
      }

      var lang = '';

      if (enableLang) {
        lang = CONFIG.code_language.default;
        if ($pre[0].children.length > 0 && $pre[0].children[0].classList.length >= 2 && $pre.children().hasClass('hljs')) {
          lang = $pre[0].children[0].classList[1];
        } else if ($pre[0].getAttribute('data-language')) {
          lang = $pre[0].getAttribute('data-language');
        } else if ($pre.parent().hasClass('sourceCode') && $pre[0].children.length > 0 && $pre[0].children[0].classList.length >= 2) {
          lang = $pre[0].children[0].classList[1];
          $pre.parent().addClass('code-wrapper');
        } else if ($pre.parent().hasClass('markdown-body') && $pre[0].classList.length === 0) {
          $pre.wrap('<div class="code-wrapper"></div>');
        }
        lang = lang.toUpperCase().replace('NONE', CONFIG.code_language.default);
      }
      $pre.append(copyTmpl.replace('LANG', lang).replace('code-widget">',
        getBgClass($pre[0]) + (enableCopy ? ' code-widget copy-btn" data-clipboard-snippet><i class="iconfont icon-copy"></i>' : ' code-widget">')));

      if (enableCopy) {
        Fluid.utils.createScript('https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js', function() {
          var clipboard = new window.ClipboardJS('.copy-btn', {
            target: function(trigger) {
              var nodes = trigger.parentNode.childNodes;
              for (var i = 0; i < nodes.length; i++) {
                if (nodes[i].tagName === 'CODE') {
                  return nodes[i];
                }
              }
            }
          });
          clipboard.on('success', function(e) {
            e.clearSelection();
            e.trigger.innerHTML = e.trigger.innerHTML.replace('icon-copy', 'icon-success');
            setTimeout(function() {
              e.trigger.innerHTML = e.trigger.innerHTML.replace('icon-success', 'icon-copy');
            }, 2000);
          });
        });
      }
    });
  })();
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/assets/wanko.model.json"},"display":{"position":"left","hOffset":0,"vOffset":-20,"width":200,"height":300},"mobile":{"show":true},"react":{"opacity":0.7},"log":false});</script></body>
</html>

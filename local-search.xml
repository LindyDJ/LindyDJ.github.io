<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>javascript几种继承方法</title>
    <link href="/2022/06/20/js/javascript%E5%87%A0%E7%A7%8D%E7%BB%A7%E6%89%BF%E6%96%B9%E6%B3%95/"/>
    <url>/2022/06/20/js/javascript%E5%87%A0%E7%A7%8D%E7%BB%A7%E6%89%BF%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h4 id="javascript实现继承的几种方法？"><a href="#javascript实现继承的几种方法？" class="headerlink" title="javascript实现继承的几种方法？"></a>javascript实现继承的几种方法？</h4><h5 id="1-原型链继承"><a href="#1-原型链继承" class="headerlink" title="1.原型链继承"></a>1.原型链继承</h5><p>构造函数，原型，实例之间的关系：每一个构造函数都有一个原型对象，原型对象中有一个执行构造函数的指针，然而实例对象中包含一个指向原型对象的指针。</p><ul><li><p>优点：父类方法可以复用。</p></li><li><p>缺点：</p><ul><li>父类中所有引用类型的数据（对象，数组）会被子类共享。只要更改了其中一个子类的数据。其他数据都会受到影响，一起变化。</li><li>子类实例不能给父类构造函数传递参数。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//父类Person</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;小明&#x27;</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">eats</span> = [<span class="hljs-string">&#x27;苹果&#x27;</span>]<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">getName</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>)<br>    &#125;<br>&#125;<br><span class="hljs-comment">//在父类原型上定义方法</span><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">get</span> = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Person的原型上的get方法&#x27;</span>)<br>&#125;<br><br><span class="hljs-comment">//子类</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Child</span>(<span class="hljs-params"></span>) &#123; &#125;<br><span class="hljs-comment">//将子类的原型指向父类的实例对象</span><br><span class="hljs-title class_">Child</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>()<br><br><br><span class="hljs-comment">//创建子类实例对象，会拥有父类Person所有的属性，方法。</span><br><span class="hljs-keyword">const</span> children = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>()<br>children.<span class="hljs-property">name</span>=<span class="hljs-string">&#x27;赵先生&#x27;</span><br>children.<span class="hljs-property">eats</span>.<span class="hljs-title function_">push</span>(<span class="hljs-string">&#x27;香蕉&#x27;</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(children.<span class="hljs-property">name</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(children.<span class="hljs-property">eats</span>)<br>children.<span class="hljs-title function_">getName</span>()<br>children.<span class="hljs-title function_">get</span>()<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&quot;</span>)<br><br><span class="hljs-comment">//创建子类实例对象，会拥有父类Person所有的属性，方法。</span><br><span class="hljs-keyword">const</span> children2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>()<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(children2.<span class="hljs-property">name</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(children2.<span class="hljs-property">eats</span>)<br>children2.<span class="hljs-title function_">getName</span>()<br>children2.<span class="hljs-title function_">get</span>()<br><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">赵先生</span><br><span class="hljs-comment">[&quot;苹果&quot;,&quot;香蕉&quot;]</span><br><span class="hljs-comment">赵先生</span><br><span class="hljs-comment">Person的原型上的get方法</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">小明</span><br><span class="hljs-comment">[&quot;苹果&quot;,&quot;香蕉&quot;]</span><br><span class="hljs-comment">小明</span><br><span class="hljs-comment">Person的原型上的get方法*/</span><br><br></code></pre></td></tr></table></figure></li></ul><h5 id="2-构造函数继承"><a href="#2-构造函数继承" class="headerlink" title="2.构造函数继承"></a>2.构造函数继承</h5><ul><li><p>优点：父类的引用类型的数据，不会被子类共享。不会互相影响。</p></li><li><p>缺点：不能访问父类构造函数原型上（Person.prototype）的参数和方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//父类Person</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;小明&#x27;</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">eats</span> = [<span class="hljs-string">&#x27;苹果&#x27;</span>]<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">getName</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>)<br>    &#125;<br>&#125;<br><span class="hljs-comment">//在父类原型上定义方法</span><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">get</span> = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Person的原型上的get方法&#x27;</span>)<br>&#125;<br><br><span class="hljs-comment">//子类</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Child</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title class_">Person</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>)<br>&#125;<br><br><br><br><span class="hljs-comment">//创建子类实例对象，会拥有父类Person构造函数的属性，方法。</span><br><span class="hljs-keyword">const</span> children = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>()<br>children.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;赵先生&#x27;</span><br>children.<span class="hljs-property">eats</span>.<span class="hljs-title function_">push</span>(<span class="hljs-string">&#x27;香蕉&#x27;</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(children.<span class="hljs-property">name</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(children.<span class="hljs-property">eats</span>)<br>children.<span class="hljs-title function_">getName</span>()<br><span class="hljs-comment">// children.get()</span><br><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&quot;</span>)<br><br><span class="hljs-comment">//创建子类实例对象，会拥有父类Person构造函数的属性，方法。</span><br><span class="hljs-keyword">const</span> children2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>()<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(children2.<span class="hljs-property">name</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(children2.<span class="hljs-property">eats</span>)<br>children2.<span class="hljs-title function_">getName</span>()<br><span class="hljs-comment">// children2.get()</span><br><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">赵先生</span><br><span class="hljs-comment">[&quot;苹果&quot;,&quot;香蕉&quot;]</span><br><span class="hljs-comment">赵先生</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">小明</span><br><span class="hljs-comment">[&quot;苹果&quot;]</span><br><span class="hljs-comment">小明</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure></li></ul><h5 id="3-组合继承"><a href="#3-组合继承" class="headerlink" title="3.组合继承"></a>3.组合继承</h5><ul><li><p>优点：组合继承就是将  原型链继承和构造函数继承  结合起来。解决了这种继承的弊端。</p></li><li><p>缺点：会调用两次父类构造函数，拥有两份一样的属性和方法。影响性能的开销。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//父类Person</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;小明&#x27;</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">eats</span> = [<span class="hljs-string">&#x27;苹果&#x27;</span>]<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">getName</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>)<br>    &#125;<br>&#125;<br><span class="hljs-comment">//在父类原型上定义方法</span><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">get</span> = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Person的原型上的get方法&#x27;</span>)<br>&#125;<br><br><span class="hljs-comment">//子类</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Child</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title class_">Person</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>)<br>&#125;<br><span class="hljs-title class_">Child</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>()<br><br><br><span class="hljs-comment">//创建子类实例对象，会拥有父类Person构造函数的属性，方法。</span><br><span class="hljs-keyword">const</span> children = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>()<br>children.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;赵先生&#x27;</span><br>children.<span class="hljs-property">eats</span>.<span class="hljs-title function_">push</span>(<span class="hljs-string">&#x27;香蕉&#x27;</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(children.<span class="hljs-property">name</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(children.<span class="hljs-property">eats</span>)<br>children.<span class="hljs-title function_">getName</span>()<br>children.<span class="hljs-title function_">get</span>()<br><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&quot;</span>)<br><br><span class="hljs-comment">//创建子类实例对象，会拥有父类Person构造函数的属性，方法。</span><br><span class="hljs-keyword">const</span> children2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>()<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(children2.<span class="hljs-property">name</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(children2.<span class="hljs-property">eats</span>)<br>children2.<span class="hljs-title function_">getName</span>()<br>children2.<span class="hljs-title function_">get</span>()<br><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">赵先生</span><br><span class="hljs-comment">[&quot;苹果&quot;,&quot;香蕉&quot;]</span><br><span class="hljs-comment">赵先生</span><br><span class="hljs-comment">Person的原型上的get方法</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">小明</span><br><span class="hljs-comment">[&quot;苹果&quot;]</span><br><span class="hljs-comment">小明</span><br><span class="hljs-comment">Person的原型上的get方法</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure></li></ul><h5 id="4-寄生式组合继承"><a href="#4-寄生式组合继承" class="headerlink" title="4.寄生式组合继承"></a>4.寄生式组合继承</h5><ul><li><p>在组合继承的基础之上，做了一个中转，不在创建父类实例（new Person()），创建一个空的函数，将该函数的原型指向父类person的原型。之后在将子类的原型指向该函数的实例对象即可。是目前相对最优的继承方式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//父类Person</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;小明&#x27;</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">eats</span> = [<span class="hljs-string">&#x27;苹果&#x27;</span>]<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">getName</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>)<br>    &#125;<br>&#125;<br><span class="hljs-comment">//在父类原型上定义方法</span><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">get</span> = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Person的原型上的get方法&#x27;</span>)<br>&#125;<br><br><span class="hljs-comment">//子类</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Child</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title class_">Person</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>)<br>&#125;<br><span class="hljs-comment">//创建空的函数，做中转，该函数指向父类的原型</span><br><span class="hljs-keyword">const</span> fn = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;&#125;<br>fn.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span><br><span class="hljs-comment">//最后子类的原型指向该函数的实例</span><br><span class="hljs-title class_">Child</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>=<span class="hljs-keyword">new</span> <span class="hljs-title function_">fn</span>()<br><br><br><span class="hljs-comment">//创建子类实例对象，会拥有父类Person构造函数的属性，方法。</span><br><span class="hljs-keyword">const</span> children = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>()<br>children.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;赵先生&#x27;</span><br>children.<span class="hljs-property">eats</span>.<span class="hljs-title function_">push</span>(<span class="hljs-string">&#x27;香蕉&#x27;</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(children.<span class="hljs-property">name</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(children.<span class="hljs-property">eats</span>)<br>children.<span class="hljs-title function_">getName</span>()<br>children.<span class="hljs-title function_">get</span>()<br><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&quot;</span>)<br><br><span class="hljs-comment">//创建子类实例对象，会拥有父类Person构造函数的属性，方法。</span><br><span class="hljs-keyword">const</span> children2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>()<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(children2.<span class="hljs-property">name</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(children2.<span class="hljs-property">eats</span>)<br>children2.<span class="hljs-title function_">getName</span>()<br>children2.<span class="hljs-title function_">get</span>()<br></code></pre></td></tr></table></figure></li></ul><h5 id="5-es6-class继承"><a href="#5-es6-class继承" class="headerlink" title="5.es6  class继承"></a>5.es6  class继承</h5><p>使用class构造一个父类，  构造一个子类使用extends来继承父类。super指向父类的原型对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Parent</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name, age</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">tt</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;sdfsdfsdfsdfdsaf&#x27;</span>)<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//原型上的方法</span><br>    <span class="hljs-title function_">sayName</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Parent</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name, age, gender</span>) &#123;<br>        <span class="hljs-variable language_">super</span>(name, age)<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">gender</span> = gender<br><br>    &#125;<br>    <span class="hljs-comment">//原型上的方法</span><br>    <span class="hljs-title function_">sayGender</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">gender</span>);<br>    &#125;<br>&#125;<br><br><br><span class="hljs-keyword">const</span> ming = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>(<span class="hljs-string">&#x27;ming&#x27;</span>, <span class="hljs-number">18</span>, <span class="hljs-string">&#x27;男&#x27;</span>)<br>ming.<span class="hljs-title function_">sayGender</span>()<br>ming.<span class="hljs-title function_">sayName</span>()<br>ming.<span class="hljs-title function_">tt</span>()<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(ming.<span class="hljs-property">name</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(ming.<span class="hljs-property">age</span>);<br><span class="hljs-comment">//console.log(ming)</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">男</span><br><span class="hljs-comment">ming</span><br><span class="hljs-comment">sdfsdfsdfsdfdsaf</span><br><span class="hljs-comment">ming</span><br><span class="hljs-comment">18</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>javascript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>继承</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue3系列面试题</title>
    <link href="/2021/10/19/vue3%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/2021/10/19/vue3%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h4 id="Vue3-0的设计目标是什么？做了哪些优化？"><a href="#Vue3-0的设计目标是什么？做了哪些优化？" class="headerlink" title="Vue3.0的设计目标是什么？做了哪些优化？"></a>Vue3.0的设计目标是什么？做了哪些优化？</h4><h5 id="设计目标"><a href="#设计目标" class="headerlink" title="设计目标"></a>设计目标</h5><ul><li>体积更小：<ul><li>vue3移除一些不常用的API，引入tree shaking，将一些无用的模块“剪辑掉”。仅打包需要的模块。使打包体积变小了。</li></ul></li><li>更快：<ul><li>diff算法优化：</li><li>静态提升</li><li>事件缓存机制</li><li>ssr优化</li></ul></li><li>更友好：<ul><li>vue3推出了composition API，大大增加了代码的组织能力和复用能力。</li></ul></li></ul><h5 id="优化方案"><a href="#优化方案" class="headerlink" title="优化方案"></a>优化方案</h5><ul><li>源码<ul><li>源码管理，体积更小</li><li>使用ts，提供类型检查</li></ul></li><li>性能<ul><li>体积优化</li><li>编译优化</li><li>数据劫持优化</li></ul></li><li>语法API<ul><li>组合式API，主要提高了代码的组织和复用能力</li></ul></li></ul><h4 id="Vue3-0性能提升主要是通过哪几方面体现的？"><a href="#Vue3-0性能提升主要是通过哪几方面体现的？" class="headerlink" title="Vue3.0性能提升主要是通过哪几方面体现的？"></a>Vue3.0性能提升主要是通过哪几方面体现的？</h4><ul><li>编译阶段<ul><li>diff算法优化：比vue2增加了静态标记，在发生改变的地方做一个flag标记，下次发生改变可以直接找到该地方进行比较。</li><li>静态提升：  vue3对不参与更新的元素，会做静态提升，只创建一次，可以复用渲染。免去重复创建节点，优化了运行时的内存。</li><li>事件缓存机制</li><li>SSR优化：  当内容达到一定量的时候，采用服务端渲染。</li></ul></li><li>源码体积<ul><li>相对于vue2来说体积变小了，去除一些不常用API。使用树摇（tree shaking），只打包需要的模块，打包体积变小了</li></ul></li><li>响应式系统<ul><li>vue2采用object.proerty（）劫持整个对象，深度遍历每个属性，给每个属性添加getter，setter，来实现响应式。</li><li>vue3使用了vue3代理对象，可以对整个对象进行监听，不需要深度遍历。</li><li>可以监听整个对象以及属性的修改和删除，可以监听数组的索引和lenght属性。</li></ul></li></ul><h4 id="Vue3-0里为什么要用-Proxy-API-替代-defineProperty-API-？"><a href="#Vue3-0里为什么要用-Proxy-API-替代-defineProperty-API-？" class="headerlink" title="Vue3.0里为什么要用 Proxy API 替代 defineProperty API ？"></a>Vue3.0里为什么要用 Proxy API 替代 defineProperty API ？</h4><ul><li>defineProerty API：<ul><li>检测不到对象属性的添加和删除， 提供了set，和delete方法。</li><li>数组的方法 无法监听到（push，shift）</li><li>需要对每个属性进行监听，如果是嵌套对象的话，需使用深度监听，可能会造成性能问题。</li></ul></li><li>Proxy：<ul><li>object.definproerty 只能遍历对象属性进行劫持，proxy直接监听整个对象。</li><li>返回一个新对象，只需操作新对象就能达到目的。</li><li>proxy有多达13种监听方法，不限于apply，has等，这是object.defineproerty（）不具备的</li><li>可以直接监听数组的变化（push，shift，splice）</li></ul></li></ul><h4 id="Vue3-0-所采用的-Composition-Api-与-Vue2-x-使用的-Options-Api-有什么不同？"><a href="#Vue3-0-所采用的-Composition-Api-与-Vue2-x-使用的-Options-Api-有什么不同？" class="headerlink" title="Vue3.0 所采用的 Composition Api 与 Vue2.x 使用的 Options Api 有什么不同？"></a>Vue3.0 所采用的 Composition Api 与 Vue2.x 使用的 Options Api 有什么不同？</h4><ul><li>Options API:<ul><li>通过定义data，methods，computed等方法和属性，来共同处理页面逻辑，一个功能的实现，需要不同的位置的方法和属性，比较分散。可能会造成组件的难以理解和维护。    </li></ul></li><li>Composition API:<ul><li>所有方法和功能都写在setup当中，将一个功能的所有方法，属性放在一起。（高内聚，低耦合）。根据相关逻辑来组织代码，提高代码的可读性和维护性。（当功能增多时，还可使用hook来封装出去）</li><li>组合式API中见不到this的使用，减少this指向不明的问题。</li><li>组合式API几乎都是函数，会有很好的类型判断。</li></ul></li></ul><h4 id="说说Vue-3-0中Treeshaking特性？举例说明一下？"><a href="#说说Vue-3-0中Treeshaking特性？举例说明一下？" class="headerlink" title="说说Vue 3.0中Treeshaking特性？举例说明一下？"></a>说说Vue 3.0中Treeshaking特性？举例说明一下？</h4><h5 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h5><p>Tree shaking是一种术语，在打包时不打包没有用到的模块，减小了打包体积。</p><h5 id="如何做？"><a href="#如何做？" class="headerlink" title="如何做？"></a>如何做？</h5><p>Tree shaking是基于es6的 <code>import</code> 和  <code>exports</code> 静态编程思想来确定模块的依赖关系。</p><ul><li>tree shaking会在编译阶段判断模块的加载状态</li><li>判断未使用的变量，进行移除。</li></ul><h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><ul><li>减小打包体积</li><li>减少程序打包的时间</li><li>便于维护优化项目框架</li></ul><h4 id="用Vue3-0-写过组件吗？如果想实现一个-Modal你会怎么设计？"><a href="#用Vue3-0-写过组件吗？如果想实现一个-Modal你会怎么设计？" class="headerlink" title="用Vue3.0 写过组件吗？如果想实现一个 Modal你会怎么设计？"></a>用Vue3.0 写过组件吗？如果想实现一个 Modal你会怎么设计？</h4><p>首先要考虑，大致实现的思路，根据ui设计图，确定好主体的内容，布局样式，做的那些交互操作，删除，修改等等。定义API方法来进行开发。</p>]]></content>
    
    
    <categories>
      
      <category>面试题总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试题总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue3中Treeaking特性</title>
    <link href="/2021/07/27/vue3/vue3%E4%B8%ADTreeshaking%E7%89%B9%E6%80%A7/"/>
    <url>/2021/07/27/vue3/vue3%E4%B8%ADTreeshaking%E7%89%B9%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h4 id="说说Vue-3-0中Treeshaking特性？举例说明一下？"><a href="#说说Vue-3-0中Treeshaking特性？举例说明一下？" class="headerlink" title="说说Vue 3.0中Treeshaking特性？举例说明一下？"></a>说说Vue 3.0中Treeshaking特性？举例说明一下？</h4><p><img src="/2021/07/27/vue3/vue3%E4%B8%ADTreeshaking%E7%89%B9%E6%80%A7/tt.png"></p><h5 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h5><p>Tree shaking是一种术语，在打包时将不打包没有用到的代码清除掉，这些代码会成为dead code（死代码）。也就是说，treeshaking在打包时所留下的，是我们用到的代码。</p><ul><li>在vue2中，无论我们使用什么功能，它们最终都会出现在打包后的文件中。因为vue2在项目中是单例的，无法检测到哪些代码在项目中是被用到的。</li><li>vue3引入了treeshaking特性，将全局api进行分块。如果没有使用到某个功能，他们将不会包含在你打包后的文件中。</li></ul><h5 id="如何做？"><a href="#如何做？" class="headerlink" title="如何做？"></a>如何做？</h5><p>Tree shaking是基于es6的模板语法import，exports静态编辑思想确定模块依赖关系的。</p><ul><li>treeshaking在编译阶段会判断模块的加载状态。</li><li>判断未使用的相关变量，进行移除。</li></ul><p>举个例子：<br> 如果，新创建的项目中，data中的变量1，和变量2被使用了，但是变量3，并没有被使用，那么变量3，会在打包的时候被移除<br> 在比如，可以对比一下项目在使用treeShaking打包之后和未使用的情况下进行打包后的大小，<br> data中的数据都被正常使用，methods的方法也被正常使用，component方法和watch方法未使用，然后进行打包<br> 答案显而易见，在使用treeShaking后进行打包只会将data和methods这种使用的方法进行打包，而不是打包所有</p><h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><ul><li>减少程序体积（更小）</li><li>减少程序执行时间（更快）</li><li>便于维护优化项目框架</li></ul><br><h5 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h5><hr><blockquote><ul><li><a href="https://segmentfault.com/a/1190000038962700">https://segmentfault.com/a/1190000038962700</a></li></ul></blockquote><blockquote><ul><li><a href="https://vue3js.cn/interview/vue3/treeshaking.html#%E4%B8%80%E3%80%81%E6%98%AF%E4%BB%80%E4%B9%88">https://vue3js.cn/interview/vue3/treeshaking.html#%E4%B8%80%E3%80%81%E6%98%AF%E4%BB%80%E4%B9%88</a></li></ul></blockquote>]]></content>
    
    
    <categories>
      
      <category>vue3</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue3Tree_shaking</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue3和vue2 API的区别</title>
    <link href="/2021/06/09/vue3/vue3%E5%92%8Cvue2-API%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2021/06/09/vue3/vue3%E5%92%8Cvue2-API%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h4 id="Vue3-0-所采用的-Composition-Api-与-Vue2-x-使用的-Options-Api-有什么不同？"><a href="#Vue3-0-所采用的-Composition-Api-与-Vue2-x-使用的-Options-Api-有什么不同？" class="headerlink" title="Vue3.0 所采用的 Composition Api 与 Vue2.x 使用的 Options Api 有什么不同？"></a>Vue3.0 所采用的 Composition Api 与 Vue2.x 使用的 Options Api 有什么不同？</h4><ol><li><p>options API:</p><p>即选项式API，通过定义methods，data，computed，watch等属性与方法，共同处理页面逻辑。</p><p>一个功能的实现，需要不同的vue配置项，定义属相和方法比较分散。大项目可能包含多个方法，这可能会导致组件难以阅读和理解。</p><p>如图：</p><p><img src="/2021/06/09/vue3/vue3%E5%92%8Cvue2-API%E7%9A%84%E5%8C%BA%E5%88%AB/tt.png"></p></li><li><p>composition API:</p><p>一个功能的所有api都会放在一起，实现了高内聚，低耦合。方便找到功能所对应的方法及属性。</p><p>根据逻辑相关性组织代码，提高可读性和可维护性，基于函数组合的API。</p><p>如图：</p><p><img src="/2021/06/09/vue3/vue3%E5%92%8Cvue2-API%E7%9A%84%E5%8C%BA%E5%88%AB/cc.png"></p><h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h4><hr><blockquote><ul><li><a href="https://vue3js.cn/interview/vue3/composition.html#%E6%AD%A3%E6%96%87">https://vue3js.cn/interview/vue3/composition.html#%E6%AD%A3%E6%96%87</a></li></ul></blockquote></li></ol>]]></content>
    
    
    <categories>
      
      <category>vue3</category>
      
    </categories>
    
    
    <tags>
      
      <tag>optionsAPI</tag>
      
      <tag>compositionAPI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue3使用proxy代替defindproerty</title>
    <link href="/2021/06/08/vue3/vue3%E4%BD%BF%E7%94%A8proxy%E4%BB%A3%E6%9B%BFdefindproerty/"/>
    <url>/2021/06/08/vue3/vue3%E4%BD%BF%E7%94%A8proxy%E4%BB%A3%E6%9B%BFdefindproerty/</url>
    
    <content type="html"><![CDATA[<h4 id="Vue3-0里为什么要用-Proxy-API-替代-defineProperty-API-？"><a href="#Vue3-0里为什么要用-Proxy-API-替代-defineProperty-API-？" class="headerlink" title="Vue3.0里为什么要用 Proxy API 替代 defineProperty API ？"></a>Vue3.0里为什么要用 Proxy API 替代 defineProperty API ？</h4><hr>proxy的性能本来比defindproerty好，proxy可以拦截属性的访问，赋值，删除等操作，不需要初始化的时候遍历所有属性。另外如果是多层嵌套的对象，只有访问某个属性的时候，才会递归处理下一级的属性。<p>object.defineproperty():</p><ul><li>检测不到对象属性的添加和删除   在这里可以使用set，delete方法。</li><li>不能根据数组索引来修改值</li><li>需要遍历每个属性进行遍历监听，如果是嵌套对象的话，就需要深层监听，造成性能问题。</li></ul><p>proxy：</p><ul><li>可以直接监听整个对象</li><li>可以直接监听数组的变化（push，shift，splice）</li><li>有多达13种拦截方法，不限于apply，has等等，是defindproerty不具备的</li><li>返回一个新的对象，只操作新的对象就能达到目的。</li></ul><br><h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h4><hr><blockquote><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty</a></li></ul></blockquote><blockquote><ul><li><a href="https://vue3js.cn/interview/vue3/proxy.html#%E4%B8%80%E3%80%81object-defineproperty">https://vue3js.cn/interview/vue3/proxy.html#%E4%B8%80%E3%80%81object-defineproperty</a></li></ul></blockquote>]]></content>
    
    
    <categories>
      
      <category>vue3</category>
      
    </categories>
    
    
    <tags>
      
      <tag>proxy,defindproerty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue3.x设计目标及优化</title>
    <link href="/2021/06/06/vue3/vue3-0%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8F%8A%E4%BC%98%E5%8C%96/"/>
    <url>/2021/06/06/vue3/vue3-0%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8F%8A%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h4 id="vue3-0的设计目标是什么？做了那些优化？"><a href="#vue3-0的设计目标是什么？做了那些优化？" class="headerlink" title="vue3.0的设计目标是什么？做了那些优化？"></a>vue3.0的设计目标是什么？做了那些优化？</h4><hr>设计目标：<ul><li>打包体积更小： vue3移除一些不常用的API，将无用的模块“剪辑”掉，仅打包需要的，使打包体积更小了。</li><li>速度更快：   diff算法优化，静态提升。</li><li>更灵活的代码组织能力：    推出composition  API，大大增加了代码的逻辑组织能力和代码复用能力。</li></ul><p>优化方案：</p><ul><li>源码<ul><li>使用ts语法，源码的优化。</li></ul></li><li>性能<ul><li>体积，编译，数据劫持优化。</li></ul></li><li>语法 API<ul><li><p>组合式API，根据相关逻辑组织代码。</p><p><img src="/2021/06/06/vue3/vue3-0%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8F%8A%E4%BC%98%E5%8C%96/tt.png"></p></li></ul></li></ul><br><h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献:"></a>参考文献:</h4><hr><blockquote><ul><li><a href="https://juejin.cn/post/6850418112878575629#heading-5">https://juejin.cn/post/6850418112878575629#heading-5</a></li></ul></blockquote><blockquote><ul><li><a href="https://vue3js.cn/docs/zh">https://vue3js.cn/docs/zh</a></li></ul></blockquote>]]></content>
    
    
    <categories>
      
      <category>vue3</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试题总结</title>
    <link href="/2021/05/17/lin-first-blog/"/>
    <url>/2021/05/17/lin-first-blog/</url>
    
    <content type="html"><![CDATA[<!-- --- title  标题  标题会显示在最上方居中位置     date  建立日期    如果不指定则为默认值-文件创建日期，可以自定义。 updated  更新日期  如果不指定则为默认值-文件修改后重新生成静态文件的日期。 comments  是否开启文章的评论功能 默认值为true tags  标签（不适用于页面page布局） categories  分类（不适用于页面page布局） permalink  覆盖文章网址 keywords  仅用于 meta 标签和 Open Graph 的关键词（不推荐使用） --- --><h4 id="1-说说你对盒子模型的理解"><a href="#1-说说你对盒子模型的理解" class="headerlink" title="1.    说说你对盒子模型的理解"></a>1.    说说你对盒子模型的理解</h4><p>标准盒子模型： </p><ul><li>content（内容）</li><li>margin（外边距） ：盒子与盒子之间的距离。</li><li>padding（内边距）：内容与边框的距离。</li><li>border（边框） </li></ul><p>IE盒子模型（怪异盒模型）</p><ul><li>content </li><li>margin </li></ul><p> 开发中往往使用IE盒模型，只需要设置box-sizing：border-box </p><p>盒⼦模型的实际宽度:width+左右padding+左右border</p><p>盒⼦模型的实际高度:height+左右padding+左右border</p><h4 id="2-css选择器有哪些？优先级？哪些属性可以继承？"><a href="#2-css选择器有哪些？优先级？哪些属性可以继承？" class="headerlink" title="2.    css选择器有哪些？优先级？哪些属性可以继承？"></a>2.    css选择器有哪些？优先级？哪些属性可以继承？</h4><ul><li><p>id选择器（#box），选择id为box的元素</p></li><li><p>类选择器（.one），选择类名为one的所有元素</p></li><li><p>标签选择器（div），选择标签为div的所有元素</p></li><li><p>后代选择器（#box  div），选择id为box元素内部所有的div元素</p></li><li><p>通配符选择器(*) </p></li><li><p>伪类选择器(a:hover, li:nth-child) </p></li></ul><p><strong>优先级</strong></p><p> 内联 &gt; ID选择器 &gt; 类选择器 &gt; 标签选择器 &gt;子代选择器&gt;后代选择器&gt;通配符选择器&gt;伪类选择器</p><p>可继承的属性：font-size, font-family, color， line-height：行高 </p><p>不可继承的属性：border, padding, margin, width, height</p><h4 id="3-元素水平垂直居中的方法有哪些？如果元素不定宽高呢？"><a href="#3-元素水平垂直居中的方法有哪些？如果元素不定宽高呢？" class="headerlink" title="3.    元素水平垂直居中的方法有哪些？如果元素不定宽高呢？"></a>3.    元素水平垂直居中的方法有哪些？如果元素不定宽高呢？</h4><ul><li><p>使用绝对定位：position:absolute;    left:0,    top:0,    bottom:0,    right:0,    margin:auto。</p></li><li><p>使用flex布局：display：flex，aligin-item：center，justify-content：center。</p></li><li><p>使用表格中属性：display：table-cell，text-align：center</p></li><li><p>使用text-align：center水平居中，使用line-height：父元素的高度</p></li></ul><h4 id="4-怎么理解回流跟重绘？什么场景下会触发？"><a href="#4-怎么理解回流跟重绘？什么场景下会触发？" class="headerlink" title="4.    怎么理解回流跟重绘？什么场景下会触发？"></a>4.    怎么理解回流跟重绘？什么场景下会触发？</h4><p>回流一定会触发重绘，重绘不能触发回流。</p><p>回流的代价高，只要元素结构发生变化就有可能全部重新渲染。</p><p>回流：当渲染树中的一些元素结构，窗口大小，位置发生变化，浏览器就会重新渲染文档这个过程叫做回流。（连锁反应）</p><p>重绘：当页面样式发生改变而不影响它在文档流中的位置，布局不会发生改变这个过程叫做重绘。</p><p>导致回流的操作：</p><ul><li>页面重新渲染</li><li>页面内容改变</li><li>添加和删除节点</li><li>浏览器窗口大小发生改变</li></ul><p>导致重绘的操作：</p><ul><li>背景颜色   透明度   阴影  发生改变。</li></ul><p>如何避免减少回流？</p><ul><li>css<ul><li>避免设置多层内联样式。</li><li>避免使用table布局</li><li>避免使用CSS表达式</li></ul></li><li>JavaScript<ul><li>避免频繁操作样式。</li><li>避免频繁操作DOM。创建一个documentFragment，在它上面应用所有DOM操作，最后再把它添加到文档中。</li><li>可以先为元素设置为不可见：display: none，操作结束后再把它显示出来。</li></ul></li></ul><h4 id="5-什么是响应式设计？响应式设计的基本原理是什么？如何做？"><a href="#5-什么是响应式设计？响应式设计的基本原理是什么？如何做？" class="headerlink" title="5.    什么是响应式设计？响应式设计的基本原理是什么？如何做？"></a>5.    什么是响应式设计？响应式设计的基本原理是什么？如何做？</h4><p>响应式设计就是：页面布局可以响应不同尺寸的屏幕，同一个页面，随着屏幕尺寸的改变，自适应的改变页面布局。</p><p>原理：利用CSS3媒体查询，为不同尺寸的设备适配不同样式。</p><p> 实现响应式布局的方式有如下 ：</p><ul><li> 媒体查询：    通过给不同分辨率的设备编写不同的样式。</li><li> 百分比：          当浏览器高度，宽度发生变化时，样式也会随着变化。</li><li> vw/vh：          vw表示视图窗口的宽度，vh表示视图窗口高度。 </li><li> rem ：             根据根元素html的font-size属性。 </li></ul><h4 id="6-如果要做优化，CSS提高性能的方法有哪些？"><a href="#6-如果要做优化，CSS提高性能的方法有哪些？" class="headerlink" title="6.    如果要做优化，CSS提高性能的方法有哪些？"></a>6.    如果要做优化，CSS提高性能的方法有哪些？</h4><p> 加载性能： </p><ul><li> css压缩：使用webpack将写好的css进行打包压缩，可以减少很多的体积 。</li><li> 减少使用@import,而建议使用link，因为后者在页面加载时一起加载，前者是等待页面加载完成之后再进行加载。  </li></ul><p> 选择器性能： </p><ul><li> 避免使用通配规则。 *{}计算次数惊人！只对需要用到的元素进行选择 。</li><li> 尽量少的去对标签进行选择，而是用class。  </li></ul><p> 渲染性能： </p><ul><li> 尽量减少页面重排、重绘 。</li><li> 属性值为0时，不加单位。 </li></ul><h4 id="7-对前端工程师这个职位是怎么样理解的？它的前景会怎么样"><a href="#7-对前端工程师这个职位是怎么样理解的？它的前景会怎么样" class="headerlink" title="7.    对前端工程师这个职位是怎么样理解的？它的前景会怎么样"></a>7.    对前端工程师这个职位是怎么样理解的？它的前景会怎么样</h4><p>理解：</p><p>前端工程师是跟用户最贴合的一个职位。一个产品的好坏并不是企业说了算，是用户喜欢的才是好的产品。而用户所能评价的就是他可以看到的，可以触摸到的。前端工程师要做的就是呈现给用户这些信息。</p><p>前景：</p><p>web前端人才需求量是比较大的。</p><p>同时他的就业方向多：包括网站，h5页面，小程序，APP等等，就需要前端开发工程师岗位。具体就业方向还可以按公司所需技术来区分，前端已经变得越来越广泛。</p><span id="more"></span><h4 id="8-说说JavaScript中的数据类型？存储上的差别？"><a href="#8-说说JavaScript中的数据类型？存储上的差别？" class="headerlink" title="8.    说说JavaScript中的数据类型？存储上的差别？"></a>8.    说说JavaScript中的数据类型？存储上的差别？</h4><p>基本数据类型：string，number，boolean，undefind，null，symbol，bigint</p><p>复杂数据类型：object，function，array，data，math</p><p>存储差别：</p><ul><li>基本数据类型存储在栈当中，固定大小，占空间小，适于频繁调用。</li><li>复杂数据类型存放在堆中，大小不固定，占空间大。并且在栈中存储了指向堆实体的指针，使用时会检索栈中的地址，再去堆中拿到实体。</li></ul><h4 id="9-typeof-与-instanceof-区别"><a href="#9-typeof-与-instanceof-区别" class="headerlink" title="9.    typeof 与 instanceof 区别"></a>9.    typeof 与 instanceof 区别</h4><p>typeof：可以正确判断基本数据类型，除了null外（object）。他不能正确判断复杂数据类型，除function外都是object。</p><p>instanceof：可以正确判断复杂数据类型，其内部机制是根据判断对象的原型链上是否含有该类型，是返回true，不是返回false。不能直接判断基本数据类型。</p><p>可使用原型判断的方式：</p><p>object.prototype.toString().call()：判断object类型的，直接调用toString()就可以返回正确类型，其他对象必须使用.call（）方法，才能返回正确的类型信息 。</p><h4 id="10-说说你对闭包的理解？闭包使用场景"><a href="#10-说说你对闭包的理解？闭包使用场景" class="headerlink" title="10.   说说你对闭包的理解？闭包使用场景"></a>10.   说说你对闭包的理解？闭包使用场景</h4><p>闭包就是一个有权访问其他函数里的变量及参数。最常见创建闭包的形式就是一个函数内嵌套一个函数。内部函数可以访问外部函数的变量和参数。突破了作用域。</p><p>两个用处：封装私有属性及私有方法。     可以读取函数内部的变量，并且不会被回收。</p><p> 闭包的使用场景： </p><ol><li>返回一个函数</li><li>函数赋值，将内部函数赋值给外部变量</li><li>返回一个函数，作为函数参数传递 </li></ol><h4 id="11-bind、call、apply-区别？如何实现一个bind"><a href="#11-bind、call、apply-区别？如何实现一个bind" class="headerlink" title="11.   bind、call、apply 区别？如何实现一个bind?"></a>11.   bind、call、apply 区别？如何实现一个bind?</h4><p>三者都可以改变函数的<code>this</code>对象指向</p><p>三者第一个参数都是<code>this</code>要指向的对象，如果没有这个参数或参数为<code>undefined</code>或<code>null</code>，则默认指向全局<code>window</code>。</p><p>call()传递参数是以参数列表的形式，apply是以数组的形式。这两者都是调用之后立即执行。</p><p>bind()返回一个绑定this之后的函数。bind第一个参数就作为运行时的this。</p><p>实现<code>bind</code>的步骤，我们可以分解成为三部分：</p><ul><li><p>修改<code>this</code>指向</p></li><li><p>动态传递参数</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 方式一：只在bind中传递函数参数</span><br>fn.<span class="hljs-title function_">bind</span>(obj,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)()<br> <br><span class="hljs-comment">// 方式二：在bind中传递函数参数，也在返回函数中传递参数</span><br>fn.<span class="hljs-title function_">bind</span>(obj,<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><ul><li>兼容<code>new</code>关键字</li></ul><h4 id="12-说说你对事件循环的理解"><a href="#12-说说你对事件循环的理解" class="headerlink" title="12.   说说你对事件循环的理解"></a>12.   说说你对事件循环的理解</h4><p>event loop过程1：</p><ul><li>同步代码，一行一行在call stack（执行栈）执行</li><li>遇到异步，会先“记录”下，等待时机（定时，网络请求等）</li><li>时机到了，就移动到 Callback  Queue （回调队列）</li></ul><p>event loop过程2：</p><ul><li>如Call Stack为空（及代码执行完）Event loop 开始工作</li><li>轮询查找Callback  Queue，如有则移动到 Call Stack执行</li><li>然后继续轮询查找（永动机一样）</li></ul><p>宏任务：</p><ul><li>js代码</li><li>setTimeout</li><li>Ajax</li><li>Dom事件</li></ul><p>微任务：</p><ul><li>Promise async/</li><li>nextTick（Node.js）</li><li>MutaionObserver</li></ul><h4 id="13-DOM常见的操作有哪些"><a href="#13-DOM常见的操作有哪些" class="headerlink" title="13.   DOM常见的操作有哪些"></a>13.   DOM常见的操作有哪些</h4><ul><li><p>创建dom节点</p><ul><li>document.createElement(‘元素名’);            创建新的元素节点</li><li>document.createAttribute(‘属性名’);           创建新的属性节点</li><li>document.createTextNode(‘⽂本内容’);      创建新的⽂本节点</li><li>document.createComment(‘注释节点’);      创建新的注释节点</li><li>document.createDocumentFragment();     创建文档片段节点</li></ul></li><li><p>访问/获取节点</p><ul><li>getElementById(‘id属性值’);                            返回拥有指定id的第⼀个对象的引⽤</li><li>getElementsByClassName(‘class属性值’);返回拥有指定class的对象集合</li><li>getElementsByTagName(‘标签名’);              返回拥有指定标签名的对象集合</li><li>getElementsByName(‘name属性值’);          返回拥有指定名称的对象结合</li><li>querySelector(‘CSS选择器’);                             仅返回第⼀个匹配的元素</li><li>querySelectorAll(‘CSS选择器’);                        返回所有匹配的元素</li><li>document.documentElement;                         获取页⾯中的HTML标签</li><li>document.body ；                                                  获取页面body标签</li></ul></li><li><p>添加节点</p><ul><li>appendChild 添加节点</li></ul></li><li><p>删除节点</p><ul><li>parentNode.removeChild( existingChild );   删除已有的⼦节点，返回值为删除节点</li><li>element.removeAttribute(‘属性名’);                 删除具有指定属性名称的属性，⽆返回值</li><li>element.removeAttributeNode( attrNode ); 删除指定属性，返回值为删除的属性</li></ul><p>修改节点内容</p><ul><li>style   设置css样式</li><li>innerHTML  修改节点内容</li><li>innerText   修改内容，也可添加一个节点</li></ul></li></ul><h4 id="14-说说你对BOM的理解，常见的BOM对象你了解哪些？"><a href="#14-说说你对BOM的理解，常见的BOM对象你了解哪些？" class="headerlink" title="14.   说说你对BOM的理解，常见的BOM对象你了解哪些？"></a>14.   说说你对BOM的理解，常见的BOM对象你了解哪些？</h4><p> <code>BOM</code> (Browser Object <a href="https://so.csdn.net/so/search?q=Model&spm=1001.2101.3001.7020">Model</a>)，浏览器对象模型，提供了内容与浏览器窗口进行交互的对象。</p><p>Bom作用：跟浏览器做一些交互效果。比如：页面的前进，后退，刷新，滚动条的滚动，鼠标的坐标 。</p><p>五个对象：</p><ul><li>window <ul><li><code>Bom</code>的核心对象是<code>window</code> ， 在全局作用域中声明的变量、函数都会变成<code>window</code>对象的属性和方法 </li></ul></li><li>location<ul><li> <code>location.reload()</code>，此方法可以重新刷新当前页面 。修改location，会重载页面。</li></ul></li><li>navigator    <ul><li>主要用来获取浏览器的属性，区分浏览器类型。</li></ul></li><li>history  <ul><li>主要用来操作浏览器<code>URL</code>的历史记录，可以通过参数向前，向后，或者向指定<code>URL</code>跳转 </li><li><code>history.go()</code></li><li><code>history.forward()</code>：向前跳转一个页面</li><li><code>history.back()</code>：向后跳转一个页面</li><li><code>history.length</code>：获取历史记录数</li></ul></li><li>screen  <ul><li>保存的是客户端的信息。比如像素的宽和高。</li></ul></li></ul><h4 id="15-Javascript本地存储的方式有哪些？区别及应用场景？"><a href="#15-Javascript本地存储的方式有哪些？区别及应用场景？" class="headerlink" title="15.   Javascript本地存储的方式有哪些？区别及应用场景？"></a>15.   Javascript本地存储的方式有哪些？区别及应用场景？</h4><ul><li>cookie</li><li>sessionStorage</li><li>locaStorage</li></ul><p>区别：</p><ul><li>cookie存储大小不能超过4k，http始终携带cookie，即使不使用。是为了解决 <code>HTTP</code> 无状态导致的问题。适合保存很小的数据。sessionStorage和localStorage比cookis大得多，可以达到5m或者更多。</li><li>cookie具有时效，时间过后清除数据。  sessionStorage是在关闭当前对话也就是当前页面清除缓存。locaStorage只有手动清除，否侧一直存在。适合做持久化。</li><li>sessionStorage只在当前浏览器窗口共享，locaStorage，cookie在所有同源浏览器窗口共享。</li></ul><h4 id="16-什么是防抖和节流？有什么区别？如何实现？"><a href="#16-什么是防抖和节流？有什么区别？如何实现？" class="headerlink" title="16.   什么是防抖和节流？有什么区别？如何实现？"></a>16.   什么是防抖和节流？有什么区别？如何实现？</h4><ul><li>防抖：在一定的时间后调用函数，如果在这段时间内重新调用该函数，则重新计算执行时间。只执行最后一次。</li><li>节流：持续触发一个事件，每隔一段时间，只执行一次事件。控制执行的次数以及事件触发的频率。从而提高性能。</li></ul><p>相同点：</p><ul><li>都可以通过使用 setTimeout 实现目的都是，降低回调执行频率。节省计算资源</li></ul><p>不同点：</p><ul><li>函数防抖，利用clearTimeout和 setTimeout实现。</li><li>防抖关注一定时间连续触发的事件，只在最后执行一次，而函数节流一段时间内只执行一次。</li></ul><p>应用场景： </p><p>​        1.scroll事件滚动触发</p><p>​        2.搜索框输入查询</p><p>​        3.表单验证</p><p>​        4.按钮提交事件</p><p>​        5.浏览器窗口缩放，resize事件</p><h4 id="17-如何通过JS判断一个数组"><a href="#17-如何通过JS判断一个数组" class="headerlink" title="17.   如何通过JS判断一个数组"></a>17.   如何通过JS判断一个数组</h4><ul><li> isArray()数组自带的判断方法 </li><li> instanceof  判断类型</li><li> constructor.toString()方法 </li><li> Object.prototype.toString.call(a) 原型方法</li></ul><h4 id="18-说说你对作用域链的理解"><a href="#18-说说你对作用域链的理解" class="headerlink" title="18.   说说你对作用域链的理解"></a>18.   说说你对作用域链的理解</h4><p>作用域的作用就是保证有权被访问的变量及函数的有序性，作用域链的变量只能向上访问，不能向下访问。当访问到window对象时终止。作用链就是变量和函数的可访问范围，控制变量和函数的可见性及生命周期。</p><h4 id="19-JavaScript原型，原型链-有什么特点？"><a href="#19-JavaScript原型，原型链-有什么特点？" class="headerlink" title="19.   JavaScript原型，原型链 ? 有什么特点？"></a>19.   JavaScript原型，原型链 ? 有什么特点？</h4><ul><li>原型： 每个对象都会在其内部初始化一个属性，就是<code>__proto__</code> （原型）。还预置了prototype属性。构造函数创建实例时，该prototype属性值就会被作为实例对象的原型proto。</li><li>原型链：当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，那么它就会去它的原型对象里找这个属性，这个原型对象又会有自己的原型，于是就这样一直找下去， 直到找到属性/方法或 <code>undefined</code> 为止 ，也就是原型链的概念 。</li><li>特点： javascript对象是通过引用来传递的，当修改原型时，与之相关的对象也会继承这一改变 。</li></ul><h4 id="20-请解释什么是事件代理"><a href="#20-请解释什么是事件代理" class="headerlink" title="20.   请解释什么是事件代理"></a>20.   请解释什么是事件代理</h4><p>事件代理也就是事件委托，将原本需要绑定的事件委托给父元素。让父元素去监听。其原理就是：dom元素的事件冒泡。好处：节省大量内存，减少事件注册，提高性能。当新增子对象时无需再次绑定。</p><h4 id="21-谈谈This对象的理解"><a href="#21-谈谈This对象的理解" class="headerlink" title="21.   谈谈This对象的理解"></a>21.   谈谈This对象的理解</h4><ul><li>this总是指向函数的直接调用者</li><li>如果有new关键字，this指向new出来的这个实例对象</li><li>在事件中，this指向触发这个事件的对象。</li><li>IE中，this总是指向全局对象window。</li><li>箭头函数没有this，箭头函数的this指向上一级的函数。</li><li>可通过apply，call，bind来改变this指向。</li></ul><h4 id="22-new操作符具体干了什么"><a href="#22-new操作符具体干了什么" class="headerlink" title="22.   new操作符具体干了什么"></a>22.   new操作符具体干了什么</h4><ul><li>创建一个空对象，并且this引用该对象，也继承了该对象的原型。</li><li>将所有的属性，方法都添加到了this引用的这个对象。</li><li>新创建的对象由this引用，最后隐式的返回this。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">mynew</span>(<span class="hljs-params">Func, ...args</span>) &#123;<br>    <span class="hljs-comment">// 1.创建一个新对象</span><br>    <span class="hljs-keyword">const</span> obj = &#123;&#125;<br>    <span class="hljs-comment">// 2.新对象原型指向构造函数原型对象</span><br>    obj.<span class="hljs-property">__proto__</span> = <span class="hljs-title class_">Func</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span><br>    <span class="hljs-comment">// 3.将构建函数的this指向新对象</span><br>    <span class="hljs-keyword">let</span> result = <span class="hljs-title class_">Func</span>.<span class="hljs-title function_">apply</span>(obj, args)<br>    <span class="hljs-comment">// 4.根据返回值判断</span><br>    <span class="hljs-keyword">return</span> result <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Object</span> ? result : obj<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="23-null，undefined-的区别"><a href="#23-null，undefined-的区别" class="headerlink" title="23.   null，undefined 的区别"></a>23.   null，undefined 的区别</h4><ul><li>undefinded：表示没有不存在的值，一个缺少值。此处应有值，但没定义。读取时，返回undefined。</li><li>null：表示一个空对象，没有任何属性及方法。对比验证时使用===。</li></ul><h4 id="24-javascript-代码中的”use-strict”-是什么意思"><a href="#24-javascript-代码中的”use-strict”-是什么意思" class="headerlink" title="24.   javascript 代码中的”use strict”;是什么意思"></a>24.   javascript 代码中的”use strict”;是什么意思</h4><p>use strict是 es5添加的一种严格运行模式，这种模式使JavaScript能够在更严格的条件下运行。使js编码更加规范，消除了一些不严谨，不合理之处。</p><h4 id="25-同步和异步的区别"><a href="#25-同步和异步的区别" class="headerlink" title="25.   同步和异步的区别"></a>25.   同步和异步的区别</h4><p>同步是阻塞模式，异步是非阻塞模式。</p><ul><li>同步<ul><li>同步是指一个进程在执行某个请求时，该请求需要一定时间返回消息。那么这个进程就会一直等待下去，直到返回消息后，才执行下面的操作。</li></ul></li><li>异步<ul><li>异步是指不需要一直等待下去，而是继续执行下面的操作。不管其他进程的状态，当返回消息时，系统会通知该进程进行处理。提高了执行效率。</li></ul></li></ul><h4 id="26-谈一谈箭头函数与普通函数的区别"><a href="#26-谈一谈箭头函数与普通函数的区别" class="headerlink" title="26.   谈一谈箭头函数与普通函数的区别"></a>26.   谈一谈箭头函数与普通函数的区别</h4><ul><li>语法形式不同，箭头函数更简短</li><li>没有单独的<code>this</code></li><li>不绑定<code>arguments</code></li><li>不能使用<code>new</code>操作</li><li>没有<code>prototype</code>属性</li><li>通过<code>call</code>或<code>apply</code>调用会忽略第一个参数，只能传递参数，不能绑定<code>this</code></li><li>不能使用<code>yield</code>关键字</li></ul><h4 id="27-JS-数组和对象的遍历方式，以及几种方式的比较"><a href="#27-JS-数组和对象的遍历方式，以及几种方式的比较" class="headerlink" title="27.   JS 数组和对象的遍历方式，以及几种方式的比较"></a>27.   JS 数组和对象的遍历方式，以及几种方式的比较</h4><ul><li>for in 循环 </li><li>for  of循环 </li><li>forEach循环</li><li>map循环</li></ul><p>区别：</p><ul><li>for in循环 和 for循环 性能低。</li><li>for in适合遍历对象，for of适合遍历数组。for in遍历的是数组的索引，对象的key值，以及原型链上的属性 。</li><li>forEach ⽆法遍历对象  forEach ⽆法使⽤ break ， continue 跳出循环，且使⽤ return 是跳过本次循环 。</li><li>map可以return出一个新数组，原数组不会改变 。⽆法遍历对象 。</li></ul><h4 id="28-如何解决跨域问题"><a href="#28-如何解决跨域问题" class="headerlink" title="28.   如何解决跨域问题"></a>28.   如何解决跨域问题</h4><p>产生跨域的是因为浏览器的同源策略，同源策略是一种约定，它是浏览器最核心也最基本的安全功能。所谓同源是指 协议 域名 端口 三者一致。若其中一项不一致就会产生跨域。</p><ul><li>jsonp跨域<ul><li>只可以使用get方式提交。设置请求url –》 参数拼接  –》创建script节点  –》  返回数据，清除script。</li></ul></li><li>nginx代理跨域</li><li>node中间件跨域</li><li>cors后端头部设置安全域名<ul><li>需要浏览器和服务器的支持，自动完成跨域。添加一些头部信息。</li></ul></li></ul><h4 id="29-XML和JSON的区别"><a href="#29-XML和JSON的区别" class="headerlink" title="29.   XML和JSON的区别"></a>29.   XML和JSON的区别</h4><p>json是一个轻量的数据交换格式。是javascript的一个子集。</p><p>xml是纯文本的格式的，可扩展标记语言。</p><ul><li>JSON 比 XML 体积小，传递速度快。</li><li>JSON对jacascript交互更方便，更容易解析。</li><li>JSON 比 XML 传输速度快很多。</li><li>JSON对数据的描述性差。</li></ul><h4 id="30-谈谈你对webpack的看法"><a href="#30-谈谈你对webpack的看法" class="headerlink" title="30.   谈谈你对webpack的看法"></a>30.   谈谈你对webpack的看法</h4><p>webpack是一个模块打包工具，可以使用webpack管理模块依赖，并编译除模块所需的静态文件。打包web开发中所用到的html，css，js等静态文件。提高开发效率。对于不同的类型的资源，webpack由相对应的模块加载器。webpack会分析模块间的相关依赖，最后生成优化后的静态资源。</p><h4 id="31-webpack的打包原理"><a href="#31-webpack的打包原理" class="headerlink" title="31.   webpack的打包原理"></a>31.   webpack的打包原理</h4><p> <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/71b263000fa94db792cf1e98d67a578a~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="img"> </p><ul><li>初始化参数：从配置文件和 Shell 语句中读取并合并参数，得出最终的配置参数。</li><li>开始编译：从上一步得到的参数初始化 <code>Compiler</code> 对象，加载所有配置的插件，执行对象的 <code>run</code> 方法开始执行编译。</li><li>确定入口：根scope据配置中的 <code>entry</code> 找出所有的入口文件。</li><li>编译模块：从入口文件出发，调用所有配置的 <code>loader</code> 对模块进行翻译，再找出该模块依赖的模块，这个步骤是递归执行的，直至所有入口依赖的模块文件都经过本步骤的处理。</li><li>完成模块编译：经过第 4 步使用 loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系。</li><li>输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 <code>chunk</code>，再把每个 <code>chunk</code> 转换成一个单独的文件加入到输出列表，这一步是可以修改输出内容的最后机会。</li><li>输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。</li></ul><p> webpack打包原理是将根据文件间的依赖关系对其进行静态分析，然后将这些模块按指定规则生成静态资源，当 webpack处理程序时，会递归地构建一个依赖关系图，其中包含应用程序需要的每个模块，然后将所所有这些模块打包成bundle。 </p><p>从配置文件中读取所需要的参数，并且加载所有的插件，开始执行编译。找到entry入口文件。调用loader对模板进行递归解析翻译。等确定每个模块的依赖关系后，将他们组装成一个个包含多个模块的chunk。确定好内容后，根据出口配置将打包后的文件写入到具体位置。</p><h4 id="32-如何优化webpack打包速度"><a href="#32-如何优化webpack打包速度" class="headerlink" title="32.   如何优化webpack打包速度"></a>32.   如何优化webpack打包速度</h4><ul><li><p>优化 loader 配置：           减少文件的搜索范围，使用test，include，exclude。</p></li><li><p>使用image-webpack-loader进行图片压缩</p></li><li><p>terser启用多线程 ：        使用多进程并行运行来提高构建速度</p></li><li><p>使用 cache-loader：      将开销较大的loader结果缓存到磁盘</p></li><li><p>优化 resolve.modules:    指明存放第三方模块的绝对路径，以减少寻找 。</p></li><li><p>优化 resolve.alias</p></li><li><p>使用 DLLPlugin 插件</p></li><li><p>合理使用 sourceMap</p></li></ul><h4 id="33-说说webpack中常见的Loader？解决了什么问题？"><a href="#33-说说webpack中常见的Loader？解决了什么问题？" class="headerlink" title="33.   说说webpack中常见的Loader？解决了什么问题？"></a>33.   说说webpack中常见的Loader？解决了什么问题？</h4><p>webpack默认情况下，只支持对js，json文件打包。像css，less，png等这些类型文件，webpack需要采用相对应的loader（模块加载器）进行解析。</p><p>关于<code>loader</code>的配置，我们是写在<code>module.rules</code>属性中，属性介绍如下：</p><ul><li><code>rules</code>是一个数组的形式，因此我们可以配置很多个<code>loader</code></li><li>每一个<code>loader</code>对应一个对象的形式，对象属性<code>test</code> 为匹配的规则，一般情况为正则表达式</li><li>属性<code>use</code>针对匹配到文件类型，调用对应的 <code>loader</code> 进行处理</li></ul><p>常见的<code>loader</code>如下：</p><ul><li>style-loader: 将css添加到DOM的内联样式标签style里</li><li>css-loader :允许将css文件通过require的方式引入，并返回css代码</li><li>less-loader: 处理less</li><li>sass-loader: 处理sass</li><li>babel-loader :用babel来转换ES6文件到ES5</li><li>file-loader: 分发文件到output目录并返回相对路径</li><li>url-loader: 和file-loader类似，但是当文件小于设定的limit时可以返回一个Data Url</li></ul><p>css-loader:        分析 <code>css</code> 模块之间的关系，并合成⼀个 <code>css</code></p><p>staly-loader:    把 <code>css-loader</code> 生成的内容，用 <code>style</code> 标签挂载到页面的 <code>head</code> 中</p><p>less-loader:      开发中，我们也常常会使用<code>less</code>、<code>sass</code>、<code>stylus</code>预处理器编写<code>css</code>样式，使开发效率提高，这里需要使用<code>less-loader</code> </p><p>url-loader:        可以处理 <code>file-loader</code> 所有的事情，遇到图片格式的模块，可以选择性的把图片转成 <code>base64</code> 格式的字符串，并打包到 <code>js</code> 中，对小体积的图片比较合适，大图片不合适。 </p><h4 id="34-说说webpack中常见的Plugin？解决了什么问题？"><a href="#34-说说webpack中常见的Plugin？解决了什么问题？" class="headerlink" title="34.   说说webpack中常见的Plugin？解决了什么问题？"></a>34.   说说webpack中常见的Plugin？解决了什么问题？</h4><p>plugin是插件，对于webpack本身的扩展，是一个扩展器。</p><p>配置方式：写在plugins属性中传入new实例对象，他是个数组，可以写多个插件。</p><p>下面介绍几个常用的插件用法：</p><ul><li>HtmlWebpackPlugin<ul><li> ⾃动生成⼀个 <code>html</code> ⽂文件，并把打包生成的<code>js</code> 模块引⼊到该 <code>html</code> 中 </li></ul></li><li>clean-webpack-plugin<ul><li> 删除（清理）构建目录 </li></ul></li><li>mini-css-extract-plugin<ul><li>提取css到一个单独文件中</li></ul></li><li>copy-webpack-plugin<ul><li>复制文件或目录到执行区域。</li></ul></li></ul><h4 id="35-说说你对promise的了解"><a href="#35-说说你对promise的了解" class="headerlink" title="35.    说说你对promise的了解"></a>35.    说说你对promise的了解</h4><p>promise是es6新增的语法，解决了回调地狱的问题。（ 多个异步任务顺序执行，形成的多层回调函数的嵌套结构，就称为回调地狱现象 ）。</p><p>promise有三个状态：pending等待初始化状态，resolved成功的状态，rejected成功的状态。变化不可逆。</p><p>promise构造函数内代码是同步的，而之后then和catch执行的是异步的。构造函数接收两个参数resolve和reject。他们的执行是传递给then，catch，表示成功的回调及失败的回调。</p><h4 id="36-async函数是什么，有什么作用"><a href="#36-async函数是什么，有什么作用" class="headerlink" title="36.    async函数是什么，有什么作用"></a>36.    async函数是什么，有什么作用</h4><p>async/await 是为了简化使用基于promiseAPI的一种语法（语法糖）。async和await简化了promise的异步行为，不用链式的调用promise。</p><p>async表示是异步操作，await表示跟在表达式后面等待结果。await只能在async函数中有效，不然会报错。async返回一个promise对象，可以使用then方法添加回调函数。不管是不是promise对象，都会被包装成promise对象。async函数内部会被await阻塞并按顺序执行代码。也可使用try..catch进行异常处理。</p><h4 id="37-有使用过vue吗？说说你对vue的理解"><a href="#37-有使用过vue吗？说说你对vue的理解" class="headerlink" title="37.    有使用过vue吗？说说你对vue的理解"></a>37.    有使用过vue吗？说说你对vue的理解</h4><p>vue是一个构建用户界面的渐进式框架。vue所关注的核心是视图层。有一套精简的mvvm框架。</p><p>vue是一款轻量级别的框架，适合开发小型项目。</p><p>vue核心特性：</p><ul><li>数据驱动（MVVM<code>表示的是 </code>Model-View-ViewModel）<ul><li>Model：模型层，负责处理业务逻辑以及和服务器端进行交互</li><li>View：视图层：负责将数据渲染出来展示页面，可以简单的理解为HTML页面</li><li>ViewModel：视图模型层，用来连接Model和View，是Model和View之间的通信桥梁。</li></ul></li><li>组件化开发<ul><li>组件可以重复使用。提高开发效率。高内聚低耦合。</li><li>提高可维护性，每个组件的职责单一 。</li></ul></li><li>有着一套丰富的vue指令<ul><li>条件渲染指令 <code>v-if</code></li><li>列表渲染指令<code>v-for</code></li><li>属性绑定指令<code>v-bind</code></li><li>事件绑定指令<code>v-on</code></li><li>双向数据绑定指令<code>v-model</code></li></ul></li></ul><h4 id="38-你对SPA单页面的理解，它的优缺点分别是什么？如何实现SPA应用呢"><a href="#38-你对SPA单页面的理解，它的优缺点分别是什么？如何实现SPA应用呢" class="headerlink" title="38.    你对SPA单页面的理解，它的优缺点分别是什么？如何实现SPA应用呢"></a>38.    你对SPA单页面的理解，它的优缺点分别是什么？如何实现SPA应用呢</h4><p> SPA仅在Web页面初始化时加载相应的HTML、JavaScript和CSS。一旦页面加载完成,SPA不会因为用户操作而进行页面的重新加载或跳转;取而代之的是利用JavaScript实现HTML内容变换,UI与用户的交互,避免页面的重新加载。 </p><p>优点：</p><ul><li>用户体验好、快，内容的改变不需要重新加载整个页面</li><li>SPA相对于服务器压力小; </li><li>良好的前后端分离，分工更明确。</li></ul><p>缺点：</p><ul><li>不利于搜索引擎的抓取</li><li>首次加载页面速度比较慢</li></ul><p>实现：</p><ul><li>hash模式<ul><li>通过onhashchange监听路由的改变，从而跳转路由更新页面。</li></ul></li><li>history模式<ul><li>history采用HTML5的新特性；pushState()添加历史记录，replaceState()修改浏览器历史记录。</li><li>通过popState()监听路由的改变，从而触发路由跳转和页面更新。</li></ul></li></ul><h4 id="39-SPA首屏加载速度慢的怎么解决？"><a href="#39-SPA首屏加载速度慢的怎么解决？" class="headerlink" title="39.    SPA首屏加载速度慢的怎么解决？"></a>39.    SPA首屏加载速度慢的怎么解决？</h4><ul><li>减小入口文件积<ul><li>路由懒加载，不同组件的分割。</li></ul></li><li>静态资源本地缓存</li><li>UI框架按需加载</li><li>开启GZip压缩</li><li>使用服务器端渲染SSR（nuxt.js）</li><li>图片资源的压缩</li></ul><h4 id="40-VUE路由的原理"><a href="#40-VUE路由的原理" class="headerlink" title="40.    VUE路由的原理"></a>40.    VUE路由的原理</h4><p>hash：</p><ul><li>其中对象中的location.hash储存的是路由的地址、可以赋值改变其URL的地址。而这会触发hashchange事件，而通过window.addEventListener监听hash值然后去匹配对应的路由、从而渲染页面的组件 。</li></ul><p>history：</p><ul><li>history采用HTML5的新特性，通过 pushState 和 replaceState 两个方法来实现 URL 的变化</li><li>可以通过 popstate 事件来监听 URL 的变化，从而对页面进行跳转（渲染）</li></ul><h4 id="41-Vue中组件和插件有什么区别？"><a href="#41-Vue中组件和插件有什么区别？" class="headerlink" title="41.    Vue中组件和插件有什么区别？"></a>41.    Vue中组件和插件有什么区别？</h4><p> 组件 <code>(Component)</code> 是用来构成 <code>App</code> 的业务模块，它的目标是 <code>App.vue</code>。  在<code>Vue</code>中每一个<code>.vue</code>文件都可以视为一个组件 </p><p>插件就是指对<code>Vue</code>的功能的增强或补充。</p><p>编写形式区别：</p><ul><li>组件是以.vue后缀结尾的组件，包含三部分。template，script，style。</li><li>插件需要暴露一个install方法，第一个参数是vue构造器，第二个参数是可选对象。</li></ul><p>注册形式区别：</p><ul><li>组件是在main.js中全局注册vue.component(),局部注册就是在组件内。</li><li>插件在main.js中使用vue实例vue.use（插件名）</li></ul><h4 id="42-Vue组件之间的通信方式都有哪些"><a href="#42-Vue组件之间的通信方式都有哪些" class="headerlink" title="42.    Vue组件之间的通信方式都有哪些"></a>42.    Vue组件之间的通信方式都有哪些</h4><ul><li>父子组件之间的通信<ul><li>使用props进行传递</li></ul></li><li>兄弟组件之间的通信<ul><li>使用eventbus  vue实例进行传递</li></ul></li><li>provide 和  inject<ul><li>在祖先组件定义<code>provide</code>属性，返回传递的值</li><li>在后代组件通过<code>inject</code>接收组件传递过来的值</li></ul></li><li>vuex</li></ul><h1 id="43-你了解vue的diff算法吗？说说看"><a href="#43-你了解vue的diff算法吗？说说看" class="headerlink" title="43.    你了解vue的diff算法吗？说说看"></a>43.    你了解vue的diff算法吗？说说看</h1><p> diff的过程就是调用名为patch的函数，比较新旧节点，一边比较一边给真实的DOM打补丁 。</p><p>原理：当数据发生改变时，<code>set</code>方法会调用<code>Dep.notify</code>通知所有订阅者<code>Watcher</code>，调用<code>patch</code>给真实的<code>DOM</code>打补丁，更新相应的视图 。</p><p>其有两个特点：</p><ul><li>比较只会在同层级进行, 不会跨层级比较</li><li>在diff比较的过程中，循环从两边向中间比较</li><li>同一个节点，进行最小量的更新。</li></ul><p> diff 算法的在很多场景下都有应用，在 vue 中，作用于虚拟 dom 渲染成真实 dom 的新旧 VNode 节点比较 </p><p>Diff算法的步骤：</p><ul><li>用 JavaScript 对象结构表示 DOM 树的结构；然后用这个树构建一个真正的 DOM 树，插到文 档当中。</li><li>当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较(diff)，记录两棵树差异。</li><li>把第二棵树所记录的差异应用到第一棵树所构建的真正的DOM树上(patch)，视图就更新了。</li></ul><h4 id="44-为什么需要-Virtual-Dom"><a href="#44-为什么需要-Virtual-Dom" class="headerlink" title="44.   为什么需要 Virtual Dom"></a>44.   为什么需要 Virtual Dom</h4><ul><li><p>DOM的操作本身是性能会出现问题，操作比较复杂的</p></li><li><p>MVVM框架解决视图和状态同步问题</p></li><li><p>模板引擎可以简化视图操作，没办法跟踪状态（无法得知当前页面变化之前的状态）</p></li><li><p>虚拟DOM能够跟踪状态变化</p></li><li><p>虚拟DOM可以维护程序的状态，跟踪上一次的状态，通过比较前后两次状态差异更新真实DOM</p></li></ul><p><strong>虚拟 DOM 的作用</strong></p><ul><li>维护视图和状态的关系</li><li>复杂视图情况下提升渲染性能</li><li>除了渲染 <code>DOM</code> 以外，还可以实现 <code>SSR(Nuxt.js/Next.js)</code>、原生应用(<code>Weex/React Native</code>)、小程序(<code>mpvue/uni-app</code>)等</li></ul><h4 id="45-Vue3-0的设计目标是什么？做了哪些优化"><a href="#45-Vue3-0的设计目标是什么？做了哪些优化" class="headerlink" title="45.   Vue3.0的设计目标是什么？做了哪些优化"></a>45.   Vue3.0的设计目标是什么？做了哪些优化</h4><p>设计目标：</p><ul><li>打包体积更小： <code>Vue3</code>移除一些不常用的 <code>API</code> ， 将无用模块“剪辑”，仅打包需要的，使打包的整体体积变小了 </li><li>速度更快： diff算法优化，静态提升。</li><li>更灵活的代码组织能力：推出Composition API，大大增加了代码的逻辑组织能力和代码复用能力。</li></ul><p>优化方案：</p><ul><li>源码<ul><li>使用ts语法，源码的优化。</li></ul></li><li>性能<ul><li>体积，编译，数据劫持优化。</li></ul></li><li>语法 API<ul><li>组合式API，根据相关逻辑组织代码。</li></ul></li></ul><h4 id="46-Vue3-0-所采用的-Composition-Api-与-Vue2-x-使用的-Options-Api-有什么不同？"><a href="#46-Vue3-0-所采用的-Composition-Api-与-Vue2-x-使用的-Options-Api-有什么不同？" class="headerlink" title="46.   Vue3.0 所采用的 Composition Api 与 Vue2.x 使用的 Options Api 有什么不同？"></a>46.   Vue3.0 所采用的 Composition Api 与 Vue2.x 使用的 Options Api 有什么不同？</h4><ul><li>Options：</li></ul><p>​                         在一个vue文件中的data，methods，computed…定义属性和方法，共同处理页面逻辑。</p><p>​                         缺点：一个功能的实现    需要不同的vue配置项，定义属性方法比较分散。大项目methods可能                                    包含多个方法，这可能会导致组件难以阅读和理解。</p><p>​                         优点：新手入门会比较简单。</p><ul><li><p>Compositions API:</p><p>​                一个功能的所有api会放在一起（高内聚，低耦合），方便找到功能所对应的方法及属性。</p><p>​                缺点：学习思维方式改变。</p><p>​                优点：根据逻辑相关性组织代码，提高可读性和可维护性，基于函数组合的API。</p></li></ul><h4 id="47-说一下Vue数据响应式的原理"><a href="#47-说一下Vue数据响应式的原理" class="headerlink" title="47.   说一下Vue数据响应式的原理"></a>47.   说一下Vue数据响应式的原理</h4><p>当一个vue实例被创建时，vue会遍历data选项的属性。采用数据劫持结合发布/订阅者模式，用es5的object.defindproerty将他们转化为getter/setter，并在内部追踪相关依赖。在属性被访问和修改时通知变化。也就是observer使用object.defindproerty来监听数据的读写。读取数据时，调用get方法通知dep收集订阅者（watcher）。添加到dep的一个属性subs数组里。   修改数据时，调用set方法，通知dep数据改变了。 使用notify方法遍历subs里面的watcher，调用watcher的update（）方法。创建出一个新的dom树与原本旧的dom树做对比，从而更新视图。</p><h4 id="48-说说对-React-的理解？有哪些特性？"><a href="#48-说说对-React-的理解？有哪些特性？" class="headerlink" title="48.   说说对 React 的理解？有哪些特性？"></a>48.   说说对 React 的理解？有哪些特性？</h4><p> 由FaceBook在2011年开发的。React用于构建用户界面的 JavaScript 库 ，声明式编程，组件化开发。</p><ol><li><p>它使用**虚拟DOM **而不是真正的DOM。</p></li><li><p>它可以用<strong>服务器端渲染</strong>。</p></li><li><p>它遵循<strong>单向数据流</strong>或数据绑定。</p></li><li><p>使用jsx语法，将html和css代码写入到一个js文件。</p></li></ol><h4 id="49-说说-Real-DOM-和-Virtual-DOM-的区别？优缺点？"><a href="#49-说说-Real-DOM-和-Virtual-DOM-的区别？优缺点？" class="headerlink" title="49.   说说 Real DOM 和 Virtual DOM 的区别？优缺点？"></a>49.   说说 Real DOM 和 Virtual DOM 的区别？优缺点？</h4><p> Real DOM（真实的dom），在页面渲染出的每个节点都是一个真实的DOM结构 。</p><p> Virtual DOM （虚拟dom），是一个轻量级的js对象，它最初只是real DOM的副本，也是一个节点树。将属性和内容作为该对象的属性。 </p><p>区别：</p><ul><li><p>虚拟dom会减少重绘和回流，而真实dom会频繁进行重绘和回流。</p></li><li><p>虚拟dom的总损耗是”虚拟dom的增删改+真实dom的<strong>差异</strong>增删改+重排“；真实dom的消耗是”真实dom全部增删改+重排“</p></li></ul><p>真实dom：  优点：直接操作html，易用。    缺点：解析速度慢，效率低，内存占用高。， 频繁操作真实                                              DOM，导致重绘、 回流</p><p>虚拟dom：  优点：减少真实dom的频繁更新，减少重绘，回流，占内存少。  跨平台：一套react代码可以多                        端运行 </p><p>​                        缺点：初次渲染时，多了一层虚拟dom计算，速度慢些。</p><h4 id="50-说说-React-生命周期有哪些不同阶段？每个阶段对应的方法是？"><a href="#50-说说-React-生命周期有哪些不同阶段？每个阶段对应的方法是？" class="headerlink" title="50.   说说 React 生命周期有哪些不同阶段？每个阶段对应的方法是？"></a>50.   说说 React 生命周期有哪些不同阶段？每个阶段对应的方法是？</h4><p> <code>React</code>生命周期就是从创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、卸载等这一过程 。</p><ul><li>创建阶段<ul><li>render     用于渲染<code>DOM</code>结构，可以访问组件<code>state</code>与<code>prop</code>属性 </li><li>componentDidMount     组件挂载到真实<code>DOM</code>节点后执行，其在<code>render</code>方法之后执行 </li><li>constructor      初始化<code>state</code>状态 </li></ul></li><li>更新阶段<ul><li>componentDidUpdate        组件更新结束后触发 </li><li>shouldComponentUpdate    告诉组件本身是否需要重新渲染，默认false。</li><li>render      用于渲染<code>DOM</code>结构</li></ul></li><li>卸载阶段<ul><li><em><strong>componentWillUnmount</strong></em><strong>()</strong> – 从 DOM 卸载组件前调用。   </li></ul></li></ul><h4 id="51-说说-React中的setState执行机制"><a href="#51-说说-React中的setState执行机制" class="headerlink" title="51.   说说 React中的setState执行机制"></a>51.   说说 React中的setState执行机制</h4><p> 当需要修改状态时通过调用<code>setState</code>来改变，从而达到更新组件内部数据的作用 。</p><p>当使用setState（）更新状态后，然后会执行render函数，从而导致页面的视图更新。</p><p>更新类型：</p><ul><li>异步更新<ul><li>在组件生命周期或React合成事件中，setState是异步</li></ul></li><li>同步更新<ul><li>在setTimeout或者原生dom事件中，setState是同步</li></ul></li></ul><h4 id="52-说说对React中类组件和函数组件的理解？有什么区别？"><a href="#52-说说对React中类组件和函数组件的理解？有什么区别？" class="headerlink" title="52.   说说对React中类组件和函数组件的理解？有什么区别？"></a>52.   说说对React中类组件和函数组件的理解？有什么区别？</h4><p>类组件：通过使用es6类的编写形式来定义，继承React.Component。如果想要访问父组件传递过来的参数，可通过this.props来拿到。使用render方法，返回一个react对象。</p><p>函数组件：通过函数来编写一个react组件，函数第一个参数用于接收父组件传过来的参数。</p><p>在hooks出来之前，函数式组件时没有生命周期的，以及无法定义状态。现在可以使用useState定义状态。</p><p>useEffect定义生命周期。类式组件是不能使用hooks的。</p><h4 id="53-说说对React-Hooks的理解？解决了什么问题？"><a href="#53-说说对React-Hooks的理解？解决了什么问题？" class="headerlink" title="53.   说说对React Hooks的理解？解决了什么问题？"></a>53.   说说对React Hooks的理解？解决了什么问题？</h4><p>hooks是react 16版本以后新增的特性，可以在不写class组件的情况下使用state及其他属性。</p><p>useState（）定义组件状态       useEffect（）定义组件生命周期，第一个参数相当于 componentDidMount 和 componentDidUpdate 。第二个参数是个列表。可以返回一个函数，相当于 componentwillUnmount 销毁生命周期。     useReducer，useRef。</p><p>解决：</p><ul><li>每调用useHook一次都会生成一份独立的状态</li><li>通过自定义hook能够更好的封装我们的功能</li></ul><p>hook的出现，使函数式组件拥有了类式组件的相似功能。还可以进行代码复用。</p><h4 id="54-说说你对Redux的理解？其工作原理？"><a href="#54-说说你对Redux的理解？其工作原理？" class="headerlink" title="54.   说说你对Redux的理解？其工作原理？"></a>54.   说说你对Redux的理解？其工作原理？</h4><p>redux与vux相似，也是将组件状态进行集中管理。相当于管理组件状态的一个工具。</p><p> <strong>Redux三大原则</strong> ：</p><ul><li>单一数据源</li><li>state是只读的</li><li>使用纯函数修改状态</li></ul><p>redux三大核心：</p><ul><li>action：    动作对象，两个参数type，和data</li><li>reducer：   用于初始化状态，加工状态</li><li>store</li></ul><p>原理： 页面需要获取数据时，通过Action creates创建一个action动作对象，提交dispatch请求给store。store通知reducer进行匹配action的属性type。从而进行返回一个新的对象。</p><h4 id="55-说说-React-性能优化的手段有哪些"><a href="#55-说说-React-性能优化的手段有哪些" class="headerlink" title="55.   说说 React 性能优化的手段有哪些"></a>55.   说说 React 性能优化的手段有哪些</h4><ul><li>为避免不必要的render渲染，可以使用shouldComponentUpdate。</li><li>避免使用内联函数</li><li>懒加载组件</li><li>服务端渲染</li><li>事件绑定方式 </li><li>列表渲染的时候加key</li><li>避免使用内联样式属性</li></ul><h4 id="56-vue、react、angular-区别"><a href="#56-vue、react、angular-区别" class="headerlink" title="56.   vue、react、angular 区别"></a>56.   vue、react、angular 区别</h4><ul><li>angular是基于MVC架构，vue和react都是基于虚拟dom。</li><li><strong>Angular</strong>使用的是双向数据绑定，<strong>React</strong>用的是单数据流的，而<strong>Vue</strong>则支持两者。 </li><li>vue与angular自带的渲染指令不同。react没有渲染指令。</li><li>react使用jsx语法，angular使用ts语法。    </li></ul><h4 id="57-说说你对-TypeScript-的理解？与-JavaScript-的区别"><a href="#57-说说你对-TypeScript-的理解？与-JavaScript-的区别" class="headerlink" title="57.   说说你对 TypeScript 的理解？与 JavaScript 的区别"></a>57.   说说你对 TypeScript 的理解？与 JavaScript 的区别</h4><p> typescript是一个强类型的JavaScript超集， 支持面向对象编程的概念，如类、接口、继承、泛型等 ，可编译为纯JavaScript 。typescrit可以在任何浏览器运行。但是不能直接运行，需要一个编译器编译成javascript文件。</p><p>区别：</p><ul><li><p>ts支持es6语法，js不支持es6。</p></li><li><p>ts支持模块，js不支持模块。</p></li><li><p>js中没有静态类型的概念。</p></li><li><p>TypeScript 文件的后缀名 .ts （.ts，.tsx，.dts），JavaScript 文件是 .js</p></li></ul><h4 id="58-说说你对-TypeScript-中泛型的理解？应用场景？"><a href="#58-说说你对-TypeScript-中泛型的理解？应用场景？" class="headerlink" title="58.   说说你对 TypeScript 中泛型的理解？应用场景？"></a>58.   说说你对 TypeScript 中泛型的理解？应用场景？</h4><p>泛型是设计语言的一种风格或规范。</p><p> 泛型（Generics）是指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性 。</p><p> 泛型通过<code>&lt;&gt;</code>的形式进行表述，可以声明 ：函数，类，接口。</p><h4 id="59-说说你对微信小程序的理解？优缺点？"><a href="#59-说说你对微信小程序的理解？优缺点？" class="headerlink" title="59.   说说你对微信小程序的理解？优缺点？"></a>59.   说说你对微信小程序的理解？优缺点？</h4><p>小程序是一种不需要下载安装即可使用的应用，用户扫一扫或者搜一下即可打开应用。</p><p>也体现了“用完即走”的理念，用户不用关心是否安装太多应用的问题。应用将无处不在，随时可用，但又无需安装卸载。</p><p>注意的是，除了微信小程序，还有百度小程序、支付宝小程序、抖音小程序，都是每个平台自己开发的，都是有针对性平台的应用程序。</p><p>优点：</p><ul><li>随搜随用，用完即走：使得小程序可以代替许多APP，或是做APP的整体嫁接，或是作为阉割版功能的承载体</li><li>流量大，易接受：小程序借助自身平台更加容易引入更多的流量</li><li>安全</li><li>开发门槛低</li><li>降低兼容性限制</li></ul><p>缺点：</p><ul><li>用户留存：及相关数据显示，小程序的平均次日留存在13%左右，但是双周留存骤降到仅有1%</li><li>体积限制：微信小程序只有2M的大小，这样导致无法开发大型一些的小程序</li><li>受控微信：比起APP，尤其是安卓版的高自由度，小程序要面对很多来自微信的限制，从功能接口，甚至到类别内容，都要接受微信的管控</li></ul><h4 id="60-说说你对发布订阅、观察者模式的理解？区别？"><a href="#60-说说你对发布订阅、观察者模式的理解？区别？" class="headerlink" title="60.   说说你对发布订阅、观察者模式的理解？区别？"></a>60.   说说你对发布订阅、观察者模式的理解？区别？</h4><ul><li><p>发布订阅模式三个角色：订阅者，发布者。信号中心。</p><ul><li> 我们假定，存在一个”信号中心”，某个任务执行完成，就向信号中心”发布”(publish)一个信 号，其他任务可以向信号中心”订阅”(subscribe)这个信号，从而知道什么时候自己可以开始执 行。这就叫做”发布/订阅模式” </li><li> 例子： Vue 的自定义事件 ， 兄弟组件通信， 模拟 Vue 自定义事件的实现 </li></ul></li><li><p>观察者模式三个角色：</p><ul><li>观察者(订阅者)–Watcher        <ul><li><code>update()</code>:当事件发生时，具体要做的事情</li></ul></li><li>目标(发布者) –Dep<ul><li><code>subs</code> 数组:存储所有的观察者</li><li><code>addSub()</code>:添加观察者</li><li><code>notify()</code>:当事件发生，调用所有观察者的 <code>update()</code> 方法</li></ul></li><li>没有事件中心</li></ul></li></ul><p><strong>发布/订阅模式</strong>由统一信号中心调用，因此发布者和订阅者不需要知道对方的存在</p><p><strong>观察者模式</strong>是由具体目标调动，比如当事件触发，<code>Dep</code> 就会去调用观察者的方法，所以观察者模 式的订阅者与发布者之间是存在依赖的</p><h4 id="61-项目做过哪些性能优化"><a href="#61-项目做过哪些性能优化" class="headerlink" title="61.   项目做过哪些性能优化"></a>61.   项目做过哪些性能优化</h4><ul><li><p>减少 <code>HTTP</code> 请求数</p></li><li><p>减少<code>DOM</code> 操作</p></li><li><p>压缩css，js，图片等</p></li><li><p>在外部使用js和css</p></li><li><p>路由懒加载，图片懒加载</p></li><li><p>减少重绘，和回流。</p></li><li><p>ui框架按需加载</p></li><li><p>减少 <code>DNS</code> 查询</p></li><li><p>使用 <code>CDN</code></p></li><li><p>避免重定向</p></li><li><p>减少 <code>DOM</code> 元素数量</p></li><li><p>优化 <code>CSS Sprite</code></p></li><li><p>使用 <code>iconfont</code></p></li><li><p>字体裁剪</p></li><li><p>多域名分发划分内容到不同域名</p></li><li><p>尽量减少 <code>iframe</code> 使用</p></li><li><p>避免图片 <code>src</code> 为空</p></li><li><p>把样式表放在<code>link</code> 中</p></li><li><p>把<code>JavaScript</code>放在页面底部</p></li></ul><h4 id="62-描述浏览器的渲染过程，DOM树和渲染树的区别"><a href="#62-描述浏览器的渲染过程，DOM树和渲染树的区别" class="headerlink" title="62.   描述浏览器的渲染过程，DOM树和渲染树的区别"></a>62.   描述浏览器的渲染过程，DOM树和渲染树的区别</h4><ul><li>浏览器的渲染过程：<ul><li>解析<code>HTML</code>构建 <code>DOM</code>(DOM树)，并请求 <code>css/image/js</code></li><li><code>CSS</code> 文件下载完成，开始构建 <code>CSSDOM</code>(<code>CSS</code>树)</li><li>css树构建结束后，和 <code>DOM</code> 一起生成 <code>Render Tree</code>(渲染树)</li><li>布局：计算出每个节点在屏幕中的位置</li><li>显示：通过显卡把页面画到屏幕上</li></ul></li><li><code>DOM</code>树 和 渲染树 的区别：<ul><li><code>DOM</code>树与<code>HTML</code>标签一一对应，包括<code>head</code>和隐藏元素</li><li>渲染树不包括<code>head</code>和隐藏元素，大段文本每一行都是独立节点，每一个节点都有对应的<code>css</code>属性。</li></ul></li></ul><h4 id="63-你认为什么样的前端代码是好的"><a href="#63-你认为什么样的前端代码是好的" class="headerlink" title="63.   你认为什么样的前端代码是好的"></a>63.   你认为什么样的前端代码是好的</h4><p>完成一个项目操作尽量是低代码，代码是高内聚，低耦合的。</p><p>代码维护性比较高，而且容易扩展的。遵循代码的规范。</p><h4 id="64-从浏览器地址栏输入url到显示页面的步骤"><a href="#64-从浏览器地址栏输入url到显示页面的步骤" class="headerlink" title="64.   从浏览器地址栏输入url到显示页面的步骤"></a>64.   从浏览器地址栏输入url到显示页面的步骤</h4><p>1，URL解析 ：判断url格式是否正确</p><p>2，DNS域名查询 ：获取域名对应的服务器IP地址</p><p>3，建立TCP连接： 三次握手建立TCP连接</p><p>4，发起http请求: 浏览器发送请求到目标服务器，进行逻辑操作</p><p>5，响应请求和页面渲染：服务器返回一个响应请求，响应完，当页面关闭，tcp经过四次挥手断开连接</p><p>6 ，页面渲染：浏览器拿到服务器响应返回的资源，解析 先对资源进行解析，比如重定向 储存cookie、解压gzip等</p><p>7，解析html，构建dom树。</p><p>8，解析css 生成css规则树。</p><p>9，合并dom树，生成rander树</p><p>10，布局rander树，绘制rander树，绘制页面像素信息</p><p>11最后，浏览器把信息给gpu将各层信息合并，显示到屏幕上；</p><h4 id="65-http-请求报文和响应报文的格式"><a href="#65-http-请求报文和响应报文的格式" class="headerlink" title="65.   http 请求报文和响应报文的格式"></a>65.   http 请求报文和响应报文的格式</h4><ul><li><p>向后端服务器发出一个web资源请求，称之为客户端向服务器端发出了一个http请求。</p><p>HTTP请求报文主要由请求行、请求头、请求正文3部分组成 。</p></li><li><p>响应就是后端服务器对该请求做了个处理，返回一些数据等等。</p><p>HTTP响应报文主要由响应行、响应头、响应正文3部分组成。</p></li></ul><h4 id="66-Token-cookie-session-区别"><a href="#66-Token-cookie-session-区别" class="headerlink" title="66.   Token cookie session 区别"></a>66.   Token cookie session 区别</h4><p> <strong>Session</strong>会话：客户端A访问服务器，服务器存储A的数据value，把key返回给客户端A，客户端A下次带着key（<a href="https://so.csdn.net/so/search?q=session&spm=1001.2101.3001.7020">session</a> ID）来访问服务器，服务器就能给出客户端A的数据。 </p><p> <strong>Cookie</strong>：客户端A访问服务器，服务器返回cookie给客户端A，客户端A存储cookie，下次需要带着cookie访问服务器，服务器返回相应的数据。 </p><p> <strong>Token</strong>令牌：客户端A访问服务器，服务器给了客户端token，客户端A拿着token访问服务器，服务器验证token，返回数据。 </p><ul><li><code>cookie</code> 数据存放在浏览器上，session 数据存放在服务器上</li><li><code>cookie</code> 不是很安全，别人可以分析存放在本地的cookie 并进行 cookie 欺骗 考虑到安全应当使用 session</li><li><code>session</code> 会在一定时间内保存在服务器上。当访问增多，服务器性能会变差，这时应当使用cookie。</li><li>单个 <code>cookie</code> 保存的数据不能超过 <code>4K</code>，很多浏览器都限制一个站点最多保存 20 个 <code>cookie</code>。session是根据服务器大小来定。</li></ul><p>token：</p><p> token是服务器生成的一串字符串，作为客户端进行请求的一个令牌。 </p><p>token比较安全，cookie容易伪造，但是token不容易伪造，盗取。</p><h4 id="67-CORS跨域的原理"><a href="#67-CORS跨域的原理" class="headerlink" title="67.   CORS跨域的原理"></a>67.   CORS跨域的原理</h4><ul><li>当我们发起跨域请求时，如果是非简单请求，浏览器会帮我们自动触发预检请求，也就是 options请求，用于确认目标资源是否支持跨域。如果是简单请求，则不会触发预检，直接发出正常请求。</li><li>浏览器会根据服务端响应的 header 自动处理剩余的请求，如果响应支持跨域，则继续发出正常请求，如果不支持，则在控制台显示错误。</li></ul><h4 id="68-什么是MVVM"><a href="#68-什么是MVVM" class="headerlink" title="68.   什么是MVVM"></a>68.   什么是MVVM</h4><p>mvvm就是modle –view  –viewmodle。mvvm是一种设计思想 。</p><p>modle：模型层，用于处理逻辑和服务器的交互。</p><p>view：视图层，用于将数据渲染在页面上。UI视图。</p><p>view-modle：视图模型层，用来连接Model和View，是Model和View之间的通信桥梁。达到数据驱动视图的效果。</p><p> MVVM模式简化了界面与业务的依赖，解决了数据频繁更新。MVVM 在使用当中，利用双向绑定技术，使得 Model 变化时，ViewModel 会自动更新，而 ViewModel 变化时，View 也会自动变化。 </p><h4 id="69-说说你对版本管理的理解？常用的版本管理工具有哪些？"><a href="#69-说说你对版本管理的理解？常用的版本管理工具有哪些？" class="headerlink" title="69.   说说你对版本管理的理解？常用的版本管理工具有哪些？"></a>69.   说说你对版本管理的理解？常用的版本管理工具有哪些？</h4><p>简单来说： 你的修改只要提到到版本控制系统，基本都可以找回，版本控制系统就像一台时光机器，可以让你回到任何一个时间点 。</p><p>三个分类：</p><ul><li>本地版本控制系统</li><li>集中式版本控制系统    优点：适合多人团队协作开发，代码集中管理。  缺点：必须联网，无法单机工作。<ul><li>SVN</li><li>CVS</li></ul></li><li>分布式版本控制系统    优点：适合多人团队协作开发，代码集中管理。可离线工作。<ul><li>Git       一般公司都是使用git和gitlab自己搭建版本控制环境。比较安全。</li><li>HG</li></ul></li></ul><h4 id="70-说说你对Git的理解？"><a href="#70-说说你对Git的理解？" class="headerlink" title="70.   说说你对Git的理解？"></a>70.   说说你对Git的理解？</h4><p>git是目前世界上最先进的分布式版本控制系统，快速高效的处理小型到大型项目的事务。</p><p> 当我们通过<code>git init</code>创建或者<code>git clone</code>一个项目的时候，项目目录会隐藏一个<code>.git</code>子目录，其作用是用来跟踪管理版本库的 。</p><p>特性：易于学习，占用内存小，具有闪电般快速的性能。</p><p>使用<code>Git</code>和<code>Gitlab</code>搭建版本控制环境是现在互联网公司最流行的版本控制方式。</p><h4 id="71-说说Git常用的命令有哪些"><a href="#71-说说Git常用的命令有哪些" class="headerlink" title="71.   说说Git常用的命令有哪些"></a>71.   说说Git常用的命令有哪些</h4><ul><li>git add  .  ：提交暂存区</li><li>git status：  查看当前分支状态</li><li>git  commit -m  ‘’ ：提交本地库</li><li>git pull  更新或合并</li><li>git push -u origin master   提交到远程仓库</li></ul><h4 id="72-说说-git-发生冲突的场景？如何解决？"><a href="#72-说说-git-发生冲突的场景？如何解决？" class="headerlink" title="72.   说说 git 发生冲突的场景？如何解决？"></a>72.   说说 git 发生冲突的场景？如何解决？</h4><p>多个分支修改了同一个文件，比如在项目开发中，需要写组件了。要注册路由，然后你增加了几个路由。在你提交前，已经有人提交了并且已经修改了路由文件。这时你提交就会冲突。</p><p>首先将修改过的文件add 提到暂存区，commit 提交本地库，git pull 更新合并代码。然后根据提示手动去解决冲突。</p><h4 id="73-loader和plugin的区别"><a href="#73-loader和plugin的区别" class="headerlink" title="73.  loader和plugin的区别"></a>73.  loader和plugin的区别</h4><p>对于loader，它是一个转换器，将A文件进行编译形成B文件，这里操作的是文件，比如将A.scss转换为A.css，单纯的文件转换过程。<br>plugin是一个插件，在webpack中相当于一个扩展器。是对现有webpack功能的一个扩展。针对于loader结束后，在webpack打包过程中并不是直接进行操作的，而是遵循事件机制工作的。会监听webpack打包过程中的某些节点，执行广泛的任务。</p>]]></content>
    
    
    <categories>
      
      <category>面试题总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>72道面试题总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue3性能提升</title>
    <link href="/2021/04/27/vue3/vue3%E6%80%A7%E8%83%BD%E6%8F%90%E5%8D%87/"/>
    <url>/2021/04/27/vue3/vue3%E6%80%A7%E8%83%BD%E6%8F%90%E5%8D%87/</url>
    
    <content type="html"><![CDATA[<h4 id="Vue3-0性能提升主要是通过哪几方面体现的？"><a href="#Vue3-0性能提升主要是通过哪几方面体现的？" class="headerlink" title="Vue3.0性能提升主要是通过哪几方面体现的？"></a>Vue3.0性能提升主要是通过哪几方面体现的？</h4><p><img src="/2021/04/27/vue3/vue3%E6%80%A7%E8%83%BD%E6%8F%90%E5%8D%87/tt.png"></p><h5 id="编译阶段"><a href="#编译阶段" class="headerlink" title="编译阶段"></a>编译阶段</h5><ul><li><p>diff算法优化</p><ul><li><p>vue3在diff算法中相比vue2增加了静态标记。作用：为了会发生变化的地方添加一个flag标记，下次发生变化的时候直接找该地方进行比较即可。</p><p>下图这里，已经标记静态节点的p标签在diff过程中则不会比较，把性能进一步提高。</p><p><img src="/2021/04/27/vue3/vue3%E6%80%A7%E8%83%BD%E6%8F%90%E5%8D%87/cc.png"></p></li></ul></li><li><p>静态提升</p><ul><li>vue3中对不参与更新的元素，会做静态提升，只会被创建一次，在渲染时直接复用。</li></ul></li><li><p>事件监听缓存</p></li><li><p>SSR优化</p><ul><li>当静态内容达到一定量度时，会使用服务端渲染。</li></ul></li></ul><h5 id="源码体积"><a href="#源码体积" class="headerlink" title="源码体积"></a>源码体积</h5><ul><li><p>相比vue2，vue3整体体积变小了，除了移除一些不常用的API，在重要的是<code>Tree shanking</code>(树摇)。比如任何一个函数（ref，reactived，computed）等，仅用到的时候才打包，没用到的模块都被摇掉，打包的整体体积变小。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; computed, defineComponent, ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineComponent</span>(&#123;<br>    <span class="hljs-title function_">setup</span>(<span class="hljs-params">props, context</span>) &#123;<br>        <span class="hljs-keyword">const</span> age = <span class="hljs-title function_">ref</span>(<span class="hljs-number">18</span>)<br><br>        <span class="hljs-keyword">let</span> state = <span class="hljs-title function_">reactive</span>(&#123;<br>            <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;test&#x27;</span><br>        &#125;)<br><br>        <span class="hljs-keyword">const</span> readOnlyAge = <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> age.<span class="hljs-property">value</span>++) <span class="hljs-comment">// 19</span><br><br>        <span class="hljs-keyword">return</span> &#123;<br>            age,<br>            state,<br>            readOnlyAge<br>        &#125;<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure></li></ul><h5 id="响应式系统"><a href="#响应式系统" class="headerlink" title="响应式系统"></a>响应式系统</h5><ul><li>vue2中采用defineProerty来劫持整个对象，然后进行深度遍历所有属性，给每个属性添加getter和setter，实现响应式。</li><li>vue3采用proxy代理对象，因为proxy可以对整个对象进行监听，所以不需要深度遍历。<ul><li>可以监听整个对象的修改和添加</li><li>可以监听数组的索引和数组length属性。</li></ul></li></ul><br> <h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h4><hr><blockquote><ul><li><a href="https://juejin.cn/post/6903171037211557895">https://juejin.cn/post/6903171037211557895</a></li></ul></blockquote><blockquote><ul><li><a href="https://vue3js.cn/interview/vue3/performance.html#%E4%B8%80%E3%80%81%E7%BC%96%E8%AF%91%E9%98%B6%E6%AE%B5">https://vue3js.cn/interview/vue3/performance.html#%E4%B8%80%E3%80%81%E7%BC%96%E8%AF%91%E9%98%B6%E6%AE%B5</a></li></ul></blockquote>]]></content>
    
    
    <categories>
      
      <category>vue3</category>
      
    </categories>
    
    
    <tags>
      
      <tag>性能提升</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pythonOpencv进阶篇视频</title>
    <link href="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/"/>
    <url>/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/</url>
    
    <content type="html"><![CDATA[<h1 id="OpenCV进阶篇01"><a href="#OpenCV进阶篇01" class="headerlink" title="OpenCV进阶篇01"></a>OpenCV进阶篇01</h1><h1 id="第14章-视频处理"><a href="#第14章-视频处理" class="headerlink" title="第14章　视频处理"></a>第14章　视频处理</h1><p>OpenCV不仅能够处理图像，还能够处理视频。视频是由大量的图像构成的，这些图像以固定的时间间隔从视频中获取。这样，就能够使用图像处理的方法对这些图像进行处理，进而达到处理视频的目的。要处理视频，需要先对视频进行读取、显示和保存等相关操作。为此，OpenCV提供了VideoCapture类和VideoWriter类的相关方法。</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128195439971.png" alt="image-20211128195439971"></p><h2 id="14-1-读取并显示摄像头视频"><a href="#14-1-读取并显示摄像头视频" class="headerlink" title="14.1　读取并显示摄像头视频"></a>14.1　读取并显示摄像头视频</h2><p>摄像头视频指的是从摄像头（见图14.1）中实时读取到的视频。为了读取并显示摄像头视频，OpenCV提供了VideoCapture类的相关方法，这些方法包括摄像头的初始化方法、检验摄像头初始化是否成功的方法、从摄像头中读取帧的方法和关闭摄像头的方法等。下面依次对这些方法进行讲解。</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128195512490.png" alt="image-20211128195512490"></p><p>​                                                                                         图14.1　摄像头说明<br>视频是由大量的图像构成的，把这些图像称作帧。</p><h3 id="14-1-1-VideoCapture类"><a href="#14-1-1-VideoCapture类" class="headerlink" title="14.1.1　VideoCapture类"></a>14.1.1　VideoCapture类</h3><p>VideoCapture类提供了构造方法VideoCapture()，用于完成摄像头的初始化工作。VideoCapture()的语法格式如下：</p><pre><code class="hljs"> capture = cv2.VideoCapture(index)</code></pre><p>参数说明：　</p><p>capture：要打开的摄像头。　</p><p>index：摄像头的设备索引。</p><p>注意<br>摄像头的数量及其设备索引的先后顺序由操作系统决定，因为OpenCV没有提供查询摄像头的数量及其设备索引的任何方法。<br>当index的值为0时，表示要打开的是第1个摄像头；对于64位的Windows 10笔记本，当index的值为0时，表示要打开的是笔记本内置摄像头，关键代码如下：</p><pre><code class="hljs"> capture = cv2.VideoCapture(0)</code></pre><p>当index的值为1时，表示要打开的是第2个摄像头；对于64位的Windows 10笔记本，当index的值为1时，表示要打开的是一个连接笔记本的外置摄像头，关键代码如下：</p><pre><code class="hljs"> capture = cv2.VideoCapture(1)</code></pre><p>为了检验摄像头初始化是否成功，VideoCapture类提供了isOpened()方法。isOpened()方法的语法格式如下：</p><pre><code class="hljs"> retval = cv2.VideoCapture.isOpened()</code></pre><p>参数说明：　</p><p>retval：isOpened()方法的返回值。如果摄像头初始化成功，retval的值为True；否则，retval的值为False。</p><p>说明<br>在VideoCapture()的语法格式基础上，isOpened()方法的语法格式可以简写为retval = capture.isOpened()<br>摄像头初始化后，可以从摄像头中读取帧，为此VideoCapture类提供了read()方法。read()方法的语法格式如下：</p><pre><code class="hljs"> retval, image = cv2.VideoCapture.read() # 可以简写为retval, image = capture.read()</code></pre><p>参数说明：　</p><p>retval：是否读取到帧。如果读取到帧，retval的值为True；否则，retval的值为False。　</p><p>image：读取到的帧。因为帧指的是构成视频的图像，所以可以把“读取到的帧”理解为“读取到的图像”。</p><p>OpenCV官网特别强调，在不需要摄像头时，要关闭摄像头。为此，VideoCapture类提供了release()方法。release()方法的语法格式如下：</p><pre><code class="hljs"> cv2.VideoCapture.release() # 可以简写为capture.release()</code></pre><h3 id="14-1-2-如何使用VideoCapture类"><a href="#14-1-2-如何使用VideoCapture类" class="headerlink" title="14.1.2　如何使用VideoCapture类"></a>14.1.2　如何使用VideoCapture类</h3><p>在14.1.1节中，介绍了VideoCapture类中的VideoCapture()方法、isOpened()方法、read()方法和release()方法。那么，在程序开发的过程中，如何使用这些方法呢？本节将通过3个实例进行讲解。</p><p>【实例14.1】　读取并显示摄像头视频。<br>编写一个程序，打开笔记本内置摄像头实时读取并显示视频。当按下空格键时，关闭笔记本内置摄像头，销毁显示摄像头视频的窗口，代码如下：</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128200517716.png" alt="image-20211128200517716"></p><p>上述代码的运行结果如图14.2所示。</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128200557699.png" alt="image-20211128200557699"></p><p>​                                                                                     图14.2　读取并显示摄像头视频说明<br>图14.2是笔者用笔记本内置摄像头实时读取并显示公司天花板的视频。<br>在实例14.1运行期间，如果按下空格键，笔记本内置摄像头将被关闭，显示摄像头视频的窗口也将被销毁。此外，PyCharm控制台将输出如图14.3所示的警告信息。</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128200630928.png" alt="image-20211128200630928"></p><p>​                                                                             图14.3　PyCharm控制台输出的警告信息<br>为了消除图14.3所示的警告信息，需要将实例14.1第3行代码：</p><pre><code class="hljs"> capture = cv2.VideoCapture(0) # 打开笔记本内置摄像头</code></pre><p>修改为如下代码：</p><pre><code class="hljs"> capture = cv2.VideoCapture(0, cv2.CAP_DSHOW) # 打开笔记本内置摄像头</code></pre><p>如果想打开的是一个连接笔记本的外置摄像头，那么需要将实例14.1第3行代码：</p><p>capture = cv2.VideoCapture(0) # 打开笔记本内置摄像头<br>修改为如下代码：</p><pre><code class="hljs"> capture = cv2.VideoCapture(1, cv2.CAP_DSHOW) # 打开笔记本外置摄像头</code></pre><p>实例14.1已经成功地读取并显示了摄像头视频，那么如何对这个视频进行处理呢？其实，处理视频所用的方法与处理图像所用的方法是相同的。实例14.2将使用处理图像的相关方法把实例14.1读取并显示的彩色视频转换为灰度视频。</p><p>【实例14.2】　将摄像头视频由彩色视频转换为灰度视频。<br>编写一个程序，使用图像处理的相关方法把实例14.1读取并显示的彩色视频转换为灰度视频。当按下空格键时，关闭笔记本内置摄像头，销毁显示摄像头视频的窗口，代码如下：</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128200727172.png" alt="image-20211128200727172"></p><p>上述代码的运行结果如图14.4所示。</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128200757312.png" alt="image-20211128200757312"></p><pre><code class="hljs">                                                                           图14.4　把彩色视频转换为灰度视频</code></pre><p>实例14.1和实例14.2都用到了按键指令。当按下空格键时，关闭笔记本内置摄像头，销毁显示摄像头视频的窗口。那么，能否通过按键指令，保存并显示摄像头视频某一时刻的图像？带着这个疑问，请读者朋友继续阅读实例14.3。</p><p>【实例14.3】　显示并保存摄像头视频某一时刻的图像。<br>编写一个程序，打开笔记本内置摄像头实时读取并显示视频。当按下空格键时，关闭笔记本内置摄像头，保存并显示此时摄像头视频中的图像，代码如下：</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128200847208.png" alt="image-20211128200847208"></p><p>上述代码的运行结果如图14.5所示。</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128200934953.png" alt="image-20211128200934953"></p><p>​                                                                          图14.5　显示摄像头视频某一时刻的图像<br>实例14.3除能够显示摄像头视频某一时刻的图像外（见图14.5），还能够把图14.5保存为D盘根目录下的copy.png文件，如图14.6所示。</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128201000098.png" alt="image-20211128201000098"></p><p>​                                                                         图14.6　把图14.5保存为D盘根目录下的copy.png<br>实例14.1～实例14.3打开的都是笔记本内置摄像头，如果在打开笔记本内置摄像头的同时，再打开一个连接笔记本的外置摄像头，应该如何实现呢？</p><p>【实例14.4】　读取并显示2个摄像头视频。</p><p>编写一个程序，在打开笔记本内置摄像头实时读取并显示视频的同时，再打开一个连接笔记本的外置摄像头。当按下空格键时，关闭笔记本内置摄像头和连接笔记本的外置摄像头，销毁显示摄像头视频的窗口。代码如下：</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128201055804.png" alt="image-20211128201055804"></p><p>上述代码的运行结果如图14.7和图14.8所示。其中，图14.7是读取并显示笔记本内置摄像头视频，图14.8是读取并显示连接笔记本的外置摄像头视频。</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128201118623.png" alt="image-20211128201118623"></p><p>​                                                                             图14.7　读取并显示笔记本内置摄像头视频</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128201143279.png" alt="image-20211128201143279"></p><p>​                                                                   图14.8　读取并显示连接笔记本的外置摄像头视频</p><h2 id="14-2-播放视频文件"><a href="#14-2-播放视频文件" class="headerlink" title="14.2　播放视频文件"></a>14.2　播放视频文件</h2><p>VideoCapture类及其方法除了能够读取并显示摄像头视频外，还能够读取并显示视频文件。当窗口根据视频文件的时长显示视频文件时，便实现了播放视频文件的效果。</p><h3 id="14-2-1-读取并显示视频文件"><a href="#14-2-1-读取并显示视频文件" class="headerlink" title="14.2.1　读取并显示视频文件"></a>14.2.1　读取并显示视频文件</h3><p>VideoCapture类的构造方法VideoCapture()不仅能够完成摄像头的初始化工作，还能够完成视频文件的初始化工作。当VideoCapture()用于初始化视频文件时，其语法格式如下：</p><p>video = cv2.VideoCapture(filename)<br>参数说明：　</p><p>video：要打开的视频。　</p><p>filename：打开视频的文件名。例如，公司宣传.avi等。</p><p>注意<br>OpenCV中的VideoCapture类虽然支持各种格式的视频文件，但是这个类在不同的操作系统中，支持的视频文件格式不同。尽管如此，VideoCapture类能够在不同的操作系统中支持后缀名为.avi的视频文件。</p><p>【实例14.5】　读取并显示视频文件。<br>编写一个程序，读取并显示PyCharm当前项目路径下名为“公司宣传.avi”的视频文件。当按Esc键时，关闭视频文件并销毁显示视频文件的窗口，代码如下：</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128201246445.png" alt="image-20211128201246445"></p><p>上述代码的运行结果如图14.9所示。</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128201314133.png" alt="image-20211128201314133"></p><pre><code class="hljs">                                                        图14.9　读取并显示名为“公司宣传.avi”的视频文件说明</code></pre><p>调整waitKey()方法中的参数值可以控制视频文件的播播放速度。例如，当代码为cv2.waitKey(1)时，等待用户按下键盘的时间为1ms，视频文件的播放速度非常快；当代码为cv2.waitKey(50)时，等待用户按下键盘的时间为50ms，能够减缓视频文件的播放速度。<br>使用处理图像的相关方法，能够将摄像头视频由彩色视频转换为灰度视频。那么，使用相同的方法，也能够将视频文件由彩色视频转换为灰度视频。</p><p>【实例14.6】　将视频文件由彩色视频转换为灰度视频。<br>编写一个程序，使用处理图像的相关方法，先将PyCharm当前项目路径下名为“公司宣传.avi”的视频文件由彩色视频转换为灰度视频，再显示转换后的灰度图像，代码如下：</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128201410162.png" alt="image-20211128201410162"></p><p>上述代码的运行结果如图14.10所示。</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128201434739.png" alt="image-20211128201434739"></p><p>​                                                            图14.10　将“公司宣传.avi”由彩色视频转换为灰度视频</p><h3 id="14-2-2-视频的暂停播放和继续播放"><a href="#14-2-2-视频的暂停播放和继续播放" class="headerlink" title="14.2.2　视频的暂停播放和继续播放"></a>14.2.2　视频的暂停播放和继续播放</h3><p>实例14.5使用VideoCapture类及其相关方法实现了在窗口中播放视频文件的效果。那么，能否在实例14.5的基础上，通过按键指令，在播放视频的过程中，实现视频的暂停播放和继续播放呢？答案是肯定的。</p><p>【实例14.7】　视频的暂停播放和继续播放。<br>编写一个程序，读取并显示PyCharm当前项目路径下名为“公司宣传.avi”的视频文件。在播放视频文件的过程中，当按空格键时，暂停播放视频；当再次按空格键时，继续播放视频；当按Esc键时，关闭视频文件并销毁显示视频文件的窗口，代码如下：</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128201543614.png" alt="image-20211128201543614"></p><p>上述代码的运行结果如图14.11和图14.12所示（其中，图14.11是暂停播放视频的效果，图14.12是继续播放视频的效果）。</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128202037480.png" alt="image-20211128202037480"></p><p>​                                                                                  图14.11　暂停播放视频</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128202102795.png" alt="image-20211128202102795"></p><p>​                                                                                          图14.12　继续播放视频</p><h3 id="14-2-3-获取视频文件的属性"><a href="#14-2-3-获取视频文件的属性" class="headerlink" title="14.2.3　获取视频文件的属性"></a>14.2.3　获取视频文件的属性</h3><p>在实际开发中，有时需要获取视频文件的属性。为此，VideoCapture类提供了get()方法。get()方法的语法格式如下：</p><pre><code class="hljs"> retval = cv2.VideoCapture.get(propId)</code></pre><p>参数说明：　</p><p>retval：获取与propId对应的属性值。　</p><p>propId：视频文件的属性值。　</p><p>VideoCapture类提供视频文件的属性值及其含义如表14.1所示。                        </p><p>​                                                                     表14.1　视频文件的属性值及其含义</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128202208827.png" alt="image-20211128202208827"></p><p>说明<br>（1）视频是由大量的、连续的图像构成的，把其中的每一幅图像称作一帧。<br>（2）帧数指的是视频文件中含有的图像总数，帧数越多，视频播放时越流畅。<br>（3）在播放视频的过程中，把每秒显示图像的数量称作帧速率（FPS，单位：帧／s）。<br>（4）帧宽度指的是图像在水平方向上含有的像素总数。<br>（5）帧高度指的是图像在垂直方向上含有的像素总数。</p><p>【实例14.8】　获取并输出视频文件的指定属性值。<br>编写一个程序，使用VideoCapture类get()方法，先获取“公司宣传.avi”的帧速率、帧数、帧宽度和帧高度，再把上述4个属性值输出在PyCharm的控制台上，代码如下：</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128202243529.png" alt="image-20211128202243529"></p><p>上述代码的运行结果如图14.13所示。</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128202327955.png" alt="image-20211128202327955"></p><p>​                                              图14.13　获取并输出“公司宣传.avi”的帧速率、帧数、帧宽度和帧高度<br>实例14.8演示了初始化视频文件后，获取并输出视频文件的指定属性值。那么，能否使得窗口在播放视频的同时，动态显示当前视频文件的属性值呢？例如，当前视频播放到第几帧，该帧对应着视频的第几秒等。</p><p>【实例14.9】　动态显示视频文件的属性值。<br>编写一个程序，窗口在播放“公司宣传.avi”视频文件的同时，动态显示当前视频播放到第几帧和该帧对应视频的第几秒，代码如下：</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128202356380.png" alt="image-20211128202356380"></p><p>上述代码的运行结果如图14.14所示。</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128202452972.png" alt="image-20211128202452972"></p><p>​                                                                            图14.14　动态显示视频文件的属性值</p><p>说明<br>图14.14中的185和7.4s的含义是当前视频播放到第185帧，第185帧对应着“公司宣传.avi”视频文件中的第7.4s。</p><h2 id="14-3-保存视频文件"><a href="#14-3-保存视频文件" class="headerlink" title="14.3　保存视频文件"></a>14.3　保存视频文件</h2><p>在实际开发过程中，很多时候希望保存一段视频。为此，OpenCV提供了VideoWriter类。下面先来熟悉一下VideoWriter类中的常用方法。</p><h3 id="14-3-1-VideoWriter类"><a href="#14-3-1-VideoWriter类" class="headerlink" title="14.3.1　VideoWriter类"></a>14.3.1　VideoWriter类</h3><p>VideoWriter类中的常用方法包括VideoWriter类的构造方法、write()方法和release()方法。其中，VideoWriter类的构造方法用于创建VideoWriter类对象，其语法格式如下：</p><pre><code class="hljs"> &lt;VideoWriter object&gt; = cv2.VideoWriter(filename, fourcc, fps, frameSize)</code></pre><p>参数说明：　</p><p>VideoWriter object：VideoWriter类对象。　</p><p>filename：保存视频时的路径（含有文件名）。</p><p>fourcc：用4个字符表示的视频编码格式。</p><p>fps：帧速率。　</p><p>frameSize：每一帧的大小。<br>在OpenCV中，使用cv2.VideoWriter_fourcc()来确定视频编码格式。表14.2列出了几个常用的视频编码格式。</p><p>​                                                                  表14.2　常用的视频编码格式</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128202614177.png" alt="image-20211128202614177"></p><p>根据上述内容，即可创建一个VideoWriter类对象。</p><p>例如，在Windows操作系统下，fourcc的值为cv2.VideoWriter_fourcc(‘X’, ‘V’, ‘I’, ‘D’)，帧速率为20，帧大小为640×480。如果想把一段视频保存为当前项目路径下的output.avi，那么就要创建一个VideoWriter类对象output，关键代码如下：</p><pre><code class="hljs"> fourcc = cv2.VideoWriter_fourcc(&#39;X&#39;, &#39;V&#39;, &#39;I&#39;, &#39;D&#39;) output = cv2.VideoWriter(&quot;output.avi&quot;, fourcc, 20, (640, 480))</code></pre><p>上述代码也可以写作：</p><pre><code class="hljs"> fourcc = cv2.VideoWriter_fourcc(* &#39;XVID&#39;) output = cv2.VideoWriter(&quot;output.avi&quot;, fourcc, 20, (640, 480))</code></pre><p>为了保存一段视频，除需要使用VideoWriter类的构造方法外，还需要使用VideoWriter类提供的write()方法。write()方法的作用是在创建好的VideoWriter类对象中写入读取到的帧，其语法格式如下：</p><pre><code class="hljs"> cv2.VideoWriter.write(frame)</code></pre><p>参数说明：　</p><p>frame：读取到的帧。</p><p>注意<br>使用write()方法时，需要由VideoWriter类对象进行调用。例如，在创建好的VideoWriter类对象output中写入读取到的帧frame，关键代码如下：</p><pre><code class="hljs"> output.write(frame)</code></pre><p>当不需要使用VideoWriter类对象时，需要将其释放掉。为此，VideoWriter类提供了release()方法，其语法格式如下：</p><p>cv2.VideoWriter.release()<br>例如，完成保存一段视频后，需要释放VideoWriter类对象output。关键代码如下：</p><pre><code class="hljs"> output.release()</code></pre><h3 id="14-3-2-如何使用VideoWriter类"><a href="#14-3-2-如何使用VideoWriter类" class="headerlink" title="14.3.2　如何使用VideoWriter类"></a>14.3.2　如何使用VideoWriter类</h3><p>使用VideoWriter类保存一段视频需要经过以下几个步骤：创建VideoWriter类对象、写入读取到的帧、释放VideoWriter类对象等。而且，这段视频既可以是摄像头视频，也可以是视频文件。本节将使用VideoWriter类以实例的方式分别对保存摄像头视频和保存视频文件进行讲解。</p><p>【实例14.10】　保存一段摄像头视频。<br>编写一个程序，首先打开笔记本内置摄像头，实时读取并显示视频；然后按Esc键，关闭笔记本内置摄像头，销毁显示摄像头视频的窗口，并且把从打开摄像头到关闭摄像头的这段视频保存为PyCharm当前项目路径下的output.avi，代码如下：</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128202745833.png" alt="image-20211128202745833"></p><p>说明<br>在Windows操作系统下，fourcc的值为cv2.VideoWriter_fourcc(‘X’, ‘V’, ‘I’, ‘D’)，帧速率为20，帧大小为640×480。<br>在上述代码运行的过程中，按Esc键后，会在PyCharm当前项目路径（D:\PyCharm\PythonDevelop）下生成一个名为“output.avi”的视频文件，如图14.15所示。双击打开D:</p><p>PyCharm\PythonDevelop路径下的“output.avi”视频文件，即可浏览被保存的摄像头视频，如图14.16所示。</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128202856720.png" alt="image-20211128202856720"></p><p>​                                                           图14.15　PyCharm当前项目路径下的output.avi</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128202918741.png" alt="image-20211128202918741"></p><p>​                                                           图14.16　浏览被保存的摄像头视频说明       </p><p>这里是使用笔记本内置摄像头录制的手机秒表的视频，读者可以根据自己的喜好录制其他视频。<br>实例14.10可以重复运行，由于output.avi已经存在于PyCharm当前项目路径下，因此新生成的output.avi会覆盖已经存在的output.avi。<br>从图14.16中能够发现，笔者使用笔记本内置摄像头录制的视频时长为26s。也就是说，从打开摄像头、到关闭摄像头的这段时间间隔为26s，并且这段时间间隔由是否按Esc键决定。那么，能否对这段时间间隔进行设置呢？例如，打开摄像头并显示10s的摄像头视频？如果能，又该如何编写具有如此功能的代码呢？</p><p>【实例14.11】　保存一段时长为10s的摄像头视频。<br>编写一个程序，首先打开笔记本内置摄像头，实时读取并显示视频；然后录制一段时长为10s的摄像头视频；10s后，自动关闭笔记本内置摄像头，同时销毁显示摄像头视频的窗口，并且把这段时长为10s的摄像头视频保存为PyCharm当前项目路径下的ten_Seconds.avi，代码如下：</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128203038547.png" alt="image-20211128203038547"></p><p>运行上述代码10s后，会在PyCharm当前项目路径下生成一个名为“ten_Seconds.avi”的视频文件。双击打开D:\PyCharm\PythonDevelop路径下的“ten_Seconds.avi”视频文件，即可浏览被保存的摄像头视频，如图14.17所示。</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128203057475.png" alt="image-20211128203057475"></p><p>​                                                                 图14.17　浏览被保存的、时长为10s的摄像头视频</p><p>实例14.10和实例14.11演示了如何使用VideoWriter类保存摄像头视频。VideoWriter类不仅能保存摄像头视频，还能保存视频文件，而且保存视频文件与保存摄像头视频的步骤是相同的。接下来，仍以实例的方式演示如何使用VideoWriter类保存视频文件。</p><p>【实例14.12】　保存视频文件。<br>编写一个程序，首先读取PyCharm当前项目路径下名为“公司宣传.avi”的视频文件，然后将“公司宣传.avi”视频文件保存为PyCharm当前项目路径下的copy.avi，代码如下：</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128203126554.png" alt="image-20211128203126554"></p><p>由于要以帧为单位，一边读取视频文件，一边保存视频文件，因此运行上述代码后，PyCharm控制台没有立即输出代码中的提示信息，如图14.18所示。</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128203221855.png" alt="image-20211128203221855"></p><p>​                                                            图14.18　PyCharm控制台没有立即输出代码中的提示信息<br>大约1min后，会在PyCharm当前项目路径下生成一个名为“copy.avi”的视频文件，如图14.19所示。这时，PyCharm控制台也将输出如图14.20所示的提示信息。</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128203239999.png" alt="image-20211128203239999"></p><p>​                                                               图14.19　PyCharm当前项目路径下生成的copy.avi</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128203302454.png" alt="image-20211128203302454"></p><p>​                                                                       图14.20　PyCharm控制台将输出提示信息<br>双击打开D:\PyCharm\PythonDevelop路径下的“copy.avi”视频文件，即可浏览被保存的视频文件，如图14.21所示。</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128203324502.png" alt="image-20211128203324502"></p><p>​                                                                 图14.21　浏览被保存的“copy.avi”视频文件</p><p>从图14.21中能够发现，保存后的“copy.avi”视频文件的时长为49s。那么，能否缩短“copy.avi”视频文件的时长？例如，只保存“公司宣传.avi”视频文件中的前10s视频？这是可以实现的，实现逻辑与实例14.11是相同的。</p><p>【实例14.13】　保存视频文件中的前10s视频。<br>编写一个程序，首先读取PyCharm当前项目路径下名为“公司宣传.avi”的视频文件，然后将“公司宣传.avi”视频文件中的前10s视频保存为PyCharm当前项目路径下的ten_Seconds.avi，代码如下：</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128203418911.png" alt="image-20211128203418911"></p><p>运行上述代码10s后，不仅会在PyCharm当前项目路径下生成一个名为“ten_Seconds.avi”视频文件，而且会在PyCharm控制台输出提示信息。双击打开D:\PyCharm\PythonDevelop路径下的“ten_Seconds.avi”视频文件，即可浏览被保存的视频文件，如图14.22所示。</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128203447064.png" alt="image-20211128203447064"></p><p>​                                                       图14.22　保存“公司宣传.avi”视频文件中的前10s视频</p><h2 id="14-4-小结"><a href="#14-4-小结" class="headerlink" title="14.4　小结"></a>14.4　小结</h2><p>视频是由一系列连续的图像构成的，这一系列连续的图像被称作帧，帧是以固定的时间间隔从视频中获取的。因为视频播放的速度就是获取帧的速度，所以把视频播放的速度称作帧速率，其单位是帧／s（即1s内出现的图像数）。所谓视频处理，处理的对象就是从视频中获取的帧，而后使用图像处理的方法对获取的帧进行处理。OpenCV提供了VideoCapture类和VideoWriter类处理视频，虽然这2个类在不同的操作系统中支持的视频文件的格式不同，但是这2个类在不同的操作系统中都支持AVI格式的视频文件。</p><h1 id="第15章-人脸检测和人脸识别"><a href="#第15章-人脸检测和人脸识别" class="headerlink" title="第15章　人脸检测和人脸识别"></a>第15章　人脸检测和人脸识别</h1><p>人脸识别是基于人的脸部特征信息进行身份识别的一种生物识别技术，也是计算机视觉重点发展的技术。机器学习算法诞生之后，计算机可以通过摄像头等输入设备自动分析图像中包含的内容信息，随着技术的不断发展，现在已经有了多种人脸识别的算法。本章将介绍OpenCV自带的多种图像跟踪技术和3种人脸识别技术的用法。</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128203604892.png" alt="image-20211128203604892"></p><h2 id="15-1-人脸检测"><a href="#15-1-人脸检测" class="headerlink" title="15.1　人脸检测"></a>15.1　人脸检测</h2><p>人脸检测是让计算机在一幅画面中找出人脸的位置。毕竟计算机还达不到人类的智能水平，所以计算机在检测人脸的过程中实际上是在做“分类”操作，例如，计算机发现图像中有一些像素组成了眼睛的特征，那这些像素就有可能是“眼睛”；如果“眼睛”旁边还有“鼻子”和“另一只眼睛”的特征，那这3个元素所在的区域就很有可能是人脸区域；但如果“眼睛”旁边缺少必要的“鼻子”和“另一只眼睛”，那就认为这些像素并没有组成人脸，它们不是人脸图像的一部分。<br>检测人脸的算法比较复杂，但OpenCV已经将这些算法封装好，本节将介绍如何利用OpenCV自带的功能进行人脸检测。</p><h3 id="15-1-1-级联分类器"><a href="#15-1-1-级联分类器" class="headerlink" title="15.1.1　级联分类器"></a>15.1.1　级联分类器</h3><p>将一系列简单的分类器按照一定顺序级联到一起就构成了级联分类器，使用级联分类器的程序可以通过一系列简单的判断来对样本进行识别。例如，依次满足“有6条腿”“有翅膀”“有头、胸、腹”这3个条件的样本就可以被初步判断为昆虫，但如果任何一个条件不满足，则不会被认为是昆虫。</p><p>OpenCV提供了一些已经训练好的级联分类器，这些级联分类器以XML文件的方式保存在以下路径中：</p><pre><code class="hljs"> ...\Python\Lib\site-packages\cv2\data\</code></pre><p>路径说明：　“…\Python\”：Python虚拟机的本地目录。　“\Lib\site-packages\”：pip安装扩展包的默认目录。　“\cv2\data\”：OpenCV库的data文件夹。<br>例如，这里的Python虚拟机安装在C:\Program Files\Python\目录下，级联分类器文件所在的位置如图15.1所示。</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128203651374.png" alt="image-20211128203651374"></p><p>​                                                                 图15.1　OpenCV自带的级联分类器XML文件<br>不同版本的OpenCV自带的级联分类器XML文件可能会有差别，data文件夹中缺少的XML文件可以到OpenCV的源码托管平台下载，地址为：<a href="https://github.com/opencv/opencv/tree/master/data/haarcascades%E3%80%82">https://github.com/opencv/opencv/tree/master/data/haarcascades。</a><br>每一个XML文件都对应一种级联分类器，但有些级联分类器的功能是类似的（正面人脸识别分类器就有3个），表15.1是部分XML文件对应的功能，</p><p>​                                                                                       表15.1　部分级联分类器XML的功能</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128203757228.png" alt="image-20211128203757228"></p><p>想要实现哪种图像检测，就要在程序启动时加载对应的级联分类器。下一节将介绍如何加载并使用这些XML文件。</p><h3 id="15-1-2-方法"><a href="#15-1-2-方法" class="headerlink" title="15.1.2　方法"></a>15.1.2　方法</h3><p>OpenCV实现人脸检测需要做两步操作：加载级联分类器和使用分类器识别图像。这两步操作都有对应的方法。<br>首先是加载级联分类器，OpenCV通过CascadeClassifier()方法创建了分类器对象，其语法如下：</p><pre><code class="hljs"> &lt;CascadeClassifier object&gt; = cv2.CascadeClassifier(filename)</code></pre><p>参数说明：　</p><p>filename：级联分类器的XML文件名。</p><p>返回值说明：　</p><p>object：分类器对象。<br>然后使用已经创建好的分类器对图像进行识别，这个过程需要调用分类器对象的detectMultiScale()方法，其语法如下：</p><pre><code class="hljs"> objects = cascade.detectMultiScale(image, scaleFactor, minNeighbors, flags, minSize, maxSize)</code></pre><p>对象说明：　</p><p>cascade：已有的分类器对象。<br>参数说明：　</p><p>image：待分析的图像</p><p>scaleFactor：可选参数，扫描图像时的缩放比例。　</p><p>minNeighbors：可选参数，每个候选区域至少保留多少个检测结果才可以判定为人脸。该值越大，分析的误差越小。　</p><p>flags：可选参数，旧版本OpenCV的参数，建议使用默认值。　</p><p>minSize：可选参数，最小的目标尺寸。　</p><p>maxSize：可选参数，最大的目标尺寸。</p><p>返回值说明：　</p><p>objects：捕捉到的目标区域数组，数组中每一个元素都是一个目标区域，每一个目标区域都包含4个值，分别是：左上角点横坐标、左上角点纵坐标、区域宽、区域高。object的格式为：[[244　203　111　111]　[432　81　133　133]]。<br>下一节将介绍如何在程序中使用这2个方法。</p><h3 id="15-1-3-分析人脸位置"><a href="#15-1-3-分析人脸位置" class="headerlink" title="15.1.3　分析人脸位置"></a>15.1.3　分析人脸位置</h3><p>haarcascade_frontalface_default.xml是检测正面人脸的级联分类器文件，加载该文件就可以创建出追踪正面人脸的分类器，调用分类器对象的detectMultiScale()方法，得到的objects结果就是分析得出的人脸区域的坐标、宽和高。下面通过一个实例介绍如何实现此功能。【实例15.1】　在图像的人脸位置绘制红框。<br>将haarcascade_frontalface_default.xml文件放到项目根目录下的cascades文件夹中，加载此级联分类器之后，检测出所有可能是人脸的区域，通过for循环在这些区域上绘制红色边框，具体代码如下：</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128203902576.png" alt="image-20211128203902576"></p><p>上述代码的运行结果如图15.2所示。</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128203949284.png" alt="image-20211128203949284"></p><p>​                                                                                图15.2　检测出的人脸位置</p><p>【实例15.2】　戴墨镜特效。<br>手机拍照软件自带各种各样的贴图特效，实际上这些贴图特效就是先定位了人脸位置，然后在人脸相应位置覆盖素材实现的。OpenCV也可以实现此类功能，例如为人脸添加戴墨镜的特效，需要执行以下3个步骤：</p><p>（1）编写一个覆盖图片的overlay_img()方法。因为素材中可能包含透明像素，这些透明像素不可以遮挡人脸，所以在覆盖背景图像时要做判断，忽略所有透明像素。判断一个像素是否为透明像素，只需将图像从3通道转为4通道，判断第4通道的alpha值，alpha值为1表示完全不透明，0表示完全透明。<br>（2）创建人脸识别级联分类器，分析图像中人脸的区域。<br>（3）把墨镜图像按照人脸宽度进行缩放，并覆盖到人脸区域约1/3的位置。<br>实现以上功能的具体代码如下：</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128204015841.png" alt="image-20211128204015841"></p><p>上述代码的运行效果如图15.3所示。</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128204055080.png" alt="image-20211128204055080"></p><p>​                                                                                          图15.3　戴墨镜特效</p><h2 id="15-2-检测其他内容"><a href="#15-2-检测其他内容" class="headerlink" title="15.2　检测其他内容"></a>15.2　检测其他内容</h2><p>OpenCV提供的级联分类器除了可以识别人脸以外，还可以识别一些其他具有明显特征的物体，如眼睛、行人等。本节将介绍几个OpenCV自带的级联分类器的用法。</p><h3 id="15-2-1-眼睛检测"><a href="#15-2-1-眼睛检测" class="headerlink" title="15.2.1　眼睛检测"></a>15.2.1　眼睛检测</h3><p>haarcascade_eye.xml是检测眼睛的级联分类器文件，加载该文件就可以追踪眼睛的分类器，下面通过一个实例来介绍如何实现此功能。【实例15.3】　在图像的眼睛位置绘制红框。<br>将haarcascade_eye.xml文件放到项目根目录下的cascades文件夹中，加载此级联分类器之后，检测出所有可能是眼睛的区域，通过for循环在这些区域上绘制红色边框，具体代码如下：</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128204131328.png" alt="image-20211128204131328"></p><p>上述代码的运行结果如图15.4所示。</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128204151205.png" alt="image-20211128204151205"></p><p>​                                                                                      图15.4　检测出的眼睛位置</p><h3 id="15-2-2-猫脸检测"><a href="#15-2-2-猫脸检测" class="headerlink" title="15.2.2　猫脸检测"></a>15.2.2　猫脸检测</h3><p>OpenCV还提供了2个训练好的检测猫脸的级联分类器，分别是haarcascade_frontalcatface.xml和haarcascade_frontalcatface_extended.xml，前者的判断标准比较高，较为精确，但可能有些猫脸识别不出来；后者的判断标准比较低，只要类似猫脸就会被认为是猫脸。使用猫脸分类器不仅可以判断猫脸的位置，还可以识别图像中有几只猫。<br>下面通过一个实例来介绍如何实现此功能。</p><p>【实例15.4】　在图像里找到猫脸的位置。<br>为了得到比较理想的检测结果，建议使用haarcascade_frontalcatface_extended.xml。将haarcascade_frontalcatface_extended.xml文件放到项目根目录下的cascades文件夹中，加载此级联分类器之后，检测出所有可能是猫脸的区域，通过for循环在这些区域上绘制红色边框，具体代码如下：</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128204247078.png" alt="image-20211128204247078"></p><p>上述代码的运行结果如图15.5所示。</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128204308682.png" alt="image-20211128204308682"></p><p>​                                                                                         图15.5　检测出猫脸的位置</p><h3 id="15-2-3-行人检测"><a href="#15-2-3-行人检测" class="headerlink" title="15.2.3　行人检测"></a>15.2.3　行人检测</h3><p>haarcascade_fullbody.xml是检测人体（正面直立全身或背面直立全身）的级联分类器文件，加载该文件就可以追踪人体的分类器，下面通过一个实例介绍如何实现此功能。</p><p>【实例15.5】　在图像中找到行人的位置。</p><p>将haarcascade_fullbody.xml文件放到项目根目录下的cascades文件夹中，加载此级联分类器之后，检测出所有可能是人形的区域，通过for循环在这些区域上绘制红色边框，具体代码如下：</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128204421178.png" alt="image-20211128204421178"></p><p>上述代码的运行结果如图15.6所示。</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128204440594.png" alt="image-20211128204440594"></p><p>​                                                                                         图15.6　检测出的行人位置</p><h3 id="15-2-4-车牌检测"><a href="#15-2-4-车牌检测" class="headerlink" title="15.2.4　车牌检测"></a>15.2.4　车牌检测</h3><p>haarcascade_russian_plate_number.xml是检测汽车车牌的级联分类器文件，加载该文件就可以追踪图像中的车牌，下面通过一个实例来介绍如何实现此功能。</p><p>【实例15.6】　标记图像中车牌的位置。<br>将haarcascade_russian_plate_number.xml文件放到项目根目录下的cascades文件夹中，加载此级联分类器之后，检测出所有可能是车牌的区域，通过for循环在这些区域上绘制红色边框，具体代码如下：</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128204518734.png" alt="image-20211128204518734"></p><p>上述代码的运行结果如图15.7所示。</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128204601073.png" alt="image-20211128204601073"></p><p>​                                                                                      图15.7　检测出的车牌位置</p><h2 id="15-3-人脸识别"><a href="#15-3-人脸识别" class="headerlink" title="15.3　人脸识别"></a>15.3　人脸识别</h2><p>OpenCV提供了3种人脸识别方法，分别是Eigenfaces、Fisherfaces和LBPH。这3种方法都是通过对比样本的特征最终实现人脸识别。因为这3种算法提取特征的方式不一样，侧重点不同，所以不能分出孰优孰劣，只能说每种方法都有各自的识别风格。<br>OpenCV为每一种人脸识别方法都提供了创建识别器、训练识别器和识别3种方法，这3种方法的语法非常相似。本节将简单介绍如何使用这些方法。</p><h3 id="15-3-1-Eigenfaces人脸识别器"><a href="#15-3-1-Eigenfaces人脸识别器" class="headerlink" title="15.3.1　Eigenfaces人脸识别器"></a>15.3.1　Eigenfaces人脸识别器</h3><p>Eigenfaces也叫作“特征脸”。Eigenfaces通过PCA（主成分分析）方法将人脸数据转换到另外一个空间维度做相似性计算。在计算过程中，算法可以忽略一些无关紧要的数据，仅识别一些具有代表性的特征数据，最后根据这些特征识别人脸。<br>开发者需要通过以下3种方法完成人脸识别操作。<br>（1）通过cv2.face.EigenFaceRecognizer_create()方法创建Eigenfaces人脸识别器，其语法如下：</p><pre><code class="hljs"> recognizer = cv2.face.EigenFaceRecognizer_create(num_components, threshold)</code></pre><p>参数说明：　</p><p>num_components：可选参数，PCA方法中保留的分量个数，建议使用默认值。　</p><p>threshold：可选参数，人脸识别时使用的阈值，建议使用默认值。</p><p>返回值说明：　</p><p>recognizer：创建的Eigenfaces人脸识别器对象。</p><p>（2）创建识别器对象后，需要通过对象的train()方法训练识别器。建议每个人都给出2幅以上的人脸图像作为训练样本。train()方法的语法如下：</p><pre><code class="hljs"> recognizer.train(src, labels)</code></pre><p>对象说明：　</p><p>recognizer：已有的Eigenfaces人脸识别器对象。<br>参数说明：　</p><p>src：用来训练的人脸图像样本列表，格式为list。样本图像必须宽、高一致。　</p><p>labels：样本对应的标签，格式为数组，元素类型为整数。数组长度必须与样本列表长度相同。样本与标签按照插入顺序一一对应。<br>（3）训练识别器后可以通过识别器的predict()方法识别人脸，该方法对比样本的特征，给出最相近的结果和评分，其语法如下：</p><pre><code class="hljs"> label, confidence = recognizer.predict(src)</code></pre><p>对象说明：　</p><p>recognizer：已有的Eigenfaces人脸识别器对象。<br>参数说明：　</p><p>src：需要识别的人脸图像，该图像宽、高必须与样本一致。<br>返回值说明：　</p><p>label：与样本匹配程度最高的标签值。　</p><p>confidence：匹配程度最高的信用度评分。评分小于5000匹配程度较高，0分表示2幅图像完全一样。<br>下面通过一个实例来演示Eigenfaces人脸识别器的用法。</p><p>【实例15.7】　使用Eigenfaces识别人脸。<br>现以两个人的照片作为训练样本，第一个人的照片如图15.8～图15.10所示，第二个人的照片如图15.11～图15.13所示。</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128204741974.png" alt="image-20211128204741974"></p><p>​                                                                                           图15.8　Summer 1</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128204805362.png" alt="image-20211128204805362"></p><p>​                                                                                                      图15.9　Summer 2</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128204824476.png" alt="image-20211128204824476"></p><p>​                                                                                                图15.10　Summer 3</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128204847564.png" alt="image-20211128204847564"></p><p>​                                                                                                       图15.11　Elvis 1</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128204943018.png" alt="image-20211128204943018"></p><p>​                                                                                                 图15.12　Elvis 2</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128205000900.png" alt="image-20211128205000900"></p><p>​                                                                                                     图15.13　Elvis 3<br>待识别的照片如图15.14所示。</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128205024760.png" alt="image-20211128205024760"></p><p>​                                                                                                图15.14　待识别照片<br>创建Eigenfaces人脸识别器对象，训练以上样本后，判断图15.13所示是哪一个人，具体代码如下：</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128205102240.png" alt="image-20211128205102240"></p><p>上述代码的运行结果如下：</p><pre><code class="hljs"> confidence = 18669.728291380223 Summer</code></pre><p>程序对比样本特征分析得出，被识别的人物特征最接近的是Summer。</p><h3 id="15-3-2-Fisherfaces人脸识别器"><a href="#15-3-2-Fisherfaces人脸识别器" class="headerlink" title="15.3.2　Fisherfaces人脸识别器"></a>15.3.2　Fisherfaces人脸识别器</h3><p>Fisherfaces是由Ronald Fisher最早提出的，这也是Fisherfaces名字的由来。Fisherfaces通过LDA（线性判别分析技术）方法将人脸数据转换到另外一个空间维度做投影计算，最后根据不同人脸数据的投影距离判断其相似度。<br>开发者需要通过以下3种方法完成人脸识别操作。<br>（1）通过cv2.face.FisherFaceRecognizer_create()方法创建Fisherfaces人脸识别器，其语法如下：</p><pre><code class="hljs"> recognizer = cv2.face.FisherFaceRecognizer_create(num_components, threshold)</code></pre><p>参数说明：　</p><p>num_components：可选参数，通过Fisherface方法进行判断分析时保留的分量个数，建议使用默认值。　</p><p>threshold：可选参数，人脸识别时使用的阈值，建议使用默认值。</p><p>返回值说明：　</p><p>recognizer：创建的Fisherfaces人脸识别器对象。<br>（2）创建识别器对象后，需通过对象的train()方法训练识别器。建议每个人都给出2幅以上的人脸图像作为训练样本。train()方法的语法如下：</p><pre><code class="hljs"> recognizer.train(src, labels)</code></pre><p>对象说明：　</p><p>recognizer：已有的Fisherfaces人脸识别器对象。</p><p>参数说明：　</p><p>src：用来训练的人脸图像样本列表，格式为list。样本图像必须宽、高一致。　</p><p>labels：样本对应的标签，格式为数组，元素类型为整数。数组长度必须与样本列表长度相同。样本与标签按照插入顺序一一对应。</p><p>（3）训练识别器后可以通过识别器的predict()方法识别人脸，该方法对比样本的特征，给出最相近的结果和评分，其语法如下：</p><pre><code class="hljs"> label, confidence = recognizer.predict(src)</code></pre><p>对象说明：　</p><p>recognizer：已有的Fisherfaces人脸识别器对象。</p><p>参数说明：　</p><p>src：需要识别的人脸图像，该图像宽、高必须与样本一致。<br>返回值说明：　</p><p>label：与样本匹配程度最高的标签值。　</p><p>confidence：匹配程度最高的信用度评分。评分小于5000程度较高，0分表示2幅图像完全一样。</p><p>下面通过一个实例演示Fisherfaces人脸识别器的用法。</p><p>【实例15.8】　使用Fisherfaces识别人脸。<br>现以2个人的照片作为训练样本，第一个人的照片如图15.15～图15.17所示，第二个人的照片如图15.18～图15.20所示。</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128205304341.png" alt="image-20211128205304341"></p><p>​                                                                                               图15.15　Mike 1</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128205346389.png" alt="image-20211128205346389"></p><p>​                                                                                                 图15.16　Mike 2</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128205403358.png" alt="image-20211128205403358"></p><p>​                                                                                                 图15.17　Mike 3</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128205425662.png" alt="image-20211128205425662"></p><p>​                                                                                             图15.18　KaiKai 1</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128205446503.png" alt="image-20211128205446503"></p><p>​                                                                                                  图15.19　KaiKai 2</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128205509193.png" alt="image-20211128205509193"></p><p>​                                                                                                图15.20　KaiKai 3<br>待识别的照片如图15.21所示。</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128205529188.png" alt="image-20211128205529188"></p><p>​                                                                                                    图15.21　待识别照片</p><p>创建Fisherfaces人脸识别器对象，训练以上样本后，判断图15.21是哪一个人，具体代码如下：</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128205614870.png" alt="image-20211128205614870"></p><p>上述代码的运行结果如下：</p><pre><code class="hljs"> confidence = 2327.170867892041 Mike</code></pre><p>程序对比样本特征分析得出，被识别的人物特征最接近的是KaiKai。</p><h3 id="15-3-3-Local-Binary-Pattern-Histogram人脸识别器"><a href="#15-3-3-Local-Binary-Pattern-Histogram人脸识别器" class="headerlink" title="15.3.3　Local Binary Pattern Histogram人脸识别器"></a>15.3.3　Local Binary Pattern Histogram人脸识别器</h3><p>Local Binary Pattern Histogram简称LBPH，即局部二进制模式直方图，这是一种基于局部二进制模式算法，这种算法善于捕获局部纹理特征。<br>开发者需要通过以下3种方法来完成人脸识别操作。</p><p>（1）通过cv2.face. LBPHFaceRecognizer_create()方法创建LBPH人脸识别器，其语法如下：</p><pre><code class="hljs"> recognizer = cv2.face.LBPHFaceRecognizer_create(radius, neighbors, grid_x, grid_y, threshold)</code></pre><p>参数说明：　</p><p>radius：可选参数，圆形局部二进制模式的半径，建议使用默认值。　</p><p>neighbors：可选参数，圆形局部二进制模式的采样点数目，建议使用默认值。</p><p>返回值说明：　</p><p>grid_x：可选参数，水平方向上的单元格数，建议使用默认值。　</p><p>grid_y：可选参数，垂直方向上的单元格数，建议使用默认值。　</p><p>threshold：可选参数，人脸识别时使用的阈值，建议使用默认值。</p><p>（2）创建识别器对象后，需要通过对象的train()方法训练识别器。建议每个人都给出2幅以上的人脸图像作为训练样本。train()方法的语法如下：</p><pre><code class="hljs"> recognizer.train(src, labels)</code></pre><p>对象说明：　</p><p>recognizer：已有的LBPH人脸识别器对象。</p><p>参数说明：　</p><p>src：用来训练的人脸图像样本列表，格式为list。样本图像必须宽、高一致。</p><p>labels：样本对应的标签，格式为数组，元素类型为整数。数组长度必须与样本列表长度相同。样本与标签按照插入顺序一一对应。</p><p>（3）训练识别器后就可以通过识别器的predict()方法识别人脸，该方法对比样本的特征，给出最相近的结果和评分，其语法如下：</p><pre><code class="hljs"> label, confidence = recognizer.predict(src)</code></pre><p>对象说明：　</p><p>recognizer：已有的LBPH人脸识别器对象。</p><p>参数说明：　</p><p>src：需要识别的人脸图像，该图像宽、高必须与样本一致。</p><p>返回值说明：　</p><p>label：与样本匹配程度最高的标签值。　</p><p>confidence：匹配程度最高的信用度评分。评分小于50匹配程度较高，0分表示2幅图像完全一样。<br>下面通过一个实例来演示LBPH人脸识别器的用法。</p><p>【实例15.9】　使用LBPH识别人脸。<br>现以2个人的照片作为训练样本，第一个人的照片如图15.22～图15.24所示，第二个人的照片如图15.25～图15.27所示。</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128205807097.png" alt="image-20211128205807097"></p><p>​                                                                                                      图15.22　lxe 1</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128205827725.png" alt="image-20211128205827725"></p><p>​                                                                                               图15.23　lxe 2</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128205853204.png" alt="image-20211128205853204"></p><p>​                                                                                                  图15.24　lxe 3</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128205910674.png" alt="image-20211128205910674"></p><p>​                                                                                                   图15.25　RuiRui 1</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128205956685.png" alt="image-20211128205956685"></p><p>​                                                                                                   图15.26　RuiRui 2</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128210013982.png" alt="image-20211128210013982"></p><p>​                                                                                                 图15.27　RuiRui 3<br>待识别的照片如图15.28所示。</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128210039659.png" alt="image-20211128210039659"></p><p>​                                                                                                图15.28　待识别照片<br>创建LBPH人脸识别器对象，训练以上样本之后，判断图15.27是哪一个人，具体代码如下：</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128210105190.png" alt="image-20211128210105190"></p><p>上述代码的运行结果如下：</p><pre><code class="hljs"> confidence = 45.082326535640014 RuiRui</code></pre><p>程序对比样本特征分析得出，被识别的人物特征最接近的是RuiRui。</p><h2 id="15-4-小结"><a href="#15-4-小结" class="headerlink" title="15.4　小结"></a>15.4　小结</h2><p>人脸检测和人脸识别是相辅相成的，这是因为在进行人脸识别前，要先判断当前图像内是否出现了人脸，这个判断过程需要由人脸检测完成。只有在当前图像内检测到人脸，才能判断出这张人脸属于哪个人，这个判断是由人脸识别器完成的。因此，人脸识别指的是程序先在图像内检测人脸，再识别这张人脸属于哪个人的过程。本章讲解了3种人脸识别器，读者要熟练掌握这3种人脸识别器的实现方法和实现原理。</p><h1 id="第16章-MR智能视频打卡系统"><a href="#第16章-MR智能视频打卡系统" class="headerlink" title="第16章　MR智能视频打卡系统"></a>第16章　MR智能视频打卡系统</h1><p>很多公司都使用打卡机或打卡软件进行考勤。传统的打卡方式包括点名、签字、刷卡和指纹等。随着技术的不断发展，计算机视觉技术越来越强大，已经可以实现人脸打卡功能。打卡软件通过摄像头扫描人脸特征，利用人脸的差异识别人员。人脸打卡的准确性不输于指纹打卡，甚至安全性和便捷性都高于指纹打卡。本章将介绍一个由Python OpenCV开发的智能视频打卡系统。</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128210226814.png" alt="image-20211128210226814"></p><h2 id="16-1-需求分析"><a href="#16-1-需求分析" class="headerlink" title="16.1　需求分析"></a>16.1　需求分析</h2><p>打卡系统有3个核心功能：录入打卡人的资料、员工打卡和查看打卡记录，在满足核心功能的基础上需要完善一些附加功能和功能细节。在开发MR智能视频打卡系统前，先对本系统的一些需求进行如下拆解和分析。</p><p>1．数据模型</p><p>本系统不使用第三方数据库，所有数据都以文本的形式保存在文件中，因此要规范数据内容和格式，建立统一模型。<br>若把软件的使用者设定为“公司”，那么打卡者身份可设定为“员工”，程序中数据模型就应该是员工数据类。<br>每一位员工都有姓名，“姓名”就作为员工类中必备的数据之一。<br>因为员工可能会重名，所以必须使用另一种标记作为员工身份的认证，即为每一位员工添加不重复的员工编号。员工编号的格式为从1开始递增数字，每添加一位新员工，员工编号就+1。员工类中添加“员工编号”。<br>系统中必须保存所有员工的照片用于人脸识别。为了区分每位员工的照片文件，程序使用“员工特征码+随机值.png”的规则为照片文件命名。如果使用员工编号作为特征码，1号员工和11号员工的文件名容易发生混淆，所以特征码不能使用员工编号，而是一种长度一致、复杂性高、不重复的字符串。员工类中添加“特征码”。<br>员工与编号、姓名、特征码是一对一的关系，但员工与打卡记录是一对多的关系，所以打卡记录可以放在员工类中保存，而不是单独保存在打卡记录模型中。打卡记录需要记录每一位员工的具体打卡时间，并能以报表的形式体现。可以使用字段保存打卡记录模型，员工姓名作为key，该员工的打卡记录列表作为value。</p><p>2．打卡功能</p><p>人脸打卡依赖于人脸识别功能。本程序可以使用OpenCV提供的人脸识别器实现此功能，建议使用正确率较高的LBPH识别器，其他识别器也可以考虑，但需要做好测试验证。<br>系统通过拍照保存员工的照片样本。当员工面对摄像头时，按Enter键就可以生成一张正面特写照片文件。为了增加识别准确率，每位员工应拍3张照片，也就是按3次Enter键才能完成录入操作。<br>OpenCV提供的人脸识别器有一个缺陷：必须比对2种不同样本才能进行判断。如果公司第一次使用打卡系统，系统中没有录入任何员工，缺少比对样本，OpenCV提供的人脸识别器就会报错。因此本系统应该给出几个无人脸的默认样本，保证即使只录入一个员工，该员工也能顺利打卡。</p><p>每次员工打卡成功后，都应该记录该员工的打卡时间，然后保存到文件中。</p><p>3．数据维护</p><p>数据维护总结起来就是增、删、改、查4种操作。简化版的打卡系统可以忽略“改”的操作，由先删除，再新增的方式代替。<br>本系统除了提供录入新员工的功能之外，也提供删除已有员工的功能。删除员工之前应输入验证码进行验证，以防用户操作失误，误删重要数据。确认执行删除操作后，不仅要删除员工的信息，也要同时删除员工的打卡记录和照片文件。完成删除操作后，所有数据文件中不再存有被删员工的任何数据。</p><p>4．考勤报表</p><p>每个公司的考勤制度都不同，很多公司都主动设置s“上班时间”和“下班时间”来做考勤的标准。员工要在“上班时间”之前打卡才算正常到岗，在“下班时间”之后打卡才算正常离岗。未在规定时间内打卡的情况属于“打卡异常”，“打卡异常”通常分为3种情况：迟到、早退或缺席（或缺勤）。<br>本系统分析每一位员工在某一天的打卡记录，如果该员工在“上班时间”前和“下班时间”后都有打卡记录，则认为该员工当天全勤，该员工当天的其他打卡记录会被忽略。但如果该员工在“上班时间”前未能打卡，而是在“上班时间”后到中午12点前打卡，这种情况被视为迟到。如果该员工在“下班时间”后未能打卡，而是在中午12点之后到“下班时间”前打卡，这种情况被视为早退。当天没有打卡记录被视为缺席。</p><h2 id="16-2-系统设计"><a href="#16-2-系统设计" class="headerlink" title="16.2　系统设计"></a>16.2　系统设计</h2><h3 id="16-2-1-开发环境"><a href="#16-2-1-开发环境" class="headerlink" title="16.2.1　开发环境"></a>16.2.1　开发环境</h3><p>本系统开发使用的环境如下：<br>Python版本：3.8.2<br>OpenCV版本：4.2.0<br>numpy版本：1.18.1</p><p>IED：PyCharm 2019.3.3 (Community Edition)<br>操作系统：Windows 7/Windows 10</p><h3 id="16-2-2-功能结构"><a href="#16-2-2-功能结构" class="headerlink" title="16.2.2　功能结构"></a>16.2.2　功能结构</h3><p>MR智能视频打卡系统的功能结构如图16.1所示。</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128210408201.png" alt="image-20211128210408201"></p><p>​                                                                                                 图16.1　功能结构</p><h3 id="16-2-3-业务流程"><a href="#16-2-3-业务流程" class="headerlink" title="16.2.3　业务流程"></a>16.2.3　业务流程</h3><p>MR智能视频打卡系统的总体业务流程如图16.2所示。</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128210435530.png" alt="image-20211128210435530"></p><p>​                                                                                                   图16.2　总体业务流程<br>打卡功能业务流程如图16.3所示。<br>查看记录功能业务流程如图16.4所示。</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128210456043.png" alt="image-20211128210456043"></p><p>​                                                                                   图16.3　打卡功能的业务流程</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128210539359.png" alt="image-20211128210539359"></p><p>​                                                                                   图16.4　查看记录功能的业务流程<br>员工管理功能业务流程如图16.5所示。</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128210604201.png" alt="image-20211128210604201"></p><p>​                                                                             图16.5　员工管理功能的业务流程<br>考勤报表功能业务流程如图16.6所示。</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128210648098.png" alt="image-20211128210648098"></p><p>​                                                                                 图16.6　考勤报表功能的业务流程<br>员工管理、查看记录和考勤报表这3个功能中都涉及权限管理业务。如果用户要使用这3个功能，需要登录管理员账号，只有登录成功后才有权使用。权限管理业务流程如图16.7所示。</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128210720411.png" alt="image-20211128210720411"></p><p>​                                                                                    图16.7　权限管理业务流程</p><h3 id="16-2-4-项目结构"><a href="#16-2-4-项目结构" class="headerlink" title="16.2.4　项目结构"></a>16.2.4　项目结构</h3><p>MR智能视频打卡系统的项目结构如下：</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128210741943.png" alt="image-20211128210741943"></p><h2 id="16-3-文件系统设计"><a href="#16-3-文件系统设计" class="headerlink" title="16.3　文件系统设计"></a>16.3　文件系统设计</h2><p>本程序没有使用任何数据库保存数据，而是采用直接读写文件的方式来保存数据。项目中的所有数据文件都保存在data文件夹中。<br>程序使用的数据文件及文件夹信息如表16.1所示。</p><p>​                                                                       表16.1　程序使用的数据文件及文件夹信息</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128210902635.png" alt="image-20211128210902635"></p><p>下面详细介绍每种数据文件的内容格式。<br>（1）employee_data.txt文件以字符串的形式保存所有员工的数据，数据之间用英文逗号隔开，一行保存一个员工。其格式如下：</p><pre><code class="hljs"> 编号1,姓名1,特征码1 编号2,姓名2,特征码2 ...</code></pre><p>例如，employee_data.txt文件保存的实际内容可能如下：</p><pre><code class="hljs"> 1,张三,526380 2,李四,571096 3,王五,381609</code></pre><p>（2）lock_record.txt文件以字符串的形式保存数据，数据格式为打卡记录字典的字符串内容，其格式如下：</p><pre><code class="hljs"> &#123;姓名a: [日期list], 姓名b: [日期list], ... , 姓名n：[日期list]&#125;</code></pre><p>例如，lock_record.txt文件保存的实际内容可能如下：</p><p>{‘张三’: [‘2020-04-15 14:59:54’], ‘李四’: [‘2020-04-15 15:02:08’], ‘王五’: [‘2020-04-15 15:11:02’, ‘2020-04-15<br>     15:35:49’]}<br>（3）work_time.txt文件以字符串的形式保存数据，其格式如下：</p><pre><code class="hljs"> 08:00:00/16:00:00</code></pre><p>前一个时间为上班时间，后一个时间为下班时间，格式均为%H:%M:%S。系统以这2个时间为标准判断员工是否出现迟到、早退。<br>（4）user_password.txt文件以字符串的形式保存数据，数据格式为管理员账号密码字典的字符串内容，其格式如下：</p><pre><code class="hljs"> &#123;管理员账号:管理员密码&#125;</code></pre><p>例如，user_password.txt文件保存的实际内容可能如下：</p><pre><code class="hljs"> &#123;&#39;mr&#39;: &#39;mrsoft&#39;, &#39;123456&#39;: &#39;123456&#39;&#125;</code></pre><p>用户可以在这个文件中手动修改管理员账号和密码。<br>（5）/data/face/文件夹下保存的是所有员工的照片文件，格式为PNG。每张照片的大小都是640×480。每名员工需保存3张照片。<br>该文件夹下还有2个默认的图像文件，文件名分别为1000000000.png和2000000000.png。这是2幅纯色图像，用于辅助训练人脸识别器。<br>人脸识别器使用样本进行训练时，至少要有2个以上的标签分类。如果程序中仅保存了一位员工的照片，人脸识别器无法拿此员工照片与其他样本做对比，人脸识别器就会报错，此时2幅默认图像文件就充当了对比样本，以防止人脸识别器无法完成训练。当程序录入了足够多的员工信息后，这2幅默认图像虽然丧失了功能，但也不会影响识别器的识别能力。</p><h2 id="16-4-数据实体模块设计"><a href="#16-4-数据实体模块设计" class="headerlink" title="16.4　数据实体模块设计"></a>16.4　数据实体模块设计</h2><p>entity包下的organizations.py文件用于封装数据模型。该文件中设计了员工类，并提供一些维护数据的方法。接下来将详细介绍organizations.py中的代码。</p><p>1．构建员工类<br>创建Employee类作为员工类，并创建包含3个参数的构造方法。3个参数分别是员工编号、员工姓名和员工特征码。员工类将作为系统的最重要的数据模型，以对象的方式保存每一位员工的信息。<br>员工类的代码如下（代码位置：资源包\TM\sl\16\clock\entity\organizations.py）：</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128211042060.png" alt="image-20211128211042060"></p><p>2．全局变量<br>organizations.py中的全局变量较多，主要用来当作系统缓存保存所有数据。这些全局代码包括：　</p><p>LOCK_RECORD　实时保存员工的打卡记录。　</p><p>EMPLOYEES　实时保存所有员工信息。　</p><p>MAX_ID　记录当前最大ID，可在录入新员工时，为新员工分配新ID。　</p><p>CODE_LEN　开发者可以通过修改CODE_LEN的值来控制员工特征码的长度，默认长度为6位。　</p><p>WORK_TIME　上班时间，用来判断员工打卡情况。程序启动时由IO流模块为其赋值。　</p><p>CLOSING_TIME　下班时间，功能同WORK_TIME。　</p><p>USERS　系统所有管理员的账号和密码字典，用于校验用户输入的管理员账号和密码。</p><p>这些全局代码如下</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128211155281.png" alt="image-20211128211155281"></p><p>3．增删员工<br>organizations.py提供了添加新员工和删除员工的方法，其他模块需要调用这些方法来进行增删操作，不应直接修改EMPLOYEES列表中的数据。<br>add()方法用于向组织中增加新员工，因为不需要对数据做校验，所以方法中的代码非常少。该方法代码如下：</p><pre><code class="hljs"> # 添加新员工 def add(e: Employee):     EMPLOYEES.append(e)</code></pre><p>remove()方法用于删除组织中的员工，参数为员工编号。方法遍历员工列表，找到该员工之后，将该员工删除，如果该员工有过打卡记录，同时将其打卡记录删除，该方法代码如下：</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128211222751.png" alt="image-20211128211222751"></p><p>4．分配ID<br>员工编号是员工的唯一标识，有新员工加入时，应为其分配最新编号。<br>get_new_id()方法用于生成新员工编号，其生成规则为“当前最大的员工编号+1”，这样可以保证所有编号都不重复，该方法代码如下）：</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128211305025.png" alt="image-20211128211305025"></p><h2 id="16-5-工具模块设计"><a href="#16-5-工具模块设计" class="headerlink" title="16.5　工具模块设计"></a>16.5　工具模块设计</h2><p>本系统的工具模块包含3个文件：public_tools.py、io_tools.py和camera.py。本节将详细介绍这3个文件中的代码。</p><h3 id="16-5-1-公共工具模块"><a href="#16-5-1-公共工具模块" class="headerlink" title="16.5.1　公共工具模块"></a>16.5.1　公共工具模块</h3><p>uitl文件夹下的public_tools.py就是本程序的公共工具模块，该模块提供了以下功能。　生成随机数和随机特征码。　校验时间字符串格式。<br>下面详细介绍public_tools.py中的代码。</p><p>1．导入模块<br>公共工具涉及随机数和日期格式，所以导入random和datetime两个服务模块。生成随机特征码需要通过organizations.py获取特征码长度，所以也要导入数据实体模块，代码如下：</p><pre><code class="hljs"> import random import datetime from entity import organizations as o2．生成随机数</code></pre><p>特征码、照片文件名和验证码都用到了随机数，公共工具模块提供了一个生成指定位数数字的randomNumber()方法，其参数就是数字的位数。例如，参数为4，生成的参数就是4位数，且不会以0开头。该方法最后返回的是字符串类。<br>randomNumber()方法的具体代码如下：</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128211436263.png" alt="image-20211128211436263"></p><p>特征码实际上是长度固定的随机码，特征码的程度保存在数据实体模块的CODE_LEN变量中，可以直接调用randomNumber(CODE_LEN)创建特征码。特征码最好保持6位以上，这样才能降低特征码重复的概率。<br>randomCode()就是生成特征码的方法，该方法代码如下# 随机生成与特征码长度相等的数字<br>     def randomCode():<br>         return randomNumber(o.CODE_LEN)  # 特征码的长度</p><p>3．校验时间格式</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128211533748.png" alt="image-20211128211533748"></p><h3 id="16-5-2-IO流模块"><a href="#16-5-2-IO流模块" class="headerlink" title="16.5.2　IO流模块"></a>16.5.2　IO流模块</h3><p>uitl文件夹下的io_tools.py是本程序的IO流工具模块，该模块提供了以下功能。　</p><p>封装所有对文件的读写操作，包括加载员工信息、加载打卡记录、加载照片文件、删除员工信息、删除打卡记录等。　文件自检功能。　创建CSV文件。<br>下面详细介绍io_tools.py中的代码。</p><p>1．导入模块<br>IO流工具将文件中的数据保存到数据实体模块中，需导入os模块和organizations.py文件。因为删除图片需要员工特征码，所以需要人事服务模块提供相关功能，代码如下：</p><pre><code class="hljs"> from service import hr_service as hr from entity import organizations as o from service import recognize_service as rs import os import cv2 import numpy as np</code></pre><p>2．全局变量<br>全局变量中保存了各个数据文件配置，包含文件路径、文件名和照片的宽和高。这里使用了os模块提供的os.getcwd()方法来获取项目根目录。全局变量的代码如下（代码位置：资源包\TM\sl\16\clock\util\io_tools.py）：</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128211636692.png" alt="image-20211128211636692"></p><p>3．文件自检方法<br>为了防止用户误删数据文件而导致程序无法正常运行，公共工具模块提供了checking_data_files()文件自检方法。该方法在程序启动时执行，然后自动检查所有数据文件的状态，如果发现丢失文件（或文件夹），就会自动创建新的空数据文件（或文件夹）。该方法代码如下（代码位置：资源包\TM\sl\16\clock\util\io_tools.py）：</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128211707043.png" alt="image-20211128211707043"></p><p>4．从文件中加载数据。</p><p>本系统中的所有数据都保存在文本文件中，当程序启动时，需要加载所有数据，包括员工信息、员工打卡记录和员工照片。这3类数据都有各自的加载方法。<br>load_employee_info()是加载员工信息的方法，该方法读取全局变量指定的员工信息文件，将文件中的内容逐行读取，然后通过英文逗号分隔，根据分隔出的数据创建员工对象，最后把员工对象保存在员工列表中。这样就完成了员工信息的加载。<br>在读取员工数据的同时，该方法也会记录出现过的最大员工编号，并将最大员工编号赋值给数据实体模块。<br>load_employee_info()方法的具体代码如下（代码位置：资源包\TM\sl\16\clock\util\io_tools.py）：</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128211741820.png" alt="image-20211128211741820"></p><p>load_lock_record()是加载员工打卡记录的方法。该方法读取全局变量指定的打卡记录文件，因为文件保存的是打卡记录字典的字符串内容，所以直接将文件中所有文本读出，然后转换成字典类型，最后将转换后的字典对象直接赋值数据实体模块即可。<br>load_lock_record()方法的具体代码如下（代码位置：资源包\TM\sl\16\clock\util\io_tools.py）：</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128211758371.png" alt="image-20211128211758371"></p><p>load_employee_pic()是加载员工照片文件的方法，该方法首先遍历全局变量指定的照片文件夹，读取每一张照片文件并封装成OpenCV中的图像对象，然后从文件名中截取特征码，将特征码作为人脸识别的标签，最后将图像、标签统一提交人脸识别器进行训练。load_employee_pic()方法的具体代码如下（代码位置：资源包\TM\sl\16\clock\util\io_tools.py）：</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128211819740.png" alt="image-20211128211819740"></p><p>load_work_time_config()是上下班时间配置文件的方法。因为配置文件中保存的数据格式非常简单，所以该方法直接将文件中所有内容读取出来，按照“/”字符截取，并将截取的数据赋值数据实体的全局变量。<br>load_work_time_config()方法的具体代码如下（代码位置：资源包\TM\sl\16\clock\util\io_tools.py）：</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128212248428.png" alt="image-20211128212248428"></p><p>load_users()是加载管理员账号密码文件的方法。因为文件保存的是管理员账号和密码字典的字符串内容，所以直接将文件中所有文本读出来，然后转换成字典类型，最后将转换之后的字典对象直接赋值数据实体模块即可<br>load_users()方法的具体代码如下（代码位置：资源包\TM\sl\16\clock\util\io_tools.py）：</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128212304806.png" alt="image-20211128212304806"></p><p>5．将数据保存到文件中<br>既然有加载数据的方法，也就应该有保存数据的方法。当数据发生变化时，程序应立即将变化后的数据保存到本地硬盘上。公共工具模块提供了2种将数据保存到文件中的方法（保存新员工照片的方法由摄像头工具模块提供）。<br>save_employee_all()方法可以将员工列表中的数据保存到员工数据文件中。该方法首先打开文件的写权限，以覆盖的方式替换文件中的内容，然后遍历所有员工，将员工信息通过英文逗号和换行符拼接到一起，最后将拼接的文本写入文件中。<br>save_employee_all()方法的具体代码如下（代码位置：资源包\TM\sl\16\clock\util\io_tools.py）：</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128212324236.png" alt="image-20211128212324236"></p><p>save_lock_record()方法可以将打卡记录字典中的数据保存到打卡记录数据文件中，其逻辑与保存员工数据的方法类似，只不过不需要拆分或拼接数据，而是直接把字典对象转换成字符串，将转换得到的字符串覆盖到打卡记录数据文件中。<br>save_lock_record()方法的具体代码如下（代码位置：资源包\TM\sl\16\clock\util\io_tools.py）：</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128211903408.png" alt="image-20211128211903408"></p><p>save_work_time_config()方法可以将数据实体中的上班时间和下班时间保存到文件中。先按照“上班时间／下班时间”格式拼接2个时间的字符串，然后将拼接好的内容写入上下班配置文件中。<br>save_work_time_config ()方法的具体代码如下（代码位置：资源包\TM\sl\16\clock\util\io_tools.py）：</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128212417032.png" alt="image-20211128212417032"></p><p>6．删除照片<br>当一名员工被删除，该员工的照片就成了系统的垃圾文件，若不及时清除不仅会占用空间，还会加重人脸识别器的训练成本。<br>remove_pics()方法就是公共工具模块提供的删除指定员工照片的方法，参数为被删除的员工编号。该方法首先通过员工编号获取该员工的特征码，然后到照片文件夹中遍历所有文件，只要文件名以此员工的特征码开头，就将文件删除。删除后在控制台打印删除日志以提醒用户。<br>remove_pics()方法的具体代码如下（代码位置：资源包\TM\sl\16\clock\util\io_tools.py）：</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128212439429.png" alt="image-20211128212439429"></p><p>7．生成CSV文件<br>考勤月报是一个内容非常多的报表，不适合在控制台中展示，但很适合生成Excel报表来展示。因为使用Python技术创建Excel文件需要下载并导入第三方模块，会加重读者的学习压力，所以这里使用更简单的CSV格式文件来展示报表。Excel可以直接打开CSV文件。<br>CSV文件实际上是一个文本文件，每一行文字都对应Excel中的一行内容。CSV文件将每一行文字内容用英文逗号分隔，Excel根据这些英文逗号自动将文字内容分配到每一列中。<br>create_CSV()方法专门用来创建CSV文件，第一个参数是CSV文件的文件名，这个名称不包含后缀；第二个参数是CSV文件写入的文本内容。方法会将CSV文件生成在／data/文件夹下，因为大部分电脑都是用Windows系统，所以按照gbk字符编码写入内容，这样可以保证Windows系统下使用Excel打开CSV文件不会发生乱码。<br>create_CSV()方法的具体代码如下：</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128212514367.png" alt="image-20211128212514367"></p><h3 id="16-5-3-摄像头工具模块"><a href="#16-5-3-摄像头工具模块" class="headerlink" title="16.5.3　摄像头工具模块"></a>16.5.3　摄像头工具模块</h3><p>uitl文件夹下的camera.py是本程序的摄像头工具模块，该模块提供了以下功能：　开启摄像头打卡。　开启摄像头为员工拍照。<br>下面详细介绍camera.py中的代码。</p><p>1．导入模块<br>摄像头模块需要调用OpenCV和人脸识别服务的方法来实现拍照和视频打卡功能。因为打卡成功后要显示员工姓名，所以还需调用人事服务模块提供的方法，代码如下（代码位置：资源包\TM\sl\16\clock\util\camera.py）：</p><pre><code class="hljs"> import cv2 from util import public_tools as tool from util import io_tools as io from service import recognize_service as rs from service import hr_service as hr</code></pre><p>2．全局变量<br>录入新用户时需为新用户拍照，用户通过按键盘按键完成拍照。全局变量保存了键盘上Esc键和Enter键的ASCII码，OpenCV对比这2个变量来判断用户按了哪个按键，代码如下（代码位置：资源包\TM\sl\16\clock\util\camera.py）：</p><pre><code class="hljs"> ESC_KEY = 27    # Esc键的ASCII码 ENTER_KEY = 13  # Enter键的ASCII码3．为新员工拍照</code></pre><p>执行register()方法开启本地默认摄像头，方法参数是被拍照员工的特征码，当用户按Enter键时，该方法把摄像头的当前帧画面保存成图像文件，文件名以该员工特征码开头。每名新员工需要拍3张图片，也就是需要按3次Enter键，该方法才会结束。最后员工拍摄的照片都保存在／data/face/文件夹中，如图16.8所示。</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128212615823.png" alt="image-20211128212615823"></p><p>图16.8　/data/face/文件夹中员工照片文件<br>register()方法的具体代码如下</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128212655013.png" alt="image-20211128212655013"></p><p>4．开启摄像头打卡<br>执行clock_in()方法开启本地默认摄像头，程序扫描摄像头每一帧画面里是否有人脸，如果有人脸，就将这一帧画面与所有员工照片样本做比对，判断当前画面里的人脸属于哪位员工。人脸识别服务给出识别成功的特征码，通过特征码获得员工姓名，最后将识别成功的员工姓名返回。如果屏幕中没有出现人脸或者识别不成功，摄像头会一直处于开启状态。<br>clock_in()方法的具体代码如下（代码位置：资源包\TM\sl\16\clock\util\camera.py）：</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128212713423.png" alt="image-20211128212713423"></p><h2 id="16-6-服务模块设计"><a href="#16-6-服务模块设计" class="headerlink" title="16.6　服务模块设计"></a>16.6　服务模块设计</h2><p>本系统的服务模块包含2个文件：hr_service.py和recognize_service.py。前者提供所有人事管理的相关功能，例如增减员工、查询员工数据；后者提供人脸识别服务。本节将详细介绍这2个文件中的代码。</p><h3 id="16-6-1-人事服务模块"><a href="#16-6-1-人事服务模块" class="headerlink" title="16.6.1　人事服务模块"></a>16.6.1　人事服务模块</h3><p>service文件夹下的hr_service.py就是本程序的人事服务模块，该模块专门处理所有人事管理方面的业务，包含以下功能。</p><p>添加新员工。　</p><p>删除某员工。　</p><p>为指定员工添加打卡记录。　</p><p>多种获取员工信息的方法。　</p><p>生成考勤日报。　</p><p>生成考勤月报（CSV文件）。</p><p>下面详细介绍hr_service.py中的代码。</p><p>1．导入模块<br>人事服务需要管理员工类列表、记录打卡时间，还要计算、对比负责的日期和时间数值，所以要导入数据实体模块、公共工具模块、时间模块和日历模块。代码如下（代码位置：资源包\TM\sl\16\clock\service\hr_service.py）：</p><pre><code class="hljs"> from entity import organizations as o from util import public_tools as tool from util import io_tools as io import datetime import calendar</code></pre><p>2．加载所有数据</p><p>程序启动的首要任务就是加载数据，人事服务模块将所有加载数据的方法封装成load_emp_data()方法，程序启动时运行此方法就可以一次性载入所有保存在文件中的数据。该方法依次进行文件自检，载入管理员账号密码、打卡记录、员工信息和员工照片。<br>load_emp_data()方法的具体代码如下（代码位置：资源包\TM\sl\16\clock\service\hr_service.py）：</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128212820407.png" alt="image-20211128212820407"></p><p>3．添加新员工<br>add_new_employee()方法用于添加新员工，参数为新员工的姓名。该方法通过公共工具模块创建随机特征码，通过数据实体模块创建新员工编号，然后结合姓名参数创建新</p><p>员工对象，在员工列表中添加新员工对象，并将最新的员工列表写入员工数据文件中，最后将该员工的特征码返回，摄像头服务根据此特征码为员工创建照片文件。<br>add_new_employee()方法的具体代码如下（代码位置：资源包\TM\sl\16\clock\service\hr_service.py）：</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128212859144.png" alt="image-20211128212859144"></p><p>4．删除员工<br>remove_employee()方法用来删除已有的员工资料，参数为被删除员工的编号。该方法首先删除该员工的所有照片文件，然后在员工列表中清除该员工的所有信息，包括打卡记录，最后将当前员工列表和打卡记录覆盖到数据文件中。这样数据文件里不会再有该员工的任何信息了。<br>remove_employee()方法的具体代码如下（代码位置：资源包\TM\sl\16\clock\service\hr_service.py）：</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128212918378.png" alt="image-20211128212918378"></p><p>5．添加打卡记录<br>add_lock_record()方法用来为指定员工添加打卡记录，参数为员工的姓名。如果某个员工打卡成功，该方法首先检查该员工是否有已经存在的打卡记录，如果没有记录就为其创建新记录，如果有记录就在原有记录上追加新时间字符串。该方法最后把当前打卡记录保存到数据文件中。<br>add_lock_record()方法的具体代码如下（代码位置：资源包\TM\sl\16\clock\service\hr_service.py）：</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128212933763.png" alt="image-20211128212933763"></p><p>6．获取员工数据<br>人事服务提供了多种获取员工数据的方法，可以满足多种业务场景，下面分别介绍。<br>get_employee_report()方法可以返回一个包含所有员工简要信息的报表，可用于在前端展示员工列表，该方法的具体代码如下（代码位置：资源包\TM\sl\16\clock\service\hr_service.py）：</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128213013377.png" alt="image-20211128213013377"></p><p>删除员工操作需输入被删除员工的编号，程序对用户输入的值进行校验，如果用户输入的员工编号不在员工列表之中（即无效编号），就认为用户操作有误，程序中断此业务。<br>check_id()方法用来判断输入的编号是否有效，编号如果有效就返回True，无效就返回False，该方法的代码如下（代码位置：资源包\TM\sl\16\clock\service\hr_service.py）：</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128213031342.png" alt="image-20211128213031342"></p><p>通过员工特征码获取该员工姓名代码如下（代码位置：资源包\TM\sl\16\clock\service\hr_service.py）：</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128213059725.png" alt="image-20211128213059725"></p><p>通过员工编号获取该员工特征码的代码如下（代码位置：资源包\TM\sl\16\clock\service\hr_service.py）：</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128213116746.png" alt="image-20211128213116746"></p><p>7．验证管理员账号和密码<br>valid_user()方法用来验证管理员的账号和密码，第一个参数为管理员账号，第二个参数为管理员密码。该方法首先判断输入的管理员账号是否存在，如果存在则再比对输入的密码，只有管理员账号存在且密码正确的情况下，该方法才返回True，其他情况返回False。</p><p>valid_user()方法的具体代码如下（代码位置：资源包\TM\sl\16\clock\service\hr_service.py）：</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128213220573.png" alt="image-20211128213220573"></p><p>8．保存上下班时间<br>save_work_time()方法用来保存用户设置的上下班时间，第一个参数为上班时间，第二个参数为下班时间，2个参数均为字符串，且必须符合“%H:%M:%S”时间格式，例如08:00:00。该方法直接修改数据实体中的全局变量，所以用户可以修改实时的上下班时间，即设置时间之后，日报和月报会立即使用新的时间分析考勤数据。<br>save_work_time()方法的具体代码如下（代码位置：资源包\TM\sl\16\clock\service\hr_service.py）：</p><pre><code class="hljs"> # 保存上下班时间 def save_work_time(work_time, close_time):     o.WORK_TIME = work_time     o.CLOSING_TIME = close_time     io.save_work_time_config()  # 上下班时间保存到文件中</code></pre><p>9．打印考勤日报</p><p>打印考勤日报的方法有2个：get_day_report()方法打印指定日期的日报，get_today_report()方法打印今天的日报。下面分别介绍。<br>get_day_report()方法打印哪一天的日报是由参数date决定的，参数d     ate是一个字符串，且必须符合“%Y-%m-%d”时间格式，例如“2008-08-08”。该方法创建date指定的时间对象，分别计算这一天0点、12点和23点59分59秒的时间对象，并且会根据用户设置的上下班时间计算这一天上班时间对象和下班时间对象，这些时间对象将用来分析员工的考勤情况。员工的打卡规则如表16.2所示。</p><p>​                                                                                  表16.2　打卡规则</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128213246503.png" alt="image-20211128213246503"></p><p>方法中分别创建了迟到、早退和缺席名单3个列表，只要某员工出现不正常打卡记录，就会将该员工姓名放到对应不正常打卡状态的名单里，最后打印报表，给出各名单人数和明细。<br>get_day_report()方法的具体代码如下（代码位置：资源包\TM\sl\16\clock\service\hr_service.py）：</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128213913981.png" alt="image-20211128213913981"></p><p>因为负责考勤的用户最常查看的就是当天的打卡情况，所以将当天打卡日报单独封装成get_today_report()方法。该方法自动生成当天的date字符串，并将其作为参数调用get_day_report()方法。<br>get_today_report()方法的具体代码如下（代码位置：资源包\TM\sl\16\clock\service\hr_service.py）：</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128213952660.png" alt="image-20211128213952660"></p><p>10．生成考勤月报<br>与考勤日报不同，考勤月报是一种汇总形式的报表，可以展示员工整个月的考勤状况。因为月报表内容较多，所以不会在控制台中展示，而是生成独立的报表文件。<br>生成考勤月报的方法有2个：get_month_report ()方法生成指定月份的月报；get_pre_month_report ()方法打印上个月的月报。下面分别介绍。<br>考勤月报的校验逻辑与考勤日报基本相同，相当于一次性统计了一个月的日报数据。唯一不同的是统计月报的时候不是创建异常打卡名单，而是统计每一位员工每一天的打卡情况。每个员工的打卡情况用一个字符串表示，如有正常打卡，就追加正常打卡的标记，如果迟到就追加迟到标记，以此类推。统计完所有员工一个月打卡情况之后再对每个字符串进行分析。　</p><p>如果员工在×日有正常上下班打卡标记，则月报×日下不显示任何内容。迟到或早退标记都被忽略，因为可能是员工误打卡。　</p><p>如果员工在×日没有上班打卡标记，且有迟到标记，则在月报×日下显示【迟到】。　</p><p>如果员工在×日没有下班打卡标记，且有早退标记，则月报×日下显示【早退】。　</p><p>如果员工在×日没有上班打卡标记，也没有迟到标记，则在月报×日下显示【上班未打卡】。　</p><p>如果员工在×日没有下班打卡标记，也没有早退标记，则在月报×日下显示【下班未打卡】。　</p><p>如果员工在×日没有任何打卡标记，则在月报×日下显示【缺席】。<br>月报采用CSV格式文件展示，CSV文件自动生成在项目的／data/文件夹下。CSV是文本文件，用换行符区分表格的行，用英文逗号区分表格的列。get_month_report()方法最后将生成的CSV格式月报用记事本打开，其效果如图16.9所示，如果用Office Excel打开则可以看到正常的表格内容，效果如图16.10所示。</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128225917095.png" alt="image-20211128225917095"></p><p>​                                                                           图16.9　用记事本打开CSV格式的月报</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128225941244.png" alt="image-20211128225941244"></p><p>​                                                                    图16.10　用Office Excel打开CSV格式的月报<br>get_month_report()方法的具体代码如下（代码位置：资源包\TM\sl\16\clock\service\hr_service.py）：</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128230016478.png" alt="image-20211128230016478"></p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128230040789.png" alt="image-20211128230040789"></p><p>因为负责考勤的用户最常查看上个月的月报，所以将生成上个月月报单独封装成了get_pre_month_report()方法。该方法自动生成上个月的pre_month字符串，并将其作为参数调用get_month_report()方法。<br>get_pre_month_report()具体代码如下（代码位置：资源包\TM\sl\16\clock\service\hr_service.py）：</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128230117420.png" alt="image-20211128230117420"></p><h3 id="16-6-2-人脸识别服务模块"><a href="#16-6-2-人脸识别服务模块" class="headerlink" title="16.6.2　人脸识别服务模块"></a>16.6.2　人脸识别服务模块</h3><p>service文件夹下的recognize_service.py就是本程序的人脸识别服务模块，该模块提供人脸识别算法，其包含以下功能。　检测图像中是否有正面人脸。　判断图像中的人脸属于哪个人。<br>下面详细介绍recognize_service.py中的代码。</p><p>1．导入包<br>人脸识别服务需要导入OpenCV相关模块和os模块，代码如下（代码位置：资源包\TM\sl\16\clock\service\recognize_service.py）：</p><p>import cv2<br>import numpy as np<br>import os</p><p>2．全局变量<br>全局变量中创建了人脸识别器引擎和人脸识别级联分类器对象，PASS_CONF为人脸识别的信用评分，只有低于这个值的人脸识别评分才认为相似度高。全局变量的代码如下：</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128230309914.png" alt="image-20211128230309914"></p><p>3．训练识别器<br>train()方法专门用来训练人脸识别器，该方法仅封装了识别器对象的训练方法，方法参数为样本图像列表和标签列表，其代码如下（代码位置：资源包\TM\sl\16\clock\service\recognize_service.py）：</p><pre><code class="hljs"> # 训练识别器 def train(photos, lables):    RECOGNIZER.train(photos, np.array(lables))  # 识别器开始训练</code></pre><p>4．发现人脸</p><p>found_face()方法用来判断图像中是否有正面人脸，参数为灰度图像。通过正面人脸级联分类器对象检测图像中出现的人脸数量，最后返回人脸数量大于0的判断结果，有人脸就返回True，没有就返回False。<br>found_face()方法的具体代码如下（代码位置：资源包\TM\sl\16\clock\service\recognize_service.py）：</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128230328108.png" alt="image-20211128230328108"></p><p>5．识别人脸<br>recognise_face()方法用来识别图像中的人脸属于哪位员工，方法参数为被识别的图像。该方法必须在识别器接受完训练之后被调用。识别器给出分析得出的评分，如果评分大于可信范围，则认为图像中不存在任何已有员工，返回-1，否则返回已有员工的特征码。<br>recognise_face()方法的具体代码如下（代码位置：资源包\TM\sl\16\clock\service\recognize_service.py）：</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128230421418.png" alt="image-20211128230421418"></p><h2 id="16-7-程序入口设计"><a href="#16-7-程序入口设计" class="headerlink" title="16.7　程序入口设计"></a>16.7　程序入口设计</h2><p>main.py是整个程序的入口文件，负责在控制台中打印菜单界面，用户通过指令可以使用系统中的全部功能，包括打卡、员工管理等，所以会有大量指令判断逻辑。<br>main.py需要导入摄像头工具模块、公共工具模块和人事服务模块。代码如下（代码位置：资源包\TM\sl\16\clock\main.py）：</p><pre><code class="hljs"> from util import camera from util import public_tools as tool from service import hr_service as hr</code></pre><p>下面详细介绍main.py中的代码</p><h3 id="16-7-1-用户权限管理"><a href="#16-7-1-用户权限管理" class="headerlink" title="16.7.1　用户权限管理"></a>16.7.1　用户权限管理</h3><p>系统中除了打卡和退出2项功能可以随意使用，其他菜单都需要管理员权限才能使用。用户选中查看记录、员工管理和考勤报表菜单，系统会验证用户身份，如果不是管理员身份就会弹出管理员登录提示，用户输入正确的账号和密码才可以继续使用这些功能。<br>main.py文件中定义了一个全局变量ADMIN_LOGIN，该变量表示管理员的登录状态，默认为False，即管理员未登录。其代码如下（代码位置：资源包\TM\sl\16\clock\main.py）：</p><pre><code class="hljs"> ADMIN_LOGIN = False  # 管理员登录状态</code></pre><p>login()为管理员登录方法，该方法弹出输入管理员账号和密码的提示，如果用户输入账号为字符串“0”，则认为用户取消了登录操作。如果用户输入了正确的账号和密码，就将全局变量ADMIN_LOGIN的值改为True，即管理员已处于登录状态，这样系统就会开放所有已设权限的功能，用户可以随意使用。<br>login()方法的具体代码如下（代码位置：资源包\TM\sl\16\clock\main.py）：</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128230514889.png" alt="image-20211128230514889"></p><h3 id="16-7-2-主菜单设计"><a href="#16-7-2-主菜单设计" class="headerlink" title="16.7.2　主菜单设计"></a>16.7.2　主菜单设计</h3><p>start()方法是程序的启动方法，在初始化方法执行完毕后执行。该方法在控制台中打印程序的主功能菜单，效果如图16.11所示。</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128230537548.png" alt="image-20211128230537548"></p><p>​                                                                               图16.11　主菜单<br>此时用户需先输入菜单对应的数字，再按Enter键进入具体功能菜单中。如果用户输入的数字不在功能菜单中，则提示指令有误，请用户重新输入。<br>如果当前用户没有管理员权限，在选中查看记录、员工管理和考勤报表菜单时会要求用户先登录管理员的账号，效果如图16.12所示。</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128230618875.png" alt="image-20211128230618875"></p><p>​                                                         图16.12　用户需登录管理员账号才能使用员工管理功能<br>start()方法的具体代码如下（代码位置：资源包\TM\sl\16\clock\main.py）：</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128230644783.png" alt="image-20211128230644783"></p><h3 id="16-7-3-人脸打卡功能"><a href="#16-7-3-人脸打卡功能" class="headerlink" title="16.7.3　人脸打卡功能"></a>16.7.3　人脸打卡功能</h3><p>face_clock()是人脸打卡功能的执行方法，该方法调用摄像头工具模块提供的打卡方法，此时只要用户面向摄像头，摄像头即可自动扫描人脸并识别特征，效果如图16.13所示。如果镜头中的人脸符合某个员工的特征，则会返回该员工姓名，然后调用人事服务模块为此员工添加打卡记录，最后提示该员工打卡成功，过程如图16.14所示。</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128230722320.png" alt="image-20211128230722320"></p><p>​                                                                                   图16.13　打卡者需正向面对镜头</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128230745651.png" alt="image-20211128230745651"></p><p>​                                                                                  图16.14　员工王五打卡成功<br>face_clock()方法的具体代码如下：</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128230807096.png" alt="image-20211128230807096"></p><h3 id="16-7-4-为新员工登记人脸照片样本"><a href="#16-7-4-为新员工登记人脸照片样本" class="headerlink" title="16.7.4　为新员工登记人脸照片样本"></a>16.7.4　为新员工登记人脸照片样本</h3><p>employee_management()方法是员工管理功能的执行方法，该方法在控制台打印员工管理功能菜单，如图16.15所示。输入菜单对应的数字，再按Enter键进入具体功能菜单中。</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128230830763.png" alt="image-20211128230830763"></p><p>​                                                               图16.15　员工管理功能菜单<br>录入新员工的过程如图16.16所示。如果用户在员工管理功能菜单中输入数字1并按Enter键，则开始执行新员工录入操作。首先输入新员工名称，输入完毕后程序打开默认摄像头，此时让新员工面对摄像头，程序将摄像头拍摄的照片展示在如图16.17所示的register窗口中。在register窗口上按3次Enter键，自动保存3张摄像头拍摄的照片文件，最后提示录入成功。</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128230908335.png" alt="image-20211128230908335"></p><p>​                                                                                                   图16.16　录入新员工的过程</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128230931356.png" alt="image-20211128230931356"></p><p>​                                                                                    图16.17　register窗口展示的员工照片</p><h3 id="16-7-5-删除员工全部数据"><a href="#16-7-5-删除员工全部数据" class="headerlink" title="16.7.5　删除员工全部数据"></a>16.7.5　删除员工全部数据</h3><p>如果用户在员工管理功能菜单中输入数字2并按Enter键，则开始执行删除员工操作。首先程序会将所有员工的名单打印到控制台中，用户输入要删除的员工编号并按Enter键，程序给出一个验证码让用户输入，如果用户输入的验证码正确，该员工的员工信息、打卡记录和照片文件都会被删除，如果用户输入的验证码错误，则会取消删除员工操作，员工数据不会丢失。删除员工操作的过程如图16.18所示。</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128230958321.png" alt="image-20211128230958321"></p><p>​                                                                            图16.18　删除员工操作的过程<br>employee_management()方法的具体代码如下（代码位置：资源包\TM\sl\16\clock\main.py）：</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128231025347.png" alt="image-20211128231025347"></p><h3 id="16-7-6-查询员工打卡记录"><a href="#16-7-6-查询员工打卡记录" class="headerlink" title="16.7.6　查询员工打卡记录"></a>16.7.6　查询员工打卡记录</h3><p>check_record()方法是查询记录功能的执行方法，该方法在控制台打印查询记录功能菜单，效果如图16.19所示。此时用户需先输入菜单对应的数字，再按Enter键进入具体功能菜单。</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128231100025.png" alt="image-20211128231100025"></p><p>​                                                                                    图16.19　查看记录功能菜单<br>如果用户在查询记录功能菜单中输入数字1并按Enter键，程序将所有员工列表打印到控制台中，效果如图16.20所示。</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128231120571.png" alt="image-20211128231120571"></p><p>​                                                                                图16.20　查看员工列表</p><p>如果用户在查询记录功能菜单中输入数字2并按Enter键，程序将所有员工的打卡记录打印到控制台中，效果如图16.21所示。</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128231213893.png" alt="image-20211128231213893"></p><p>​                                                                                        图16.21　查看打卡记录<br>check_record()方法的具体的代码如下（代码位置：资源包\TM\sl\16\clock\main.py）：</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128231247326.png" alt="image-20211128231247326"></p><h3 id="16-7-7-生成考勤报表"><a href="#16-7-7-生成考勤报表" class="headerlink" title="16.7.7　生成考勤报表"></a>16.7.7　生成考勤报表</h3><p>check_report()方法是考勤报表功能的执行方法，该方法在控制台打印考勤报表功能菜单，效果如图16.22所示。此时用户需先输入菜单对应的数字，再按Enter键进入具体功能菜单。</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128231405373.png" alt="image-20211128231405373"></p><p>​                                                                                               图16.22　考勤报表功能菜单<br>如果用户在考勤报表功能菜单中输入数字1并按Enter键，则会提示用户输入日期。用户按照指定格式输入日期后即可看到该日期的考勤日报。如果用户输入数字0，可以打印当天的考勤日报。例如，打印2021年3月2日考勤日报的效果如图16.23所示。</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128231458581.png" alt="image-20211128231458581"></p><p>​                                                                                     图16.23　打印2021年3月2日的考勤日报<br>如果用户在考勤报表功能菜单中输入数字2并按Enter键，则提示用户输入月份。用户按照指定格式输入月份后，即可生成该月考勤月报，并显示生成的月报文件地址。如果用户输入数字0，可以生成上个月的考勤月报。例如，生成2021年3月考勤月报的效果如图16.24所示。</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128231521785.png" alt="image-20211128231521785"></p><p>​                                                                    图16.24　生成2021年3月考勤月报<br>图16.24中提示“2021年3月考勤月报.csv”文件保存在D:\clock\data\文件夹中，打开这个文件夹即可以看到月报文件，如图16.25所示，用Office Excel打开月报即可以看到如图16.26所示的表格内容。</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128231550636.png" alt="image-20211128231550636"></p><p>​                                                                            图16.25　CSV文件的位置</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128231612666.png" alt="image-20211128231612666"></p><p>​                                                                图16.26　使用Office Excel打开月报的效果<br>check_report()方法的具体代码如下（代码位置：资源包\TM\sl\16\clock\main.py）：</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128231638940.png" alt="image-20211128231638940"></p><h3 id="16-7-8-自定义上下班时间"><a href="#16-7-8-自定义上下班时间" class="headerlink" title="16.7.8　自定义上下班时间"></a>16.7.8　自定义上下班时间</h3><p>report_config()方法是报表设置功能的执行方法，如果用户在考勤报表功能菜单中输入数字3并按Enter键，则进入报表设置功能菜单，效果如图16.27所示，在这个菜单中可以设置用于分析考勤记录的上下班时间。</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128231711120.png" alt="image-20211128231711120"></p><p>​                                                                                     图16.27　报表设置功能菜单<br>如果用户在报表设置功能菜单中输入数字1并按Enter键，则分别提示用户输入上班时间和下班时间，效果如图16.28所示。如果用户输入的时间格式错误，程序要求用户重新输入。当用户设置完后，上下班时间立即生效，此时再打印考勤报表就会按照最新的上下班时间进行分析。</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128231731240.png" alt="image-20211128231731240"></p><p>​                                                                     图16.28　用户设置上班时间和下班时间      </p><p>report_config()方法的具体代码如下（代码位置：资源包\TM\sl\16\clock\main.py）：</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128231810922.png" alt="image-20211128231810922"></p><h3 id="16-7-9-启动程序"><a href="#16-7-9-启动程序" class="headerlink" title="16.7.9　启动程序"></a>16.7.9　启动程序</h3><p>main.py定义完所有全局变量和方法之后，代码的最下方就是整个系统的启动脚本：首先执行系统初始化操作，然后启动系统。具体代码如下（代码位置：资源包\TM\sl\16\clock\main.py）：</p><p><img src="/2020/06/15/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87%E8%A7%86%E9%A2%91/image-20211128231824542.png" alt="image-20211128231824542"></p><h2 id="16-8-小结"><a href="#16-8-小结" class="headerlink" title="16.8　小结"></a>16.8　小结</h2><p>本章详细介绍了一个完整小型项目的开发流程。这个项目主要包括5大功能：打卡、退出、查看记录、员工管理和考勤报表。其中，查看记录、员工管理和考勤报表3个功能需要管理员权限才能使用。这个项目采用命令提示符窗口实现与计算机之间的交互。虽然命令提示符窗口有些简陋，但不影响这个项目的实用价值。如果读者想制作一个绚丽的窗口界面运行这个项目，可以在掌握这个项目的功能结构、业务流程和实现原理后，尝试用Python PyQt5的相关知识予以实现。</p>]]></content>
    
    
    <categories>
      
      <category>数据分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>openCv</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pythonOpencv进阶篇</title>
    <link href="/2020/06/04/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87/"/>
    <url>/2020/06/04/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h1 id="OpenCV进阶篇"><a href="#OpenCV进阶篇" class="headerlink" title="OpenCV进阶篇"></a>OpenCV进阶篇</h1><h1 id="第10章-模板匹配"><a href="#第10章-模板匹配" class="headerlink" title="第10章　模板匹配"></a>第10章　模板匹配</h1><p>模板匹配是一种最原始、最基本的识别方法，可以在原始图像中寻找特定图像的位置。模板匹配经常应用于简单的图像查找场景中，例如，在集体合照中找到某个人的位置。本章将介绍如何利用OpenCV实现模板匹配。</p><p><img src="/2020/06/04/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87/image-20211122082012339.png" alt="image-20211122082012339"></p><h2 id="10-1-模板匹配方法"><a href="#10-1-模板匹配方法" class="headerlink" title="10.1　模板匹配方法"></a>10.1　模板匹配方法</h2><p>模板是被查找目标的图像，查找模板在原始图像中的哪个位置的过程就叫模板匹配。OpenCV提供的matchTemplate()方法就是模板匹配方法，其语法如下：</p><pre><code class="hljs"> result = cv2.matchTemplate(image, templ, method, mask)</code></pre><p>参数说明：　</p><p>image：原始图像。　</p><p>templ：模板图像，尺寸必须小于或等于原始图像。　</p><p>method：匹配的方法，可用参数值如表10.1所示。</p><p>表10.1　</p><p><img src="/2020/06/04/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87/image-20211122082047351.png" alt="image-20211122082047351"></p><p>匹配方法的参数值　</p><p>mask：可选参数。掩模，只有cv2.TM_SQDIFF和cv2.TM_CCORR_NORMED支持此参数，建议采用默认值。</p><p>返回值说明：　</p><p>result：计算得出的匹配结果。如果原始图像的宽、高分别为W、H，模板图像的宽、高分别为w、h，result就是一个W-w+1列、H-h+1行的32位浮点型数组。数组中每一个浮点数都是原始图像中对应像素位置的匹配结果，其含义需要根据method参数来解读。<br>在模板匹配的计算过程中，模板会在原始图像中移动。模板与重叠区域内的像素逐个对比，最后将对比的结果保存在模板左上角像素点索引位置对应的数组位置中。计算过程如图10.1所示。</p><p><img src="/2020/06/04/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87/image-20211122082229394.png" alt="image-20211122082229394"></p><p>​                                                                         图10.1　模板在原始图像中移动并逐个匹配</p><p>使用cv2.TM_SQDIFF（平方差匹配）方法计算出的数组格式如下（其他方法计算出的数组格式相同，仅数值不同）：</p><pre><code class="hljs"> [[0.10165964 0.10123613 0.1008469  ... 0.10471864 0.10471849 0.10471849]  [0.10131165 0.10087635 0.10047968 ... 0.10471849 0.10471834 0.10471849]  [0.10089004 0.10045089 0.10006084 ... 0.10471849 0.10471819 0.10471849]  ...  [0.16168603 0.16291814 0.16366465 ... 0.12178455 0.12198001 0.12187888]  [0.15859096 0.16000605 0.16096526 ... 0.12245651 0.12261643 0.12248362]  [0.15512456 0.15672517 0.15791312 ... 0.12315679 0.1232616  0.12308815]]</code></pre><p>模板将原始图像中每一块区域都覆盖一遍，但结果数组的行、列数并不等于原始图像的像素的行、列数。假设模板的宽为w，高为h，原始图像的宽为W，高为H，如图10.2所示。<br>模板移动到原始图像的边缘之后就不会继续移动了，所以模板的移动区域如图10.3所示，该区域的边长为“原始图像边长-模板边长+1”，最后加1是因为移动区域内的上下、左右的2个边都被模板覆盖到了，如果不加1会丢失数据。</p><p><img src="/2020/06/04/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87/image-20211122085327267.png" alt="image-20211122085327267"></p><p>​                                                                                        图10.2　模板和原始图像的宽、高</p><p><img src="/2020/06/04/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87/image-20211122085350483.png" alt="image-20211122085350483"></p><p>​                                                                                                图10.3　模板移动的范围</p><h2 id="10-2-单模板匹配"><a href="#10-2-单模板匹配" class="headerlink" title="10.2　单模板匹配"></a>10.2　单模板匹配</h2><p>匹配过程中只用到一个模板场景叫单模板匹配。原始图像中可能只有一个和模板相似的图像，也可能有多个。如果只获取匹配程度最高的那一个结果，这种操作叫作单目标匹配。如果需要同时获取所有匹配程度较高的结果，这种操作叫作多目标匹配。</p><h3 id="10-2-1-单目标匹配"><a href="#10-2-1-单目标匹配" class="headerlink" title="10.2.1　单目标匹配"></a>10.2.1　单目标匹配</h3><p>单目标匹配只获取一个结果即可，就是匹配程度最高的结果（如果使用平方差匹配，则为计算出的最小结果；如果使用相关匹配或相关系数匹配，则为计算出的最大结果）。本节以平方差匹配为例介绍。<br>matchTemplate()方法的计算结果是一个二维数组，OpenCV提供了一个minMaxLoc()方法专门用来解析这个二维数组中的最大值、最小值以及这2个值对应的坐标，minMaxLoc()方法的语法如下：</p><pre><code class="hljs"> minValue, maxValue, minLoc, maxLoc = cv2.minMaxLoc(src, mask)</code></pre><p>参数说明：　</p><p>src：matchTemplate()方法计算得出的数组。　</p><p>mask：可选参数，掩模，建议使用默认值。</p><p>返回值说明：　</p><p>minValue：数组中的最小值。</p><p>maxValue：数组中的最大值。　</p><p>minLoc：最小值的坐标，格式为(x, y)。　</p><p>maxLoc：最大值的坐标，格式为(x, y)。<br>平方差匹配的计算结果越小，匹配程度越高。minMaxLoc()方法返回的minValue值就是模板匹配的最优结果，minLoc就是最优结果区域左上角的点坐标，区域大小与模板大小一致。</p><p>【实例10.1】　为原始图片中匹配成功的区域绘制红框。<br>将图10.4作为模板，将图10.5作为原始图像，使用cv2.TM_SQDIFF_NORMED方式进行模板匹配，在原始图像中找到与模板一样的图案，并在该图案上绘制红色方框。</p><p><img src="/2020/06/04/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87/image-20211122085451979.png" alt="image-20211122085451979"></p><p>​                                                                                                                  图10.4　模板</p><p><img src="/2020/06/04/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87/image-20211122085539068.png" alt="image-20211122085539068"></p><p>​                                                                               图10.5　原始图片<br>具体代码如下：</p><p><img src="/2020/06/04/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87/image-20211122085602382.png" alt="image-20211122085602382"></p><p>上述代码的运行结果如图10.6所示。</p><p><img src="/2020/06/04/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87/image-20211122085749850.png" alt="image-20211122085749850"></p><p>​                                                                                        图10.6　模板匹配的效果</p><p>在许多综艺节目里，导演组给选手们一幅图像，让选手在指定区域内寻找图像中的某一静物。为了增加游戏难度，导演组可能会让选手们从2个或者多个相似的场景中选择最佳的匹配结果。接下来，使用模板匹配的相应方法模拟这个游戏。</p><p>【实例10.2】　从2幅图像中选择最佳的匹配结果。<br>将图10.7作为模板，将图10.8和图10.9作为原始图像，使用cv2.TM_SQDIFF_NORMED方式进行模板匹配，在2幅原始图像中找到与模板匹配结果最好的图像，并在窗口中显示出来。</p><p><img src="/2020/06/04/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87/image-20211122085811909.png" alt="image-20211122085811909"></p><p>​                                                                                                          图10.7　模板</p><p><img src="/2020/06/04/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87/image-20211122085837681.png" alt="image-20211122085837681"></p><p>​                                                                                                  图10.8　原始图像221</p><p><img src="/2020/06/04/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87/image-20211122085907444.png" alt="image-20211122085907444"></p><p>​                                                                                             图10.9　原始图像222<br>具体代码如下：</p><p><img src="/2020/06/04/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87/image-20211122085934422.png" alt="image-20211122085934422"></p><p>上述代码的运行结果如图10.10所示。</p><p><img src="/2020/06/04/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87/image-20211122090014973.png" alt="image-20211122090014973"></p><p>​                                                                            图10.10　从2幅图像中选择最佳的匹配结果</p><p>网速的提升让容量较大的文件更容易在互联网上传播，最明显结果就是现在用户计算机里被堆满了各种各样的图像文件。<br>图像文件与其他文件不同，相同内容的图像可能保存在不同大小、不同格式的文件中，这些文件的二进制字节码差别较大，很难用简单的程序识别。在没有高级识别软件的情况下想要找出内容相同的图像就只能一个一个打开用肉眼识别了。<br>OpenCV能够打破图像文件规格、格式的限制来识别图像内容。</p><p>【实例10.3】　查找重复的图像。<br>图10.11所示的文件夹中有10幅图像，这些图像不仅有JPG格式的，还有PNG格式的，而且这些图像的分辨率也各不相同。接下来将编写一个程序，在该文件夹中找出哪些是重复的照片。</p><p><img src="/2020/06/04/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87/image-20211122090116485.png" alt="image-20211122090116485"></p><p>​                                                                              图10.11　文件夹中的所有照片文件<br>想要解决这个问题，可以使用OpenCV提供的matchTemplate()方法来判断2幅图像的相似度，如果相似度大于0.9，就认为这2幅图像是相同的。<br>具体代码如下：</p><p><img src="/2020/06/04/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87/image-20211122090219888.png" alt="image-20211122090219888"></p><p>上述代码的运行结果如下：</p><pre><code class="hljs"> 相同的照片：10.png, 4.jpg, 相同的照片：2.jpg, 5.jpg, 9.png,</code></pre><h3 id="10-2-2-多目标匹配"><a href="#10-2-2-多目标匹配" class="headerlink" title="10.2.2　多目标匹配"></a>10.2.2　多目标匹配</h3><p>多目标匹配需要将原始图像中所有与模板相似的图像都找出来，使用相关匹配或相关系数匹配可以很好地实现这个功能。如果计算结果大于某值（例如0.999），则认为匹配区域的图案和模板是相同的。</p><p>【实例10.4】　为原始图片中所有匹配成功的图案绘制红框。<br>将图10.12作为模板，将图10.13作为原始图像。原始图像中有很多重复的图案，每一个与模板相似的图案都需要被标记出来。</p><p><img src="/2020/06/04/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87/image-20211122090300666.png" alt="image-20211122090300666"></p><p>​                                                                                                     图10.12　模板</p><p><img src="/2020/06/04/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87/image-20211122090321173.png" alt="image-20211122090321173"></p><p>​                                                                                       图10.13　包含重复内容的原始图像<br>使用cv2.TM_CCOEFF_NORMED方法进行模板匹配，使用for循环遍历matchTemplate()方法返回的结果，找到所有大于0.99的计算结果，在这些结果的对应区域位置绘制红色矩形边框。编写代码时要注意：数组的列数在图像坐标系中为横坐标，数组的行数在图像坐标系中为纵坐标。<br>具体代码如下：</p><p><img src="/2020/06/04/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87/image-20211122090346039.png" alt="image-20211122090346039"></p><p>上述代码的运行结果如图10.14所示，程序找到了3处与模板相似的图案。</p><p><img src="/2020/06/04/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87/image-20211122090426271.png" alt="image-20211122090426271"></p><p>​                                                                                                    图10.14　匹配结果<br>多目标匹配在实际生活中有很多应用场景。例如，统计一条快轨线路的站台总数；同一地点附近有2个地铁站，优先选择直线距离最短的地铁站等。</p><p>【实例10.5】　统计一条快轨线路的站台总数。<br>将图10.15作为模板，图10.16作为原始图像，在原始图像中标记快轨线路各个站台，统计这条快轨线路的站台总数。</p><p><img src="/2020/06/04/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87/image-20211122090450906.png" alt="image-20211122090450906"></p><p>​                                                                                                       图10.15　模板</p><p><img src="/2020/06/04/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87/image-20211122090516424.png" alt="image-20211122090516424"></p><p>​                                                                                                 图10.16　原始图像<br>使用cv2.TM_CCOEFF_NORMED方法进行模板匹配，使用for循环遍历matchTemplate()方法返回的结果，找到所有大于0.99的计算结果，在这些结果的对应区域位置绘制蓝色矩形边框，代码如下：       </p><p><img src="/2020/06/04/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87/image-20211122090545588.png" alt="image-20211122090545588"></p><p>上述代码的运行结果如图10.17所示。<br>实例10.5第6行中的results包含所有蓝色矩形边框左上角的横、纵坐标。利用这一特点，还可以模拟“同一地点附近有2个地铁站，优先选择直线距离最短的地铁站”这一生活场景，模板如图10.18所示。</p><p><img src="/2020/06/04/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87/image-20211122090628716.png" alt="image-20211122090628716"></p><p>​                                                                                   图10.17　统计一条快轨线路的站台总数</p><p>【实例10.6】　优先选择直线距离最短的地铁站。<br>如图10.19所示，坐标为(62, 150)的地点附近有人民广场和解放大路两个地铁站，如何优先选择直线距离最短的地铁站呢？首先将图10.18作为模板，将图10.19作为原始图像，然后在原始图像中标记出这两个地铁站，最后计算并比较坐标为(62, 150)这个地点与这两个地铁站的直线距离。</p><p><img src="/2020/06/04/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87/image-20211122090830746.png" alt="image-20211122090830746"></p><p>​                                                                                                      图10.18　模板</p><p>​                                                                                                 图10.19　原始图像<br>使用cv2.TM_CCOEFF_NORMED方法进行模板匹配，使用for循环遍历matchTemplate()方法返回的结果，找到所有大于0.99的计算结果，在这些结果的对应区域位置绘制蓝色矩形边框，分别计算(62,150)到蓝色矩形边框左上角的距离，用绿色线段标记出直线距离最短的地铁站，代码如下：</p><p><img src="/2020/06/04/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87/image-20211122091313117.png" alt="image-20211122091313117"></p><p>上述代码的运行结果如图10.20所示。</p><p><img src="/2020/06/04/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87/image-20211122091347963.png" alt="image-20211122091347963"></p><p>​                                                                            图10.20　优先选择直线距离最短的地铁站</p><h2 id="10-3-多模板匹配"><a href="#10-3-多模板匹配" class="headerlink" title="10.3　多模板匹配"></a>10.3　多模板匹配</h2><p>匹配过程中同时查找多个模板的操作叫多模板匹配。多模板匹配实际上就是进行了n次“单模板多目标匹配”操作，n的数量为模板总数。【实例10.7】　同时匹配3个不同的模板。<br>将图10.21～图10.23作为模板，将图10.24（a）作为原始图像。</p><p><img src="/2020/06/04/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87/image-20211122091419764.png" alt="image-20211122091419764"></p><p>​                                                                                                       图10.21　模板1</p><p><img src="/2020/06/04/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87/image-20211122091440162.png" alt="image-20211122091440162"></p><p>​                                                                                                  图10.22　模板2</p><p><img src="/2020/06/04/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87/image-20211122091458891.png" alt="image-20211122091458891"></p><p>​                                                                                                         图10.23　模板3<br>每一个模板都要做一次“单模板多目标匹配”，最后把所有模板的匹配结果汇总到一起。“单模板多目标匹配”的过程可以封装成一个方法，方法参数为模板和原始图像，方法内部将计算结果再加工一下，直接返回所有红框左上角和右下角两点横纵坐标的列表。在方法之外，将所有模板计算得出的坐标汇总到一个列表中，按照这些汇总的坐标一次性将所有红框都绘制出来。<br>具体代码如下：</p><p><img src="/2020/06/04/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87/image-20211122091539261.png" alt="image-20211122091539261"></p><p>上述代码的运行效果如图10.24（b）所示。</p><p><img src="/2020/06/04/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87/image-20211122091621151.png" alt="image-20211122091621151"></p><p>​                                                                                                图10.24　多模板匹配效果<br>使用多模板匹配能够解决很多生活中的实际问题。例如，一个收费停车场有4个车位，车位上陆续地停放了4辆车，通过多模板匹配，能够知晓这4辆车分别停在了哪个车位上。接下来将模拟这一生活场景。</p><p>【实例10.8】　使用多模板匹配让控制台判断4辆车分别停在了哪个车位上。<br>有4辆车按图10.25～图10.28的顺序陆续驶入停车场，这4辆车停在4个车位上的效果如图10.29所示。将图10.25～图10.28作为模板，将图10.29作为原始图像，使用cv2. TM_CCOEFF_NORMED方式进行模板匹配，在原始图像中找到与4个模板一样的图像后，在控制台上输出这4辆车分别停在了哪个车位上。</p><p>说明<br>在图10.29中，1号车位水平像素的取值范围是0<del>200，2号车位水平像素的取值范围是200</del>433，3号车位水平像素的取值范围是433<del>656，4号车位水平像素的取值范围是656</del>871。</p><p><img src="/2020/06/04/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87/image-20211122091712450.png" alt="image-20211122091712450"></p><p>​                                                                                                      图10.25　模板1</p><p><img src="/2020/06/04/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87/image-20211122091731718.png" alt="image-20211122091731718"></p><p>​                                                                                                     图10.26　模板2</p><p><img src="/2020/06/04/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87/image-20211122091750330.png" alt="image-20211122091750330"></p><p>​                                                                                                       图10.27　模板3</p><p><img src="/2020/06/04/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87/image-20211122091808719.png" alt="image-20211122091808719"></p><p>​                                                                                                        图10.28　模板4</p><p><img src="/2020/06/04/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87/image-20211122091825529.png" alt="image-20211122091825529"></p><p>​                                                                                                       图10.29　原始图像<br>具体代码如下：</p><p><img src="/2020/06/04/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87/image-20211122091850011.png" alt="image-20211122091850011"></p><p>上述代码的运行结果如下：</p><pre><code class="hljs"> 车位编号: 4 车位编号: 3 车位编号: 2 车位编号: 1</code></pre><p>上面的结果可以得出以下结论：图10.25所示的车辆停在了4号车位上，图10.26所示的车辆停在了3号车位上，图10.27所示的车辆停在了2号车位上，图10.28所示的车辆停在了1号车位上。</p><h2 id="10-4-小结"><a href="#10-4-小结" class="headerlink" title="10.4　小结"></a>10.4　小结</h2><p>模板匹配包括单模板匹配和多模板匹配，单模板匹配又包括单目标匹配和多目标匹配。实现这些内容的基础方法就是模板匹配方法，即matchTemplate()方法。其中，重点掌握模板匹配方法的6个参数值。此外，为了实现单目标匹配，除了需要使用模板匹配方法matchTemplate()外，还要使用minMaxLoc()方法，这个方法返回的就是单目标匹配的最优结果。对于多目标匹配，要将它和多模板匹配区分开：多目标匹配只有一个模板，而多模板匹配则有多个模板。</p><h1 id="第11章-滤波器"><a href="#第11章-滤波器" class="headerlink" title="第11章　滤波器"></a>第11章　滤波器</h1><p>在尽量保留原图像信息的情况下，去除图像内噪声、降低细节层次信息等一系列过程，叫作图像的平滑处理（或图像的模糊处理）。实现平滑处理最常用的工具就是滤波器。通过调节滤波器的参数，可以控制图像的平滑程度。OpenCV提供了种类丰富的滤波器，每种滤波器使用的算法均不同，但都能对图像中的像素值进行微调，让图像呈现平滑效果。本章将介绍均值滤波器、中值滤波器、高斯滤波器和双边滤波器的使用方法。</p><p><img src="/2020/06/04/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87/image-20211122092213657.png" alt="image-20211122092213657"></p><h2 id="11-1-均值滤波器"><a href="#11-1-均值滤波器" class="headerlink" title="11.1　均值滤波器"></a>11.1　均值滤波器</h2><p><img src="/2020/06/04/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87/image-20211122092621030.png" alt="image-20211122092621030"></p><p>​                                                                                               图11.1　噪声图像<br>图像中可能会出现这样一种像素，该像素与周围像素的差别非常大，导致从视觉上就能看出该像素无法与周围像素组成可识别的图像信息，降低了整个图像的质量。这种“格格不入”的像素就是图像的噪声。如果图像中的噪声都是随机的纯黑像素或者纯白像素，这样的噪声称作“椒盐噪声”或“盐噪声”。例如如图7.1所示的就是一幅只有噪声的图像，常称为“雪花点”。<br>以一个像素为核心，其周围像素可以组成一个n行n列（简称n×n）的矩阵，这样的矩阵结构在滤波操作中被称为“滤波核”。矩阵的行、列数决定了滤波核的大小，如图11.2所示的滤波核大小为3×3，包含9个像素；图11.3所示的滤波核大小为5×5，包含25个像素。</p><p><img src="/2020/06/04/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87/image-20211122092605201.png" alt="image-20211122092605201"></p><p>​                                                                                                 图11.2　3×3的滤波核</p><p><img src="/2020/06/04/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87/image-20211122092712502.png" alt="image-20211122092712502"></p><p>​                                                                                                   图11.3　5×5的滤波核<br>均值滤波器（也称为低通滤波器）可以把图像中的每一个像素都当成滤波核的核心，然后计算核内所有像素的平均值，最后让核心像素值等于这个平均值。<br>例如，图11.4就是均值滤波的计算过程。滤波核大小为3×3，核心像素值是35，颜色较深，周围像素值都为110～150，因此可以认为核心像素是噪声。将滤波核中的所有像素值相加，然后除以像素个数，就得出了平均值123（四舍五入取整）。将核心像素的值改成123，其颜色就与周围颜色差别不大，图像就变得平滑了。这就是均值滤波去噪的原理。</p><p><img src="/2020/06/04/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87/image-20211122092745945.png" alt="image-20211122092745945"></p><p>​                                                                               图11.4　均值滤波的计算过程<br>OpenCV将均值滤波器封装成blur()方法，其语法如下：</p><pre><code class="hljs"> dst = cv2.blur(src, ksize, anchor, borderType)</code></pre><p>参数说明：　</p><p>src：被处理的图像。　</p><p>ksize：滤波核大小，其格式为(高度，宽度)，建议使用如(3, 3)、(5, 5)、(7, 7)等宽、高相等的奇数边长。滤波核越大，处理之后的图像就越模糊。　</p><p>anchor：可选参数，滤波核的锚点，建议采用默认值，可以自动计算锚点。</p><p>borderType：可选参数，边界样式，建议采用默认值。</p><p>返回值说明：　</p><p>dst：经过均值滤波处理之后的图像。</p><p>【实例11.1】　对花朵图像进行均值滤波操作。<br>分别使用大小为3×3、5×5和9×9的滤波核对花朵图像进行均值滤波操</p><p>作，具体代码如下：</p><p><img src="/2020/06/04/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87/image-20211122094217442.png" alt="image-20211122094217442"></p><p>上述代码的运行结果如图11.5所示，从这个结果可以看出，滤波核越大，处理之后的图像就越模糊。</p><p><img src="/2020/06/04/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87/image-20211122092914325.png" alt="image-20211122092914325"></p><p>​                                                                                          图11.5　图像均值滤波效果</p><h2 id="11-2-中值滤波器"><a href="#11-2-中值滤波器" class="headerlink" title="11.2　中值滤波器"></a>11.2　中值滤波器</h2><p>中值滤波器的原理与均值滤波器非常相似，唯一的不同就是不计算像素的平均值，而是将所有像素值排序，把最中间的像素值取出，赋值给核心像素。</p><p>例如，图11.6就是中值滤波的计算过程。滤波核大小为3×3，核心像素值是35，周围像素值都为110～150。将核内所有像素值按升序排列，9个像素值排成一行，最中间位置为第5个位置，这个位置的像素值为131。不需再做任何计算，直接把131赋值给核心像素，其颜色就与周围颜色差别不大，图像就变得平滑了。这就是中值滤波去噪的原理。</p><p><img src="/2020/06/04/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87/image-20211122095233594.png" alt="image-20211122095233594"></p><p>图11.6　中值滤波的计算过程<br>OpenCV将中值滤波器封装成medianBlur()方法，其语法如下：</p><pre><code class="hljs"> dst = cv2.medianBlur(src, ksize)</code></pre><p>参数说明：　</p><p>src：被处理的图像。　</p><p>ksize：滤波核的边长，必须是大于1的奇数，如3、5、7等。该方法根据此边长自动创建一个正方形的滤波核。</p><p>返回值说明：　</p><p>dst：经过中值滤波处理之后的图像。</p><p>注意<br>中值滤波器的ksize参数是边长，而其他滤波器的ksize参数通常为（高，宽）。</p><p>【实例11.2】　对花朵图像进行中值滤波操作.<br>分别使用边长为3、5、9的滤波核对花朵图像进行中值滤波操作，具体代码如下：</p><p><img src="/2020/06/04/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87/image-20211122095347319.png" alt="image-20211122095347319"></p><p>上述代码的运行结果如图11.7所示，滤波核的边长越长，处理之后的图像就越模糊。中值滤波处理的图像会比均值滤波处理的图像丢失更多细节。</p><p><img src="/2020/06/04/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87/image-20211122095440078.png" alt="image-20211122095440078"></p><p>​                                                                                      图11.7　图像中值滤波效果</p><h2 id="11-3-高斯滤波器"><a href="#11-3-高斯滤波器" class="headerlink" title="11.3　高斯滤波器"></a>11.3　高斯滤波器</h2><p>高斯滤波也被称为高斯模糊或高斯平滑，是目前应用最广泛的平滑处理算法。高斯滤波可以很好地在降低图片噪声、细节层次的同时保留更多的图像信息，经过处理的图像呈现“磨砂玻璃”的滤镜效果。<br>进行均值滤波处理时，核心周围每个像素的权重都是均等的，也就是每个像素都同样重要，所以计算平均值即可。但在高斯滤波中，越靠近核心的像素权重越大，越远离核心的像素权重越小，例如5×5大小的高斯滤波卷积核的权重示意图如图11.8所示。像素权重不同不能取平均值，要从权重大的像素中取较多的信息，从权重小的像素中取较少的信息。简单概括就是“离谁更近，跟谁更像”。<br>高斯滤波的计算过程涉及卷积运算，会有一个与滤波核大小相等的卷积核。本节仅以3×3的滤波核为例，简单地描述一下高斯滤波的计算过程。<br>卷积核中保存的值就是核所覆盖区域的权重值，其遵循图11.8的规律。卷积核中所有权重值相加的结果为1。例如，3×3的卷积核可以是如图11.9所示的值。随着核大小、σ标准差的变化，卷积核中的值也会发生较大变化，图11.9仅是一种最简单的情况。</p><p><img src="/2020/06/04/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87/image-20211122095530857.png" alt="image-20211122095530857"></p><p>​                                                                 图11.8　5×5的高斯滤波卷积核的权重示意图</p><p><img src="/2020/06/04/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87/image-20211122095559972.png" alt="image-20211122095559972"></p><p>​                                                                                   图11.9　简化的3×3的卷积核<br>进行高斯滤波的过程中，滤波核中像素与卷积核进行卷积计算，最后将计算结果赋值给滤波核的核心像素。其计算过程如图11.10所示。</p><p><img src="/2020/06/04/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87/image-20211122095620790.png" alt="image-20211122095620790"></p><p>​                                                                                           图11.10　像素与卷积核进行卷积计算<br>在图11.10的计算过程中，滤波核中的每个像素值都与卷积核对应位置的权重值相乘，最后计算出9个值，计算过程如下：</p><pre><code class="hljs"> 137 × 0.05  150 × 0.1  125 × 0.05     6.85  15    6.25 141 × 0.1   35 × 0.4   131 × 0.1   =  14.1  14    13.1 119 × 0.05  118 × 0.1  150 × 0.05     5.95  11.8  7.5</code></pre><p>让这9个值相加，再四舍五入取整，计算过程如下：</p><pre><code class="hljs"> 6.85 + 15 + 6.25 + 14.1 + 14 + 13.1 + 5.95 + 11.8 + 7.5 = 94.55 ≈ 95</code></pre><p>最后得到的这个结果就是高斯滤波的计算结果，滤波核的核心像素值从35改为95。<br>OpenCV将高斯滤波器封装成了GaussianBlur()方法，其语法如下：</p><pre><code class="hljs"> dst = cv2.GaussianBlur(src, ksize, sigmaX, sigmaY, borderType)</code></pre><p>参数说明：　</p><p>src：被处理的图像。</p><p>ksize：滤波核的大小，宽高必须是奇数，如(3, 3)、(5, 5)等。　</p><p>sigmaX：卷积核水平方向的标准差。　</p><p>sigmaY：卷积核垂直方向的标准差。　修改sigmaX或sigmaY的值都可以改变卷积核中的权重比例。如果不知道如何设计这2个参数值，就直接把这2个参数的值写成0，该方法就会根据滤波核的大小自动计算合适的权重比例。　</p><p>borderType：可选参数，边界样式，建议使用默认值。</p><p>返回值说明：　</p><p>dst：经过高斯滤波处理之后的图像。</p><p>【实例11.3】　对花朵图像进行高斯滤波操作。<br>分别使用大小为5×5、9×9和15×15的滤波核对花朵图像进行高斯滤波操作，水平方向和垂直方向的标准差参数值全部为0，具体代码如下：</p><p><img src="/2020/06/04/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87/image-20211122095728517.png" alt="image-20211122095728517"></p><p>上述代码的运行结果如图11.11所示，滤波核越大，处理之后的图像就越模糊。和均值滤波、中值滤波处理的图像相比，高斯滤波处理的图像更加平滑，保留的图像信息更多，更容易辨认。</p><p><img src="/2020/06/04/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87/image-20211122095747712.png" alt="image-20211122095747712"></p><p><img src="/2020/06/04/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87/image-20211122095856218.png" alt="image-20211122095856218"></p><p>​                                                                                    图11.11　图像的高斯滤波效果</p><h2 id="11-4-双边滤波器"><a href="#11-4-双边滤波器" class="headerlink" title="11.4　双边滤波器"></a>11.4　双边滤波器</h2><p>不管是均值滤波、中值滤波还是高斯滤波，都会使整幅图像变得平滑，图像中的边界会变得模糊不清。双边滤波是一种在平滑处理过程中可以有效保护边界信息的滤波操作方法。<br>双边滤波器自动判断滤波核处于“平坦”区域还是“边缘”区域：如果滤波核处于“平坦”区域，则会使用类似高斯滤波的算法进行滤波；如果滤波核处于“边缘”区域，则加大“边缘”像素的权重，尽可能地让这些像素值保持不变。<br>例如，图11.12是一幅黑白拼接图像，对这幅图像进行高斯滤波，黑白交界处就会变得模糊不清，效果如图11.13所示，但如果对这幅图像进行双边滤波，黑白交界处的边界则可以很好地保留下来，效果如图11.14所示。</p><p><img src="/2020/06/04/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87/image-20211122095927108.png" alt="image-20211122095927108"></p><p>​                                                                                             图11.12　原图</p><p><img src="/2020/06/04/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87/image-20211122095943849.png" alt="image-20211122095943849"></p><p>​                                                                                      图11.13　高斯滤波效果</p><p><img src="/2020/06/04/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87/image-20211122100141070.png" alt="image-20211122100141070"></p><p>​                                                                                      图11.14　双边滤波效果<br>OpenCV将双边滤波器封装成bilateralFilter()方法，其语法如下：</p><pre><code class="hljs"> dst = cv2.bilateralFilter(src, d, sigmaColor, sigmaSpace, borderType)</code></pre><p>参数说明：　</p><p>src：被处理的图像。　</p><p>d：以当前像素为中心的整个滤波区域的直径。如果d&lt;0，则自动根据sigmaSpace参数计算得到。该值与保留的边缘信息数量成正比，与方法运行效率成反比。　</p><p>sigmaColor：参与计算的颜色范围，这个值是像素颜色值与周围颜色值的最大差值，只有颜色值之差小于这个值时，周围的像素才进行滤波计算。值为255时，表示所有颜色都参与计算。　</p><p>sigmaSpace：坐标空间的σ（sigma）值，该值越大，参与计算的像素数量就越多。　</p><p>borderType：可选参数，边界样式，建议默认。<br>返回值说明：　</p><p>dst：经过双边滤波处理之后的图像。</p><p>【实例11.4】　对比高斯滤波和双边滤波的处理效果。</p><p>使用大小为(15, 15)的滤波核对花朵图像进行高斯滤波处理，同样使用15作为范围直径对花朵图像进行双边滤波处理，观察两种滤波处理之后的图像边缘有什么差别，具体代码如下：</p><p><img src="/2020/06/04/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87/image-20211122100239643.png" alt="image-20211122100239643"></p><p>上述代码的运行结果如图11.15所示，可以看出高斯滤波模糊了整个画面，但双边滤波保留了较清晰的边缘信息。</p><p><img src="/2020/06/04/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87/image-20211122100319332.png" alt="image-20211122100319332"></p><p>​                                                                           图11.15　两种滤波方法效果对比</p><h2 id="11-5-小结"><a href="#11-5-小结" class="headerlink" title="11.5　小结"></a>11.5　小结</h2><p>噪声指的是一幅图像内部的、高亮度的像素点。图像平滑处理是指在尽量保留原图像信息的情况下，去除图像内部的这些高亮度的像素点（也就是“噪声”）。为了实现图像平滑处理，需要的工具就是滤波器。本章主要讲解了OpenCV中的4种滤波器，虽然每种滤波器的实现原理都不同，但是每种滤波器都能对图像进行图像平滑处理。读者朋友在掌握这4种滤波器的实现方法的同时，也要熟悉这4种滤波器的实现原理。</p><h1 id="第12章-腐蚀与膨胀"><a href="#第12章-腐蚀与膨胀" class="headerlink" title="第12章　腐蚀与膨胀"></a>第12章　腐蚀与膨胀</h1><p>腐蚀和膨胀是图像形态学中的两种核心操作，通过这两种操作可以清除或强化图像中的细节。合理使用腐蚀和膨胀，还可以实现图像开运算、闭运算、梯度运算、顶帽运算和黑帽运算等极具特点的操作。下面将对腐蚀、膨胀以及其他形态学操作进行详细的介绍。</p><p><img src="/2020/06/04/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87/image-20211125193906728.png" alt="image-20211125193906728"></p><h2 id="12-1-腐蚀"><a href="#12-1-腐蚀" class="headerlink" title="12.1　腐蚀"></a>12.1　腐蚀</h2><p>腐蚀操作可以让图像沿着自己的边界向内收缩。OpenCV通过“核”来实现收缩计算。“核”的英文名为kernel，在形态学中可以理解为“由n个像素组成的像素块”，像素块包含一个核心（核心通常在中央位置，也可以定义在其他位置）。像素块在图像的边缘移动，在移动过程中，核会将图像边缘那些与核重合但又没有越过核心的像素点都抹除，效果类似图12.1所示的过程，就像削土豆皮一样，将图像一层一层地“削薄”。</p><p><img src="/2020/06/04/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87/image-20211125193959328.png" alt="image-20211125193959328"></p><p>​                                                                                       图12.1　核腐蚀图像中的像素</p><p>OpenCV将腐蚀操作封装成erode()方法，该方法的语法如下：</p><pre><code class="hljs"> dst = cv2.erode(src, kernel, anchor, iterations, borderType, borderValue)</code></pre><p>参数说明：</p><p>src：原始图像。</p><p>kernel：腐蚀使用的核。　</p><p>anchor：可选参数，核的锚点位置。　</p><p>iterations：可选参数，腐蚀操作的迭代次数，默认值为1。　</p><p>borderType：可选参数，边界样式，建议默认。　</p><p>borderValue：可选参数，边界值，建议默认。</p><p>返回值说明：　</p><p>dst：经过腐蚀之后的图像。<br>图像经过腐蚀操作之后，可以抹除一些外部的细节，如图12.2所示是一个卡通小蜘蛛，如果用一个5×5的像素块作为核对小蜘蛛进行腐蚀操作，可以得到如图12.3所示的结果。小蜘蛛的腿被当成外部细节抹除了，同时小蜘蛛的眼睛变大了，因为核从内部也“削”了一圈。</p><p><img src="/2020/06/04/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87/image-20211125194100364.png" alt="image-20211125194100364"></p><p>​                                                                                               图12.2　原图</p><p><img src="/2020/06/04/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87/image-20211125194124001.png" alt="image-20211125194124001"></p><p>​                                                                                         图12.3　腐蚀之后的图像<br>在OpenCV做腐蚀或其他形态学操作时，通常使用numpy模块来创建核数组，例如：</p><pre><code class="hljs"> import numpy as np k = np.ones((5, 5), np.uint8)</code></pre><p>这两行代码就是通过numpy模块的ones()方法创建了一个5行5列（简称5×5）、数字类型为无符号8位整数、每一个数字的值都是1的数组，这个数组作为erode()方法的核参数。除了5×5的结构，还可以使用3×3、9×9、11×11等结构，行列数越大，计算出的效果就越粗糙，行列数越小，计算出的效果就越精细。</p><p>【实例12.1】　将仙人球图像中的刺抹除。<br>仙人球的叶子呈针状，茎呈深绿色，如图12.4所示。</p><p><img src="/2020/06/04/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87/image-20211125194225098.png" alt="image-20211125194225098"></p><p>​                                                                                               图12.4　仙人球<br>使用3×3的核对仙人球图像进行腐蚀操作，可以将图像里的刺抹除，具体代码如下：</p><p><img src="/2020/06/04/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87/image-20211125194308740.png" alt="image-20211125194308740"></p><p>上述代码的运行结果如图12.5所示。</p><p><img src="/2020/06/04/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87/image-20211125194341145.png" alt="image-20211125194341145"></p><p>​                                                                              图12.5　图像腐蚀操作效果</p><h2 id="12-2-膨胀"><a href="#12-2-膨胀" class="headerlink" title="12.2　膨胀"></a>12.2　膨胀</h2><p>膨胀操作与腐蚀操作相反，膨胀操作可以让图像沿着自己的边界向内扩张。同样是通过核来计算，当核在图像的边缘移动时，核会将图像边缘填补新的像素，效果类似图12.6所示的过程，就像在一面墙上反反复复地涂水泥，让墙变得越来越厚。</p><p><img src="/2020/06/04/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87/image-20211125194443041.png" alt="image-20211125194443041"></p><p>​                                                                                      图12.6　核填补图像中的像素<br>OpenCV将膨胀操作封装成dilate()方法，该方法的语法如下：</p><pre><code class="hljs"> dst = cv2.dilate(src, kernel, anchor, iterations, borderType, borderValue)</code></pre><p>参数说明：　</p><p>src：原始图像。　</p><p>kernel：膨胀使用的核。　</p><p>anchor：可选参数，核的锚点位置。　</p><p>iterations：可选参数，腐蚀操作的迭代次数，默认值为1。　</p><p>borderType：可选参数，边界样式，建议默认。　</p><p>borderValue：可选参数，边界值，建议默认。<br>返回值说明：　</p><p>dst：经过膨胀之后的图像。<br>图像经过膨胀操作之后，可以放大一些外部的细节，如图12.7（a）所示的卡通小蜘蛛，如果用一个5×5的像素块作为核对小蜘蛛进行膨胀操作，可以得到如图12.7（b）所示的结果，小蜘蛛不仅腿变粗了，而且连眼睛都胖没了。</p><p><img src="/2020/06/04/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87/image-20211125194535307.png" alt="image-20211125194535307"></p><p>​                                                                                图12.7　图像膨胀操作效果</p><p>【实例12.2】　将图像加工成“近视眼”效果。<br>近视眼由于聚焦不准，看东西都需要放大并且模模糊糊的，利用膨胀操作可以将正常画面处理成近视眼看到的画面。采用9×9的数组作为核，对图12.8（a）进行膨胀操作。<br>具体代码如下：</p><p><img src="/2020/06/04/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87/image-20211125194619331.png" alt="image-20211125194619331"></p><p>上述代码的运行结果如图12.8所示</p><p><img src="/2020/06/04/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87/image-20211125194637143.png" alt="image-20211125194637143"></p><p>​                                                                   图12.8　图像膨胀操作“近视眼”效果</p><h2 id="12-3-开运算"><a href="#12-3-开运算" class="headerlink" title="12.3　开运算"></a>12.3　开运算</h2><p>开运算是将图像先进行腐蚀操作，再进行膨胀操作。开运算可以用来抹除图像外部的细节（或者噪声）。<br>例如，图12.9是一个简单的二叉树，父子节点之间都有线连接。如果对此图像进行腐蚀操作，可以得出如图12.10所示的图像，连接线消失了，节点也比原图节点小一圈。此时再执行膨胀操作，让缩小的节点恢复到原来的大小，就得到了如图12.11所示的效果。<br>这3幅图就是开运算的过程，从结果中可以明显地看出：经过开运算之后，二叉树中的连接线消失了，只剩下光秃秃的节点。因为连接线被核当成“细节”抹除了，所以利用检测轮廓的方法可以统计二叉树节点数量，也就是说在某些情况下，开运算的结果还可以用来做数量统计。</p><p><img src="/2020/06/04/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87/image-20211125194659165.png" alt="image-20211125194659165"></p><p>​                                                                                        图12.9　简单的二叉树</p><p><img src="/2020/06/04/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87/image-20211125194754294.png" alt="image-20211125194754294"></p><p>​                                                                      图12.10　二叉树图像腐蚀之后的效果</p><p><img src="/2020/06/04/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87/image-20211125194813564.png" alt="image-20211125194813564"></p><p>​                                                                         图12.11　对腐蚀的图像做膨胀操作</p><p>【实例12.3】　抹除黑种草图像中的针状叶子。<br>黑种草如图12.12（a）所示，花呈蓝色，叶子像针一样又细又长，呈羽毛状。要抹除黑种草图像中的叶子，可以使用5×5的核对图像进行开运算。<br>具体代码如下：</p><p><img src="/2020/06/04/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87/image-20211125194832293.png" alt="image-20211125194832293"></p><p>上述代码的运行结果如图12.12（b）所示，经过开运算后黑种草图像虽然略为模糊，但叶子都不见了。</p><p><img src="/2020/06/04/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87/image-20211125194853964.png" alt="image-20211125194853964"></p><p>​                                                                                                   图12.12　图像开运算效果</p><h2 id="12-4-闭运算"><a href="#12-4-闭运算" class="headerlink" title="12.4　闭运算"></a>12.4　闭运算</h2><p>闭运算是将图像先进行膨胀操作，再进行腐蚀操作。闭运算可以抹除图像内部的细节（或者噪声）。<br>例如，图12.13（a）是一个身上布满斑点的小蜘蛛，这些斑点就是图像的内部细节。先将图像进行膨胀操作，小蜘蛛身上的斑点（包括眼睛）被抹除，效果如图12.13（b）所示。然后再将图像进行腐蚀操作，膨胀的小蜘蛛恢复到原来的大小，效果如图12.13（c）所示。</p><p><img src="/2020/06/04/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87/image-20211125194952165.png" alt="image-20211125194952165"></p><p>​                                                                                  图12.13　图像闭运算效果<br>这3幅图就是闭运算的过程，从结果中可以明显地看出：经过闭运算后，小蜘蛛身上的花纹都被抹除了，就连眼睛也被当成“细节”抹除了。<br>闭运算除了会抹除图像内部的细节，还会让一些离得较近的区域合并成一块区域。</p><p>【实例12.4】　对汉字图片进行闭运算。<br>使用15×15的核对图12.14（a）做闭运算。因为使用的核比较大，很容易导致一些间隔较近的区域合并到一起，观察闭运算对汉字图片造成了哪些影响。<br>具体代码如下：</p><p><img src="/2020/06/04/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87/image-20211125195012305.png" alt="image-20211125195012305"></p><p>上述代码的运行结果如图12.14（b）所示，“田”字经过闭运算之后没有多大变化，但是“野”字经过闭运算之后，许多独立的区域因膨胀操作合并到一起，导致文字很难辨认。</p><p><img src="/2020/06/04/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87/image-20211125195103765.png" alt="image-20211125195103765"></p><p>​                                                                                        图12.14　汉字图片闭运算效果</p><h2 id="12-5-形态学运算"><a href="#12-5-形态学运算" class="headerlink" title="12.5　形态学运算"></a>12.5　形态学运算</h2><p>腐蚀和膨胀是形态学的基础操作，除了开运算和闭运算以外，形态学中还有几种比较有特点的运算。OpenCV提供了一个morphologyEx()形态学方法，包含所有常用的运算，其语法如下：</p><pre><code class="hljs"> dst = cv2.morphologyEx(src, op, kernel, anchor, iterations, borderType, borderValue)</code></pre><p>参数说明：　</p><p>src：原始图像。　</p><p>op：操作类型，具体值如表12.1所示。</p><p>​                                                                           表12.1　形态学函数的操作类型参数　</p><p><img src="/2020/06/04/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87/image-20211125195140684.png" alt="image-20211125195140684"></p><p>kernel：操作过程中使用的核。　</p><p>anchor：可选参数，核的锚点位置。　</p><p>iterations：可选参数，迭代次数，默认值为1。　</p><p>borderType：可选参数，边界样式，建议默认。　</p><p>borderValue：可选参数，边界值，建议默认。</p><p>返回值说明：　</p><p>dst：操作之后得到的图像。<br>morphologyEx()方法实现的腐蚀、膨胀、开运算和闭运算效果与前文中介绍的效果完全一致，本节不再赘述，下面将介绍3个特点鲜明的操作：梯度运算、顶帽运算和黑帽运算。</p><h3 id="12-5-1-梯度运算"><a href="#12-5-1-梯度运算" class="headerlink" title="12.5.1　梯度运算"></a>12.5.1　梯度运算</h3><p>这里的梯度是指图像梯度，可以简单地理解为像素的变化程度。如果几个连续的像素，其像素值跨度越大，则梯度值越大。<br>梯度运算的运算过程如图12.15所示，让原图的膨胀图减原图的腐蚀图。因为膨胀图比原图大，腐蚀图比原图小，利用腐蚀图将膨胀图掏空，就得到了原图的轮廓图。说明<br>梯度运算中得到的轮廓图只是一个大概轮廓，不精准。</p><p><img src="/2020/06/04/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87/image-20211125195234243.png" alt="image-20211125195234243"></p><p>​                                                                                 图12.15　梯度运算过程<br>梯度运算的参数为cv2.MORPH_GRADIENT，下面通过一段代码实现图12.15的效果。</p><p>【实例12.5】　通过梯度运算画出小蜘蛛的轮廓。<br>使用5×5的核对小蜘蛛图像进行形态学梯度运算，具体代码如下：</p><p><img src="/2020/06/04/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87/image-20211125195253240.png" alt="image-20211125195253240"></p><p>上述代码的运行结果如图12.16所示。</p><p><img src="/2020/06/04/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87/image-20211125195322974.png" alt="image-20211125195322974"></p><p>​                                                                                           图12.16　图像梯度运算效果</p><h3 id="12-5-2-顶帽运算"><a href="#12-5-2-顶帽运算" class="headerlink" title="12.5.2　顶帽运算"></a>12.5.2　顶帽运算</h3><p>顶帽运算的运算过程如图12.17所示，让原图减原图的开运算图。因为开运算抹除图像的外部细节，“有外部细节”的图像减去“无外部细节”的图像，得到的结果就只剩外部细节了，所以经过顶帽运算之后，小蜘蛛就只剩蜘蛛腿了。</p><p><img src="/2020/06/04/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87/image-20211125195410644.png" alt="image-20211125195410644"></p><p>​                                                                                      图12.17　顶帽运算过程<br>顶帽运算的参数为cv2.MORPH_TOPHA，下面通过一段代码实现图12.18的效果。</p><p>【实例12.6】　通过顶帽运算画出小蜘蛛的腿。<br>使用5×5的核对小蜘蛛图像进行顶帽运算，具体代码如下：</p><p><img src="/2020/06/04/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87/image-20211125195435250.png" alt="image-20211125195435250"></p><p>上述代码的运算结果如图12.18所示。</p><p><img src="/2020/06/04/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87/image-20211125195455237.png" alt="image-20211125195455237"></p><p>​                                                                                                图12.18　图像开运算效果</p><h3 id="12-5-3-黑帽运算"><a href="#12-5-3-黑帽运算" class="headerlink" title="12.5.3　黑帽运算"></a>12.5.3　黑帽运算</h3><p>黑帽运算的运算过程如图12.19所示，让原图的闭运算图减去原图。因为闭运算抹除图像的内部细节，“无内部细节”的图像减去“有内部细节”的图像，得到的结果就只剩内部细节了，所以经过黑帽运算之后，小蜘蛛就只剩下斑点、花纹和眼睛了。</p><p><img src="/2020/06/04/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87/image-20211125195549507.png" alt="image-20211125195549507"></p><p>​                                                                                  图12.19　黑帽运算过程<br>黑帽运算的参数为cv2.MORPH_BLACKHAT，下面通过一段代码实现图12.19的效果。</p><p>【实例12.7】　通过黑帽运算画出小蜘蛛身上的花纹。<br>使用5×5的核对小蜘蛛图像进行黑帽运算，具体代码如下：</p><p><img src="/2020/06/04/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87/image-20211125195624673.png" alt="image-20211125195624673"></p><p>上述代码的运行结果如图20所示。</p><p><img src="/2020/06/04/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87/image-20211125195644815.png" alt="image-20211125195644815"></p><p>​                                                                                    图12.20　图像黑帽运算效果</p><h2 id="12-6-小结"><a href="#12-6-小结" class="headerlink" title="12.6　小结"></a>12.6　小结</h2><p>本章介绍的基础内容是腐蚀和膨胀。读者掌握了其用法，就能轻而易举地实现开运算和闭运算。其中，开运算是对图像先进行腐蚀操作，再进行膨胀操作，其作用是抹除图像外部的细节；而闭运算是对图像先进行膨胀操作，再进行腐蚀操作，其作用是抹除图像内部的细节。此外，形态学运算也是构建在腐蚀和膨胀的基础上的。其中，梯度运算是让原图的膨胀图减原图的腐蚀图，得到的结果是原图的轮廓；顶帽运算是让原图减原图的开运算图，得到的结果是图像的外部细节；黑帽运算是让原图的闭运算图减去原图，得到的结果是图像的内部细节。</p><h1 id="第13章-图形检测"><a href="#第13章-图形检测" class="headerlink" title="第13章　图形检测"></a>第13章　图形检测</h1><p>图形检测是计算机视觉的一项重要功能。通过图形检测可以分析图像中可能存在的形状，然后对这些形状进行描绘，如搜索并绘制图像的边缘，定位图像的位置，判断图像中有没有直线、圆形等。虽然图形检测涉及非常深奥的数学算法，但OpenCV已经将这些算法封装成简单的方法，开发者只要学会如何调用方法、调整参数即可很好地实现检测功能。<br>本章将介绍如何检测图像的形状、图像所占的区域，以及如何查找图像中出现的几何图形等。</p><p><img src="/2020/06/04/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87/image-20211125195758972.png" alt="image-20211125195758972"></p><h2 id="13-1-图像的轮廓"><a href="#13-1-图像的轮廓" class="headerlink" title="13.1　图像的轮廓"></a>13.1　图像的轮廓</h2><p>轮廓是指图像中图形或物体的外边缘线条。简单的几何图形轮廓是由平滑的线构成的，容易识别，但不规则图形的轮廓可能由许多个点构成，识别起来比较困难。<br>OpenCV提供的findContours()方法可以通过计算图像梯度来判断图像的边缘，然后将边缘的点封装成数组返回。findContours()方法的语法如下：</p><pre><code class="hljs"> contours, hierarchy = cv2.findContours(image, mode, methode)</code></pre><p>参数说明：　</p><p>image：被检测的图像，必须是8位单通道二值图像。如果原始图像是彩色图像，必须转为灰度图像，并经过二值化处理。　</p><p>mode：轮廓的检索模式，具体值如表13.1所示。</p><p>​                                                                                              表13.1　轮廓的检索模式参数值</p><p><img src="/2020/06/04/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87/image-20211125195942347.png" alt="image-20211125195942347"></p><p>methode：</p><p>检测轮廓时使用的方法，具体值如表13.2所示。</p><p>​                                                                                            表13.2　检测轮廓时使用的方法</p><p><img src="/2020/06/04/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87/image-20211125200003759.png" alt="image-20211125200003759"></p><p>返回值说明：　</p><p>contours：检测出的所有轮廓，list类型，每一个元素都是某个轮廓的像素坐标数组。　</p><p>hierarchy：轮廓之间的层次关系。<br>通过findContours()方法找到图像轮廓后，为了方便开发人员观测，最好能把轮廓画出来，于是OpenCV提供了drawContours()方法用来绘制这些轮廓。drawContours()方法的语法如下：</p><pre><code class="hljs"> image = cv2.drawContours(image, contours, contourIdx, color, thickness, lineTypee, hierarchy, maxLevel, offse)</code></pre><p>参数说明：</p><p>image：被绘制轮廓的原始图像，可以是多通道图像。　</p><p>contours：findContours()方法得出的轮廓列表。　</p><p>contourIdx：绘制轮廓的索引，如果为-1则绘制所有轮廓。　</p><p>color：绘制颜色，使用BGR格式。　</p><p>thickness：可选参数，画笔的粗细程度，如果该值为-1则绘制实心轮廓。　</p><p>lineTypee：可选参数，绘制轮廓的线型。　</p><p>hierarchy：可选参数，findContours()方法得出的层次关系。　</p><p>maxLevel：可选参数，绘制轮廓的层次深度，最深绘制第maxLevel层。　</p><p>offse：可选参数，偏移量，可以改变绘制结果的位置。</p><p>返回值说明：</p><p>image：同参数中的image，执行后原始图中就包含绘制的轮廓了，可以不使用此返回值保存结果。</p><p>【实例13.1】　绘制几何图像的轮廓。<br>将如图13.1所示的几何图像转换成二值灰度图像，然后通过findContours()方法找到出现的所有轮廓，再通过drawContours()方法将这些轮廓绘制成红色。轮廓的检索模式采用cv2.RETR_LIST，检测方法采用cv2.CHAIN_APPROX_NONE。</p><p><img src="/2020/06/04/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87/image-20211125200104772.png" alt="image-20211125200104772"></p><p>​                                                                                 图13.1　简单的几何图像<br>具体代码如下：</p><p><img src="/2020/06/04/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87/image-20211125200222796.png" alt="image-20211125200222796"></p><p>上述代码的运行结果如图13.2所示。</p><p><img src="/2020/06/04/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87/image-20211125200313470.png" alt="image-20211125200313470"></p><p>​                                                                                           图13.2　绘制全部轮廓</p><p>如果使用cv2.RETR_EXTERNAL做参数则只绘制外轮廓，关键代码如下：</p><pre><code class="hljs"> contours, hierarchy = cv2.findContours(binary, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE) cv2.drawContours(img, contours, -1, (0, 0, 255), 5)</code></pre><p>绘制轮廓的效果如图13.3所示。</p><p><img src="/2020/06/04/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87/image-20211125200347818.png" alt="image-20211125200347818"></p><p>​                                                                               图13.3　只绘制外轮廓的效果</p><p>drawContours()方法的第3个参数可以指定绘制哪个索引的轮廓。索引的顺序由轮廓的检索模式决定，例如cv2.RETR_CCOMP模式下绘制索引为0的轮廓的关键代码如下：</p><pre><code class="hljs"> contours, hierarchy = cv2.findContours(binary, cv2.RETR_CCOMP, cv2.CHAIN_APPROX_NONE) cv2.drawContours(img, contours, 0, (0, 0, 255), 5)</code></pre><p>在同样的检索模式下，绘制索引为1的轮廓的关键代码如下：</p><pre><code class="hljs"> cv2.drawContours(img, contours, 1, (0, 0, 255), 5)</code></pre><p>绘制索引为2的轮廓的关键代码如下：</p><pre><code class="hljs"> cv2.drawContours(img, contours, 2, (0, 0, 255), 5)</code></pre><p>绘制索引为3的轮廓的关键代码如下：</p><pre><code class="hljs"> cv2.drawContours(img, contours, 3, (0, 0, 255), 5)</code></pre><p>绘制的效果如图13.4～图13.7所示。</p><p><img src="/2020/06/04/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87/image-20211125200419734.png" alt="image-20211125200419734"></p><p>​                                                                                 图13.4　绘制索引为0的轮廓</p><p><img src="/2020/06/04/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87/image-20211125200519831.png" alt="image-20211125200519831"></p><p>​                                                                          图13.5　绘制索引为1的轮廓</p><p><img src="/2020/06/04/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87/image-20211125200538416.png" alt="image-20211125200538416"></p><p>​                                                                            图13.6　绘制索引为2的轮廓</p><p><img src="/2020/06/04/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87/image-20211125200557884.png" alt="image-20211125200557884"></p><p>​                                                                                   图13.7　绘制索引为3的轮廓</p><p>【实例13.2】　绘制花朵的轮廓。<br>为图13.8（a）所示的花朵图像绘制轮廓，首先要降低图像中的噪声干扰，进行滤波处理，然后将图像处理成二值灰度图像，并检测出轮廓，最后利用绘制轮廓的方法在原始图像中绘制轮廓。<br>具体代码如下：</p><p><img src="/2020/06/04/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87/image-20211125200623625.png" alt="image-20211125200623625"></p><p>上述代码的运行结果如图13.8（b）和图13.8（c）所示。</p><p><img src="/2020/06/04/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87/image-20211125200704091.png" alt="image-20211125200704091"></p><p>​                                                                                  图12.8　绘制花朵轮廓效果</p><h2 id="13-2-轮廓拟合"><a href="#13-2-轮廓拟合" class="headerlink" title="13.2　轮廓拟合"></a>13.2　轮廓拟合</h2><p>拟合是指将平面上的一系列点，用一条光滑的曲线连接起来。轮廓的拟合就是将凹凸不平的轮廓用平整的几何图形体现出来。本节将介绍如何按照轮廓绘制矩形包围框和圆形包围框。</p><h3 id="13-2-1-矩形包围框"><a href="#13-2-1-矩形包围框" class="headerlink" title="13.2.1　矩形包围框"></a>13.2.1　矩形包围框</h3><p>矩形包围框是指图像轮廓的最小矩形边界。OpenCV提供的boundingRect()方法可以自动计算轮廓最小矩形边界的坐标、宽和高。boundingRect()方法的语法如下：</p><pre><code class="hljs"> retval = cv2.boundingRect (array)</code></pre><p>参数说明：　</p><p>array：轮廓数组。</p><p>返回值说明：</p><p>retval：元组类型，包含4个整数值，分别是最小矩形包围框的：左上角顶点的横坐标、左上角顶点的纵坐标、矩形的宽和高。所以也可以写成x, y, w, h = cv2.boundingRect (array)的形式。</p><p>【实例13.3】　为爆炸图形绘制矩形包围框。</p><p><img src="/2020/06/04/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87/image-20211125200758268.png" alt="image-20211125200758268"></p><p>​                                                                                        图13.9　爆炸图形<br>为图13.9所示的爆炸图形绘制矩形包围框，首先判断图形的轮廓，使用cv2.RETR_LIST检索所有轮廓，使用cv2.CHAIN_APPROX_SIMPLE检索图形所有的端点，然后利用cv2.boundingRect()方法计算最小矩形包围框，并通过cv2.rectangle()方法将这个矩形绘制出来，具体代码如下：</p><p><img src="/2020/06/04/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87/image-20211125200901021.png" alt="image-20211125200901021"></p><p>上述代码的运行结果如图13.10所示。</p><p><img src="/2020/06/04/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87/image-20211125200917139.png" alt="image-20211125200917139"></p><p>​                                                                                图13.10　爆炸图形的最小矩形包围框</p><h3 id="13-2-2-圆形包围框"><a href="#13-2-2-圆形包围框" class="headerlink" title="13.2.2　圆形包围框"></a>13.2.2　圆形包围框</h3><p>圆形包围框与矩形包围框一样，是图像轮廓的最小圆形边界。OpenCV提供的minEnclosingCircle ()方法可以自动计算轮廓最小圆形边界的圆心和半径。minEnclosingCircle()方法的语法如下：</p><pre><code class="hljs"> center, radius = cv2.minEnclosingCircle(points)</code></pre><p>参数说明：　</p><p>points：轮廓数组。</p><p>返回值说明：　</p><p>center：元组类型，包含2个浮点值，是最小圆形包围框圆心的横坐标和纵坐标。　</p><p>radius：浮点类型，最小圆形包围框的半径。</p><p>【实例13.4】　为爆炸图形绘制圆形包围框。<br>为图13.9所示的爆炸图形绘制矩形包围框，首先判断图形的轮廓，使用cv2.RETR_LIST检索所有轮廓，使用cv2.CHAIN_APPROX_SIMPLE检索图形所有的端点，然后利用cv2. minEnclosingCircle()方法计算最小圆形包围框，并通过cv2.circle()方法将这个矩形绘制出来。绘制过程中要注意：圆心坐标和圆半径都是浮点数，在绘制之前要将浮点数转换成整数。<br>具体代码如下：</p><p><img src="/2020/06/04/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87/image-20211125201112737.png" alt="image-20211125201112737"></p><p>上述代码的运行结果如图13.11所示。</p><p><img src="/2020/06/04/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87/image-20211125201129231.png" alt="image-20211125201129231"></p><p>​                                                                                图13.11　爆炸图形的最小圆形包围框</p><h2 id="13-3-凸包"><a href="#13-3-凸包" class="headerlink" title="13.3　凸包"></a>13.3　凸包</h2><p>之前介绍了矩形包围框和圆形包围框，这2种包围框虽然已经逼近了图形的边缘，但这种包围框为了保持几何形状，与图形的真实轮廓贴合度较差。如果能找出图形最外层的端点，将这些端点连接起来，就可以围出一个包围图形的最小包围框，这种包围框叫凸包。<br>凸包是最逼近轮廓的多边形，凸包的每一处都是凸出来的，也就是任意3个点组成的内角均小于180°。例如，图13.12就是凸包，而图13.13就不是凸包。</p><p><img src="/2020/06/04/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87/image-20211125205558522.png" alt="image-20211125205558522"></p><p>​                                                                                                    图13.12　凸包</p><p><img src="/2020/06/04/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87/image-20211125205619316.png" alt="image-20211125205619316"></p><p>​                                                                                                  图13.13　不是凸包<br>OpenCV提供的convexHull()方法可以自动找出轮廓的凸包，该方法的语法如下：</p><pre><code class="hljs"> hull = cv2.convexHull(points, clockwise, returnPoints)</code></pre><p>参数说明：　</p><p>points：轮廓数组。　</p><p>clockwise：可选参数，布尔类型。当该值为True时，凸包中的点按顺时针排列，为False时按逆时针排列。　</p><p>returnPoints：可选参数，布尔类型。当该值为True时返回点坐标，为False时返回点索引。默认值为True。</p><p>返回值说明：　</p><p>hull：凸包的点阵数组。<br>下面通过一个例子演示如何绘制凸包。</p><p>【实例13.5】　为爆炸图形绘制凸包。<br>为图13.9所示的爆炸图形绘制凸包，首先要先判断图形的轮廓，使用cv2.RETR_LIST检索出图形的轮廓，然后使用convexHull()方法找到轮廓的凸包，最后通过polylines()方法将凸包中各点连接起来，具体代码如下：</p><p><img src="/2020/06/04/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87/image-20211125205730374.png" alt="image-20211125205730374"></p><p>上述代码的运行结果如图13.14所示。</p><p><img src="/2020/06/04/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87/image-20211125205746309.png" alt="image-20211125205746309"></p><p>​                                                                                          图13.14　爆炸图形的凸包</p><h2 id="13-4-Canny边缘检测"><a href="#13-4-Canny边缘检测" class="headerlink" title="13.4　Canny边缘检测"></a>13.4　Canny边缘检测</h2><p>Canny边缘检测算法是John F. Canny于1986年开发的一个多级边缘检测算法，该算法根据像素的梯度变化寻找图像边缘，最终可以绘制十分精细的二值边缘图像。<br>OpenCV将Canny边缘检测算法封装在Canny()方法中，该方法的语法如下：</p><pre><code class="hljs"> edges = cv2.Canny(image, threshold1, threshold2, apertureSize, L2gradient)</code></pre><p>参数说明：　</p><p>image：检测的原始图像。　</p><p>threshold1：计算过程中使用的第一个阈值，可以是最小阈值，也可以是最大阈值，通常用来设置最小阈值。　</p><p>threshold2：计算过程中使用的第二个阈值，通常用来设置最大阈值。　</p><p>apertureSize：可选参数，Sobel算子的孔径大小。　</p><p>L2gradient：可选参数，计算图像梯度的标识，默认值为False。值为True时采用更精准的算法进行计算。</p><p>返回值说明：　</p><p>edges：计算后得出的边缘图像，是一个二值灰度图像。</p><p>在开发过程中可以通过调整最小阈值和最大阈值控制边缘检测的精细程度。当2个阈值都较小时，检测出较多的细节；当2个阈值都较大时，忽略较多的细节。</p><p>【实例13.6】　使用Canny算法检测花朵边缘。<br>利用Canny()方法检测图13.15（a）所示的花朵图像，分别使用10和50、100和200、400和600作为最低阈值和最高阈值检测3次，具体代码如下：</p><p><img src="/2020/06/04/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87/image-20211125205855069.png" alt="image-20211125205855069"></p><p>上述代码的运行结果如图13.15所示，阈值越小，检测出的边缘越多；阈值越大，检测出的边缘越少，只能检测出一些较明显的边缘。</p><p><img src="/2020/06/04/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87/image-20211125205918990.png" alt="image-20211125205918990"></p><p>​                                                                                   图13.15　图像Canny检测效果</p><h2 id="13-5-霍夫变换"><a href="#13-5-霍夫变换" class="headerlink" title="13.5　霍夫变换"></a>13.5　霍夫变换</h2><p>霍夫变换是一种特征检测，通过算法识别图像的特征，从而判断图像中的特殊形状，例如直线和圆。本节将介绍如何检测图像中的直线和圆。</p><h3 id="13-5-1-直线检测"><a href="#13-5-1-直线检测" class="headerlink" title="13.5.1　直线检测"></a>13.5.1　直线检测</h3><p>霍夫直线变换是通过霍夫坐标系的直线与笛卡儿坐标系的点之间的映射关系来判断图像中的点是否构成直线。OpenCV将此算法封装成两个方法，分别是cv2.HoughLines()和cv2.HoughLinesP()，前者用于检测无限延长的直线，后者用于检测线段。本节仅介绍比较常用的HoughLinesP()方法。<br>HoughLinesP()方法名称最后有一个大写的P，该方法只能检测二值灰度图像，也就是只有两种像素值的黑白图像。该方法最后把找出的所有线段的两个端点坐标保存成一个数组。<br>HoughLinesP()方法的语法如下：</p><pre><code class="hljs"> lines = cv2.HoughLinesP(image, rho, theta, threshold, minLineLength, maxLineGap)</code></pre><p>参数说明：　</p><p>image：检测的原始图像。　</p><p>rho：检测直线使用的半径步长，值为1时，表示检测所有可能的半径步长。　</p><p>theta：搜索直线的角度，值为π/180°时，表示检测所有角度。　</p><p>threshold：阈值，该值越小，检测出的直线就越多。　</p><p>minLineLength：线段的最小长度，小于该长度的线段不记录到结果中。　</p><p>maxLineGap：线段之间的最小距离。</p><p>返回值说明：</p><p>lines：一个数组，元素为所有检测出的线段，每条线段是一个数组，代表线段两个端点的横、纵坐标，格式为[[[x1, y1, x2, y2], [x1, y1, x2, y2]]]。注意<br>使用该方法前应该为原始图像进行降噪处理，否则会影响检测结果。</p><p>【实例13.7】　检测笔图像中出现的直线。</p><p>检测如图13.16所示的中性笔照片，先将图像降噪，再对图像进行边缘检测，然后利用HoughLinesP()方法找出边缘图像中的直线线段，最后用cv2.line()方法将找出的线段绘制成红色。</p><p><img src="/2020/06/04/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87/image-20211125210047560.png" alt="image-20211125210047560"></p><p>​                                                                                                图13.16　笔图像<br>具体代码如下：</p><p><img src="/2020/06/04/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87/image-20211126130401949.png" alt="image-20211126130401949"></p><p>上述代码的运行结果如图13.17和图13.18所示。</p><p><img src="/2020/06/04/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87/image-20211126130420890.png" alt="image-20211126130420890"></p><p>​                                                                                   图13.17　笔图像的边缘检测结果</p><p><img src="/2020/06/04/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87/image-20211126130515954.png" alt="image-20211126130515954"></p><p>​                                                                         图13.18　将笔图像中检测出的线段描红</p><h3 id="13-5-2-圆环检测"><a href="#13-5-2-圆环检测" class="headerlink" title="13.5.2　圆环检测"></a>13.5.2　圆环检测</h3><p>霍夫圆环变换的原理与霍夫直线变换类似。OpenCV提供的HoughCircles()方法用于检测图像中的圆环，该方法在检测过程中进行两轮筛选：第一轮筛选找出可能是圆的圆心坐标，第二轮筛选计算这些圆心坐标可能对应的半径长度。该方法最后将圆心坐标和半径封装成一个浮点型数组。<br>HoughCircles()方法的语法如下：</p><pre><code class="hljs"> circles = cv2.HoughCircles(image, method, dp, minDist, param1, param2, minRadius, maxRadius)</code></pre><p>参数说明：　</p><p>image：检测的原始图像。　</p><p>method：检测方法，OpenCV 4.0.0及以前版本仅提供了cv2.HOUGH_GRADIENT作为唯一可用方法。　</p><p>dp：累加器分辨率与原始图像分辨率之比的倒数。值为1时，累加器与原始图像具有相同的分辨率；值为2时，累加器的分辨率为原始图像的1/2。通常使用1作为参数。　</p><p>minDist：圆心之间的最小距离。　</p><p>param1：可选参数，Canny边缘检测使用的最大阈值。　</p><p>param2：可选参数，检测圆环结果的投票数。第一轮筛选时投票数超过该值的圆环才会进入第二轮筛选。值越大，检测出的圆环越少，但越精准。　</p><p>minRadius：可选参数，圆环的最小半径。　</p><p>maxRadius：可选参数，圆环的最大半径。</p><p>返回值说明：　</p><p>circles：一个数组，元素为所有检测出的圆环，每个圆环也是一个数组，内容为圆心的横、纵坐标和半径长度，格式为：[[[x1 ,y1, r1], [x2 ,y2, r2]]]。</p><p>注意<br>使用该方法前应该为原始图像进行降噪处理，否则会影响检测结果。</p><p>【实例13.8】　检测硬币图像中出现的圆环。<br>检测如图13.19所示的硬币照片，先将图像降噪，再将图像变成单通道灰度图像，然后利用HoughCircles()方法检测图像中可能是圆环的位置，最后通过cv2.circle()方法在这些位置上绘制圆环和对应的圆心。在绘制圆环之前，要将HoughCircles()方法返回的浮点数组元素转换成整数。</p><p><img src="/2020/06/04/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87/image-20211126130634358.png" alt="image-20211126130634358"></p><p>​                                                                                                       图13.19　硬币图像<br>具体代码如下：</p><p><img src="/2020/06/04/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87/image-20211126130715358.png" alt="image-20211126130715358"></p><p>上述代码的运行结果如图13.20所示。</p><p><img src="/2020/06/04/shujufenxi/pythonOpencv%E8%BF%9B%E9%98%B6%E7%AF%87/image-20211126130658457.png" alt="image-20211126130658457"></p><p>​                                                                                                   图13.20　检测出的圆环位置</p><h2 id="13-6-小结"><a href="#13-6-小结" class="headerlink" title="13.6　小结"></a>13.6　小结</h2><p>图像轮廓指的是将图像的边缘连接起来形成的一个整体，它是图像的一个重要的特征信息，通过对图像的轮廓进行操作，能够得到这幅图像的大小、位置和方向等信息，用于后续的计算。为此，OpenCV提供了findContours()方法，通过计算图像的梯度，判断图像的轮廓。为了绘制图像的轮廓，OpenCV又提供了drawContours()方法。但需要注意的是，Canny()方法虽然能够检测出图像的边缘，但这个边缘是不连续的。</p>]]></content>
    
    
    <categories>
      
      <category>数据分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>openCv</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pythonOpencv基础篇线段</title>
    <link href="/2020/06/01/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87%E7%BA%BF%E6%AE%B5/"/>
    <url>/2020/06/01/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87%E7%BA%BF%E6%AE%B5/</url>
    
    <content type="html"><![CDATA[<h1 id="PythonOpenCV基础篇"><a href="#PythonOpenCV基础篇" class="headerlink" title="PythonOpenCV基础篇"></a>PythonOpenCV基础篇</h1><h1 id="第6章-绘制图形和文字"><a href="#第6章-绘制图形和文字" class="headerlink" title="第6章　绘制图形和文字"></a>第6章　绘制图形和文字</h1><p>OpenCV提供了许多绘制图形的方法，包括绘制线段的line()方法、绘制矩形的rectangle()方法、绘制圆形的circle()方法、绘制多边形的polylines()方法和绘制文字的putText()方法。本章将依次对上述各个方法进行讲解，并使用上述方法绘制相应的图形。</p><p><img src="/2020/06/01/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87%E7%BA%BF%E6%AE%B5/image-20211118141415260.png" alt="image-20211118141415260"></p><h2 id="6-1-线段的绘制"><a href="#6-1-线段的绘制" class="headerlink" title="6.1　线段的绘制"></a>6.1　线段的绘制</h2><p>OpenCV提供了用于绘制线段的line()方法，使用这个方法即可绘制长短不一、粗细各异、五颜六色的线段。line()方法的语法格式如下：</p><pre><code class="hljs"> img = cv2.line(img, pt1, pt2, color, thickness)</code></pre><p>参数说明：　</p><p>img：画布。　</p><p>pt1：线段的起点坐标。　</p><p>pt2：线段的终点坐标。　</p><p>color：绘制线段时的线条颜色。　</p><p>thickness：绘制线段时的线条宽度。</p><p>注意<br>线条颜色是RGB格式的，例如红色的RGB值是(255, 0, 0)。但是在OpenCV中，RGB图像的通道顺序被转换成B→G→R，因此(0, 0, 255)代表的是红色。</p><p>【实例6.1】　绘制线段并拼成一个“王”字。<br>编写一个程序，使用line()方法分别绘制颜色为蓝色、绿色、红色和黄色，线条宽度为5、10、15和20的4条线段，并且这4条线段能够拼成一个“王”字如图6.1所示，把其主体部分放在图6.2所示的坐标系中，即可确定每条线段的起点坐标和终点坐标，代码如下：</p><pre><code class="hljs"> import numpy as np # 导入Python中的numpy模块 import cv2 # np.zeros()：创建了一个画布 # (300, 300, 3)：一个300 x 300，具有3个颜色空间（即Red、Green和Blue）的画布 # np.uint8：OpenCV 中的灰度图像和RGB图像都是以uint8存储的，因此这里的类型也是uint8 canvas = np.zeros((300, 300, 3), np.uint8) # 在画布上，绘制一条起点坐标为(50, 50)、终点坐标为(250, 50)、蓝色的、线条宽度为5的线段 canvas = cv2.line(canvas, (50, 50), (250, 50), (255, 0, 0), 5) # 在画布上，绘制一条起点坐标为(50, 150)、终点坐标为(250, 150)、绿色的、线条宽度为10的线段 canvas = cv2.line(canvas, (50, 150), (250, 150), (0, 255, 0), 10) # 在画布上，绘制一条起点坐标为(50, 250)、终点坐标为(250, 250)、红色的、线条宽度为15的线段 canvas = cv2.line(canvas, (50, 250), (250, 250), (0, 0, 255), 15) # 在画布上，绘制一条起点坐标为(150, 50)、终点坐标为(150, 250)、黄色的、线条宽度为20的线段 canvas = cv2.line(canvas, (150, 50), (150, 250), (0, 255, 255), 20) cv2.imshow(&quot;Lines&quot;, canvas) # 显示画布 cv2.waitKey() cv2.destroyAllWindows()</code></pre><p><img src="/2020/06/01/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87%E7%BA%BF%E6%AE%B5/image-20211118142121651.png" alt="image-20211118142121651"></p><p>​                                                                                          图6.1　绘制线段并拼成一个“王”字</p><p><img src="/2020/06/01/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87%E7%BA%BF%E6%AE%B5/image-20211118142054962.png" alt="image-20211118142054962"></p><p>​                                                                                图6.2　每条线段的起点坐标和终点坐标</p><p>此外，如果想把图6.1中的黑色背景替换为白色背景，应该如何操作呢？</p><p>这时，只需将实例6.1的第7行代码替换成如下代码即可：</p><pre><code class="hljs"> canvas = np.ones((300, 300, 3), np.uint8) * 255</code></pre><p>运行修改后的代码，得到如图6.3所示的结果。</p><p><img src="/2020/06/01/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87%E7%BA%BF%E6%AE%B5/image-20211118142429945.png" alt="image-20211118142429945"></p><p>​                                                                             图6.3　把图6.1中的黑色背景替换为白色背景</p><h2 id="6-2-矩形的绘制"><a href="#6-2-矩形的绘制" class="headerlink" title="6.2　矩形的绘制"></a>6.2　矩形的绘制</h2><p>OpenCV提供了用于绘制矩形的rectangle()方法，使用这个方法既可以绘制矩形边框，也可以绘制实心矩形。rectangle()方法的语法格式如下：</p><pre><code class="hljs"> img = cv2.rectangle(img, pt1, pt2, color, thickness)</code></pre><p>参数说明：　</p><p>img：画布。</p><p>pt1：矩形的左上角坐标。　</p><p>pt2：矩形的右下角坐标。　</p><p>color：绘制矩形时的线条颜色。　</p><p>thickness：绘制矩形时的线条宽度。</p><p>【实例6.2】　绘制一个矩形边框。<br>编写一个程序，使用rectangle()方法绘制一个青色的、线条宽度为20的矩形边框。绘制矩形时，矩形的左上角坐标为(50, 50)，矩形的右下角坐标为(200, 150)，代码如下：</p><pre><code class="hljs"> import numpy as np # 导入Python中的numpy模块 import cv2 # np.zeros()：创建了一个画布 # (300, 300, 3)：一个300 x 300，具有3个颜色空间（即Red、Green和Blue）的画布 # np.uint8：OpenCV中的灰度图像和RGB图像都是以uint8存储的，因此这里的类型也是uint8 canvas = np.zeros((300, 300, 3), np.uint8) # 在画布上绘制一个左上角坐标为(50,50)、右下角坐标为(200,150)、青色的、线条宽度为20的矩形边框 canvas = cv2.rectangle(canvas, (50, 50), (200, 150), (255, 255, 0), 20) cv2.imshow(&quot;Rectangle&quot;, canvas) # 显示画布 cv2.waitKey() cv2.destroyAllWindows()</code></pre><p>上述代码的运行结果如图6.4所示</p><p>说明<br>可参照图6.2所示的坐标系，了解矩形的左上角坐标和矩形的右下角坐标是如何确定的。<br>如果想要填充图6.4中的矩形边框，使之变成实心矩形，应该如何修改上述代码呢？<br>在rectangle()方法的语法格式中，thickness表示绘制矩</p><p>形时的线条宽度。当thickness的值为-1时，即可绘制一个实心矩形。也就是说，只需要把实例6.2的第9行代码中的最后一个参数20修改为-1，就能够绘制一个实心矩形，关键代码如下：</p><pre><code class="hljs"> canvas = cv2.rectangle(canvas, (50, 50), (200, 150), (255, 255, 0), -1) # 绘制一个实心矩形</code></pre><p>运行修改后的代码，得到如图6.5所示的结果。</p><p><img src="/2020/06/01/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87%E7%BA%BF%E6%AE%B5/image-20211118142643073.png" alt="image-20211118142643073"></p><p>​                                                                             图6.4　绘制一个矩形边框</p><p><img src="/2020/06/01/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87%E7%BA%BF%E6%AE%B5/image-20211118142722661.png" alt="image-20211118142722661"></p><p>​                                                                                      图6.5　绘制一个实心矩形</p><p>正方形是特殊的矩形，因此使用rectangle()方法不仅能绘制矩形，还能绘制正方形。</p><p>【实例6.3】　绘制正方形。<br>编写一个程序，使用rectangle()方法分别绘制3个正方形边框和1个实心正方形，具体要求如下。<br>（1）左上角坐标为(50, 50)、右下角坐标为(250, 250)、红色的、线条宽度为40的正方形边框。<br>（2）左上角坐标为(90, 90)、右下角坐标为(210, 210)、绿色的、线条宽度为30的正方形边框。<br>（3）左上角坐标为(120, 120)、右下角坐标为(180, 180)、蓝色的、线条宽度为20的正方形边框。</p><p>（4）左上角坐标为(140, 140)、右下角坐标为(160, 160)、黄色的实心正方形。<br>代码如下：</p><pre><code class="hljs"> import numpy as np # 导入Python中的numpy模块 import cv2 # np.zeros()：创建了一个画布 # (300, 300, 3)：一个300 x 300，具有3个颜色空间（即Red、Green和Blue）的画布 # np.uint8：OpenCV中的灰度图像和RGB图像都是以uint8存储的，因此这里的类型也是uint8 canvas = np.zeros((300, 300, 3), np.uint8) # 绘制一个左上角坐标为(50,50)、右下角坐标为(250,250)、红色的、线条宽度为40的正方形边框 canvas = cv2.rectangle(canvas, (50, 50), (250, 250), (0, 0, 255), 40) # 绘制一个左上角坐标为(90,90)、右下角坐标为(210,210)、绿色的、线条宽度为30的正方形边框 canvas = cv2.rectangle(canvas, (90, 90), (210, 210), (0, 255, 0), 30) # 绘制一个左上角坐标为(120,120)、右下角坐标为(180,180)、蓝色的、线条宽度为20的正方形边框 canvas = cv2.rectangle(canvas, (120, 120), (180, 180), (255, 0, 0), 20) # 绘制一个左上角坐标为(140,140)、右下角坐标为(160,160)、黄色的实心正方形 canvas = cv2.rectangle(canvas, (140, 140), (160, 160), (0, 255, 255), -1) cv2.imshow(&quot;Square&quot;, canvas) # 显示画布 cv2.waitKey() cv2.destroyAllWindows()</code></pre><p>上述代码的运行结果如图6.6所示。</p><p><img src="/2020/06/01/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87%E7%BA%BF%E6%AE%B5/image-20211118143019442.png" alt="image-20211118143019442"></p><p>​                                                                                      图6.6　绘制正方形</p><h2 id="6-3-圆形的绘制"><a href="#6-3-圆形的绘制" class="headerlink" title="6.3　圆形的绘制"></a>6.3　圆形的绘制</h2><p>OpenCV提供了用于绘制圆形的circle()方法，这个方法与rectangle()方法的功能相同，既可以绘制圆形边框，也可以绘制实心圆形。circle()方法的语法格式如下：</p><pre><code class="hljs"> img = cv2.circle(img, center, radius, color, thickness)</code></pre><p>参数说明：　img：画布。　center：圆形的圆心坐标。　radius：圆形的半径。　color：绘制圆形时的线条颜色。　thickness：绘制圆形时的线条宽度。【实例6.4】　绘制“交通灯”。（实例位置：资源包\TM\sl\6\04）<br>编写一个程序，使用circle()方法分别绘制红色的、黄色的和绿色的3个实心圆形，用于模拟交通灯。这3个实心圆形的半径均为40，并且呈水平方向放置，代码如下：</p><pre><code class="hljs"> import numpy as np # 导入Python中的numpy模块 import cv2 # np.zeros()：创建了一个画布 # (100, 300, 3)：一个100 x 300，具有3个颜色空间（即Red、Green和Blue）的画布 # np.uint8：OpenCV中的灰度图像和RGB图像都是以uint8存储的，因此这里的类型也是uint8 canvas = np.zeros((100, 300, 3), np.uint8)</code></pre><p>在画布上，绘制一个圆心坐标为(50, 50)、半径为40、红色的实心圆形</p><pre><code class="hljs"> canvas = cv2.circle(canvas, (50, 50), 40, (0, 0, 255), -1) # 在画布上，绘制一个圆心坐标为(150, 50)、半径为40、黄色的实心圆形 canvas = cv2.circle(canvas, (150, 50), 40, (0, 255, 255), -1) # 在画布上，绘制一个圆心坐标为(250, 50)、半径为40、绿色的实心圆形 canvas = cv2.circle(canvas, (250, 50), 40, (0, 255, 0), -1) cv2.imshow(&quot;TrafficLights&quot;, canvas) # 显示画布 cv2.waitKey() cv2.destroyAllWindows()</code></pre><p>上述代码的运行结果如图6.7所示。</p><p><img src="/2020/06/01/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87%E7%BA%BF%E6%AE%B5/image-20211118143049435.png" alt="image-20211118143049435"></p><p>​                                                                                                   图6.7　绘制“交通灯”<br>绘制圆形和绘制线段或者矩形一样容易，但是绘制圆形要比绘制线段或者矩形多一些趣味。例如，绘制同心圆、绘制随机圆等。</p><p>【实例6.5】　绘制同心圆。（实例位置：资源包\TM\sl\6\05）<br>编写一个程序，使用circle()方法和for循环绘制5个同心圆，这些圆形的圆心坐标均为画布的中心，半径的值分别为0，30，60，90和120，线条颜色均为绿色，线条宽度均为5，代码如下：</p><pre><code class="hljs"> import numpy as np # 导入Python中的numpy模块 import cv2 # np.zeros()：创建了一个画布 # (300, 300, 3)：一个300 x 300，具有3个颜色空间（即Red、Green和Blue）的画布 # np.uint8：OpenCV中的灰度图像和RGB图像都是以u #uint8存储的，因此这里的类型也是uint8 canvas = np.zeros((300, 300, 3), np.uint8)#shape[1]表示画布的宽度，center_X表示圆心的横坐标#圆心的横坐标等于画布的宽度的一半center_X = int(canvas.shape[1] / 2)#shape[0]表示画布的高度，center_X表示圆心的纵坐标#圆心的纵坐标等于画布的高度的一半center_Y = int(canvas.shape[0] / 2)#r表示半径；其中，r的值分别为0，30，60，90和120for r in range(0, 150, 30):#绘制一个圆心坐标为(center_X, center_Y)、半径为r、绿色的、线条宽度为5的圆形    cv2.circle(canvas, (center_X, center_Y), r, (0, 255, 0), 5)cv2.imshow(&quot;Circles&quot;, canvas) # 显示画布cv2.waitKey()cv2.destroyAllWindows()</code></pre><p>上述代码的运行结果如图6.8所示。</p><p><img src="/2020/06/01/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87%E7%BA%BF%E6%AE%B5/image-20211118143455707.png" alt="image-20211118143455707"></p><p>​                                                                                                   图6.8　绘制同心圆</p><p>【实例6.6】　绘制27个随机实心圆。（实例位置：资源包\TM\sl\6\06）<br>编写一个程序，使用circle()方法和for循环随机绘制27个实心圆。其中，圆心的横、纵坐标在[0, 299]内取值，半径在[11, 70]内取值，线条颜色由3个在[0, 255]内的随机数组成的列表表示，代码如下：</p><pre><code class="hljs"> import numpy as np # 导入Python中的numpy模块 import cv2 # np.zeros()：创建了一个画布 # (300, 300, 3)：一个300 x 300，具有3个颜色空间（即Red、Green和Blue）的画布 # np.uint8：OpenCV中的灰度图像和RGB图像都是以uint8存储的，因此这里的类型也是uint8 canvas = np.zeros((300, 300, 3), np.uint8) # 通过循环绘制27个实心圆 for numbers in range(0, 28):     # 获得随机的圆心横坐标，这个横坐标在[0, 299]范围内取值     center_X = np.random.randint(0, high = 300)     # 获得随机的圆心纵坐标，这个纵坐标在[0, 299]范围内取值     center_Y = np.random.randint(0, high = 300)     # 获得随机的半径，这个半径在[11, 70]范围内取值     radius = np.random.randint(11, high = 71)     # 获得随机的线条颜色，这个颜色由3个在[0, 255]范围内的随机数组成的列表表示     color = np.random.randint(0, high = 256, size = (3,)).tolist()     # 绘制一个圆心坐标为(center_X, center_Y)、半径为radius、颜色为color的实心圆形     cv2.circle(canvas, (center_X, center_Y), radius, color, -1) cv2.imshow(&quot;Circles&quot;, canvas) # 显示画布 cv2.waitKey() cv2.destroyAllWindows()</code></pre><p>上述代码的运行结果如图6.9所示。</p><p><img src="/2020/06/01/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87%E7%BA%BF%E6%AE%B5/image-20211118143627408.png" alt="image-20211118143627408"></p><pre><code class="hljs">                                                                              图6.9　绘制27个随机实心圆注意</code></pre><p>因为OpenCV中的颜色值是一个列表（例如(0, 0, 255))等），所以color=np.random.randint(0, high =256, size=(3,)).tolist()中的.tolist()不能忽略，否则运行程序时会发生错误。</p><h2 id="6-4-多边形的绘制"><a href="#6-4-多边形的绘制" class="headerlink" title="6.4　多边形的绘制"></a>6.4　多边形的绘制</h2><p>OpenCV提供了绘制多边形的polylines()方法，使用这个方法绘制的多边形既可以是闭合的，也可以是不闭合的。polylines()方法的语法格式如下：</p><pre><code class="hljs"> img = cv2.polylines(img, pts, isClosed, color, thickness)</code></pre><p>参数说明：　</p><p>img：画布。　</p><p>pts：由多边形各个顶点的坐标组成的一个列表，这个列表是一个numpy的数组类型。　</p><p>isClosed：如果值为True，表示一个闭合的多边形；如果值为False，表示一个不闭合的多边形。　</p><p>color：绘制多边形时的线条颜色。　</p><p>thickness：绘制多边形时的线条宽度。</p><p>【实例6.7】　绘制一个等腰梯形边框。<br>编写一个程序，按顺时针给出等腰梯形4个顶点的坐标，即(100, 50)，(200, 50)，(250, 250)和(50, 250)。在画布上根据4个顶点的坐标，绘制一个闭合的、红色的、线条宽度为5的等腰梯形边框，代码如下：</p><pre><code class="hljs"> import numpy as np # 导入Python中的numpy模块 import cv2 # np.zeros()：创建了一个画布 # (300, 300, 3)：一个300 x 300，具有3个颜色空间（即Red、Green和Blue）的画布 # np.uint8：OpenCV中的灰度图像和RGB图像都是以uint8存储的，因此这里的类型也是uint8 canvas = np.zeros((300, 300, 3), np.uint8) # 按顺时针给出等腰梯形4个顶点的坐标 # 这4个顶点的坐标构成了一个大小等于“顶点个数 * 1 * 2”的数组 # 这个数组的数据类型为np.int32 pts = np.array([[100, 50], [200, 50], [250, 250], [50, 250]], np.int32) # 在画布上根据4个顶点的坐标，绘制一个闭合的、红色的、线条宽度为5的等腰梯形边框 canvas = cv2.polylines(canvas, [pts], True, (0, 0, 255), 5) cv2.imshow(&quot;Polylines&quot;, canvas) # 显示画布 cv2.waitKey() cv2.destroyAllWindows()</code></pre><p>上述代码的运行结果如图6.10所示。注意<br>在绘制一个等腰梯形边框时，需按顺时针（即(100, 50)，(200, 50)，(250, 250)和(50, 250)）或者逆时针（即(100, 50)，(50, 250)，(250, 250)和(200, 50)）给出等腰梯形4个顶点的坐标，否则无法绘制一个等腰梯形边框。<br>例如，把实例6.7的第11行代码做如下修改：</p><pre><code class="hljs"> pts = np.array([[100, 50], [200, 50], [50, 250], [250, 250]], np.int32)</code></pre><p>运行修改后的代码，得到如图6.11所示的结果。</p><p><img src="/2020/06/01/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87%E7%BA%BF%E6%AE%B5/image-20211118183008718.png" alt="image-20211118183008718"></p><p>​                                                                                 图6.10　绘制一个等腰梯形边框</p><p><img src="/2020/06/01/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87%E7%BA%BF%E6%AE%B5/image-20211118183106168.png" alt="image-20211118183106168"></p><p>​                                                          图6.11　不按顺时针或逆时针给出等腰梯形4个顶点的坐标的运行结果<br>再如，把实例6.7的第13行代码中的True修改为False，那么将绘制出一个不闭合的等腰梯形边框，代码如下：</p><pre><code class="hljs"> canvas = cv2.polylines(canvas, [pts], False, (0, 0, 255), 5) # 绘制一个不闭合的等腰梯形边框</code></pre><p>运行修改后的代码，得到如图6.12所示的结果。</p><p><img src="/2020/06/01/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87%E7%BA%BF%E6%AE%B5/image-20211118183128142.png" alt="image-20211118183128142"></p><p>​                                                                                      图6.12　绘制一个不闭合的等腰梯形边框</p><h2 id="6-5-文字的绘制"><a href="#6-5-文字的绘制" class="headerlink" title="6.5　文字的绘制"></a>6.5　文字的绘制</h2><p>OpenCV提供了用于绘制文字的putText()方法，使用这个方法不仅能够设置字体的样式、大小和颜色，而且能够使字体呈现斜体的效果，还能够控制文字的方向，进而使文字呈现垂直镜像的效果。putText()方法的语法格式如下：</p><pre><code class="hljs"> img = cv2.putText(img, text, org, fontFace, fontScale, color, thickness, lineType, bottomLeftOrigin)</code></pre><p>参数说明：　</p><p>img：画布。　</p><p>text：要绘制的文字内容。　</p><p>org：文字在画布中的左下角坐标。　</p><p>fontFace：字体样式，可选参数如表6.1所示。</p><p>​                                                                                        表6.1　字体样式及其含义</p><p><img src="/2020/06/01/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87%E7%BA%BF%E6%AE%B5/image-20211118190722929.png" alt="image-20211118190722929"></p><p>fontScale：字体大小。　</p><p>color：绘制文字时的线条颜色。　</p><p>thickness：绘制文字时的线条宽度。　</p><p>lineType：线型。（线型指的是线的产生算法，有4和8两个值，默认值为8）　</p><p>bottomLeftOrigin：绘制文字时的方向。（有True和False两个值，默认值为False）</p><p>说明<br>使用putText()方法时，thickness、lineType和bottomLeftOrigin是可选参数，有无均可。</p><p>【实例6.8】　绘制文字“mrsoft”。（实例位置：资源包\TM\sl\6\08）<br>编写一个程序，在画布上绘制文字“mrsoft”。其中，文字左下角的坐标为(20, 70)，字体样式为FONT_HERSHEY_TRIPLEX，字体大小为2，线条颜色是绿色，线条宽度为5，代码如下：</p><pre><code class="hljs"> import numpy as np # 导入Python中的numpy模块 import cv2 # np.zeros()：创建了一个画布 # (100, 300, 3)：一个100 x 300，具有3个颜色空间（即Red、Green和Blue）的画布 # np.uint8：OpenCV中的灰度图像和RGB图像都是以uint8存储的，因此这里的类型也是uint8 canvas = np.zeros((100, 300, 3), np.uint8) # 在画布上绘制文字“mrsoft”，文字左下角的坐标为(20, 70) #字体样式为FONT_HERSHEY_TRIPLEX#字体大小为2，线条颜色是绿色，线条宽度为5cv2.putText(canvas, &quot;mrsoft&quot;, (20, 70), cv2.FONT_HERSHEY_TRIPLEX, 2, (0, 255, 0), 5)cv2.imshow(&quot;Text&quot;, canvas) # 显示画布cv2.waitKey()cv2.destroyAllWindows()</code></pre><p>上述代码的运行结果如图6.13所示。说明<br>不借助其他库或者模块，使用putText()方法绘制中文时，即把实例6.8的第11行代码中的mrsoft修改为“您好”，代码如下：</p><pre><code class="hljs"> cv2.putText(canvas, &quot;您好&quot;, (20, 70), cv2.FONT_HERSHEY_TRIPLEX, 2, (0, 255, 0), 5)</code></pre><p>运行上述代码会出现如图6.14所示的乱码。</p><p>如果把实例6.8的第11行代码中的字体样式由“cv2.FONT_HERSHEY_TRIPLEX”修改为“cv2.FONT_HERSHEY_DUPLEX”，那么将改变图6.13中的字体样式，关键代码如下：</p><pre><code class="hljs"> cv2.putText(canvas, &quot;mrsoft&quot;, (20, 70), cv2.FONT_HERSHEY_DUPLEX, 2, (0, 255, 0), 5)</code></pre><p>运行修改后的代码，得到如图6.15所示的效果（图6.15（a）是FONT_HERSHEY_TRIPLEX呈现的效果）。</p><p><img src="/2020/06/01/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87%E7%BA%BF%E6%AE%B5/image-20211118191113526.png" alt="image-20211118191113526"></p><p>​                                                                                    图6.15　字体样式变化效果<br>根据上述修改方法，读者朋友可以把实例6.8的第11行代码中的字体样式依次修改为表6.1中的各个字体样式，这样就能够查看每一个字体样式所呈现的效果。</p><h3 id="6-5-1-文字的斜体效果"><a href="#6-5-1-文字的斜体效果" class="headerlink" title="6.5.1　文字的斜体效果"></a>6.5.1　文字的斜体效果</h3><p>FONT_ITALIC可以与其他文字类型一起使用，使字体在呈现指定字体样式效果的同时，也呈现斜体效果。</p><p>【实例6.9】　绘制指定字体样式的文字并呈现斜体效果。（实例位置：资源包\TM\sl\6\09）<br>编写一个程序，在图6.13呈现的文字效果的基础上，使字体呈现斜体效果，代码如下：</p><pre><code class="hljs"> import numpy as np # 导入Python中的numpy模块 import cv2 # np.zeros()：创建了一个画布 # (100, 300, 3)：一个100 x 300，具有3个颜色空间（即Red、Green和Blue）的画布 # np.uint8：OpenCV中的灰度图像和RGB图像都是以uint8存储的，因此这里的类型也是uint8 canvas = np.zeros((100, 300, 3), np.uint8) # 字体样式为FONT_HERSHEY_TRIPLEX和FONT_ITALIC fontStyle = cv2.FONT_HERSHEY_TRIPLEX + cv2.FONT_ITALIC # 在画布上绘制文字“mrsoft”，文字左下角的坐标为(20, 70) # 字体样式为fontStyle，字体大小为2，线条颜色是绿色，线条宽度为5 cv2.putText(canvas, &quot;mrsoft&quot;, (20, 70), fontStyle, 2, (0, 255, 0), 5) cv2.imshow(&quot;Text&quot;, canvas) # 显示画布 cv2.waitKey() cv2.destroyAllWindows()</code></pre><p>上述代码的运行效果如图6.16所示（图6.16（a）是原图像，即图6.13）。</p><p><img src="/2020/06/01/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87%E7%BA%BF%E6%AE%B5/image-20211118191251684.png" alt="image-20211118191251684"></p><p>​                                                                                              图6.16　文字的斜体效果</p><h3 id="6-5-2-文字的垂直镜像效果"><a href="#6-5-2-文字的垂直镜像效果" class="headerlink" title="6.5.2　文字的垂直镜像效果"></a>6.5.2　文字的垂直镜像效果</h3><p>在putText()方法的语法格式中，有一个控制绘制文字时的方向的参数，即bottomLeftOrigin，其默认值为False。当bottomLeftOrigin为True时，文字将呈现垂直镜像效果。</p><p>【实例6.10】　绘制呈现垂直镜像效果的“mrsoft”。（实例位置：资源包\TM\sl\6\10）<br>编写一个程序，首先在画布上绘制文字“mrsoft”。其中，文字左下角的坐标为(20, 70)，字体样式为FONT_HERSHEY_TRIPLEX，字体大小为2，线条颜色是绿色，线条宽度为5。然后在该画布上绘制相同的字体样式、字体大小、线条颜色和线条宽度，而且呈现垂直镜像效果的“mrsoft”，代码如下：</p><pre><code class="hljs"> import numpy as np # 导入Python中的numpy模块 import cv2 # np.zeros()：创建了一个画布 # (200, 300, 3)：一个200 x 300，具有3个颜色空间（即Red、Green和Blue）的画布 # np.uint8：OpenCV中的灰度图像和RGB图像都是以uint8存储的，因此这里的类型也是uint8 canvas = np.zeros((200, 300, 3), np.uint8) # 字体样式为FONT_HERSHEY_TRIPLEX fontStyle = cv2.FONT_HERSHEY_TRIPLEX # 在画布上绘制文字“mrsoft”，文字左下角的坐标为(20, 70) # 字体样式为fontStyle，字体大小为2，线条颜色是绿色，线条宽度为5 cv2.putText(canvas, &quot;mrsoft&quot;, (20, 70), fontStyle, 2, (0, 255, 0), 5) # 使文字“mrsoft”呈现垂直镜像效果，这时lineType和bottomLeftOrigin变成了必须参数 # 其中，lineType取默认值8，bottomLeftOrigin的值为True cv2.putText(canvas, &quot;mrsoft&quot;, (20, 100), fontStyle, 2, (0, 255, 0), 5, 8, True) cv2.imshow(&quot;Text&quot;, canvas) # 显示画布 cv2.waitKey() cv2.destroyAllWindows()</code></pre><p>上述代码的运行效果如图6.17所示。</p><p><img src="/2020/06/01/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87%E7%BA%BF%E6%AE%B5/image-20211118191411682.png" alt="image-20211118191411682"></p><p>​                                                                             图6.17　绘制呈现垂直镜像效果的“mrsoft”</p><h3 id="6-5-3-在图像上绘制文字"><a href="#6-5-3-在图像上绘制文字" class="headerlink" title="6.5.3　在图像上绘制文字"></a>6.5.3　在图像上绘制文字</h3><p>OpenCV除了可以在np.zeros()创建的画布上绘制文字外，还能够在图像上绘制文字。区别是当在图像上绘制文字时，不再需要导入Python中的numpy模块。</p><p>【实例6.11】　在图像上绘制文字。（实例位置：资源包\TM\sl\6\11）<br>编写一个程序，在D盘根目录下的2.1.jpg上绘制文字“Flower”。其中，文字左下角的坐标为(20, 90)，字体样式为FONT_HERSHEY_TRIPLEX，字体大小为1，线条颜色是黄色，代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs HTML">import cv2<br>image = cv2.imread(<span class="hljs-symbol">&amp;quot;</span>D:/2.1.jpg<span class="hljs-symbol">&amp;quot;</span>) # 读取D盘根目录下的2.1.jpg<br>#字体样式为FONT_HERSHEY_TRIPLEX<br>fontStyle = cv2.FONT_HERSHEY_TRIPLEX<br># 在image上绘制文字“mrsoft”，文字左下角的坐标为(20, 90)，<br># 字体样式为fontStyle，字体大小为1，线条颜色是黄色<br>cv2.putText(image, <span class="hljs-symbol">&amp;quot;</span>Flower<span class="hljs-symbol">&amp;quot;</span>, (20, 90), fontStyle, 1, (0, 255, 255))<br>cv2.imshow(<span class="hljs-symbol">&amp;quot;</span>Text<span class="hljs-symbol">&amp;quot;</span>, image) # 显示画布<br>cv2.waitKey()<br>cv2.destroyAllWindows()<br><br></code></pre></td></tr></table></figure><p>上述代码的运行结果如图6.18所示。</p><p>说明<br>借助Python中的PIL(Python Imaging Library)模块，OpenCV能够在图像上输出中文，需要做的是对图像进行OpenCV格式和PIL格式的相互转换。这部分内容较为复杂，本书不做介绍，读者可以自学相关内容。</p><p><img src="/2020/06/01/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87%E7%BA%BF%E6%AE%B5/image-20211118191653484.png" alt="image-20211118191653484"></p><p>​                                                                                       图6.18　在图像上绘制文字</p><h2 id="6-6-动态绘制图形"><a href="#6-6-动态绘制图形" class="headerlink" title="6.6　动态绘制图形"></a>6.6　动态绘制图形</h2><p>前面主要讲解的是如何在画布上绘制静态的图形，如线段、矩形、正方形、圆形、多边形和文字等。那么，能不能让这些静态的图形动起来呢？如果能，又该怎么做呢？</p><p>【实例6.12】　弹球动画。（实例位置：资源包\TM\sl\6\12）</p><p>在一个宽、高都为200像素的纯白色图像中，绘制一个半径为20像素的纯蓝色小球。让小球做匀速直线运动，一旦圆形碰触到图像边界则开始反弹（反弹不损失动能）。想要实现这个功能需要解决两个问题：如何计算运动轨迹和如何实现动画。下面分别介绍这两个问题的解决思路。1．通过图像坐标系计算运动轨迹<br>小球在运动的过程中可以把移动速度划分为上、下、左、右4个方向。左右为横坐标移动速度，上下为纵坐标移动速度。小球向右移动时横坐标不断变大，向左移动时横坐标不断变小，由此可以认为：小球向右的移动速度为正，向左的移动速度为负。纵坐标同理，因为图像坐标系的原点为背景左上角顶点，越往下延伸纵坐标越大，所以小球向上的移动速度为负，向下的移动速度为正。4个方向的速度如图6.19所示。<br>假设小球移动一段时间后，移动的轨迹如图6.20所示，小球分别达到了4个位置，2号位置和3号位置发生了反弹，也就是移动速度发生变化，导致移动方向发生变化。整个过程中，4个位置的速度分别如下：<br>❶：右下方向移动，横坐标向右，横坐标速度为+vx，纵坐标向下，纵坐标速度为+vy。<br>❷：右上方向移动，横坐标向右，横坐标速度为+vx，纵坐标向上，纵坐标速度为-vy。<br>❸：左上方向2移动，横坐标向左，横坐标速度为-vx，纵坐标向上，纵坐标速度为-vy。<br>❹：左上方移动，没有碰到边界，依然保持着与3号位置相同移动速度。<br>由此可以得出，只需要改变速度的正负号小球就可以改变移动方向，所以在程序中可以将小球的横坐标速度和纵坐标速度设定成一个不变的值，每次小球碰到左右边界，就更改横坐标速度的正负号，碰到上下边界，就更改纵坐标速度的正负号。</p><p><img src="/2020/06/01/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87%E7%BA%BF%E6%AE%B5/image-20211118191737740.png" alt="image-20211118191737740"></p><p>​                                                                               图6.19　小球在4个方向的速度</p><p><img src="/2020/06/01/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87%E7%BA%BF%E6%AE%B5/image-20211118191824935.png" alt="image-20211118191824935"></p><p>​                                                                                     图6.20　小球的移动轨迹</p><p>2．通过time模块实现动画效果</p><p>Python自带一个time时间模块，该模块提供了一个sleep()方法可以让当前线程休眠一段时间，其语法格式如下：</p><pre><code class="hljs"> time.sleep(seconds)</code></pre><p>参数说明：　</p><p>seconds：休眠时间，单位为s，可以是小数，如1/10表示（1/10）s。<br>例如，让当前线程休眠1s，代码如下：</p><pre><code class="hljs"> import time time.sleep(1)  # 休眠1s</code></pre><p>动画实际上是由多幅画面在短时间内交替放映实现的视觉效果。每一幅画面被称为一帧，所谓的60帧就是指1s放映了60幅画面。使用time模块每（1/60）s计算一次小球的移动轨迹，并将移动后的结果绘制到图像上，这样1s有60幅图像交替放映，就可以看到弹球的动画效果了。<br>弹球动画的具体代码如下：</p><p><img src="/2020/06/01/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87%E7%BA%BF%E6%AE%B5/image-20211118191858592.png" alt="image-20211118191858592"></p><p>运行结果如图6.21所示。</p><p><img src="/2020/06/01/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87%E7%BA%BF%E6%AE%B5/image-20211118191931672.png" alt="image-20211118191931672"></p><p>​                                                                                                  图6.21　小球运动轨迹</p><h2 id="6-7-小结"><a href="#6-7-小结" class="headerlink" title="6.7　小结"></a>6.7　小结</h2><p>不论是绘制图形，还是绘制文字，都需要创建画布，这个画布可以是一幅图像。需要确定线条的颜色时，要特别注意颜色的表示方式，即(B, G, R)。当绘制矩形、圆形和多边形时，通过设置线条宽度，既可以绘制图形的边框，又可以绘制被填充的图形。但是，在绘制多边形的过程中，要按照顺时针或者逆时针的方向，标记多边形各个顶点的坐标。此外，OpenCV提供的用于绘制图形的方法，不仅可以绘制静态的图形，还可以绘制动态的图形。</p><h1 id="第7章-图像的几何变换"><a href="#第7章-图像的几何变换" class="headerlink" title="第7章　图像的几何变换"></a>第7章　图像的几何变换</h1><p>几何变换是指改变图像的几何结构，例如大小、角度和形状等，让图像呈现出缩放、翻转、映射和透视效果。这些几何变换操作都涉及复杂、精密的计算，OpenCV将这些计算过程封装成非常灵活的方法，开发者只需修改一些参数，就能实现图像的变换效果。本章将介绍几种常见的几何变换效果及其实现方法。</p><h2 id="7-1-缩放"><a href="#7-1-缩放" class="headerlink" title="7.1　缩放"></a>7.1　缩放</h2><p>“缩”表示缩小，“放”表示放大，通过OpenCV提供的resize()方法可以随意更改图像的大小比例，其语法如下：</p><pre><code class="hljs"> dst = cv2.resize(src, dsize, fx, fy, interpolation)</code></pre><p>参数说明：　</p><p>src：原始图像。　</p><p>dsize：输出图像的大小，格式为（宽，高），单位为像素。　</p><p>fx：可选参数。水平方向的缩放比例。　</p><p>fy：可选参数。垂直方向的缩放比例。　</p><p>interpolation：可选参数。缩放的插值方式。在图像缩小或放大时需要删减或补充像素，该参数可以指定使用哪种算法对像素进行增减。建议使用默认值。<br>返回值说明：　</p><p>dst：缩值之后的图像。</p><p>resize()方法有两种使用方式，一种是通过dsize参数实现缩放，另一种是通过fx和fy参数实现缩放，下面分别介绍。</p><h3 id="7-1-1-dsize参数实现缩放"><a href="#7-1-1-dsize参数实现缩放" class="headerlink" title="7.1.1　dsize参数实现缩放"></a>7.1.1　dsize参数实现缩放</h3><p>dsize参数的格式是一个元组，例如(100, 200)，表示将图像按照宽100像素、高200像素的大小进行缩放。如果使用dsize参数，就可以不写fx和fy参数。</p><p>【实例7.1】　将图像按照指定宽高进行缩放。（实例位置：资源包\TM\sl\7\01）<br>将一个图像按照宽100像素、高100像素的大小进行缩小，再按照宽400像素、高400像素的大小进行放大，代码如下：<br>上述代码的运行结果如图7.1所示。</p><p><img src="/2020/06/01/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87%E7%BA%BF%E6%AE%B5/image-20211118192105062.png" alt="image-20211118192105062"></p><p>​                                                                                  图7.1　dsize参数缩放图像效果</p><h3 id="7-1-2-fx和fy参数实现缩放"><a href="#7-1-2-fx和fy参数实现缩放" class="headerlink" title="7.1.2　fx和fy参数实现缩放"></a>7.1.2　fx和fy参数实现缩放</h3><p>使用fx参数和fy参数控制缩放时，dsize参数值必须使用None，否则fx和fy失效。<br>fx参数和fy参数可以使用浮点值，小于1的值表示缩小，大于1的值表示放大。其计算公式为：</p><pre><code class="hljs"> 新图像宽度 = round(fx × 原图像宽度) 新图像高度 = round(fy × 原图像高度)</code></pre><p>【实例7.2】　将图像按照指定比例进行缩放</p><p>将一个图像宽缩小到原来的1/3、高缩小到原来的1/2，再将图像宽放大2倍，高也放大2倍，代码如下：</p><p><img src="/2020/06/01/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87%E7%BA%BF%E6%AE%B5/image-20211118192221463.png" alt="image-20211118192221463"></p><p>上述代码的运行结果如图7.2所示。</p><p><img src="/2020/06/01/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87%E7%BA%BF%E6%AE%B5/image-20211118192248191.png" alt="image-20211118192248191"></p><p>​                                                                                      图7.2　fx和fy参数缩放图像效果</p><h2 id="7-2-翻转"><a href="#7-2-翻转" class="headerlink" title="7.2　翻转"></a>7.2　翻转</h2><p>水平方向被称为X轴，垂直方向被称为Y轴。图像沿着X轴或Y轴翻转之后，可以呈现出镜面或倒影的效果，如图7.3和图7.4所示。</p><p><img src="/2020/06/01/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87%E7%BA%BF%E6%AE%B5/image-20211118192311942.png" alt="image-20211118192311942"></p><p>​                                                                                              图7.3　沿X轴翻转的效果</p><p><img src="/2020/06/01/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87%E7%BA%BF%E6%AE%B5/image-20211118192332597.png" alt="image-20211118192332597"></p><p>​                                                                                                图7.4　沿Y轴翻转的效果<br>OpenCV通过cv2.flip()方法实现翻转效果，其语法如下：</p><pre><code class="hljs"> dst = cv2.flip(src, flipCode)</code></pre><p>参数说明：　</p><p>src：原始图像。</p><p>flipCode：翻转类型，类型值及含义如表7.1所示。<br>返回值说明：　</p><p>dst：翻转之后的图像。</p><p>​                                                                                               表7.1　flipCode类型值及含义</p><p><img src="/2020/06/01/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87%E7%BA%BF%E6%AE%B5/image-20211118192448155.png" alt="image-20211118192448155"></p><p>【实例7.3】　同时实现3种翻转效果。<br>分别让图像沿X轴翻转，沿Y轴翻转，同时沿X轴、Y轴翻转，查看翻转的效果，代码如下：</p><p><img src="/2020/06/01/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87%E7%BA%BF%E6%AE%B5/image-20211118192557425.png" alt="image-20211118192557425"></p><p>上述代码的运行结果如图7.5所示。</p><p><img src="/2020/06/01/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87%E7%BA%BF%E6%AE%B5/image-20211118192614947.png" alt="image-20211118192614947"></p><p>​                                                                                           图7.5　图像实现3种翻转效果</p><h2 id="7-3-仿射变换"><a href="#7-3-仿射变换" class="headerlink" title="7.3　仿射变换"></a>7.3　仿射变换</h2><p>仿射变换是一种仅在二维平面中发生的几何变形，变换之后的图像仍然可以保持直线的“平直性”和“平行性”，也就是说原来的直线变换之后还是直线，平行线变换之后还是平行线。常见的仿射变换效果如图7.6所示，包含平移、旋转和倾斜。</p><p><img src="/2020/06/01/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87%E7%BA%BF%E6%AE%B5/image-20211118192719998.png" alt="image-20211118192719998"></p><p>​                                                                                         图7.6　3种常见的仿射变换效果<br>OpenCV通过cv2. warpAffine()方法实现仿射变换效果，其语法如下：</p><pre><code class="hljs"> dst = cv2.warpAffine(src, M, dsize, flags, borderMode, borderValue)</code></pre><p>参数说明：　</p><p>src：原始图像。　</p><p>M：一个2行3列的矩阵，根据此矩阵的值变换原图中的像素位置。　</p><p>dsize：输出图像的尺寸大小。　</p><p>flags：可选参数，插值方式，建议使用默认值。　</p><p>borderMode：可选参数，边界类型，建议使用默认值。　</p><p>borderValue：可选参数，边界值，默认为0，建议使用默认值。</p><p>返回值说明：　</p><p>dst：经过反射变换后输出图像。M也被叫作仿射矩阵，实际上就是一个2×3的列表，其格式如下：</p><pre><code class="hljs"> M = [[a, b, c],[d, e, f]]</code></pre><p>图像做何种仿射变换，完全取决于M的值，仿射变换输出的图像按照以下公式进行计算：</p><pre><code class="hljs"> 新x = 原x × a + 原y × b + c</code></pre><p>新y = 原x × d + 原y × e + f<br>原x和原y表示原始图像中像素的横坐标和纵坐标，新x与新y表示同一个像素经过仿射变换后在新图像中的横坐标和纵坐标。M矩阵中的数字采用32位浮点格式，可以采用两种方式创建M。<br>（1）创建一个全是0的M，代码如下：</p><pre><code class="hljs"> import numpy as np M = np.zeros((2, 3), np.float32)</code></pre><p>（2）创建M的同时赋予具体值，代码如下：</p><pre><code class="hljs"> import numpy as np M = np.float32([[1, 2, 3], [4, 5, 6]])</code></pre><p>通过设定M的值就可以实现多种仿射效果，下面分别介绍如何实现图像的平移、旋转和倾斜。</p><h3 id="7-3-1-平移"><a href="#7-3-1-平移" class="headerlink" title="7.3.1　平移"></a>7.3.1　平移</h3><p>平移就是让图像中的所有像素同时沿着水平或垂直方向移动。实现这种效果只需要将M的值按照以下格式进行设置：</p><pre><code class="hljs"> M = [[1, 0, 水平移动的距离],[0, 1, 垂直移动的距离]]</code></pre><p>原始图像的像素就会按照以下公式进行变换：</p><pre><code class="hljs"> 新x = 原x × 1 + 原y × 0 + 水平移动的距离 = 原x + 水平移动的距离 新y = 原x × 0 + 原y × 1 + 垂直移动的距离 = 原y + 垂直移动的距离</code></pre><p>若水平移动的距离为正数，图像向右移动，若为负数，图像向左移动；若垂直移动的距离为正数，图像向下移动，若为负数，图像向上移动；若水平移动的距离和垂直移动的距离的值为0，图像不发生移动。</p><p>【实例7.4】　让图像向右下方平移。（实例位置：资源包\TM\sl\7\04）<br>例如，将图像向右移动50像素、向下移动100像素，代码如下：</p><p><img src="/2020/06/01/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87%E7%BA%BF%E6%AE%B5/image-20211118192856809.png" alt="image-20211118192856809"></p><p>上述代码的运行结果如图7.7 示。</p><p><img src="/2020/06/01/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87%E7%BA%BF%E6%AE%B5/image-20211118192839832.png" alt="image-20211118192839832"></p><p>​                                                                  图7.7　图像向右下方平移效果<br>通过修改M的值可以实现其他平移效果。例如，横坐标不变，纵坐标向上移动50像素，M的值如下：</p><pre><code class="hljs"> M = np.float32([[1, 0, 0],  # 横坐标不变              [0, 1, -50]])  # 纵坐标向上移动50像素</code></pre><p>移动效果如图7.8所示。<br>纵坐标不变，横坐标向左移动200像素，M的值如下：</p><pre><code class="hljs"> M = np.float32([[1, 0, -200],  # 横坐标向左移动200像素               [0, 1, 0]])      # 纵坐标不变</code></pre><p>移动效果如图7.9所示。</p><p><img src="/2020/06/01/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87%E7%BA%BF%E6%AE%B5/image-20211118192940668.png" alt="image-20211118192940668"></p><p>​                                                            图7.8　横坐标不变、纵坐标向上移动50像素的效果</p><p><img src="/2020/06/01/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87%E7%BA%BF%E6%AE%B5/image-20211118193002091.png" alt="image-20211118193002091"></p><p>​                                                     图7.9　纵坐标不变、横坐标向左移动200像素的效果</p><h3 id="7-3-2-旋转"><a href="#7-3-2-旋转" class="headerlink" title="7.3.2　旋转"></a>7.3.2　旋转</h3><p>让图像旋转也是通过M矩阵实现的，但得出这个矩阵需要做很复杂的运算，于是OpenCV提供了getRotationMatrix2D()方法自动计算旋转图像的M矩阵。getRotationMatrix2D()方法的语法如下：</p><pre><code class="hljs">  M = cv2.getRotationMatrix2D(center, angle, scale)</code></pre><p>参数说明：　</p><p>center：旋转的中心点坐标。　</p><p>angle：旋转的角度（不是弧度）。正数表示逆时针旋转，负数表示顺时针旋转。　</p><p>scale：缩放比例，浮点类型。如果取值1，表示图像保持原来的比例。</p><p>返回值说明：　</p><p>M：getRotationMatrix2D()方法计算出的仿射矩阵。</p><p>【实例7.5】　让图像逆时针旋转。<br>让图像逆时针旋转30°的同时缩小到原来的80%，代码如下：</p><p><img src="/2020/06/01/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87%E7%BA%BF%E6%AE%B5/image-20211118193039585.png" alt="s"></p><p>上述代码的运行效果如图7.10所示。</p><p><img src="/2020/06/01/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87%E7%BA%BF%E6%AE%B5/image-20211118193113385.png" alt="image-20211118193113385"></p><p>​                                                                                           7.10　图像逆时针旋转效果</p><h3 id="7-3-3-倾斜"><a href="#7-3-3-倾斜" class="headerlink" title="7.3.3　倾斜"></a>7.3.3　倾斜</h3><p>OpenCV需要定位图像的3个点来计算倾斜效果，3个点的位置如图7.11所示，这3个点分别是“左上角”点A、“右上角”点B和“左下角”点C。OpenCV会根据这3个点的位置变化来计算其他像素的位置变化。因为要保证图像的“平直性”和“平行性”，所以不需要“右下角”的点做第4个参数，右下角这个点的位置根据A、B、C 3点的变化自动计算得出。</p><p><img src="/2020/06/01/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87%E7%BA%BF%E6%AE%B5/image-20211118193145154.png" alt="image-20211118193145154"></p><p>​                                                                  图7.11　通过3个点定位图像的仿射变换效果说明</p><p>“平直性”是指图像中的直线在经过仿射变换之后仍然是直线。“平行性”是指图像中的平行线在经过仿射变换之后仍然是平行线。<br>让图像倾斜也是需要通过M矩阵实现的，但得出这个矩阵需要做很复杂的运算，于是OpenCV提供了getAffineTransform()方法来自动计算倾斜图像的M矩阵。getRotationMatrix2D()方法的语法如下：</p><pre><code class="hljs"> M = cv2.getAffineTransform(src, dst)</code></pre><p>参数说明：　</p><p>src：原图3个点坐标，格式为3行2列的32位浮点数列表，例如：[[0, 1], [1, 0], [1, 1]]。　</p><p>dst：倾斜图像的3个点坐标，格式与src一样。</p><p>返回值说明：　</p><p>M：getAffineTransform()方法计算出的仿射矩阵。</p><p>【实例7.6】　让图像向右倾斜。<br>让图像向右倾斜，代码如下：</p><p><img src="/2020/06/01/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87%E7%BA%BF%E6%AE%B5/image-20211119061021581.png" alt="image-20211119061021581"></p><p>上述代码的运行结果如图7.12所示</p><p><img src="/2020/06/01/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87%E7%BA%BF%E6%AE%B5/image-20211119061045205.png" alt="image-20211119061045205"></p><p>​                                                                                            图7.12　图像向右倾斜效果<br>如果让图像向左倾斜，不能只通过移动点A来实现，还需要通过移动点B和点C来实现，3个点的修改方式如下：</p><p><img src="/2020/06/01/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87%E7%BA%BF%E6%AE%B5/image-20211119061108326.png" alt="image-20211119061108326"></p><p>使用这两组数据计算出的M矩阵可以实现如图7.13所示的向左倾斜效果。</p><p><img src="/2020/06/01/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87%E7%BA%BF%E6%AE%B5/image-20211119061130763.png" alt="image-20211119061130763"></p><p>​                                                                                                               图7.13　向左倾斜效果</p><h2 id="7-4-透视"><a href="#7-4-透视" class="headerlink" title="7.4　透视"></a>7.4　透视</h2><p>如果说仿射是让图像在二维平面中变形，那么透视就是让图像在三维空间中变形。从不同的角度观察物体，会看到不同的变形画面，例如，矩形会变成不规则的四边形，直角会变成锐角或钝角，圆形会变成椭圆，等等。这种变形之后的画面就是透视图。</p><p><img src="/2020/06/01/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87%E7%BA%BF%E6%AE%B5/image-20211119061322272.png" alt="image-20211119061322272"></p><p>​                                                                        图7.14　从图像的底部观察图像</p><p>如图7.14所示从图像的底部观察图7.15（a），眼睛距离图像底部较近，所以图像底部宽度不变，但眼睛距离图像顶部较远，图像顶部宽度就会等比缩小，于是观察者就会看到如图7.15（b）所示的透视效果。</p><p><img src="/2020/06/01/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87%E7%BA%BF%E6%AE%B5/image-20211119061347353.png" alt="image-20211119061347353"></p><p>​                                                                                    图7.15　人眼观察图像透视效果<br>OpenCV中需要通过定位图像的4个点计算透视效果，4个点的位置如图7.16所示。OpenCV根据这4个点的位置变化来计算其他像素的位置变化。透视效果不能保证图像的“平直性”和“平行性”。<br>OpenCV通过warpPerspective()方法来实现透视效果，其语法如下：</p><pre><code class="hljs"> dst = cv2.warpPerspective(src, M, dsize, flags, borderMode, borderValue)</code></pre><p><img src="/2020/06/01/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87%E7%BA%BF%E6%AE%B5/image-20211119061419756.png" alt="image-20211119061419756"></p><p>​                                                                                 图7.16　通过4个点定位图像的透视效果<br>参数说明：　</p><p>src：原始图像。　</p><p>M：一个3行3列的矩阵，根据此矩阵的值变换原图中的像素位置。　</p><p>dsize：输出图像的尺寸大小。　</p><p>flags：可选参数，插值方式，建议使用默认值。　</p><p>borderMode：可选参数，边界类型，建议使用默认值。</p><p>borderValue：可选参数，边界值，默认为0，建议使用默认值。<br>返回值说明：　</p><p>dst：经过透视变换后输出图像。<br>warpPerspective()方法也需要通过M矩阵计算透视效果，但得出这个矩阵需要做很复杂的运算，于是OpenCV提供了getPerspectiveTransform()方法自动计算M矩阵。getPerspectiveTransform()方法的语法如下：</p><pre><code class="hljs"> M = cv2.getPerspectiveTransform(src, dst,)</code></pre><p>参数说明：　</p><p>src：原图4个点坐标，格式为4行2列的32位浮点数列表，例如：[[0, 0], [1, 0], [0, 1],[1, 1]]。　</p><p>dst：透视图的4个点坐标，格式与src一样。<br>返回值说明：　</p><p>M：getPerspectiveTransform()方法计算出的仿射矩阵。</p><p>【实例7.7】　模拟从底部观察图像得到的透视效果。<br>模拟从底部观察图像得到的透视效果，将图像顶部边缘收窄，底部边缘保持不变，代码如下：</p><p><img src="/2020/06/01/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87%E7%BA%BF%E6%AE%B5/image-20211119061533770.png" alt="image-20211119061533770"></p><p>上述代码的运行结果如图7.17所示。</p><p><img src="/2020/06/01/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87%E7%BA%BF%E6%AE%B5/image-20211119061620244.png" alt="image-20211119061620244"></p><p>​                                                                                              图7.17　图像透视效果</p><h2 id="7-5-小结"><a href="#7-5-小结" class="headerlink" title="7.5　小结"></a>7.5　小结</h2><p>图像的缩放有2种方式：一种是设置dsize参数，另一种是设置fx参数和fy参数。图像的翻转有3种方式，沿X轴翻转、沿Y轴翻转和同时沿X轴、Y轴翻转，这3种方式均由flipCode参数的值决定。图像的仿射变换取决于仿射矩阵，采用不同的仿射矩阵（M），就会使图像呈现不同的仿射效果。此外，图像的透视仍然要依靠M矩阵实现。因此，只要熟练掌握并灵活运用M矩阵，就能够得心应手地对图像进行几何变换操作。</p><h1 id="第8章-图像的阈值处理"><a href="#第8章-图像的阈值处理" class="headerlink" title="第8章　图像的阈值处理"></a>第8章　图像的阈值处理</h1><p>阈值是图像处理中一个很重要的概念，类似一个“像素值的标准线”。所有像素值都与这条“标准线”进行比较，最后得到3种结果：像素值比阈值大、像素值比阈值小或像素值等于阈值。程序根据这些结果将所有像素进行分组，然后对某一组像素进行“加深”或“变淡”操作，使得整个图像的轮廓更加鲜明，更容易被计算机或肉眼识别。</p><p><img src="/2020/06/01/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87%E7%BA%BF%E6%AE%B5/image-20211119061719129.png" alt="image-20211119061719129"></p><h2 id="8-1-阈值处理函数"><a href="#8-1-阈值处理函数" class="headerlink" title="8.1　阈值处理函数"></a>8.1　阈值处理函数</h2><p>在图像处理的过程中，阈值的使用使得图像的像素值更单一，进而使得图像的效果更简单。首先，把一幅彩色图像转换为灰度图像，这样图像的像素值的取值范围即可简化为0~255。然后，通过阈值使得转换后的灰度图像呈现出只有纯黑色和纯白色的视觉效果。例如，当阈值为127时，把小于127的所有像素值都转换为0（即纯黑色），把大于127的所有像素值都转换为255（即纯白色）。虽然会丢失一些灰度细节，但是会更明显地保留灰度图像主体的轮廓。<br>OpenCV提供的threshold()方法用于对图像进行阈值处理，threshold()方法的语法如下：</p><pre><code class="hljs"> retval, dst = cv2.threshold(src, thresh, maxval, type)</code></pre><p>参数说明：　</p><p>src：被处理的图像，可以是多通道图像。　</p><p>thresh：阈值，阈值在125～150取值的效果最好。　</p><p>maxval：阈值处理采用的最大值。　</p><p>type：阈值处理类型。常用类型和含义如表8.1所示。</p><p>​                                                                                                 表8.1　阈值处理类型</p><p><img src="/2020/06/01/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87%E7%BA%BF%E6%AE%B5/image-20211119061937771.png" alt="image-20211119061937771"></p><p>返回值说明：　</p><p>retval：处理时采用的阈值。　</p><p>dst：经过阈值处理后的图像。</p><h2 id="8-2-“非黑即白”的图像"><a href="#8-2-“非黑即白”的图像" class="headerlink" title="8.2　“非黑即白”的图像"></a>8.2　“非黑即白”的图像</h2><p>二值化处理和反二值化处理使得灰度图像的像素值两极分化，灰度图像呈现出只有纯黑色和纯白色的视觉效果。</p><h3 id="8-2-1-二值化处理"><a href="#8-2-1-二值化处理" class="headerlink" title="8.2.1　二值化处理"></a>8.2.1　二值化处理</h3><p>二值化处理也叫二值化阈值处理，该处理让图像仅保留两种像素值，或者说所有像素都只能从两种值中取值。<br>进行二值化处理时，每一个像素值都会与阈值进行比较，<strong>将大于阈值的像素值变为最大值，将小于或等于阈值的像素值变为0</strong>，计算公式如下：</p><pre><code class="hljs"> if 像素值 &lt;= 阈值: 像素值 = 0 if 像素值 &gt; 阈值: 像素值 = 最大值</code></pre><p>通常二值化处理是使用255作为最大值，因为灰度图像中255表示纯白色，能够很清晰地与纯黑色进行区分，所以灰度图像经过二值化处理后呈现“非黑即白”的效果。<br>例如，图8.1是一个由白到黑的渐变图，最左侧的像素值为255（表现为纯白色），右侧的像素值逐渐递减，直到最右侧的像素值为0（表现为纯黑色）。像素值的变化如图8.2所示。</p><p><img src="/2020/06/01/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87%E7%BA%BF%E6%AE%B5/image-20211119062048670.png" alt="image-20211119062048670"></p><p>​                                                                                     图8.1　由白到黑的渐变图像</p><p><img src="/2020/06/01/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87%E7%BA%BF%E6%AE%B5/image-20211119062107944.png" alt="image-20211119062107944"></p><p>​                                                                                   图8.2　渐变图像像素值变化示意图</p><p>【实例8.1】　二值化处理白黑渐变图。<br>将图8.1进行二值化处理，取0~255的中间值127作为阈值，将255作为最大值，代码如下：</p><p><img src="/2020/06/01/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87%E7%BA%BF%E6%AE%B5/image-20211119062149699.png" alt="image-20211119062149699"></p><p>上述代码的运行结果如图8.3和图8.4所示，图像中凡是大于127的像素值都变成了255（纯白色），小于或等于127的像素值都变成了0（纯黑色）。原图从白黑渐变图像变成了白黑拼接图像，可以看到非常清晰的黑白交界。</p><p><img src="/2020/06/01/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87%E7%BA%BF%E6%AE%B5/image-20211119062216440.png" alt="image-20211119062216440"></p><p>​                                                                                         图8.3　原图</p><p><img src="/2020/06/01/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87%E7%BA%BF%E6%AE%B5/image-20211119062238704.png" alt="image-20211119062238704"></p><p>​                                                                            图8.4　二值化处理效果</p><p>【实例8.2】　观察不同阈值的处理效果。<br>通过修改阈值大小可以调整黑白交界的位置。例如，分别采用127和210作为阈值，对比处理结果，代码如下：</p><p><img src="/2020/06/01/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87%E7%BA%BF%E6%AE%B5/image-20211119062337018.png" alt="image-20211119062337018"></p><p>上述代码的运行结果如图8.5所示。因为原图中大部分像素值都大于127，所以阈值为127时，大部分像素都变成了255（纯白色）；但原图中大于210的像素值并不多，所以阈值为210时，大部分像素都变成了0（纯黑色）。</p><p><img src="/2020/06/01/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87%E7%BA%BF%E6%AE%B5/image-20211119062354861.png" alt="image-20211119062354861"></p><p>​                                                                                              图8.5　不同阈值处理效果</p><p>【实例8.3】　观察不同最大值的处理效果。（实例位置：资源包\TM\sl\8\03）<br>像素值的最小值默认为0，但最大值可以由开发者设定。如果最大值不是255（纯白色），那么“非黑”的像素就不一定是纯白色了。例如，灰度值150表现为“灰色”，查看将150作为最大值处理的效果，代码如下：</p><p><img src="/2020/06/01/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87%E7%BA%BF%E6%AE%B5/image-20211119062420756.png" alt="image-20211119062420756"></p><p>上述代码的运行结果如图8.6所示。当最大值设为150时，凡是大于127的像素值都被改为150，呈现灰色。</p><p><img src="/2020/06/01/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87%E7%BA%BF%E6%AE%B5/image-20211119062503592.png" alt="image-20211119062503592"></p><p>​                                                                                         图8.6　不同最大值处理效果<br>彩色图像也可以进行二值化处理，处理之后会将颜色夸张化，对比效果如图8.7和图8.8所示。</p><p><img src="/2020/06/01/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87%E7%BA%BF%E6%AE%B5/image-20211119062737249.png" alt="image-20211119062737249"></p><p>​                                                                                     图8.7　彩色图像原图</p><p><img src="/2020/06/01/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87%E7%BA%BF%E6%AE%B5/image-20211119062804127.png" alt="image-20211119062804127"></p><p>​                                                                                           图8.8　彩色图像进行二值化处理的效果</p><h3 id="8-2-2-反二值化处理"><a href="#8-2-2-反二值化处理" class="headerlink" title="8.2.2　反二值化处理"></a>8.2.2　反二值化处理</h3><p>反二值化处理也叫反二值化阈值处理，其结果为二值化处理的相反结果。<strong>将大于阈值的像素值变为0，将小于或等于阈值的像素值变为最大值</strong>。原图像中白色的部分变成黑色，黑色的部分变成白色。计算公式如下：</p><pre><code class="hljs"> if 像素值 &lt;= 阈值: 像素值 = 最大值 if 像素值 &gt; 阈值: 像素值 = 0</code></pre><p>【实例8.4】　对图像进行反二值化处理。</p><p>分别将图8.1进行二值化处理和反二值化处理，对比处理结果，代码如下：</p><p><img src="/2020/06/01/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87%E7%BA%BF%E6%AE%B5/image-20211119062916394.png" alt="image-20211119062916394"></p><p>上述代码的运行效果如图8.9所示，可以明显地看出二值化处理效果和反二值化处理效果是完全相反的。</p><p><img src="/2020/06/01/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87%E7%BA%BF%E6%AE%B5/image-20211119062935052.png" alt="image-20211119062935052"></p><p>​                                                                                   图8.9　二值化处理和反二值化处理效果<br>彩色图像经过反二值化处理后，因为各通道的颜色分量值不同，会呈现“混乱”的效果，对比效果如图8.10所示。</p><p><img src="/2020/06/01/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87%E7%BA%BF%E6%AE%B5/image-20211119062958289.png" alt="image-20211119062958289"></p><p>​                                                                            图8.10　彩色图像反二值化处理效果</p><h2 id="8-3-零处理"><a href="#8-3-零处理" class="headerlink" title="8.3　零处理"></a>8.3　零处理</h2><p>零处理会将某一个范围内的像素值变为0，并允许范围之外的像素保留原值。零处理包括低于阈值零处理和超出阈值零处理。</p><h3 id="8-3-1-低于阈值零处理"><a href="#8-3-1-低于阈值零处理" class="headerlink" title="8.3.1　低于阈值零处理"></a>8.3.1　低于阈值零处理</h3><p>低于阈值零处理也叫低阈值零处理，该处理将<strong>低于或等于阈值的像素值变为0，大于阈值的像素值保持原值</strong>，计算公式如下：</p><pre><code class="hljs"> if 像素值 &lt;= 阈值: 像素值 = 0</code></pre><p>if 像素值 &gt; 阈值: 像素值 = 原值</p><p>【实例8.5】　对图像进行低于阈值零处理。</p><p>将图8.1进行低于阈值零处理，阈值设为127，代码如下：</p><p><img src="/2020/06/01/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87%E7%BA%BF%E6%AE%B5/image-20211119063054958.png" alt="image-20211119063054958"></p><p>上述代码的运行结果如图8.11所示，像素值低于或等于127的区域彻底变黑，像素值高于127的区域仍然保持渐变效果。</p><p><img src="/2020/06/01/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87%E7%BA%BF%E6%AE%B5/image-20211119063110806.png" alt="image-20211119063110806"></p><p>​                                                                                            图8.11　图像低于阈值零处理效果<br>图像经过低于阈值零处理后，颜色深的位置会彻底变黑，颜色浅的位置不受影响。彩色图像经过低于阈值零处理后，会让深颜色区域的颜色变得更深，甚至变黑，对比效果如图8.12所示。</p><p><img src="/2020/06/01/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87%E7%BA%BF%E6%AE%B5/image-20211119063132937.png" alt="image-20211119063132937"></p><p>​                                                                                   图8.12　彩色图像低于阈值零处理效果</p><h3 id="8-3-2-超出阈值零处理"><a href="#8-3-2-超出阈值零处理" class="headerlink" title="8.3.2　超出阈值零处理"></a>8.3.2　超出阈值零处理</h3><p>超出阈值零处理也叫超阈值零处理，该处理<strong>将大于阈值的像素值变为0，小于或等于阈值的像素值保持原值</strong>。计算公式如下：</p><pre><code class="hljs"> if 像素值 &lt;= 阈值: 像素值 = 原值 if 像素值 &gt; 阈值: 像素值 = 0</code></pre><p>【实例8.6】　对图像进行超出阈值零处理。<br>将图8.1进行超出阈值零处理，阈值设为127，代码如下：</p><p><img src="/2020/06/01/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87%E7%BA%BF%E6%AE%B5/image-20211119063244471.png" alt="image-20211119063244471"></p><p>上述代码的运行结果如图8.13所示，像素值高于127的区域彻底变黑，像素值低于或等于127的区域仍然保持渐变效果。</p><p><img src="/2020/06/01/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87%E7%BA%BF%E6%AE%B5/image-20211119063259837.png" alt="image-20211119063259837"></p><p>​                                                                                              图8.13　图像超出阈值零处理效果<br>图像经过超出阈值零处理后浅颜色区域彻底变黑，深颜色区域则不受影响。但彩色图像经过超出阈值零处理后，浅颜色区域的颜色分量取相反的极值，也呈现出一种“混乱”的效果，对比效果如图8.14所示。</p><p><img src="/2020/06/01/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87%E7%BA%BF%E6%AE%B5/image-20211119063324538.png" alt="image-20211119063324538"></p><p>​                                                                                      图8.14　彩色图像超出阈值零处理效果</p><h2 id="8-4-截断处理"><a href="#8-4-截断处理" class="headerlink" title="8.4　截断处理"></a>8.4　截断处理</h2><p>截断处理也叫截断阈值处理，该处理将图像中<strong>大于阈值的像素值变为和阈值一样的值，小于或等于阈值的像素保持原值</strong>，其公式如下：</p><pre><code class="hljs"> if 像素 &lt;= 阈值: 像素 = 原值 if 像素 &gt; 阈值: 像素 = 阈值</code></pre><p>【实例8.7】　对图像进行截断处理。<br>将图8.1进行截断处理，取127作为阈值，代码如下：</p><p><img src="/2020/06/01/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87%E7%BA%BF%E6%AE%B5/image-20211119063441020.png" alt="image-20211119063441020"></p><p>上述代码的运行结果如图8.15所示，浅颜色区域都变成了灰色，但深颜色区域仍然是渐变效果。</p><p><img src="/2020/06/01/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87%E7%BA%BF%E6%AE%B5/image-20211119063457401.png" alt="image-20211119063457401"></p><p>​                                                                                              图8.15　图像截断处理效果<br>图像经过截断处理后，整体颜色都会变暗。彩色图像经过截断处理后，在降低亮度的同时还会让浅颜色区域的颜色变得更浅，对比效果如图8.16所示。</p><p><img src="/2020/06/01/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87%E7%BA%BF%E6%AE%B5/image-20211119063611119.png" alt="image-20211119063611119"></p><p>​                                                                                         图8.16　彩色图像截断处理效果</p><h2 id="8-5-自适应处理"><a href="#8-5-自适应处理" class="headerlink" title="8.5　自适应处理"></a>8.5　自适应处理</h2><p>前面已经依次对cv2.THRESH_BINARY、cv2.THRESH_BINARY_INV、cv2.THRESH_TOZERO、cv2.THRESH_TOZERO_INV和cv2.THRESH_TRUNC这5种阈值处理类型进行了详解。因为图8.1是一幅色彩均衡的图像，所以直接使用一种阈值处理类型就能够对图像进行阈值处理。很多时候图像的色彩是不均衡的，如果只使用一种阈值处理类型，就无法得到清晰有效的结果。</p><p>【实例8.8】　使用常用的5种阈值处理类型对色彩不均衡的图像</p><p><img src="/2020/06/01/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87%E7%BA%BF%E6%AE%B5/4.27.png" alt="4.27"></p><p>​                                                                                         图8.17　色彩不均衡的图像<br>先将图8.17转换为灰度图像，再依次使用cv2.THRESH_BINARY、cv2.THRESH_BINARY_INV、cv2.THRESH_TOZERO、cv2.THRESH_TOZERO_INV和cv2.THRESH_TRUNC这5种阈值处理类型对转换后的灰度图像进行阈值处理，代码如下：</p><p><img src="/2020/06/01/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87%E7%BA%BF%E6%AE%B5/image-20211119063800302.png" alt="image-20211119063800302"></p><p>上述代码的运行结果如图8.18～图8.22所示。</p><p><img src="/2020/06/01/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87%E7%BA%BF%E6%AE%B5/image-20211119063819692.png" alt="image-20211119063819692"></p><p>​                                                                                              图8.18　二值化处理</p><p><img src="/2020/06/01/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87%E7%BA%BF%E6%AE%B5/image-20211119063905724.png" alt="image-20211119063905724"></p><p>​                                                                                      图8.19　反二值化处理</p><p><img src="/2020/06/01/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87%E7%BA%BF%E6%AE%B5/image-20211119063924931.png" alt="image-20211119063924931"></p><p>​                                                                                          图8.20　低于阈值零处理</p><p><img src="/2020/06/01/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87%E7%BA%BF%E6%AE%B5/image-20211119063944429.png" alt="image-20211119063944429"></p><p>​                                                                                       图8.21　超出阈值零处理</p><p><img src="/2020/06/01/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87%E7%BA%BF%E6%AE%B5/image-20211119064005583.png" alt="image-20211119064005583"></p><p>​                                                                                                         图8.22　截断处理</p><p>从视觉上看，对于色彩不均衡的图像，虽然使用截断处理的效果是5种阈值处理类型中效果比较好的，但是有些轮廓依然模糊不清（例如，图8.22中的手部轮廓），使用程序继续对其进行处理仍然很困难。这时，需要进一步简化图像。<br>OpenCV提供了一种改进的阈值处理技术：图像中的不同区域使用不同的阈值。把这种改进的阈值处理技术称作自适应阈值处理也称自适应处理，自适应阈值是根据图像中某一正方形区域内的所有像素值按照指定的算法计算得到的。与前面讲解的5种阈值处理类型相比，自适应处理能更好地处理明暗分布不均的图像，获得更简单的图像效果。<br>OpenCV提供了adaptiveThresHold()方法对图像进行自适应处理，adaptiveThresHold()方法的语法如下：</p><p>dst = cv2.adaptiveThreshold(src, maxValue, adaptiveMethod, thresholdType, blockSize, C)<br>参数说明：　</p><p>src：被处理的图像。需要注意的是，该图像需是灰度图像。　</p><p>maxValue：阈值处理采用的最大值。　</p><p>adaptiveMethod：自适应阈值的计算方法。自适应阈值的计算方法及其含义如表8.2所示。</p><p>​                                                                                    表8.2　自适应阈值的计算方法及其含义　</p><p><img src="/2020/06/01/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87%E7%BA%BF%E6%AE%B5/image-20211119064121242.png" alt="image-20211119064121242"></p><p>thresholdType：阈值处理类型；需要注意的是，阈值处理类型需是cv2.THRESH_BINARY或cv2.THRESH_BINARY_INV中的一个。　</p><p>blockSize：一个正方形区域的大小。例如，5指的是5×5的区域。　</p><p>C：常量。阈值等于均值或者加权值减去这个常量。</p><p>返回值说明：　</p><p>dst：经过阈值处理后的图像。</p><p>【实例8.9】　使用自适应处理的效果。（实例位置：资源包\TM\sl\8\09）<br>先将图8.17转换为灰度图像，再分别使用cv2.ADAPTIVE_THRESH_MEAN_C和cv2.ADAPTIVE_THRESH_GAUSSIAN_C这两种自适应阈值的计算方法对转换后的灰度图像进行阈值处理，代码如下：</p><p><img src="/2020/06/01/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87%E7%BA%BF%E6%AE%B5/image-20211119064147759.png" alt="image-20211119064147759"></p><p>上述代码的运行结果如图8.23和图8.24所示。</p><p><img src="/2020/06/01/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87%E7%BA%BF%E6%AE%B5/image-20211119064354181.png" alt="image-20211119064354181"></p><p>​                                                          图8.23　ADAPTIVE_THRESH_MEAN_C的处理结果</p><p><img src="/2020/06/01/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87%E7%BA%BF%E6%AE%B5/image-20211119064417014.png" alt="image-20211119064417014"></p><p>​                                                                 图8.24　ADAPTIVE_THRESH_GAUSSIAN_C的处理结果<br>与前面讲解的5种阈值处理类型的处理结果相比，自适应处理保留了图像中更多的细节信息，更明显地保留了灰度图像主体的轮廓。注意<br>使用自适应阈值处理图像时，如果图像是彩色图像，那么需要先将彩色图像转换为灰度图像；否则，运行程序时会出现如图8.25所示的错误提示。</p><p><img src="/2020/06/01/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87%E7%BA%BF%E6%AE%B5/image-20211119064438784.png" alt="image-20211119064438784"></p><p>​                                                                                 图8.25　运行程序时出现的错误</p><h2 id="8-6-Otsu方法"><a href="#8-6-Otsu方法" class="headerlink" title="8.6　Otsu方法"></a>8.6　Otsu方法</h2><p>前面在讲解5种阈值处理类型的过程中，每个实例设置的阈值都是127，这个127是笔者设置的，并不是通过算法计算得到的。对于有些图像，当阈值被设置为127时，得到的效果并不好，这时就需要一个个去尝试，直到找到最合适的阈值。<br>逐个寻找最合适的阈值不仅工作量大，而且效率低。为此，OpenCV提供了Otsu方法。Otsu方法能够遍历所有可能的阈值，从中找到最合适的阈值。<br>Otsu方法的语法与threshold()方法的语法基本一致，只不过在为type传递参数时，要多传递一个参数，即cv2.THRESH_OTSU。cv2.THRESH_OTSU的作用就是实现Otsu方法的阈值处理。Otsu方法的语法如下：</p><p>retval, dst = cv2.threshold(src, thresh, maxval, type)<br>参数说明：　</p><p>src：被处理的图像。需要注意的是，该图像需是灰度图像。　</p><p>thresh：阈值，且要把阈值设置为0。　</p><p>maxval：阈值处理采用的最大值，即255。　</p><p>type：阈值处理类型。除在表8.1中选择一种阈值处理类型外，还要多传递一个参数，即cv2.THRESH_OTSU。例如，cv2.THRESH_BINARY+cv2.THRESH_OTSU。<br>返回值说明：　</p><p>retval：由Otsu方法计算得到并使用的最合适的阈值。</p><p>dst：经过阈值处理后的图像。</p><p>【实例8.10】　在图8.26上实现Otsu方法的阈值处理。（实例位置：资源包\TM\sl\8\10）<br>图8.26是一幅亮度较高的图像，分别对这幅图像进行二值化处理和实现Otsu方法的阈值处理，对比处理后图像的差异，代码如下：</p><p><img src="/2020/06/01/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87%E7%BA%BF%E6%AE%B5/image-20211119064609735.png" alt="image-20211119064609735"></p><p>​                                                                                 </p><p><img src="/2020/06/01/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87%E7%BA%BF%E6%AE%B5/image-20211119064647798.png" alt="image-20211119064647798"></p><p>​                                                                                              图8.26　一幅亮度较高的图像<br>上述代码的运行结果如图8.27和图8.28所示。<br>对比图8.27和图8.28后能够发现，由于图8.26的亮度较高，使用阈值为127进行二值化阈值处理的结果没有很好地保留图像主体的轮廓，并出现了大量的白色区域。但是，通过实现Otsu方法的阈值处理，不仅找到了最合适的阈值（即184），还将图像主体的轮廓很好地保留了下来，获得了比较好的处理结果。</p><p><img src="/2020/06/01/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87%E7%BA%BF%E6%AE%B5/image-20211119064729264.png" alt="image-20211119064729264"></p><p>​                                                                                   图8.27　二值化处理的结果</p><p><img src="/2020/06/01/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87%E7%BA%BF%E6%AE%B5/image-20211119064754376.png" alt="image-20211119064754376"></p><p>​                                                                                          图8.28　实现Otsu方法的阈值处理的结果</p><h2 id="8-7-阈值处理的作用"><a href="#8-7-阈值处理的作用" class="headerlink" title="8.7　阈值处理的作用"></a>8.7　阈值处理的作用</h2><p>阈值处理在计算机视觉技术中占有十分重要的位置，它是很多高级算法的底层处理逻辑之一。因为二值图像会忽略细节，放大特征，而很多高级算法要根据物体的轮廓来分析物体特征，所以二值图像非常适合做复杂的识别运算。在进行识别运算之前，应先将图像转为灰度图像，再进行二值化处理，这样就得到了算法所需要的物体（大致）轮廓图像。<br>下面通过一个实例来演示通过阈值处理获取物体轮廓的方法。</p><p>【实例8.11】　利用阈值处理勾勒楼房和汽车的轮廓。<br>读取一幅图像，先将图像转为灰度图像，再将图像分别进行二值化处理和反二值化处理，具体代码如下：</p><p><img src="/2020/06/01/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87%E7%BA%BF%E6%AE%B5/image-20211119064833488.png" alt="image-20211119064833488"></p><p>上述代码的运行结果如图8.29～图8.32所示。</p><p><img src="/2020/06/01/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87%E7%BA%BF%E6%AE%B5/image-20211119064852964.png" alt="image-20211119064852964"></p><p>​                                                                                                          图8.29　原始图像</p><p><img src="/2020/06/01/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87%E7%BA%BF%E6%AE%B5/image-20211119065010880.png" alt="image-20211119065010880"></p><p>​                                                                                                 图8.30　灰度图像</p><p><img src="/2020/06/01/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87%E7%BA%BF%E6%AE%B5/image-20211119065032490.png" alt="image-20211119065032490"></p><p>​                                                                                           图8.31　二值化处理效果</p><p><img src="/2020/06/01/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87%E7%BA%BF%E6%AE%B5/image-20211119065054225.png" alt="image-20211119065054225"></p><p>​                                                                                             图8.32　反二值化处理效果<br>从后面两幅图像可以看到，二值化处理后，图片只有纯黑和纯白两种颜色，图像中的楼房边缘变得更加鲜明，更容易被识别。地面因为颜色较深，所以大面积被涂黑，这样白色的汽车就与地面形成了鲜明的反差。二值化处理后的汽车轮廓在肉眼看来可能还不够明显，但反二值化处理后的汽车轮廓与地面的反差就非常大。高级图像识别算法可以根据这种鲜明的像素变化来搜寻特征，最后达到识别物体分类的目的。</p><h2 id="8-8-小结"><a href="#8-8-小结" class="headerlink" title="8.8　小结"></a>8.8　小结</h2><p>OpenCV提供了一个可以快速抠出图像主体线条的工具，这个工具就是阈值。在阈值的作用下，一幅彩色图像被转换为只有纯黑和纯白的二值图像。然而，灰度图像经5种阈值处理类型处理后，都无法得到图像主体的线条。为此，OpenCV提供了一种改进的阈值处理技术，即自适应处理，其关键在于对图像中的不同区域使用不同的阈值。有了这种改进的阈值处理技术，得到图像主体的线条就不再是一件难以实现的事情了。</p><h1 id="第9章-图像的运算"><a href="#第9章-图像的运算" class="headerlink" title="第9章　图像的运算"></a>第9章　图像的运算</h1><p>图像是由像素组成的，像素又是由具体的正整数表示的，因此图像也可以进行一系列数学运算，通过运算可以获得截取、合并图像等效果。OpenCV提供了很多图像运算方法，经过运算的图像可以呈现出很多有趣的视觉效果。下面将对OpenCV中一些常用的图像运算方法进行介绍。</p><p><img src="/2020/06/01/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87%E7%BA%BF%E6%AE%B5/image-20211120060956203.png" alt="image-20211120060956203"></p><h2 id="9-1-掩模"><a href="#9-1-掩模" class="headerlink" title="9.1　掩模"></a>9.1　掩模</h2><p>前面的章节出现过“掩模”这个参数，当时建议大家不使用这个参数。掩模到底有什么用呢？这一节将介绍掩模的概念。<br>外科医生在给患者做手术时，会为患者盖上手术洞巾，类似图9.1，这样医生就只在这个预设好的孔洞部位进行手术。手术洞巾不仅有利于医生定位患处、暴露手术视野，还可以对非患处起到隔离、防污的作用。<br>同样，当计算机处理图像时，图像也如同一名“患者”一样，有些内容需要处理，有些内容不需要处理。通常计算机处理图像时会把所有像素都处理一遍，但如果想让计算机像外科大夫那样仅处理某一小块区域，那就要为图像盖上一张仅暴露一小块区域的“手术洞巾”。像“手术洞巾”那样能够覆盖原始图像、仅暴露原始图像“感兴趣区域”（ROI）的模板图像就被叫作掩模。<br>掩模，也叫作掩码，英文为mask，在程序中用二值图像来表示：0值（纯黑）区域表示被遮盖的部分，255值（纯白）区域表示暴露的部分（某些场景下也会用0和1当作掩模的值）。<br>例如，图9.2是一幅小猫的原始图像，图9.3是原始图像的掩模，掩模覆盖原始图像之后，可以得到如图9.4所示的结果。</p><p>0<img src="/2020/06/01/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87%E7%BA%BF%E6%AE%B5/image-20211120061039170.png" alt="image-20211120061039170"></p><p>​                                                                      图9.1　外科手术给患者使用的手术洞巾</p><p><img src="/2020/06/01/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87%E7%BA%BF%E6%AE%B5/image-20211120061106906.png" alt="image-20211120061106906"></p><p>​                                                                                                    图9.2　原始图像</p><p><img src="/2020/06/01/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87%E7%BA%BF%E6%AE%B5/image-20211120061128635.png" alt="image-20211120061128635"></p><p>​                                                                              图9.3　掩模</p><p><img src="/2020/06/01/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87%E7%BA%BF%E6%AE%B5/image-20211120061150893.png" alt="image-20211120061150893"></p><p>​                                                                         图9.4　被掩模覆盖后得到的图像<br>如果调换了掩模中黑白区域，如图9.5所示，掩模覆盖原始图像之后得到的结果如图9.6所示。</p><p><img src="/2020/06/01/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87%E7%BA%BF%E6%AE%B5/image-20211120061213880.png" alt="image-20211120061213880"></p><p>​                                                                         图9.5　调换黑白区域的新掩模</p><p><img src="/2020/06/01/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87%E7%BA%BF%E6%AE%B5/image-20211120061336692.png" alt="image-20211120061336692"></p><p>​                                                                               图9.6　被新掩模覆盖后得到的图像<br>在使用OpenCV处理图像时，通常使用numpy库提供的方法创建掩模图像，下面通过一个实例演示如何创建掩模图像。</p><p>【实例9.1】　创建3通道掩模图像。（实例位置：资源包\TM\sl\9\01）<br>利用numpy库的zeros()方法创建一幅掩模图像，感兴趣区域为在该图像中横坐标为20、纵坐标为50、宽为60、高为50的矩形，展示该掩模图像。调换该掩模图像的感兴趣区域和不感兴趣区域之后，再次展示掩模图像，具体代码如下：</p><p><img src="/2020/06/01/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87%E7%BA%BF%E6%AE%B5/image-20211120061301526.png" alt="image-20211120061301526"></p><p>运行结果如图9.7和图9.8所示。</p><p><img src="/2020/06/01/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87%E7%BA%BF%E6%AE%B5/image-20211120061400048.png" alt="image-20211120061400048"></p><p>​                                                                                     图9.7　掩模图像</p><p><img src="/2020/06/01/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87%E7%BA%BF%E6%AE%B5/image-20211120061420875.png" alt="image-20211120061420875"></p><p>​                                                                                         图9.8　调换之后的掩模图像</p><p>掩模在图像运算过程中充当了重要角色，通过掩模才能看到最直观的运算结果，接下来将详细介绍图像运算的相关内容。</p><h2 id="9-2-图像的加法运算"><a href="#9-2-图像的加法运算" class="headerlink" title="9.2　图像的加法运算"></a>9.2　图像的加法运算</h2><p>图像中每一个像素都有用整数表示的像素值，2幅图像相加就是让相同位置像素值相加，最后将计算结果按照原位置重新组成一幅新图像。原理如图9.9所示。</p><p><img src="/2020/06/01/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87%E7%BA%BF%E6%AE%B5/image-20211120061517289.png" alt="image-20211120061517289"></p><p>​                                                                                               图9.9　图像相加生成新像素<br>图9.9中2幅图像的左上角像素值相加的结果就是新图像左上角的像素值，计算过程如下：</p><pre><code class="hljs"> 152 + 35 = 187</code></pre><p>在开发程序时通常不会使用“+”运算符对图像做加法运算，而是用OpenCV提供的add()方法，该方法的语法如下：</p><pre><code class="hljs"> dst = cv2.add(src1, src2, mask, dtype)</code></pre><p>参数说明：　</p><p>src1：第一幅图像。　</p><p>src2：第二幅图像。　</p><p>mask：可选参数，掩模，建议使用默认值。　</p><p>dtype：可选参数，图像深度，建议使用默认值。<br>返回值说明：　</p><p>dst：相加之后的图像。如果相加之后值的结果大于255，则取255。</p><p>下面通过一个实例演示“+”运算符和add()方法处理结果的不同。</p><p>【实例9.2】　分别使用“+”和add()方法计算图像和。（实例位置：资源包\TM\sl\9\02）<br>读取一幅图像，让该图像自己对自己做加法运算，分别使用“+”运算符和add()方法，观查两者相加结果的不同，具体代码如下：</p><p><img src="/2020/06/01/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87%E7%BA%BF%E6%AE%B5/image-20211120061614335.png" alt="image-20211120061614335"></p><p>上述代码的运行结果如图9.10所示。从结果可以看出<strong>，“+”运算符的计算结果如果超出了255，就会取相加和除以255的余数，也就是取模运算，像素值相加后反而变得更小，由浅色变成了深色；而add()方法的计算结果如果超过了255，就取值255，很多浅颜色像素彻底变成了纯白色</strong>。</p><p><img src="/2020/06/01/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87%E7%BA%BF%E6%AE%B5/image-20211120061639378.png" alt="image-20211120061639378"></p><p>​                                                              图9.10　图像的加法运算效果</p><p>下面通过一个实例演示如何使用加运算修改图像颜色。</p><p>【实例9.3】　模拟三色光叠加得白光。<br>颜料中的三原色为红、黄、蓝，这3种颜色混在一起变成黑色，而光学中的三原色为红、绿、蓝，这3种颜色混在一起变成白色。现在分别创建纯蓝、纯绿、纯红3种图像，取3幅图像的相加和，查看结果是黑色还是白色，具体代码如下：</p><p><img src="/2020/06/01/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87%E7%BA%BF%E6%AE%B5/image-20211120061705351.png" alt="image-20211120061705351"></p><p>蓝色加上绿色等于青色，青色再加上红色就等于白色，结果符合光学三原色的叠加原理。</p><p>图像的加法运算中也可以使用掩模，下面通过一个实例介绍掩模的使用方法。</p><p>【实例9.4】　利用掩模遮盖相加结果。<br>创建纯蓝和纯红2幅图像，使用add()方法对2幅图像进行加法运算，并在方法中添加一个掩模，具体代码如下：</p><p><img src="/2020/06/01/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87%E7%BA%BF%E6%AE%B5/image-20211120061833765.png" alt="image-20211120061833765"></p><p>上述代码的运行结果如图9.16～图9.18所示，从结果可以看出，add()方法中如果使用了掩模参数，相加的结果只会保留掩模中白色覆盖的区域。</p><p><img src="/2020/06/01/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87%E7%BA%BF%E6%AE%B5/image-20211120061859770.png" alt="image-20211120061859770"></p><p>​                                                                                图9.16　蓝色和红色相加的结果</p><p><img src="/2020/06/01/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87%E7%BA%BF%E6%AE%B5/image-20211120061924099.png" alt="image-20211120061924099"></p><p>​                                                                                                   图9.17　掩模</p><p><img src="/2020/06/01/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87%E7%BA%BF%E6%AE%B5/image-20211120061948929.png" alt="image-20211120061948929"></p><p>​                                                                                          图9.18　通过掩模相加的结果</p><h2 id="9-3-图像的位运算"><a href="#9-3-图像的位运算" class="headerlink" title="9.3　图像的位运算"></a>9.3　图像的位运算</h2><p>位运算是二进制数特有的运算操作。图像由像素组成，每个像素可以用十进制整数表示，十进制整数又可以转化为二进制数，所以图像也可以做位运算，并且位运算是图像数字化技术中一项重要的运算操作。<br>OpenCV提供了几种常用的位运算方法，具体如表9.1所示。</p><p>表9.1　OpenCV提供的位运算方法</p><p><img src="/2020/06/01/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87%E7%BA%BF%E6%AE%B5/image-20211120062045946.png" alt="image-20211120062045946"></p><p>接下来将详细介绍这些方法的含义及使用方式。</p><h3 id="9-3-1-按位与运算"><a href="#9-3-1-按位与运算" class="headerlink" title="9.3.1　按位与运算"></a>9.3.1　按位与运算</h3><p>与运算就是按照二进制位进行判断，<strong>如果同一位的数字都是1，则运算结果的相同位数字取1，否则取0</strong>。<br>OpenCV提供bitwise_and()方法来对图像做与运算，该方法的语法如下：</p><pre><code class="hljs"> dst = cv2.bitwise_and(src1, src2, mask)</code></pre><p>参数说明：　</p><p>src1：第一幅图像。　</p><p>src2：第二幅图像。　</p><p>mask：可选参数，掩模。</p><p>返回值说明：　</p><p>dst：与运算之后的图像。<br>图像做与运算时，会把每一个像素值都转为二进制数，然后让两幅图像相同位置的两个像素值做与运算，最后把运算结果保存在新图像的相同位置上，运算过程如图9.19所示。</p><p><img src="/2020/06/01/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87%E7%BA%BF%E6%AE%B5/image-20211120062122565.png" alt="image-20211120062122565"></p><p>​                                                                                图9.19　图像做与运算的过程<br>与运算有两个特点。<br>（1）如果某像素与纯白像素做与运算，结果仍然是某像素的原值，计算过程如下：</p><pre><code class="hljs"> 00101011 &amp; 11111111 = 00101011</code></pre><p>（2）如果某像素与纯黑像素做与运算，结果为纯黑像素，计算过程如下：</p><pre><code class="hljs"> 00101011 &amp; 00000000 = 00000000</code></pre><p>由此可以得出：如果原图像与掩模进行与运算，原图像仅保留掩模中白色区域覆盖的内容，其他区域全部变成黑色。下面通过一个实例演示掩模在与运算过程的作用。</p><p>【实例9.5】　花图像与十字掩模做与运算。<br>创建一个掩模，在掩模中央保留一个十字形的白色区域，让掩模与花图像做与运算，具体代码如下：</p><p><img src="/2020/06/01/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87%E7%BA%BF%E6%AE%B5/image-20211120062312995.png" alt="image-20211120062312995"></p><p>上述代码的运行结果如图9.20～图9.22所示，经过与运算之后，花图像仅保留了掩模中白色区域覆盖的内容，其他区域都变成了黑色。</p><p><img src="/2020/06/01/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87%E7%BA%BF%E6%AE%B5/image-20211120062336698.png" alt="image-20211120062336698"></p><p>​                                                                                               图9.20　花图像</p><p><img src="/2020/06/01/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87%E7%BA%BF%E6%AE%B5/image-20211120062357566.png" alt="image-20211120062357566"></p><p>​                                                                                          图9.21　掩模图像</p><p><img src="/2020/06/01/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87%E7%BA%BF%E6%AE%B5/image-20211120062502072.png" alt="image-20211120062502072"></p><p>​                                                                                  图9.22　花图像与掩模图像与运算的效果</p><h3 id="9-3-2-按位或运算"><a href="#9-3-2-按位或运算" class="headerlink" title="9.3.2　按位或运算"></a>9.3.2　按位或运算</h3><p>或运算也是按照二进制位进行判断，<strong>如果同一位的数字都是0，则运算结果的相同位数字取0，否则取1</strong>。<br>OpenCV提供bitwise_or()方法来对图像做或运算，该方法的语法如下：</p><pre><code class="hljs"> dst = cv2.bitwise_or(src1, src2, mask)</code></pre><p>参数说明：　</p><p>src1：第一幅图像。　</p><p>src2：第二幅图像。　</p><p>mask：可选参数，掩模。</p><p>返回值说明：　</p><p>dst：或运算之后的图像。<br>图像做或运算时的运算过程如图9.23所示。</p><p><img src="/2020/06/01/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87%E7%BA%BF%E6%AE%B5/image-20211120062536061.png" alt="image-20211120062536061"></p><p>​                                                                             图9.23　图像做或运算的过程<br>或运算有以下两个特点。<br>（1）如果某像素与纯白像素做或运算，结果为纯白像素，计算过程如下：</p><pre><code class="hljs"> 00101011 | 11111111 = 11111111</code></pre><p>（2）如果某像素与纯黑像素做或运算，结果仍然是某像素的原值，过程如下：</p><pre><code class="hljs"> 00101011 | 00000000 = 00101011</code></pre><p>由此可以得出：如果原图像与掩模进行或运算，原图像仅保留掩模中黑色区域覆盖的内容，其他区域全部变成白色。下面通过一个实例演示掩模在或运算过程中的作用。</p><p>【实例9.6】　花图像与十字掩模做或运算。<br>创建一个掩模，在掩模中央保留一个十字形的白色区域，让掩模与花图像做或运算，具体代码如下：</p><p><img src="/2020/06/01/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87%E7%BA%BF%E6%AE%B5/image-20211120062638230.png" alt="image-20211120062638230">上述代码的运行结果如图9.24所示，经过或运算后，花图像仅保留了掩模中黑色区域覆盖的内容，其他区域都变成了白色。</p><p><img src="/2020/06/01/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87%E7%BA%BF%E6%AE%B5/image-20211120062715613.png" alt="image-20211120062715613"></p><p>​                                                                              图9.24　图像或运算效果</p><h3 id="9-3-3-按位取反运算"><a href="#9-3-3-按位取反运算" class="headerlink" title="9.3.3　按位取反运算"></a>9.3.3　按位取反运算</h3><p>取反运算是一种单目运算，仅需一个数字参与运算就可以得出结果。取反运算也是按照二进制位进行判断，<strong>如果运算数某位上数字是0，则运算结果的相同位的数字就取1，如果这一位的数字是1，则运算结果的相同位的数字就取0</strong>。<br>OpenCV提供bitwise_not()方法来对图像做取反运算，该方法的语法如下：</p><p>dst = cv2.bitwise_not(src, mask)<br>参数说明：　</p><p>src：参与运算的图像。　</p><p>mask：可选参数，掩模。<br>返回值说明：</p><p>　dst：取反运算之后的图像。<br>图像做取反运算的过程如图9.25所示。</p><p><img src="/2020/06/01/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87%E7%BA%BF%E6%AE%B5/image-20211120062822407.png" alt="image-20211120062822407"></p><p>​                                                                                图9.25　图像做取反运算的过程<br>图像经过取反运算后呈现与原图颜色完全相反的效果，下面通过一个实例演示掩膜在取反运算过程中的作用。</p><p>【实例9.7】　对花图像进行取反运算。<br>对花图像进行取反运算，具体代码如下：</p><p><img src="/2020/06/01/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87%E7%BA%BF%E6%AE%B5/image-20211120062846036.png" alt="image-20211120062846036"></p><p>上述代码的运行结果如图9.26所示。</p><p><img src="/2020/06/01/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87%E7%BA%BF%E6%AE%B5/image-20211120062904656.png" alt="image-20211120062904656"></p><p>​                                                                      图9.26　图像取反运算的效果</p><h3 id="9-3-4-按位异或运算"><a href="#9-3-4-按位异或运算" class="headerlink" title="9.3.4　按位异或运算"></a>9.3.4　按位异或运算</h3><p>异或运算也是按照二进制位进行判断，<strong>如果两个运算数同一位上的数字相同，则运算结果的相同位数字取0，否则取1</strong>。OpenCV提供bitwise_xor()方法对图像做异或运算，该方法的语法如下：</p><pre><code class="hljs"> dst = cv2.bitwise_xor(src, mask)</code></pre><p>参数说明：　</p><p>src：参与运算的图像。　</p><p>mask：可选参数，掩模。</p><p>返回值说明：　</p><p>dst：异或运算之后的图像。<br>图像做异或运算的过程如图9.27所示。</p><p><img src="/2020/06/01/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87%E7%BA%BF%E6%AE%B5/image-20211120063005147.png" alt="image-20211120063005147"></p><p>​                                                                                     图9.27　图像做异或运算的过程<br>异或运算有两个特点。<br>（1）如果某像素与纯白像素做异或运算，结果为原像素的取反结果，计算过程如下：</p><pre><code class="hljs"> 00101011 ^ 11111111 = 11010100</code></pre><p>（2）如果某像素与纯黑像素做异或运算，结果仍然是某像素的原值，计算过程如下：</p><pre><code class="hljs"> 00101011 ^ 00000000 = 00101011</code></pre><p>由此可以得出：如果原图像与掩模进行异或运算，掩模白色区域覆盖的内容呈现取反效果，黑色区域覆盖的内容保持不变。下面通过一个实例演示掩模在异或运算过程的作用。</p><p>【实例9.8】　花图像与十字掩模做异或运算。<br>创建一个掩模，在掩模中央保留一个十字形的白色区域，让掩模与花图像做异或运算，具体代码如下：</p><p><img src="/2020/06/01/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87%E7%BA%BF%E6%AE%B5/image-20211120063056227.png" alt="image-20211120063056227"></p><p>运算结果如图9.28所示，掩模白色区域覆盖的内容与原图像做取反运算的结果一致，掩模黑色区域覆盖的内容保持不变。</p><p><img src="/2020/06/01/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87%E7%BA%BF%E6%AE%B5/image-20211120063113955.png" alt="image-20211120063113955"></p><p>​                                                                                      图9.28　图像异或运算效果<br>异或运算还有一个特点：执行一次异或运算得到一个结果，再对这个结果执行第二次异或运算，则还原成最初的值。利用这个特点可以实现对图像内容的加密和解密。下面通过一个实例，利用异或运算的特点对图像数据进行加密和解密。</p><p>【实例9.9】　对图像进行加密、解密。<br>利用numpy.random.randint()方法创建一个随机像素值图像作为密钥图像，让密钥图像与原始图像做异或运算得出加密图像，再使用密钥图像对加密图像进行解密，具体代码如下：</p><p><img src="/2020/06/01/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87%E7%BA%BF%E6%AE%B5/image-20211120063142267.png" alt="image-20211120063142267"></p><p>上述代码的运行结果如图9.29所示。</p><p><img src="/2020/06/01/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87%E7%BA%BF%E6%AE%B5/image-20211120063219114.png" alt="image-20211120063219114"></p><p>​                                                                                         图9.29　图像加密、解密效果</p><h2 id="9-4-合并图像"><a href="#9-4-合并图像" class="headerlink" title="9.4　合并图像"></a>9.4　合并图像</h2><p>在处理图像时经常会遇到需要将两幅图像合并成一幅图像，合并图像也分2种情况：①两幅图像融合在一起；②每幅图像提供一部分内容，将这些内容拼接成一幅图像。OpenCV分别用加权和和覆盖两种方式来满足上述需求。本节将分别介绍如何利用代码实现加权和和覆盖效果。</p><h3 id="9-4-1-加权和"><a href="#9-4-1-加权和" class="headerlink" title="9.4.1　加权和"></a>9.4.1　加权和</h3><p>多次曝光技术是指在一幅胶片上拍摄几个影像，最后冲印出的相片同时具有多个影像的信息。<br>OpenCV通过计算加权和的方式，按照不同的权重取两幅图像的像素之和，最后组成新图像。加权和不会像纯加法运算那样让图像丢失信息，而是在尽量保留原有图像信息的基础上把两幅图像融合到一起。<br>OpenCV通过addWeighted()方法计算图像的加权和，该方法语法如下：</p><pre><code class="hljs"> dst = cv2.addWeighted(src1, alpha, src2, beta, gamma)</code></pre><p>参数说明：　</p><p>src1：第一幅图像。　</p><p>alpha：第一幅图像的权重。　</p><p>src2：第二幅图像。　</p><p>beta：第二幅图像的权重。　</p><p>gamma：在和结果上添加的标量。该值越大，结果图像越亮，相反则越暗。可以是负数。</p><p>返回值说明：　</p><p>dst：加权和后的图像。</p><p>下面通过一个实例演示addWeighted()方法的效果。</p><p>【实例9.10】　利用计算加权和的方式实现多次曝光效果。<br>读取两幅不同的风景照片，使用addWeighted()方法计算两幅图像的加权和，两幅图像的权重都为0.6，标量为0，查看处理之后的图像是否为多次曝光效果，具体代码如下：</p><p><img src="/2020/06/01/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87%E7%BA%BF%E6%AE%B5/image-20211120063330427.png" alt="image-20211120063330427"></p><p>上述代码的运行结果如图9.30～图9.32所示，可以看出最后得到的图像中同时包含两幅图像的信息。</p><p><img src="/2020/06/01/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87%E7%BA%BF%E6%AE%B5/image-20211120063347197.png" alt="image-20211120063347197"></p><p>​                                                                                               图9.30　日落图像</p><p><img src="/2020/06/01/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87%E7%BA%BF%E6%AE%B5/image-20211120063409727.png" alt="image-20211120063409727"></p><p>​                                                                                              图9.31　沙滩图像</p><p><img src="/2020/06/01/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87%E7%BA%BF%E6%AE%B5/image-20211120063438319.png" alt="image-20211120063438319"></p><p>​                                                                                 图9.32　两幅图像加权和的结果</p><h3 id="9-4-2-覆盖"><a href="#9-4-2-覆盖" class="headerlink" title="9.4.2　覆盖"></a>9.4.2　覆盖</h3><p>覆盖图像就是直接把前景图像显示在背景图像中，前景图像挡住背景图像。覆盖之后背景图像会丢失信息，不会出现加权和那样的“多次曝光”效果。<br>OpenCV没有提供覆盖操作的方法，开发者可以直接用修改图像像素值的方式实现图像的覆盖、拼接效果：从A图像中取像素值，直接赋值给B图像的像素，这样就能在B图像中看到A图像的信息了。<br>下面通过一个实例来演示如何从前景图像中抠图，再将抠出的图像覆盖在背景图像中。</p><p>【实例9.11】　将小猫图像覆盖到沙滩图像上。</p><p>读取小猫原始图像，将原始图像中75～400行、120～260列的像素单独保存成一幅小猫图像，并将小猫图像缩放成70×160大小。读取沙滩图像，将小猫图像覆盖到沙滩图像(100, 200)的坐标位置。覆盖过程中将小猫图像的像素逐个赋值给沙滩图像中对应位置的像素，具体代码如下：</p><p><img src="/2020/06/01/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87%E7%BA%BF%E6%AE%B5/image-20211120063525987.png" alt="image-20211120063525987"></p><p>运行结果如图9.33所示，沙滩图像中的像素被替换成小猫之后，就可实现类似拼接图像的效果。</p><p><img src="/2020/06/01/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87%E7%BA%BF%E6%AE%B5/image-20211120063608529.png" alt="image-20211120063608529"></p><p>​                                                                                                图9.33　覆盖图像效果<br>如果前景图像是4通道（含alpha通道）图像，就不能使用上面例子中直接替换整个区域的方式覆盖背景图像了。因为前景图像中有透明的像素，透明的像素不应该挡住背景，所以在给背景图像像素赋值时应排除所有透明的前景像素。下面通过一个实例来演示如何在覆盖过程中排除4通道图像的透明区域。</p><p>【实例9.12】　拼接禁止吸烟图像。<br>禁止图像由一个红圈和一个斜杠组成，这个图像是4通道图像，格式为PNG。将禁止图像覆盖到吸烟图像上时要注意：不要把前景图像的透明像素覆盖到背景图像上。覆盖之前要遍历前景图像中的每一个像素，如果像素的alpha通道值为0，表示该像素是透明像素，就要停止操作该像素，实现的具体代码如下：</p><p><img src="/2020/06/01/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87%E7%BA%BF%E6%AE%B5/image-20211120063635612.png" alt="image-20211120063635612"></p><p>上述代码的运行结果如图9.34～图9.36所示，禁止图像的透明位置没有挡住吸烟图像。</p><p><img src="/2020/06/01/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87%E7%BA%BF%E6%AE%B5/image-20211120063725775.png" alt="image-20211120063725775"></p><p>​                                                                                        图9.34　禁止图像</p><p><img src="/2020/06/01/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87%E7%BA%BF%E6%AE%B5/image-20211120063745746.png" alt="image-20211120063745746"></p><p>​                                                                                          图9.35　吸烟图像</p><p><img src="/2020/06/01/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87%E7%BA%BF%E6%AE%B5/image-20211120063807277.png" alt="image-20211120063807277"></p><p>​                                                                                图9.36　2幅图像拼接之后的禁止吸烟图像</p><h2 id="9-5-小结"><a href="#9-5-小结" class="headerlink" title="9.5　小结"></a>9.5　小结</h2><p>明确关于掩模的3个问题：0和255这2个值在掩模中各自发挥的作用；通过这2个值，掩模的作用又是什么；如何创建一个掩模。掌握了掩模后，就能够利用掩模遮盖图像相加后的结果。掩模除了应用于图像的加法运算外，还应用于图像的位运算。一个掩模应用于图像的位运算的典型实例就是对图像进行加密、解密。本章除了上述内容，还讲解了合并图像的2种方式：加权和、覆盖。</p>]]></content>
    
    
    <categories>
      
      <category>数据分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>openCv</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python_openCv</title>
    <link href="/2020/05/27/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87/"/>
    <url>/2020/05/27/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h1 id="Python-OpenCV基础篇"><a href="#Python-OpenCV基础篇" class="headerlink" title="Python OpenCV基础篇"></a>Python OpenCV基础篇</h1><h1 id="第一章-OpenCV简介"><a href="#第一章-OpenCV简介" class="headerlink" title="第一章 OpenCV简介"></a>第一章 OpenCV简介</h1><h2 id="1-1-OpenCV概述"><a href="#1-1-OpenCV概述" class="headerlink" title="1.1 OpenCV概述"></a>1.1 OpenCV概述</h2><p>OpenCV是一个开源的计算机视觉库，可以在windows，Linux，MacOS等操作系统上运行，它起源于英特尔性能实验室研究，由俄罗斯的专家负责实现和优化，并以计算机视觉提供通用性接口为目标。</p><p>人类由于被赋予了视觉，因此很容易认为“计算机视觉是一种很容易实现的功能”。但是，这种想法是错误的。<br>如图1.7所示，人类的视觉能够很轻易地从这幅图像中识别花朵。但是，计算机视觉不会像人类视觉那样能够对图像进行感知和识别，更不会自动控制焦距和光圈，而是把图像解析为按照栅格状排列的数字。以图1.7为例，计算机视觉将其解析为如图1.8所示的按照栅格状排列的数字（图1.8只是图1.7的一部分）。</p><p><img src="/2020/05/27/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87/1.1.jpg" alt="1.1"></p><p>​                                                                                        图1.7　一幅显示花朵的彩色图像</p><p><img src="/2020/05/27/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211117145923429.png" alt="image-20211117145923429"></p><p>​                                                                                          图1.8　计算机视觉中的图1.7<br>这些按照栅格状排列的数字包含大量的噪声，噪声在图像上常表现为引起较强视觉效果的孤立像素点或像素块，使得图像模糊不清。因此，噪声是计算机视觉面临的一个难题。要让图片变得清晰，就需要对抗噪声。<br>计算机视觉使用统计的方法对抗噪声，例如，计算机视觉虽然很难通过某个像素或者这个像素的相邻像素判断这个像素是否在图像主体的边缘上，但是如果对图像某一区域内的像素做统计，那么上述判断就变得简单了，即在指定区域内，图像主体的边缘应该表现为一连串独立的像素，而且这一连串像素的方向应该是一致的。<br>为了有效地解决计算机视觉面临的难题，OpenCV提供了许多模块，这些模块中的方法具有很好的完备性。</p><h3 id="1-1-1-OpenCV包含的模块"><a href="#1-1-1-OpenCV包含的模块" class="headerlink" title="1.1.1　OpenCV包含的模块"></a>1.1.1　OpenCV包含的模块</h3><p>OpenCV是由很多模块组成的，这些模块可以分为很多层，具体如图1.11所示。<br>那么，OpenCV包含的模块有哪些呢？表1.1列举的是OpenCV常用的模块。</p><p><img src="/2020/05/27/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211118043722625.png" alt="image-20211118043722625"></p><p>​                                                                                        图1.11　OpenCV包含的模块的层级结构</p><p>​                                                                                       表1.1　OpenCV常用的模块及其说明说明</p><p><img src="/2020/05/27/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211118043819255.png" alt="image-20211118043819255"></p><p>表1.1中的模块随着OpenCV的版本不断地更新而发生变化，有的可能被取消，有的可能被融合到其他模块中。</p><p>为了快速建立精巧的视觉应用，OpenCV提供了许多模块和方法。开发人员不必过多关注这些模块和方法的具体实现细节，只需关注图像处理本身，就能够很方便地使用它们对图像进行相应的处理。</p><h3 id="1-1-2-OpenCV的发展历程"><a href="#1-1-2-OpenCV的发展历程" class="headerlink" title="1.1.2　OpenCV的发展历程"></a>1.1.2　OpenCV的发展历程</h3><p><img src="/2020/05/27/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211118044141267.png" alt="image-20211118044141267"></p><p>​                                                                          图1.12　自2009年OpenCV的发展历程<br>从2009年3月至今，OpenCV的发展历程如图1.12所示。随着OpenCV被越来越多的用户认可并提供越来越多的技术支持，OpenCV的研发团队也加大了研究人员和研究经费的投入，这使得OpenCV的下载量逐年增长。<br>OpenCV的发展不是一帆风顺的。OpenCV在发展历程中，不仅受到了互联网行业泡沫经济的冲击，还受到了管理层和管理方向不断变更的影响，有时甚至没有研究人员和研究经费的投入。但是，随着多核处理器的出现以及计算机视觉的应用越来越广泛，OpenCV的应用价值开始上升。<br>截至目前，OpenCV已经得到了基金会、一些上市公司和私人机构的支持。OpenCV的宗旨是促进商业（利用OpenCV构建商业产品）和研究，因此OpenCV是开源并且免费的。这不仅使得OpenCV拥有着庞大的用户群体，还使得OpenCV在世界各国逐渐流行起来。</p><h3 id="1-1-3-OpenCV的应用"><a href="#1-1-3-OpenCV的应用" class="headerlink" title="1.1.3　OpenCV的应用"></a>1.1.3　OpenCV的应用</h3><p>因为OpenCV是一个开源的计算机视觉库，所以在举例介绍OpenCV的应用之前，先对计算机视觉的应用进行介绍。<br>计算机视觉不仅被广泛地应用到安保行业（见图1.13中的监控摄像头），还被应用到网页端的图像和视频处理以及游戏交互中，甚至在某些现代化工厂里，被应用到产品质检工作上。此外，计算机视觉还被应用到一些高精尖领域，包括无人机领域和航空航天领域等，这些领域使用计算机视觉中的图像拼接技术获取街景图像（见图1.14）或者航空图像（见图1.15）。</p><p><img src="/2020/05/27/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211118044301194.png" alt="image-20211118044301194"></p><p>​                                                                                             图1.13　监控摄像头</p><p><img src="/2020/05/27/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211118044402545.png" alt="image-20211118044402545"></p><p>​                                                                                            图1.14　街景图像</p><p><img src="/2020/05/27/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211118044454076.png" alt="image-20211118044454076"></p><p>​                                                                                               图1.15　航空图像<br>OpenCV自发布起便得到广泛应用，其中包括在安保以及工业检测系统，网络产品以及科研工作，医学、卫星和网络地图（例如，医学图像的降噪，街景图像或者航空图像的拼接及其扫描校准等），汽车自动驾驶，相机校正等。此外，OpenCV还被应用到处理声音的频谱图像上，进而实现对声音的识别。</p><h3 id="1-1-4-Python-OpenCV的开发工具"><a href="#1-1-4-Python-OpenCV的开发工具" class="headerlink" title="1.1.4　Python OpenCV的开发工具"></a>1.1.4　Python OpenCV的开发工具</h3><p>Python相比Java、C、C++等编程语言，其优势在于集成度高。虽然Python的执行效率低，但是可以调用大量免费使用的类库。Java、C、C++语言如果要实现一个功能，那么需要先实现其中的基本功能模块。Python直接调用相应的类库就能将这个功能轻松实现。简单地说，Python通过简短的代码就能够实现很强大的功能。<br>此外，Python在OpenCV、Web、爬虫、数据分析等方向都有很好的发展前景。Python OpenCV的优势在于Python能够借助OpenCV库轻轻松松地实现对图像的处理操作。<br>Python OpenCV的开发工具如图1.16所示。</p><p><img src="/2020/05/27/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211118044618479.png" alt="image-20211118044618479"></p><p>​                                                                          图1.16　Python OpenCV的开发工具</p><h1 id="第2章-搭建开发环境"><a href="#第2章-搭建开发环境" class="headerlink" title="第2章　搭建开发环境"></a>第2章　搭建开发环境</h1><p>第1章介绍了本书要使用的开发工具，它们分别是Python解释器、OpenCV-Contrib-Python库、Numpy库和集成开发工具PyCharm。使用这些开发工具前，需先对它们进行下载和安装。</p><p><img src="/2020/05/27/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211118044843794.png" alt="image-20211118044843794"></p><h2 id="2-1-Python的下载和安装"><a href="#2-1-Python的下载和安装" class="headerlink" title="2.1　Python的下载和安装"></a>2.1　Python的下载和安装</h2><p>工欲善其事，必先利其器。为了使用Python OpenCV对图像进行处理，本节介绍Python的下载和安装。Python是跨平台的开发工具，可以在Windows、Linux和MacOS等操作系统上使用。说明<br>本节使用的是64位的Windows 10操作系统。</p><h3 id="2-1-1-下载Python"><a href="#2-1-1-下载Python" class="headerlink" title="2.1.1　下载Python"></a>2.1.1　下载Python</h3><p>在Python的官网中，可以很方便地下载Python的开发工具，具体下载步骤如下。<br>（1）打开浏览器，在浏览器的地址栏中输入Python的官网地址<a href="https://www.python.org/%EF%BC%8C%E6%8C%89Enter%E9%94%AE%E5%90%8E%EF%BC%8C%E8%BF%9B%E5%85%A5Python%E7%9A%84%E5%AE%98%E7%BD%91%E9%A6%96%E9%A1%B5%EF%BC%9B%E5%B0%86%E9%BC%A0%E6%A0%87%E7%A7%BB%E5%8A%A8%E5%88%B0Downloads%E8%8F%9C%E5%8D%95%E4%B8%8A%EF%BC%8C%E6%98%BE%E7%A4%BA%E5%A6%82%E5%9B%BE2.1%E6%89%80%E7%A4%BA%E7%9A%84%E8%8F%9C%E5%8D%95%E9%A1%B9%E3%80%82%E8%AF%B4%E6%98%8E">https://www.python.org/，按Enter键后，进入Python的官网首页；将鼠标移动到Downloads菜单上，显示如图2.1所示的菜单项。说明</a><br>推荐使用Python 3.8.2及其以上版本。<br>（2）单击图2.1中的Windows菜单项后，将进入详细的下载列表，如图2.2所示。</p><p><img src="/2020/05/27/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211118045031864.png" alt="image-20211118045031864"></p><p>​                                                                              图2.1　Downloads菜单中的菜单项</p><p><img src="/2020/05/27/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211118045054226.png" alt="image-20211118045054226"></p><p>​                                                                   图2.2　适合Windows系统的Python下载列表说明<br>在如图2.2所示的下载列表中，带有“x86”字样的压缩包，表示该开发工具可以在Windows 32位系统上使用；而带有“x86-64”字样的压缩包，则表示该开发工具可以在Windows 64位系统上使用。另外，标记为“web-based installer”字样的压缩包，表示需要通过联网完成安装；标记为“executable installer”字样的压缩包，表示通过可执行文件（*.exe）方式离线安装；标记为“embeddable zip file”字样的压缩包，表示嵌入式版本，可以集成到其他应用中。<br>（3）在如图2.2所示的下载列表中，列出了各个版本的下载链接，可以根据需要选择相应的版本进行下载。因为本书使用的是64位的Windows 10操作系统，所以选择并单击Windows x86-64 executable installer超链接进行下载。<br>（4）下载完成后，将得到一个名为python-3.8.2-amd64.exe的安装文件。</p><h3 id="2-1-2-安装Python"><a href="#2-1-2-安装Python" class="headerlink" title="2.1.2　安装Python"></a>2.1.2　安装Python</h3><p>安装Python的步骤如下。<br>（1）双击下载完成后得到的安装文件python-3.8.2-amd64.exe，将显示如图2.3所示的安装向导对话框；选中当前对话框中的Add Python 3.8 to PATH复选框，表示自动配置环境变量。<br>（2）单击图2.3中的Customize installation按钮，进行自定义安装；在弹出的如图2.4所示的安装选项对话框中，都采用默认设置。</p><p><img src="/2020/05/27/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211118045151983.png" alt="image-20211118045151983"></p><p>​                                                                               图2.3　Python安装向导对话框</p><p><img src="/2020/05/27/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211118045216258.png" alt="image-20211118045216258"></p><p>​                                                                                        图2.4　安装选项对话框<br>（3）单击图2.4中的Next按钮，弹出如图2.5所示的高级选项对话框。在当前对话框中，除了默认设置外，选中Install for all users复选框（表示当前计算机的所有用户都可以使用）；单击Browse按钮，设置Python的安装路径。注意<br>在设置安装路径时，建议路径中不要使用中文或空格，避免使用过程中出现错误。<br>（4）单击图2.5中的Install按钮后，将显示如图2.6所示的Python安装进度。</p><p><img src="/2020/05/27/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211118045243028.png" alt="image-20211118045243028"></p><p>​                                                                            图2.5　高级选项对话框</p><p><img src="/2020/05/27/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211118045323265.png" alt="image-20211118045323265"></p><p>​                                                                              图2.6　Python安装进度<br>（5）安装完成后，将显示如图2.7所示的对话框，单击Close按钮关闭当前对话框即可。</p><p><img src="/2020/05/27/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211118045349459.png" alt="image-20211118045349459"></p><p>​                                                                                   图2.7　安装完成对话框</p><h3 id="2-1-3-测试Python是否安装成功"><a href="#2-1-3-测试Python是否安装成功" class="headerlink" title="2.1.3　测试Python是否安装成功"></a>2.1.3　测试Python是否安装成功</h3><p>测试Python是否安装成功的步骤如下。<br>（1）单击开始菜单，直接输入cmd，如图2.8所示。<br>（2）按Enter键后，打开“命令提示符”窗口，如图2.9所示。</p><p><img src="/2020/05/27/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211118045430521.png" alt="image-20211118045430521"></p><p>​                                                                                    图2.8　单击开始菜单输入cmd</p><p><img src="/2020/05/27/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211118045450877.png" alt="image-20211118045450877"></p><p>​                                                                                   图2.9　“命令提示符”窗口<br>（3）在“命令提示符”窗口中的光标处输入python，按Enter键；如果当前窗口显示如图2.10所示的信息，说明Python安装成功。</p><p><img src="/2020/05/27/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211118045511638.png" alt="image-20211118045511638"></p><p>​                                                            图2.10　安装成功后输入python显示的信息说明<br>图2.10中的信息是在“命令提示符”窗口中的光标处输入python后显示的。如果读者朋友选择的版本不同，测试时显示的信息会与图2.10中显示的有所差异。当“命令提示符”窗口出现&gt;&gt;&gt;时，说明Python已经安装成功，而且已经进入Python，正在等待用户输入Python命令。</p><h2 id="2-2-Python-OpenCV的下载和安装"><a href="#2-2-Python-OpenCV的下载和安装" class="headerlink" title="2.2　Python OpenCV的下载和安装"></a>2.2　Python OpenCV的下载和安装</h2><p>为了更快速、更简单地下载和安装Python OpenCV，从清华镜像下载和安装OpenCV-Contrib-Python库。在这个库中，除包括OpenCV-Contrib-Python库外，还包括Numpy库。Numpy库是Python语言的一个扩展程序库，支持大量的维度数组与矩阵运算。</p><p>opencv-python 是只包含了主要模块的包，opencv-contrib-python包含了主要模块以及扩展模块，扩展模块主要是包含了一些带专利的收费算法（如shift特征检测）以及一些在测试的新的算法（稳定后会合并到主要模块）。</p><h3 id="2-2-1-下载和安装OpenCV-Contrib-Python库"><a href="#2-2-1-下载和安装OpenCV-Contrib-Python库" class="headerlink" title="2.2.1　下载和安装OpenCV-Contrib-Python库"></a>2.2.1　下载和安装OpenCV-Contrib-Python库</h3><p>从清华镜像下载和安装OpenCV-Contrib-Python库的步骤如下。<br>（1）可以参照图2.8和图2.9，打开“命令提示符”窗口。<br>（2）在“命令提示符”窗口中的光标处输入pip install -i <a href="https://pypi.tuna.tsinghua.edu.cn/simple">https://pypi.tuna.tsinghua.edu.cn/simple</a> opencv-contrib-python，如图2.11所示。</p><p><img src="/2020/05/27/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211118045621571.png" alt="image-20211118045621571"></p><p>​                                                                                    图2.11　输入pip命令</p><p>说明</p><p>​            （1）<a href="https://pypi.tuna.tsinghua.edu.cn/simple%E6%98%AF%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6%E6%8F%90%E4%BE%9B%E7%9A%84%E7%94%A8%E4%BA%8E%E4%B8%8B%E8%BD%BD%E5%92%8C%E5%AE%89%E8%A3%85OpenCV-Contrib-Python%E5%BA%93%E7%9A%84%E9%95%9C%E5%83%8F%E5%9C%B0%E5%9D%80%E3%80%82">https://pypi.tuna.tsinghua.edu.cn/simple是清华大学提供的用于下载和安装OpenCV-Contrib-Python库的镜像地址。</a></p><p>​            （2）pip命令是用于查找、下载、安装和卸载Python库的管理工具。如果图2.11中的pip命令得不到如图2.12所示的界面，那么要将pip命令修改为pip install opencv-python。</p><p>（3）按Enter键后，系统将自动从<a href="https://pypi.tuna.tsinghua.edu.cn/simple%E5%85%88%E4%B8%8B%E8%BD%BDOpenCV-Contrib-Python%E5%BA%93%EF%BC%8C%E5%86%8D%E4%B8%8B%E8%BD%BDNumpy%E5%BA%93%E3%80%82%E5%BE%85OpenCV-Contrib-Python%E5%BA%93%E5%92%8CNumpy%E5%BA%93%E9%83%BD%E4%B8%8B%E8%BD%BD%E5%AE%8C%E6%88%90%E5%90%8E%EF%BC%8C%E7%B3%BB%E7%BB%9F%E5%B0%86%E8%87%AA%E5%8A%A8%E5%AE%89%E8%A3%85Numpy%E5%BA%93%E5%92%8COpenCV-Contrib-Python%E5%BA%93%EF%BC%8C%E5%A6%82%E5%9B%BE2.12%E6%89%80%E7%A4%BA%E3%80%82">https://pypi.tuna.tsinghua.edu.cn/simple先下载OpenCV-Contrib-Python库，再下载Numpy库。待OpenCV-Contrib-Python库和Numpy库都下载完成后，系统将自动安装Numpy库和OpenCV-Contrib-Python库，如图2.12所示。</a></p><p><img src="/2020/05/27/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211118050033294.png" alt="image-20211118050033294"></p><p>​                                                图2.12　安装Numpy库和OpenCV-Contrib-Python库</p><h3 id="2-2-2-测试OpenCV-Contrib-Python库和Numpy库是否安装成功"><a href="#2-2-2-测试OpenCV-Contrib-Python库和Numpy库是否安装成功" class="headerlink" title="2.2.2　测试OpenCV-Contrib-Python库和Numpy库是否安装成功"></a>2.2.2　测试OpenCV-Contrib-Python库和Numpy库是否安装成功</h3><p>测试OpenCV-Contrib-Python库和Numpy库是否安装成功的步骤如下。<br>（1）如图2.13所示，在光标处输入python，按Enter键，进入Python。<br>（2）当“命令提示符”窗口出现&gt;&gt;&gt;时，在光标处输入import cv2，按Enter键。如果“命令提示符”窗口在新的一行出现&gt;&gt;&gt;，说明OpenCV-Contrib-Python库安装成功。<br>（3）在新的一行的&gt;&gt;&gt;后的光标处输入import numpy as np，按Enter键。如果“命令提示符”窗口在新的一行出现&gt;&gt;&gt;，说明Numpy库安装成功。<br>（4）在新的一行的&gt;&gt;&gt;后的光标处输入exit()，按Enter键，退出Python。<br>（5）在“命令提示符”窗口的光标处输入exit或者exit()，按Enter键，退出“命令提示符”窗口。说明<br>exit()用于退出Python，exit或exit()用于退出“命令提示符”窗口。</p><p><img src="/2020/05/27/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211118050138981.png" alt="image-20211118050138981"></p><p>​                                       图2.13　测试OpenCV-Contrib-Python库和Numpy库是否安装成功</p><h1 id="第3章-图像处理的基本操作"><a href="#第3章-图像处理的基本操作" class="headerlink" title="第3章　图像处理的基本操作"></a>第3章　图像处理的基本操作</h1><p>OpenCV的作用在于让开发人员更容易地通过编码来处理图像。那么，处理图像需要执行哪些操作呢？图像处理的基本操作包含4个方面的内容：读取图像、显示图像、保存图像和获取图像属性。其中，常用的图像属性有3个：shape、size和dtype。本章将依次详解实现图像处理的4个基本操作，并分别阐明常用的3个图像属性各自的含义及其使用方法。</p><h2 id="3-1-读取图像"><a href="#3-1-读取图像" class="headerlink" title="3.1　读取图像"></a>3.1　读取图像</h2><p>要对一幅图像进行处理，首先要做的就是读取这幅图像。那么，如何才能读取这幅图像呢？OpenCV提供了用于读取图像的imread()方法，其语法格式如下：</p><pre><code class="hljs"> image = cv2.imread(filename, flags)</code></pre><p>参数说明：　</p><p>image：imread()方法的返回值，返回的是读取到的图像。　</p><p>filename：要读取的图像的完整文件名。例如，要读取当前项目目录下的3.1.jpg，filename的值为”3.1.jpg”（双引号是英文格式的）。　</p><p>flags：读取图像颜色类型的标记。当flags的默认值为1时，表示读取的是彩色图像，此时的flags值可以省略；当flags的值为0时，表示读取的是灰度图像（如果读取的是彩色图像，也将转换为与彩色图像对应的灰度图像）。</p><p>flags对应的全部属性：</p><p><a href="https://docs.opencv.org/3.4.2/d4/da8/group__imgcodecs.html#ga461f9ac09887e47797a54567df3b8b63">https://docs.opencv.org/3.4.2/d4/da8/group__imgcodecs.html#ga461f9ac09887e47797a54567df3b8b63</a></p><p><img src="/2020/05/27/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87/工作/振涛/课件-郭溪溪/20课时讲义/专高四-机器学习算法与opencv/Day07.assets/image-20211208115112743.png" alt="image-20211208115112743"></p><p>说明</p><p>灰度图像是一种每个像素都是从黑到白，被处理为256个灰度级别的单色图像。256个灰度级别分别用0（纯黑色）～255（纯白色）的数值表示。</p><p>【实例3.1】　读取当前项目目录下的图像。（实例位置：资源包\TM\sl\3\01）<br>如图3.1所示，在PyCharm中的PythonDevelop项目下，有一幅名为3.1.jpg的图像。在ImageTest.py文件中，先使用imread()方法读取3.1.jpg，再使用print()方法打印3.1.jpg，代码如下：</p><pre><code class="hljs"> import cv2 # 读取3.1.jpg，等价于image = cv2.imread(&quot;3.1.jpg&quot;，1) image = cv2.imread(&quot;3.1.jpg&quot;) print(image) # 打印3.1.jpg</code></pre><p>上述代码打印的部分结果如图3.2所示。</p><p><img src="/2020/05/27/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211118050941447.png" alt="image-20211118050941447"></p><p>​                                                                    图3.1　PythonDevelop项目下的3.1.jpg</p><p><img src="/2020/05/27/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211118051005696.png" alt="image-20211118051005696"></p><p>​                                                                                 图3.2　打印3.1.jpg说明<br>图3.2输出的数字是3.1.jpg的部分像素值。<br>如果3.1.jpg在D盘的根目录下，应该如何使用imread()方法进行读取呢？<br>只需将实例3.1代码：</p><p>image = cv2.imread(“3.1.jpg”)<br>修改为如下代码：</p><pre><code class="hljs"> image = cv2.imread(&quot;D:/3.1.jpg&quot;) # 路径中不能出现中文注意</code></pre><p>“D:/3.1.jpg”等价于”D:\3.1.jpg”。</p><h2 id="3-2-显示图像"><a href="#3-2-显示图像" class="headerlink" title="3.2　显示图像"></a>3.2　显示图像</h2><p>相比图3.2中密密麻麻的数字，如果能够将这幅图像显示出来，就可以更加直观地看到它。为此，OpenCV提供了imshow()方法、waitKey()方法和destroyAllWindows()方法。<br>（1）imshow()方法用于显示图像，其语法格式如下：</p><pre><code class="hljs"> cv2.imshow(winname, mat)</code></pre><p>参数说明：　</p><p>winname：显示图像的窗口名称。　</p><p>mat：要显示的图像。<br>（2）waitKey()方法用于等待用户按下键盘上按键的时间。当用户按下键盘上的任意按键时，将执行waitKey()方法，并且获取waitKey()方法的返回值。其语法格式如下：</p><pre><code class="hljs"> retval = cv2.waitKey(delay)</code></pre><p>参数说明：　</p><p>retval：与被按下的按键对应的ASCII码。例如，Esc键的ASCII码是27，当用户按Esc键时，waitKey()方法的返回值是27。如果没有按键被按下，waitKey()方法的返回值是-1。　</p><p>delay：等待用户按下键盘上按键的时间，单位为毫秒（ms）。</p><p>当delay的值为负数、0或者空时，表示无限等待用户按下键盘上按键的时间。</p><p>(4)</p><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nsis">cv2.namedWindow(<span class="hljs-string">&#x27;窗口名称&#x27;</span>,cv2.WINDOW_<span class="hljs-params">NORMAL</span>)<span class="hljs-comment">#窗口可以缩放</span><br></code></pre></td></tr></table></figure><p>（3）destroyAllWindows()方法用于销毁所有正在显示图像的窗口，其语法格式如下：</p><pre><code class="hljs"> cv2.destroyAllWindows()【实例3.2】　显示图像。（实例位置：资源包\TM\sl\3\02）</code></pre><p>编写一个程序，使用imread()方法、imshow()方法、waitKey()方法和destroyAllWindows()方法，读取并显示PythonDevelop项目下的3.1.jpg，代码如下：</p><pre><code class="hljs"> import cv2 image = cv2.imread(&quot;3.1.jpg&quot;)       # 读取3.1.jpg cv2.imshow(&quot;flower&quot;, image)         # 在名为flower的窗口中显示3.1.jpg cv2.waitKey()                       # 按下任何键盘按键后 cv2.destroyAllWindows()             # 销毁所有窗口</code></pre><p>上述代码的运行结果如图3.3所示。注意<br>（1）显示图像的窗口名称不能使用中文（例如，把实例3.2第4行代码中的”flower”修改为”鲜花”），否则会出现如图3.4所示的乱码。<br>（2）为了能够正常显示图像，要在cv2.imshow()之后紧跟着cv2.waitKey()。</p><p><img src="/2020/05/27/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87/1.1.jpg" alt="1.1"></p><p>​                                                                                               图3.3　显示3.1.jpg</p><p>依据imread()方法的语法，如果把实例3.2第3行代码：</p><pre><code class="hljs"> image = cv2.imread(&quot;3.1.jpg&quot;)</code></pre><p>修改为如下代码：</p><pre><code class="hljs"> image = cv2.imread(&quot;3.1.jpg&quot;, 0)</code></pre><p>如果想设置窗口显示图像的时间为5s，又该如何编写代码呢？<br>只需将实例3.2第5行代码：</p><pre><code class="hljs"> cv2.waitKey()</code></pre><p>修改为如下代码：</p><pre><code class="hljs"> cv2.waitKey(5000) # 1000ms为1s，5000ms为5s</code></pre><h2 id="3-3-保存图像"><a href="#3-3-保存图像" class="headerlink" title="3.3　保存图像"></a>3.3　保存图像</h2><p>在实际开发的过程中，对一幅图像进行一系列的处理后，需要保存处理图像后的结果。为此，OpenCV提供了用于按照指定路径保存图像的imwrite()方法，其语法格式如下：</p><pre><code class="hljs"> cv2.imwrite(filename, img)</code></pre><p>参数说明：　</p><p>filename：保存图像时所用的完整路径。　</p><p>img：要保存的图像。</p><p>【实例3.3】　保存图像。（实例位置：资源包\TM\sl\3\03）<br>编写一个程序，把PythonDevelop项目下的3.1.jpg保存为E盘根目录下的、Pictures文件夹中的1.jpg，代码如下：</p><pre><code class="hljs"> import cv2 image = cv2.imread(&quot;3.1.jpg&quot;) # 读取3.1.jpg # 把3.1.jpg保存为E盘根目录下的、Pictures文件夹中的1.jpg cv2.imwrite(&quot;E:/Pictures/1.jpg&quot;, image)</code></pre><p>运行上述代码前，确认E盘根目录下有Pictures文件夹。如果没有，在E盘根目录下新建一个空的Pictures文件夹。<br>运行上述代码后，打开E盘根目录下的Pictures文件夹，即可看到1.jpg。</p><h2 id="3-4-获取图像属性"><a href="#3-4-获取图像属性" class="headerlink" title="3.4　获取图像属性"></a>3.4　获取图像属性</h2><p>在处理图像的过程中，经常需要获取图像的大小、类型等图像属性。为此，OpenCV提供了shape、size和dtype 3个常用属性，具体含义分别如下。</p><p>shape：如果是彩色图像，那么获取的是一个包含图像的水平像素、垂直像素和通道数的数组，即（垂直像素，水平像素，通道数）；如果是灰度图像，那么获取的是一个包含图像的水平像素和垂直像素的数组，即（垂直像素，水平像素）。说明<br>垂直像素指的是垂直方向上的像素，水平像素指的是水平方向上的像素。有关像素、灰度图像和通道的内容，将在本书的第4章和第5章进行讲解。　</p><p>size：获取的是图像包含的像素个数，其值为“水平像素×垂直像素×通道数”。灰度图像的通道数为1。　</p><p>dtype：获取的是图像的数据类型。</p><p>【实例3.4】　分别获取彩色图像和灰度图像的属性。（实例位置：资源包\TM\sl\3\04）<br>编写一个程序，先获取PythonDevelop项目下的3.1.jpg的属性，再获取由3.1.jpg转换得到的灰度图像的属性。代码如下：<br>上述代码的运行结果如图3.7所示。</p><p><img src="/2020/05/27/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211118052254399.png" alt="image-20211118052254399"></p><p>​                                                         图3.7　获取并打印彩色图像的属性说明</p><p>图3.7中（292, 219, 3）的含义是3.1.jpg的垂直像素是292，水平像素是219，通道数是3。（292,219）的含义是由3.1.jpg转换得到的灰度图像的垂直像素是292，水平像素是219，通道数是1。</p><h2 id="3-5-图像编解码"><a href="#3-5-图像编解码" class="headerlink" title="3.5 图像编解码"></a>3.5 图像编解码</h2><p>cv2.imdecode()函数从指定的内存缓存中读取数据，并把数据转换(解码)成图像格式;主要用于从网络传输数据中恢复出图像。<br>cv2.imencode()函数是将图片格式转换(编码)成流数据，赋值到内存缓存中;主要用于图像数据格式的压缩，方便网络传输。</p><p><img src="/2020/05/27/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87/Users\123\Desktop\专高四\pythonOpencv基础篇\image-20211208115449554.png" alt="image-20211208115449554"></p><p>imdecode()使用</p><p>从网络读取图像数据并转换成图片格式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding: utf-8 -*-</span><br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> urllib.request<br><span class="hljs-keyword">import</span> cv2<br><br>url = <span class="hljs-string">&#x27;http://www.pyimagesearch.com/wp-content/uploads/2015/01/google_logo.png&#x27;</span><br>resp = urllib.request.urlopen(url)<br>image = np.asarray(<span class="hljs-built_in">bytearray</span>(resp.read()), dtype=<span class="hljs-string">&quot;uint8&quot;</span>)<br>image = cv2.imdecode(image, cv2.IMREAD_COLOR)<br>cv2.imshow(<span class="hljs-string">&#x27;URL2Image&#x27;</span>,image)<br>cv2.waitKey()<br><br></code></pre></td></tr></table></figure><p>imenconde()使用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding: utf-8 -*-</span><br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> urllib.request<br><span class="hljs-keyword">import</span> cv2<br><br>img = cv2.imread(<span class="hljs-string">&#x27;0122.jpg&#x27;</span>)<br><span class="hljs-comment"># &#x27;.jpg&#x27;表示把当前图片img按照jpg格式编码，按照不同格式编码的结果不一样</span><br>img_encode = cv2.imencode(<span class="hljs-string">&#x27;.jpg&#x27;</span>, img)[<span class="hljs-number">1</span>]<br><span class="hljs-comment"># imgg = cv2.imencode(&#x27;.png&#x27;, img)</span><br><br>data_encode = np.array(img_encode)<br>str_encode = data_encode.tostring()<br><br><span class="hljs-comment"># 缓存数据保存到本地</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;img_encode.txt&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    f.write(str_encode)<br>    f.flush<br><br></code></pre></td></tr></table></figure><h1 id="第4章-像素的操作"><a href="#第4章-像素的操作" class="headerlink" title="第4章　像素的操作"></a>第4章　像素的操作</h1><p>像素是图像的最小单位。每一幅图像都是由M行N列的像素组成的，其中每一个像素都存储一个像素值。以灰度图像为例，计算机通常把灰度图像的像素处理为256个灰度级别，256个灰度级别分别使用区间[0, 255]中的整数数值表示。其中，“0”表示纯黑色；“255”表示纯白色。本章将围绕着像素展开，介绍如何使用NumPy模块操作像素。</p><p><img src="/2020/05/27/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211118052436390.png" alt="image-20211118052436390"></p><h2 id="4-1-像素"><a href="#4-1-像素" class="headerlink" title="4.1　像素"></a>4.1　像素</h2><p>像素是构成数字图像的基本单位。现有一幅显示花朵的图像（见图4.1），在花瓣边缘提取一个小圆圈圈住的区域，将得到一幅如图4.2所示的图像。</p><p><img src="/2020/05/27/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211118052508759.png" alt="image-20211118052508759"></p><p>​                                                                              图4.1　一幅显示花朵的图像</p><p><img src="/2020/05/27/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211118052529006.png" alt="image-20211118052529006"></p><p>​                                                                    图4.2　提取并放大图4.1中被圆圈圈住的区域</p><p>不难发现，图4.2所示的图像是由许多小方块组成的，通常把一个小方块称作一个像素。因此，一个像素是具有一定面积的一个块，而不是一个点。需要注意的是，像素的形状是不固定的，大多数情况下，像素被认为是方形的，但有时也可能是圆形的或者是其他形状的。</p><h3 id="4-1-1-确定像素的位置"><a href="#4-1-1-确定像素的位置" class="headerlink" title="4.1.1　确定像素的位置"></a>4.1.1　确定像素的位置</h3><p>以图4.1为例，在访问图4.1中的某个像素前，要确定这个像素在图4.1中的位置。那么，这个位置应该如何确定呢？<br>首先，确定图4.1在水平方向和垂直方向的像素个数。图4.1的水平方向和垂直方向如图4.3所示。<br>在Windows 10系统的“画图”工具中打开图4.1，得到如图4.4所示的界面。在这个界面中，就会得到图4.1在水平方向的像素是219个，在垂直方向的像素是292个。</p><p><img src="/2020/05/27/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211118052630446.png" alt="image-20211118052630446"></p><p>​                                                                                       图4.3　图4.1的水平方向和垂直方向</p><p><img src="/2020/05/27/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211118052657074.png" alt="image-20211118052657074"></p><p>​                                                                                                       图4.4　用“画图”工具打开图4.1</p><p>然后，根据图4.1在水平方向和垂直方向的像素，绘制如图4.5所示的坐标系。</p><p><img src="/2020/05/27/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211118052750858.png" alt="image-20211118052750858"></p><p>​                                                                  图4.5　根据图4.1在水平方向和垂直方向的像素绘制坐标系</p><p>说明<br>图4.1在水平方向的像素是219个，与其对应的是x轴的取值范围，即0～218；同理，在垂直方向的像素是292个，与其对应的是y轴的取值范围，即0～291。<br>这样，就能够通过坐标来确定某个像素在图4.1中的位置。在OpenCV中，正确表示图4.1中某个像素坐标的方式是(y, x)。例如，在如图4.5所示的坐标系中，图4.1右下角的像素坐标是(291, 218)。</p><p>【实例4.1】　表示图4.1中的指定像素。（实例位置：资源包\TM\sl\4\01）<br>编写一段代码，先读取D盘根目录下的4.1.jpg，再表示坐标(291, 218)上的像素，具体如下：</p><pre><code class="hljs"> import cv2 image = cv2.imread(&quot;D:/4.1.jpg&quot;)  # 读取D盘根目录下的4.1.jpg px = image[291, 218]              # 坐标(291, 218)上的像素</code></pre><h3 id="4-1-2-获取像素的BGR值"><a href="#4-1-2-获取像素的BGR值" class="headerlink" title="4.1.2　获取像素的BGR值"></a>4.1.2　获取像素的BGR值</h3><p>在4.1.1节中，已经得到了坐标(291, 218)上的像素px。现使用print()方法打印这个像素，将得到这个像素的BGR值，代码如下：</p><pre><code class="hljs"> print(&quot;坐标(291, 218)上的像素的BGR值是&quot;, px)</code></pre><p>上述代码的运行结果如下：</p><pre><code class="hljs"> 坐标(291, 218)上的像素的BGR值是 [36 42 49]</code></pre><p>不难发现，坐标(291, 218)上的像素的BGR值是由36、42和49这3个数值组成的。在讲解这3个数值各自代表的含义之前，先了解什么是三基色。<br>如图4.6所示，人眼能够感知红色、绿色和蓝色3种不同的颜色，因此把这3种颜色称作三基色。如果将这3种颜色以不同的比例进行混合，人眼就会感知到丰富多彩的颜色。<br>那么，对于计算机而言，是如何对这些颜色进行编码的呢？答案就是利用色彩空间。也就是说，色彩空间是计算机对颜色进行编码的模型。</p><p>以较为常用的RGB色彩空间为例，在RGB色彩空间中，存在3个通道，即R通道、G通道和B通道。其中，R通道指的是红色通道；G通道指的是绿色通道；B通道指的是蓝色通道；并且每个色彩通道都在区间[0, 255]内取值。<br>这样，计算机将利用3个色彩通道的不同组合来表示不同的颜色。如图4.7所示，通过截图工具，能够得到坐标(291, 218)上的像素值为(49, 42, 36)。</p><p><img src="/2020/05/27/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211118053134133.png" alt="image-20211118053134133"></p><p>​                                                                                              图4.6　三基色</p><p><img src="/2020/05/27/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211118053208551.png" alt="image-20211118053208551"></p><p>​                                                                           图4.7　坐标(291, 218)上的像素的像素值<br>使用print()方法打印图4.1中坐标(291, 218)上的像素px，其结果是(36, 42, 49)。而图4.7中这个坐标上的像素值为(49, 42, 36)。这时会发现这两个结果中的数值是相同的，但顺序是相反的，这是为什么呢？<br>原因是在RGB色彩空间中，彩色图像的通道顺序是R（49）→G（42）→B（36）；但是，在OpenCV中，RGB色彩空间被BGR色彩空间取代，使得彩色图像的通道顺序变为了B（36）→G（42）→R（49）。<br>从上文能够知晓，在BGR色彩空间的图像中，每3个数值表示一个像素，这3个数值分别表示蓝色、绿色和红色3种颜色分量，把每一种颜色分量所在的区域称作通道。那么，OpenCV是如何获取指定位置上的像素的B通道、G通道和R通道的值呢？<br>有如下两种方式（以坐标(291, 218)上的像素为例）。<br>（1）同时获取坐标(291, 218)上的像素的B通道、G通道和R通道的值，代码如下：</p><pre><code class="hljs"> import cv2 image = cv2.imread(&quot;D:/4.1.jpg&quot;) px = image[291, 218]              # 坐标(291, 218)上的像素 print(px)</code></pre><p>上述代码的运行结果如下：</p><pre><code class="hljs"> [36 42 49]</code></pre><p>（2）分别获取坐标(291, 218)上的像素的B通道、G通道和R通道的值，代码如下：</p><pre><code class="hljs"> import cv2 image = cv2.imread(&quot;D:/4.1.jpg&quot;) blue = image[291, 218, 0]         # 坐标(291, 218)上的像素的B通道的值 green = image[291, 218, 1]        # 坐标(291, 218)上的像素的G通道的值 red = image[291, 218, 2]          # 坐标(291, 218)上的像素的R通道的值 print(blue, green, red)</code></pre><p>上述代码的运行结果如下：</p><pre><code class="hljs"> 36 42 49说明</code></pre><p>（1）image[291, 218, 0]中的最后一个数值0表示B通道。<br>（2）image[291, 218, 1]中的最后一个数值1表示G通道。<br>（3）image[291, 218, 2]中的最后一个数值2表示R通道。</p><h3 id="4-1-3-修改像素的BGR值"><a href="#4-1-3-修改像素的BGR值" class="headerlink" title="4.1.3　修改像素的BGR值"></a>4.1.3　修改像素的BGR值</h3><p>在4.1.2节中，已经获取了图4.5中坐标(291, 218)上的像素px的BGR值，即(36, 42, 49)。现要将像素px的BGR值由原来的(36, 42, 49)修改为(255, 255, 255)，代码如下：</p><pre><code class="hljs"> import cv2 image = cv2.imread(&quot;D:/4.1.jpg&quot;) px = image[291, 218] print(&quot;坐标(291, 218)上的像素的初始BGR值是&quot;, px) px = [255, 255, 255]                # 把坐标(291, 218)上的像素的值修改为[255, 255, 255] print(&quot;坐标(291, 218)上的像素修改后的BGR值是&quot;, px)</code></pre><p>上述代码的运行结果如下：</p><pre><code class="hljs"> 坐标(291, 218)上的像素的初始BGR值是 [36 42 49] 坐标(291, 218)上的像素修改后的BGR值是 [255, 255, 255]说明</code></pre><p>对于BGR色彩空间的图像，当每个像素的B、G、R的3个数值相等时，就可以得到灰度图像。其中，B=G=R=0为纯黑色，B=G=R=255为纯白色。</p><p>【实例4.2】　修改图4.1中指定区域内的所有像素。<br>编写一个程序，将图4.1中的坐标(241, 168)、(241, 218)、(291, 168)和(291, 218)的4个点所围成的区域内的所有像素都修改为纯白色，代码如下：</p><p><img src="/2020/05/27/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211118053821109.png" alt="image-20211118053821109">上述代码的运行结果如图4.8所示（左侧的图片是原图)。</p><p><img src="/2020/05/27/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211118054002437.png" alt="image-20211118054002437"></p><p>​                                                           图4.8　把指定区域内的所有像素都修改为白色</p><h2 id="4-2-使用NumPy模块操作像素"><a href="#4-2-使用NumPy模块操作像素" class="headerlink" title="4.2　使用NumPy模块操作像素"></a>4.2　使用NumPy模块操作像素</h2><p>图像在OpenCV中以二维或三维数组表示，数组中的每一个值就是图像的像素值。善于操作数组的NumPy模块就成了OpenCV的依赖包。OpenCV中很多操作都要依赖NumPy模块，例如创建纯色图像、创建掩模和创建卷积核等。本节将简单介绍NumPy模块的常用操作方法，并演示如何利用NumPy模块创建图像。</p><h3 id="4-2-1-NumPy概述"><a href="#4-2-1-NumPy概述" class="headerlink" title="4.2.1　NumPy概述"></a>4.2.1　NumPy概述</h3><p>NumPy（见图4.9）更像是一个魔方（见图4.10），它是Python数组计算、矩阵运算和科学计算的核心库，NumPy来源于Numerical和Python两个单词。NumPy提供了一个高性能的数组对象，以及可以轻松创建一维数组、二维数组和多维数组等大量实用方法，帮助开发者轻松地进行数组计算，从而广泛地应用于数据分析、机器学习、图像处理和计算机图形学、数学任务等领域中。由于NumPy是由C语言实现的，所以其运算速度非常快。具体功能如下。　</p><p>有一个强大的N维数组对象ndarray。　</p><p>广播功能方法。　</p><p>线性代数、傅里叶变换、随机数生成、图形操作等功能。　</p><p>整合C/C++/Fortran代码的工具。</p><p><img src="/2020/05/27/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211118054232190.png" alt="image-20211118054232190"></p><p>​                                                                                              图4.9　NumPy</p><p><img src="/2020/05/27/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211118054256857.png" alt="image-20211118054256857"></p><p>​                                                                                                      图4.10　魔方</p><h3 id="4-2-2-数组的类型"><a href="#4-2-2-数组的类型" class="headerlink" title="4.2.2　数组的类型"></a>4.2.2　数组的类型</h3><p>在对数组进行基本操作前，首先了解一下NumPy的数据类型。NumPy比Python增加了更多种类的数值类型，如表4.1所示，为了区别于Python数据类型，NumPy中的bool、int、float、complex等数据类型名称末尾都加了短下画线“_”。</p><p>表4.1　NumPy数据类型</p><p><img src="/2020/05/27/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211118054337712.png" alt="image-20211118054337712"></p><p>每一种数据类型都有相应的数据转换方法。举例如下：</p><pre><code class="hljs"> np.int8(3.141) np.float64(8) np.float(True)</code></pre><p>结果为：</p><p>​     3<br>​     8.0<br>​     1.0</p><h3 id="4-2-3-创建数组"><a href="#4-2-3-创建数组" class="headerlink" title="4.2.3　创建数组"></a>4.2.3　创建数组</h3><p>NumPy提供了很多创建数组的方法，下面分别介绍。</p><p>1．最常规的array()方法<br>NumPy创建简单的数组主要使用array()方法，通过传递列表、元组来创建NumPy数组，其中的元素可以是任何对象，语法如下：</p><pre><code class="hljs"> numpy.array(object, dtype, copy, order, subok, ndmin)</code></pre><p>参数说明：　</p><p>object：任何具有数组接口方法的对象。　</p><p>dtype：数据类型。　</p><p>copy：可选参数，布尔型，默认值为True，则object对象被复制；否则，只有当__array__返回副本，object参数为嵌套序列，或者需要副本满足数据类型和顺序要求时，才会生成副本。　</p><p>order：元素在内存中的出现顺序，其值为K、A、C、F。如果object参数不是数组，则新创建的数组将按行排列（C），如果值为F，则按列排列；如果object参数是一个数组，则以下顺序成立：C（按行）、F（按列）、A（原顺序）、K（元素在内存中的出现顺序）。</p><p>说明<br>当order是’ A ‘，object是一个既不是’ C ‘也不是’ F ‘ order的数组，并且由于dtype的更改而强制执行了一个副本时，那么结果的顺序不一定是’ C ‘。这可能是一个bug。</p><p>subok：布尔型。如果值为True，则传递子类，否则返回的数组将强制为基类数组（默认值）。　</p><p>ndmin：指定生成数组的最小维数。<br>下面通过一个实例演示如何创建一维数组和二维数组。</p><p>【实例4.3】　创建一维和二维数组。（实例位置：资源包\TM\sl\4\03）<br>分别创建一维数组和二维数组，效果如图4.11所示。</p><p><img src="/2020/05/27/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211118054551232.png" alt="image-20211118054551232"></p><p>​                                                                                                  图4.11　简单数组<br>具体代码如下：</p><pre><code class="hljs"> import numpy as np            #导入numpy模块 n1 = np.array([1,2,3])        #创建一个简单的一维数组 n2 = np.array([0.1,0.2,0.3])  #创建一个包含小数的一维数组 n3 = np.array([[1,2],[3,4]])  #创建一个简单的二维数组</code></pre><p>【实例4.4】　创建浮点类型数组。（实例位置：资源包\TM\sl\4\04）</p><p>NumPy支持比Python更多种类的数据类型，通过dtype参数可以指定数组的数据类型，具体代码如下：<br>运行结果如下：</p><pre><code class="hljs">  [1. 2. 3.] float64 &lt;class &#39;numpy.float64&#39;&gt;</code></pre><p> 【实例4.5】　创建三维数组。（实例位置：资源包\</p><p>创建三维数组是将ndmin参数值设为3即可得到三维数组，具体代码如下：</p><pre><code class="hljs"> import numpy as np nd1 = [1, 2, 3] nd2 = np.array(nd1, ndmin=3)  #三维数组 print(nd2)</code></pre><p>运行结果如下：</p><pre><code class="hljs"> [[[1 2 3]]]</code></pre><p>由此结果可以看出一维数组被转换成了三维数组。2．创建指定维度和数据类型未初始化的数组<br>创建指定维度和数据类型未初始化的数组主要使用empty()方法，数组元素因为未被初始化会自动取随机值。如果要改变数组类型，可以使用dtype参数，如将数组类型设为整型，dtype=int。【实例4.6】　创建2行3列的未初始化数组。（实例位置：资源包\TM\sl\4\06）<br>创建2行3列的未初始化数组，具体代码如下：</p><pre><code class="hljs"> import numpy as np n = np.empty([2, 3]) print(n)</code></pre><p>运行结果如下：</p><pre><code class="hljs"> [[2.22519099e-307 2.33647355e-307 1.23077925e-312]  [2.33645827e-307 2.67023123e-307 1.69117157e-306]]</code></pre><p>5．创建随机数组<br>randint()方法用于生成一定范围内的随机整数数组，左闭右开区间（[low,high)），语法如下：</p><pre><code class="hljs"> numpy.random.randint(low,high,size)</code></pre><p>参数说明：　</p><p>low：随机数最小取值范围。　</p><p>high：可选参数，随机数最大取值范围。若high为空，取值范围为（0，low）。若high不为空，则high必须大于low。　</p><p>size：可选参数，数组维数。</p><p>【实例4.9】　创建随机数组。（实例位置：资源包\TM\sl\4\09）<br>生成一定范围内的随机数组，具体代码如下：</p><pre><code class="hljs"> import numpy as np n1 = np.random.randint(1, 3, 10) print(&#39;随机生成10个1～3且不包括3的整数：&#39;) print(n1) n2 = np.random.randint(5, 10) print(&#39;size数组大小为空随机返回一个整数：&#39;) print(n2) n3 = np.random.randint(5, size=(2, 5)) print(&#39;随机生成5以内二维数组：&#39;) print(n3)</code></pre><p>运行结果如下：</p><pre><code class="hljs"> 随机生成10个1～3且不包括3的整数： [1 1 2 1 1 1 2 2 2 1] size数组大小为空随机返回一个整数： 7</code></pre><h3 id="4-2-4-操作数组"><a href="#4-2-4-操作数组" class="headerlink" title="4.2.4　操作数组"></a>4.2.4　操作数组</h3><p>不用编写循环即可对数据执行批量运算，这就是NumPy数组运算的特点，NumPy称为矢量化。大小相等的数组之间的任何算术运算都可以用NumPy实现。本节主要介绍如何复制数组和简单的数组运算。</p><p>1．加法运算<br>例如，加法运算是数组中对应位置的元素相加（即每行对应相加），如图4.12所示。</p><p><img src="/2020/05/27/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211118054822245.png" alt="image-20211118054822245"></p><p>​                                                                                 图4.12　数组加法运算示意图</p><p>【实例4.10】　对数组做加法运算。（实例位置：资源包\TM\sl\4\10）<br>使用NumPy创建2个数组，并让2个数据进行加法运算，具体代码如下：</p><pre><code class="hljs"> import numpy as np n1 = np.array([1, 2])  # 创建一维数组 n2 = np.array([3, 4]) print(n1 + n2)         # 加法运算</code></pre><p>运行结果如下：</p><pre><code class="hljs"> [4 6]2．减法和乘除法运算</code></pre><p>除了加法运算，还可以实现数组的减法、乘法和除法，如图4.13所示。</p><p><img src="/2020/05/27/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211118054909470.png" alt="image-20211118054909470"></p><p>​                                                                                图4.13　数组减法和乘除法运算示意图</p><p>【实例4.11】　对数组做减法、乘法和除法运算。（实例位置：资源包\TM\sl\4\11）<br>使用NumPy创建2个数组，并让2个数组进行减法、乘法和除法运算，具体代码如下：</p><p><img src="/2020/05/27/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211118054951102.png" alt="image-20211118054951102">运行结果如下：</p><pre><code class="hljs"> [-2 -2] [3 8] [0.33333333 0.5  ]3．幂运算</code></pre><p>幂是数组中对应位置元素的幂运算，使用“**”运算符进行运算，效果如图4.14所示。从图中得出：数组n1的元素1和数组n2的元素3，通过幂运算得到的是1的3次幂；数组n1的元素2和数组n2的元素4，通过幂运算得到的是2的4次幂。</p><p><img src="/2020/05/27/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211118055007461.png" alt="image-20211118055007461"></p><p>​                                                                                  图4.14　数组幂运算示意图</p><p>【实例4.12】　两个数组做幂运算。（实例位置：资源包\TM\sl\4\12）<br>使用NumPy创建2个数组，并让2个数组做幂运算，具体代码如下：</p><pre><code class="hljs"> import numpy as np n1 = np.array([1, 2])  # 创建一维数组 n2 = np.array([3, 4]) print(n1 ** n2)        # 幂运算</code></pre><p>运行结果如下：</p><pre><code class="hljs"> [ 1 16]4．比较运算</code></pre><p>NumPy创建的数组可以使用逻辑运算符进行比较运算，运算的结果是布尔值数组，数组中的布尔值为相比较的数组在相同位置元素的比较结果。</p><p>【实例4.13】　使用逻辑运算符比较数组。（实例位置：资源包\TM\sl\4\13）<br>使用NumPy创建2个数组，分别使用“&gt;=”“==”“&lt;=”和“!=”运算符比较2个数组，具体代码如下：</p><p><img src="/2020/05/27/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211118055106239.png" alt="image-20211118055106239"></p><p>运行结果如下：</p><pre><code class="hljs"> [False False] [False False] [ True  True] [ True  True]5．复制数组</code></pre><p>NumPy提供的array()方法可以使用如下语法复制数据：</p><pre><code class="hljs"> n2 = np.array(n1, copy=True)</code></pre><p>但开发过程中更常用的是copy()方法，其语法如下：</p><pre><code class="hljs"> n2 = n1.copy()</code></pre><p>这两种方法都可以按照原数组的结构、类型、元素值创建出一个副本，修改副本中的元素不会影响到原数组。</p><p>【实例4.14】　复制数据，比较复制的结果与原数组是否相同。（实例位置：资源包\TM\sl\4\14）<br>使用copy()方法复制数组，比较2个数组是否相同。修改副本数组中的元素值后，再查看2个数组是否相同，具体代码如下：</p><p><img src="/2020/05/27/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211118055207036.png" alt="image-20211118055207036"></p><p>运行结果如下：</p><pre><code class="hljs"> [ True  True] [1 2] [9 2] [False  True]</code></pre><h3 id="4-2-5-数组的索引和切片"><a href="#4-2-5-数组的索引和切片" class="headerlink" title="4.2.5　数组的索引和切片"></a>4.2.5　数组的索引和切片</h3><p>NumPy数组元素是通过数组的索引和切片来访问和修改的，因此索引和切片是NumPy中最重要、最常用的操作。</p><p>1．索引<br>所谓数组的索引，即用于标记数组中对应元素的唯一数字，从0开始，即数组中的第一个元素的索引是0，依次类推。NumPy数组可以使用标准Python语法x[obj]的语法对数组进行索引，其中x是数组，obj是选择方式。</p><p>【实例4.15】　查找一维数组索引为0的元素。（实例位置：资源包\TM\sl\4\15）<br>查找数组n1索引为0的元素，具体代码如下：</p><pre><code class="hljs"> import numpy as np n1=np.array([1,2,3])  #创建一维数组 print(n1[0])</code></pre><p>运行结果如下：</p><p>1</p><p>2．切片式索引<br>数组的切片可以理解为对数组的分割，按照等分或者不等分，将一个数组切割为多个片段，与Python中列表的切片操作一样。NumPy中用冒号分隔切片参数来进行切片操作，语法如下：</p><pre><code class="hljs"> [start:stop:step]</code></pre><p>参数说明：　</p><p>start：起始索引，若不写任何值，则表示从0开始的全部索引。　</p><p>stop：终止索引，若不写任何值，则表示直到末尾的全部索引。　</p><p>step：步长。<br>例如，对数组n1进行一系列切片式索引操作的示意图如图4.15所示。</p><p><img src="/2020/05/27/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211118055256979.png" alt="image-20211118055256979"></p><p>​                                                                                图4.15　切片式索引示意图</p><p>【实例4.16】　获取数组中某范围内的元素。（实例位置：资源包\TM\sl\4\16）<br>按照图4.15所示的切片式索引操作获取数据中某范围的元素，具体代码如下：<br>运行结果如下：</p><pre><code class="hljs"> 1 2 [1 2] [2 3]</code></pre><p>[1 2]<br>切片式索引操作需要注意以下几点。<br>（1）索引是左闭右开区间，如上述代码中的n1[0:2]，只能取到索引从0～1的元素，而取不到索引为2的元素。<br>（2）当没有start参数时，代表从索引0开始取数，如上述代码中的n1[:2]。<br>（3）start、stop和step 3个参数都可以是负数，代表反向索引。以step参数为例，如图4.16所示。</p><p><img src="/2020/05/27/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211118055352405.png" alt="image-20211118055352405"></p><p>​                                                                                      图4.16　反向索引示意图</p><p>【实例4.17】　使用不同的切片式索引操作获取数组中的元素。（实例位置：资源包\TM\sl\4\17）<br>分别演示start、stop、step 3种索引的切片场景，具体代码如下：</p><p><img src="/2020/05/27/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211118055419253.png" alt="image-20211118055419253"></p><p>运行结果如下：</p><pre><code class="hljs"> [0 1 2 3 4 5 6 7 8 9] [0 1 2] [3 4 5] [6 7 8 9] [0 1 2 3 4 5 6 7 8 9] [0 1 2 3 4 5 6 7 8 9] [0 2 4 6 8] [1 6] [2 8] [9 8 7 6 5 4 3 2 1 0] [9 8] [7 6] [5 4 3 2 1 0]</code></pre><p>3．二维数组索引<br>二维数组索引可以使用array[n,m]的方式，以逗号分隔，表示第n个数组的第m个元素。<br>例如，创建一个3行4列二维数组，实现简单的索引操作，效果如图4.17所示。</p><p><img src="/2020/05/27/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211118055517374.png" alt="image-20211118055517374"></p><p>图4.17　二维数组索引示意图</p><p>【实例4.18】　用3种方式获取二维数组中的元素。（实例位置：资源包\TM\sl\4\18）<br>分别获取二维数组中索引为1的元素、第2行第3列的元素、索引为-1的元素，具体代码如下：</p><pre><code class="hljs"> import numpy as np #创建3行4列的二维数组 n=np.array([[0,1,2,3],[4,5,6,7],[8,9,10,11]]) print(n[1]) print(n[1,2]) print(n[-1])</code></pre><p>运行结果如下：</p><pre><code class="hljs"> [4 5 6 7] 6 [ 8  9 10 11]</code></pre><p>上述代码中，n[1]表示第2个数组，n[1,2]表示第2个数组第3个元素，它等同于n[1][2]，表示数组n中第2行第3列的值，即n[1][2]先索引第一个维度得到一个数组，然后在此基础上再索引。</p><p>4．二维数组切片式索引<br>二维数组也支持切片式索引操作，如图4.18所示就是获取二维数组中某一块区域的索引。</p><p><img src="/2020/05/27/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211118055605378.png" alt="image-20211118055605378"></p><p>​                                                              图4.18　二维数组切片式索引示意图</p><p>【实例4.19】　对二维数组进行切片式索引操作。（实例位置：资源包\TM\sl\4\19）<br>参照图4.18创建二维数组，对该数组进行切片式索引操作，具体代码如下：</p><pre><code class="hljs"> import numpy as np # 创建3行3列的二维数组 n = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) print(n[:2, 1:]) print(n[1, :2]) print(n[:2, 2]) print(n[:, :1])</code></pre><p>运行结果如下：</p><pre><code class="hljs"> [[2 3]  [5 6]] [4 5] [3 6] [[1]  [4]  [7]]注意</code></pre><p>数组索引、像素行列和像素坐标的关系如下。</p><p>数组行索引=像素所在行数-1=像素纵坐标。<br>数组列索引=像素所在列数-1=像素横坐标。</p><h3 id="4-2-6-创建图像"><a href="#4-2-6-创建图像" class="headerlink" title="4.2.6　创建图像"></a>4.2.6　创建图像</h3><p>在OpenCV中，黑白图像实际上就是一个二维数组，彩色图像是一个三维数组。数组中每个元素就是图像对应位置的像素值。因此修改图像像素的操作实际上就是修改数组的操作。本节将介绍几个在OpenCV中常用的操作。</p><p>1．创建黑白图像<br>在黑白图像中，像素值为0表示纯黑，像素值为255表示纯白。</p><p>【实例4.20】　创建纯黑图像。（实例位置：资源包\TM\sl\4\20）<br>创建一个100行、200列（即宽200、高100）的数组，数组元素格式为无符号8位整数，用0填充整个数组，将该数组当作图像显示出来，具体代码如下：</p><p><img src="/2020/05/27/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211118055711105.png" alt="image-20211118055711105"></p><p>运行结果如图4.19所示。</p><p><img src="/2020/05/27/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211118055728732.png" alt="image-20211118055728732"></p><p>​                                                                                  图4.19　宽200、高100的纯黑图像<br>创建纯白图像有两种方式：第一种是先纯黑图像，然后将图像中所有的像素值改为255；第二种使用NumPy提供的ones()方法创建一个像素值均为1的数组，然后让数组乘以255。</p><p>【实例4.21】　创建纯白图像。（实例位置：资源包\TM\sl\4\21）<br>创建一个100行、200列（即宽200、高100）的数组，数组元素格式为无符号8位整数，用1填充整个数组，然后让数组乘以255，最后将该数组当作图像显示出来，具体代码如下：</p><p><img src="/2020/05/27/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211118055838709.png" alt="image-20211118055838709"></p><p>运行结果如图4.20所示。</p><p><img src="/2020/05/27/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211118055855352.png" alt="image-20211118055855352"></p><p>​                                                                         图4.20　宽200、高100的纯白图像<br>通过切片式索引操作可以修改图像中指定区域内的像素，从而达到修改图像内容的效果，下面通过实例来展示。</p><p>【实例4.22】　在黑图像内部绘制白色矩形。（实例位置：资源包\TM\sl\4\22）<br>先绘制纯黑图像作为背景，然后使用切片式索引操作将图像中横坐标为50<del>100、纵坐标为25</del>75的矩形区域颜色改为纯白色，具体代码如下：</p><p><img src="/2020/05/27/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211118055923134.png" alt="image-20211118055923134"></p><p>运行结果如图4.21所示。</p><p><img src="/2020/05/27/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211118055940627.png" alt="image-20211118055940627"></p><p>​                                                                              图4.21　在黑色图像内部绘制白色矩形<br>若将切片式索引操作引入循环内，则可以绘制带有规律的几何图像，下面通过实例来展示。</p><p>【实例4.23】　创建黑白相间的图像。（实例位置：资源包\TM\sl\4\23）<br>先绘制纯黑图像作为背景，然后在循环中使用切片式索引操作绘制黑白间隔图像，具体代码如下：</p><p><img src="/2020/05/27/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211118060035152.png" alt="image-20211118060035152"></p><p>运行结果如图4.22所示。</p><p><img src="/2020/05/27/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211118060052474.png" alt="image-20211118060052474"></p><p>​                                                                                 图4.22　黑白相间的图像</p><p>2．创建彩色图像<br>以上实例演示的都是用二维数组表示的黑白图像，而当显示生活中丰富多彩的颜色需要引入光谱三基色的概念时，无法用二维数组表示，而要用到三维数组。OpenCV中彩色图像默认为BGR格式，彩色图像的第三个索引表示的就是蓝、绿、红3种颜色的分量。</p><p>【实例4.24】　创建彩色图像。（实例位置：资源包\TM\sl\4\24）<br>创建彩色图像数组时要将数组创建成三维数组，元素类型仍然为无符号8位整数。创建好表示纯黑图像的三维数组后，复制出3个副本，3个副本分别修改最后一个索引代表的元素值。根据BGR的顺序，索引0表示蓝色分量，索引1表示绿色分量，索引2表示红色分量，让3个副本分别显示纯蓝、纯绿和纯红，具体代码如下：</p><p><img src="/2020/05/27/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211118060117266.png" alt="image-20211118060117266"></p><p>运行结果如图4.23～图4.25所示。</p><p><img src="/2020/05/27/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211118060249284.png" alt="image-20211118060249284"></p><pre><code class="hljs">         图4.23　纯蓝图像图                 4.24　纯绿图像图                                 4.25　纯红图像</code></pre><p>3．创建随机图像<br>随机图像是指图像中每一个像素值都是随机生成的，因为像素之间不会组成有效的视觉信息，所以这样的图像看上去就像杂乱无章的沙子。虽然随机图像没有任何视觉信息，但对于图像处理技术仍然很重要，毫无规律的像素数组被称为干扰图像的噪声，可以当作图像加密的密钥。<br>下面介绍如何利用NumPy创建随机图像。</p><p>【实例4.25】　创建随机像素的雪花点图像。（实例位置：资源包\TM\sl\4\25）<br>使用NumPy提供的random.randint()方法就可以创建随机数组，将随机值的取值范围设定在0～256（即像素值范围），元素类型设定为无符号8位整数，具体代码如下：</p><p><img src="/2020/05/27/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211118060413130.png" alt="image-20211118060413130"></p><p>运行结果如图4.26所示。<br>这个实例演示的是随机的黑白图像，random.randint()方法在指定数组行列后默认创建的是二维数组，如果创建的是三维数组，就可以获得随机彩色图像。创建三维随机数组仅需修改size参数中的维度参数，修改后的代码如下：</p><pre><code class="hljs"> img = np.random.randint(256, size=(height, width, 3), dtype=np.uint8)</code></pre><p>再次运行后随机彩色图像效果如图4.27所示。</p><p><img src="/2020/05/27/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211118060503763.png" alt="image-20211118060503763"></p><p>图4.26　随机黑白图像</p><p><img src="/2020/05/27/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211118060553084.png" alt="image-20211118060553084"></p><p>图4.27　随机彩色图像</p><h3 id="4-2-7-拼接图像"><a href="#4-2-7-拼接图像" class="headerlink" title="4.2.7　拼接图像"></a>4.2.7　拼接图像</h3><p>NumPy提供了两种拼接数组的方法，分别是hstack()方法和vstack()方法。这两种拼接方法同样可用于拼接图像，下面分别介绍。1．水平拼接数组<br>hstack()方法可以对数组进行水平拼接（或叫横向拼接），其语法如下：</p><pre><code class="hljs"> array = numpy.hstack(tup)</code></pre><p>参数说明：　</p><p>tup：要拼接的数组元组。<br>返回值说明：　</p><p>array：将参数元组中的数组水平拼接后生成的新数组。<br>hstack()方法可以拼接多个数组，拼接效果如图4.28所示。被拼接的数组必须在每一个维度都具有相同的长度，也就是数组“形状相同”，例如2行2列的数组只能拼接2行2列的数组，否则会出现错误。</p><p><img src="/2020/05/27/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211118060627002.png" alt="image-20211118060627002"></p><p>图4.28　水平拼接2个数组<br>例如，创建3个一维数组，将这3个数组进行水平拼接，代码如下：</p><p>import numpy as np<br>     a = np.array([1, 2, 3])<br>     b = np.array([4, 5, 6])<br>     c = np.array([7, 8, 9])<br>     result = np.hstack((a, b, c))<br>     print(result)<br>运行结果如下：</p><pre><code class="hljs"> [1 2 3 4 5 6 7 8 9]</code></pre><p>从这个结果可以看出，一维数组进行水平拼接之后，会生成一个较长的、包含所有元素的新一维数组。2．垂直拼接数组<br>vstack()方法可以对数组进行垂直拼接（或叫纵向拼接），其语法如下：</p><pre><code class="hljs"> array = numpy.vstack(tup)</code></pre><p>参数说明：　</p><p>tup：要拼接的数组元组。<br>返回值说明：　</p><p>array：将参数元组中的数组垂直拼接后生成的新数组。<br>vstack()方法可以拼接多个数组，拼接效果如图4.29所示。被拼接的数组的格式要求与hstack()方法相同。</p><p><img src="/2020/05/27/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211118060727628.png" alt="image-20211118060727628"></p><p>图4.29　垂直拼接2个数组<br>例如，创建3个一维数组，将这3个数组进行垂直拼接，代码如下：</p><pre><code class="hljs"> import numpy as np a = np.array([1, 2, 3]) b = np.array([4, 5, 6]) c = np.array([7, 8, 9]) result = np.vstack((a, b, c)) print(result)</code></pre><p>运行结果如下：</p><pre><code class="hljs"> [[1 2 3]  [4 5 6]  [7 8 9]]</code></pre><p>从这个结果可以看出，一维数组进行垂直拼接后，生成一个三维数组，每一个被拼接的一维数组都形成三维数组中的一行。</p><p>3．在图像处理中的应用</p><p>在OpenCV中，图像就是一个二维或三维的像素数组，这些数组同样可以被NumPy拼接，下面通过一个实例展示图像拼接的效果。</p><p>【实例4.26】　按照水平和垂直2种方式拼接2幅图像。（实例位置：资源包\TM\sl\4\26）<br>读取一幅图像，让该图像拼接自身图像，分别用水平和垂直2种方式拼接，具体代码如下：</p><p><img src="/2020/05/27/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211118060817990.png" alt="image-20211118060817990"></p><p>运行效果如图4.30和图4.31所示。</p><p><img src="/2020/05/27/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211118061009035.png" alt="image-20211118061009035"></p><p>​                                                            图4.30　水平拼接的效果</p><p><img src="/2020/05/27/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211118061107773.png" alt="image-20211118061107773"></p><p>​                                                                                  图4.31　垂直拼接的效果</p><h2 id="4-3-小结"><a href="#4-3-小结" class="headerlink" title="4.3　小结"></a>4.3　小结</h2><p>本章详细讲解了像素和使用NumPy模块操作像素两个方面的内容。</p><p>注意掌握以下几个内容：一是在表示图像某一个像素的坐标的时候，正确的表示方式是（垂直像素，水平像素）；二是在OpenCV中，彩色图像的通道顺序是B→G→R；三是重点掌握且灵活运用NumPy模块实现图像的创建和图像的拼接。</p><h1 id="第5章-色彩空间与通道"><a href="#第5章-色彩空间与通道" class="headerlink" title="第5章　色彩空间与通道"></a>第5章　色彩空间与通道</h1><p>色彩是人类的眼睛对于不同频率的光线的不同感受，不同频率的光线既是客观存在的又是人类主观感知的。为了表示这些不同频率的光线的色彩，人类建立了多种色彩模型，把这些色彩模型称作色彩空间。OpenCV中的BGR色彩空间有3个通道，即表示蓝色的B通道、表示绿色的G通道和表示红色的R通道。本章将具体讲解色彩空间和通道，以及二者之间的紧密联系。</p><p><img src="/2020/05/27/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211118061230858.png" alt="image-20211118061230858"></p><h2 id="5-1-色彩空间"><a href="#5-1-色彩空间" class="headerlink" title="5.1　色彩空间"></a>5.1　色彩空间</h2><p>虽然Photoshop把一幅彩色图像的色彩空间默认为RGB色彩空间，但是OpenCV把一幅彩色图像的色彩空间默认为BGR色彩空间，这是因为OpenCV拆分一幅彩色图像的通道后，默认的通道顺序是B→G→R。熟悉了BGR色彩空间后，本节将结合如图5.1所示的图像（本书彩色图像见资源包），介绍另外两个比较常见的色彩空间：GRAY色彩空间和HSV色彩空间。</p><p><img src="/2020/05/27/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87/1.1-16371871184721.jpg" alt="1.1"></p><p>​                                                                                                图5.1　一幅彩色图像</p><h3 id="5-1-1-GRAY色彩空间"><a href="#5-1-1-GRAY色彩空间" class="headerlink" title="5.1.1　GRAY色彩空间"></a>5.1.1　GRAY色彩空间</h3><p>1．什么是GRAY色彩空间<br>GRAY色彩空间通常指的是灰度图像，灰度图像是一种每个像素都是从黑到白，被处理为256个灰度级别的单色图像。这256个灰度级别分别用区间[0, 255]中的数值表示。其中，“0”表示纯黑色，“255”表示纯白色，0～255的数值表示</p><p>不同亮度（即色彩的深浅程度）的深灰色或者浅灰色。因此，一幅灰度图像也能够展现丰富的细节信息，如图5.2所示。</p><p><img src="/2020/05/27/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211118061419144.png" alt="image-20211118061419144"></p><p>​                                                   图5.2　一幅灰度图像</p><p>2．从BGR色彩空间转换到GRAY色彩空间<br>读者朋友很容易就会发现，图5.1和图5.2是同一幅图像。只不过，图5.1是彩色图像，而图5.2是灰度图像。OpenCV能够将同一幅图像从一个色彩空间转换到另一个色彩空间。例如，图5.1从BGR色彩空间转换到图5.2所示的GRAY色彩空间。<br>那么，OpenCV是如何实现从BGR色彩空间转换到GRAY色彩空间的呢？答案就是OpenCV中用于转换图像色彩空间的cvtColor()方法，其语法格式如下：</p><pre><code class="hljs"> dst = cv2.cvtColor(src, code)</code></pre><p>参数说明：　</p><p>dst：转换后的图像。　</p><p>src：转换前的初始图像。　</p><p>code：色彩空间转换码。</p><p>说明<br>当图像从BGR色彩空间转换到GRAY色彩空间时，常用的色彩空间转换码是cv2.COLOR_BGR2GRAY。</p><p>【实例5.1】　从BGR色彩空间转换到GRAY色彩空间。（实例位置：资源包\TM\sl\5\01）<br>编写一个程序，将图5.1从BGR色彩空间转换到GRAY色彩空间，代码如下：</p><p><img src="/2020/05/27/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211118061511239.png" alt="image-20211118061511239"></p><p>上述代码的运行结果如图5.3所示。</p><p><img src="/2020/05/27/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211118061629219.png" alt="image-20211118061629219"></p><p>​                                                      图5.3从BGR色彩空间转换到GRAY色彩空间</p><p>说明<br>虽然色彩空间类型转换是双向的，而且OpenCV也提供了cv2.COLOR_GRAY2BGR（从GRAY色彩空间转换到BGR色彩空间）和cv2.COLOR_ BGR2GRAY（从BGR色彩空间转换到GRAY色彩空间）2个色彩空间转换码，但是灰度图像是无法转换成彩色图像的。这是因为在彩色图像转换成灰度图像的过程中，丢失了颜色比例（即红色、绿色和蓝色之间的混合比例）。这些比例一旦丢失，就再也找不回来了。</p><h3 id="5-1-2-HSV色彩空间"><a href="#5-1-2-HSV色彩空间" class="headerlink" title="5.1.2　HSV色彩空间"></a>5.1.2　HSV色彩空间</h3><p>1．什么是HSV色彩空间<br>BGR色彩空间是基于三基色而言的，三基色指的是红色、绿色和蓝色。而HSV色彩空间则是基于色调、饱和度和亮度而言的。<br>其中，色调（H）是指光的颜色，例如，彩虹中的赤、橙、黄、绿、青、蓝、紫分别表示不同的色调，如图5.4所示。在OpenCV中，色调在区间[0, 180]内取值。例如，代表红色、黄色、绿色和蓝色的色调值分别为0、30、60和120。<br>饱和度（S）是指色彩的深浅。在OpenCV中，饱和度在区间[0, 255]内取值。当饱和度为0时，图像将变为灰度图像。例如，图5.1是用手机拍摄的原图像，图5.5是把图5.1的饱和度调为0时的效果。</p><p><img src="/2020/05/27/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211118061921187.png" alt="image-20211118061921187"></p><p>​                                                                                        图5.4　彩虹中的色调</p><p><img src="/2020/05/27/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211118061951173.png" alt="image-20211118061951173"></p><p>​                                                                          图5.5　图5.1的饱和度调为0时的效果<br>如图5.6所示，亮度（V）是指光的明暗。与饱和度相同，在OpenCV中，亮度在区间[0, 255]内取值。亮度值越大，图像越亮；当亮度值为0时，图像呈纯黑色。</p><p><img src="/2020/05/27/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211118062031261.png" alt="image-20211118062031261"></p><p>​                                                                                                 图5.6　光的明暗</p><p>2．从BGR色彩空间转换到HSV色彩空间<br>OpenCV提供的cvtColor()方法不仅能将图像从BGR色彩空间转换到GRAY色彩空间，还能将图像从BGR色彩空间转换到HSV色彩空间。当图像在BGR色彩空间和HSV色彩空间之间转换时，常用的色彩空间转换码是cv2.COLOR_BGR2HSV和cv2.COLOR_HSV2BGR。</p><p>【实例5.2】　从BGR色彩空间转换到HSV色彩空间。（实例位置：资源包\TM\sl\5\02）<br>编写一个程序，将图5.1从BGR色彩空间转换到HSV色彩空间，代码如下：</p><pre><code class="hljs"> import cv2 image = cv2.imread(&quot;D:/5.1.jpg&quot;) cv2.imshow(&quot;5.1&quot;, image)                 # 显示图5.1 # 将图5.1从BGR色彩空间转换到HSV色彩空间 hsv_image = cv2.cvtColor(image, cv2.COLOR_BGR2HSV) cv2.imshow(&quot;HSV&quot;, hsv_image)             # 用HSV色彩空间显示的图像 cv2.waitKey() cv2.destroyAllWindows()</code></pre><p>上述代码的运行结果如图5.7所示。</p><p><img src="/2020/05/27/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211118062234401.png" alt="image-20211118062234401"></p><p>图5.7　把图5.1从BGR色彩空间转换到HSV色彩空间</p><h2 id="5-2-通道"><a href="#5-2-通道" class="headerlink" title="5.2　通道"></a>5.2　通道</h2><p>在BGR色彩空间中，图像的通道由B通道、G通道和R通道构成。本节将介绍如何使用OpenCV提供的方法拆分和合并通道。</p><h3 id="5-2-1-拆分通道"><a href="#5-2-1-拆分通道" class="headerlink" title="5.2.1　拆分通道"></a>5.2.1　拆分通道</h3><p>为了拆分图像中的通道，OpenCV提供了split()方法。</p><p>1．拆分一幅BGR图像中的通道<br>当使用split()方法拆分一幅BGR图像中的通道时，split()方法的语法如下：</p><pre><code class="hljs"> b, g, r = cv2.split(bgr_image)</code></pre><p>参数说明：　</p><p>b：B通道图像。　</p><p>g：G通道图像。</p><p>r：R通道图像。　</p><p>bgr_image：一幅BGR图像。</p><p>【实例5.3】　拆分一幅BGR图像中的通道。（实例位置：资源包\TM\sl\5\03）<br>编写一个程序，先拆分图5.1中的通道，再显示拆分后的通道图像，代码如下：</p><p><img src="/2020/05/27/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211118062257967.png" alt="image-20211118062257967"></p><p>运行上述代码后，得到如图5.8所示的4个窗口。其中，图5.8（a）是原图像（见图5.1），图5.8（b）是图5.1中的B通道图像，图5.8（c）是图5.1中的G通道图像，图5.8（d）是图5.1中的R通道图像。</p><p>图5.8　拆分BGR图像中通道的效果</p><p>R通道是红色通道，G通道是绿色通道，B通道是蓝色通道。但是图5.9中的B通道图像、G通道图像和R通道图像是3幅不同亮度的灰度图像，这是为什么呢？<br>原因是当程序执行到cv2.imshow(“B”, b)时，原图像B、G、R这3个通道的值都会被修改为B通道图像的值，即(b, b, b)。同理，当程序执行到cv2.imshow(“G”, g)和cv2.imshow(“R”, r)时，原图像R、G、B这3个通道的值将依次被修改为G通道图像的值(g, g, g)和R通道图像的值(r, r, r)。对于BGR图像，只要B、G、R这3个通道的值都相同，就可以得到灰度图像。</p><p>2．拆分一幅HSV图像中的通道<br>当使用split()方法拆分一幅HSV图像中的通道时，split()方法的语法如下：</p><pre><code class="hljs"> h, s, v = cv2.split(hsv_image)</code></pre><p>参数说明：　</p><p>h：H通道图像。　</p><p>s：S通道图像。　</p><p>v：V通道图像。　</p><p>hsv_image：一幅HSV图像。</p><p>【实例5.4】　拆分一幅HSV图像中的通道。（实例位置：资源包\TM\sl\5\04）<br>编写一个程序，首先将图5.1从BGR色彩空间转换到HSV色彩空间，然后拆分得到的HSV图像中的通道，最后显示拆分后的通道图像，代码如下：</p><p><img src="/2020/05/27/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211118062529046.png" alt="image-20211118062529046"></p><p>运行上述代码后，得到如图5.9所示的4个窗口。其中，图5.9（a）是原图像（见图5.1），图5.9（b）是图5.1中的H通道图像，图5.9（c）是图5.1中的S通道图像，图5.9（d）是图5.1中的V通道图像。</p><p><img src="/2020/05/27/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211118062558943.png" alt="image-20211118062558943"></p><p>​                                                                    图5.9　拆分HSV图像中通道的效果</p><h3 id="5-2-2-合并通道"><a href="#5-2-2-合并通道" class="headerlink" title="5.2.2　合并通道"></a>5.2.2　合并通道</h3><p>合并通道是拆分通道的逆过程。以图5.1为例，虽然拆分通道后，会得到3幅不同亮度的灰度图像；但是将这3幅不同亮度的灰度图像合并后，又重新得到图5.1。下面将使用OpenCV中用于合并通道的merge()方法，验证一下上述说法。</p><p>1．合并B通道图像、G通道图像和R通道图像<br>当使用merge()方法按B→G→R的顺序合并通道时，merge()方法的语法如下：</p><pre><code class="hljs"> bgr = cv2.merge([b, g, r])</code></pre><p>参数说明：　</p><p>bgr：按B→G→R的顺序合并通道后得到的图像。</p><p>b：B通道图像。</p><p>g：G通道图像。　</p><p>r：R通道图像。</p><p>【实例5.5】　合并B通道图像、G通道图像和R通道图像。（实例位置：资源包\TM\sl\5\05）<br>编写一个程序，按B→G→R的顺序对图5.1执行先拆分通道，再合并通道，代码如下：</p><p><img src="/2020/05/27/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211118062834827.png" alt="image-20211118062834827"></p><p>上述代码的运行结果如图5.10所示。</p><p><img src="/2020/05/27/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211118062855098.png" alt="image-20211118062855098"></p><p>​                                                                       图5.10　按B→G→R的顺序合并通道后的图像</p><p>2．合并H通道图像、S通道图像和V通道图像<br>当使用merge()方法合并H通道图像、S通道图像和V通道图像时，merge()方法的语法如下：</p><pre><code class="hljs"> hsv = cv2.merge([h, s, v])</code></pre><p>参数说明：　</p><p>hsv：合并H通道图像、S通道图像和V通道图像后得到的图像。　</p><p>h：H通道图像。　</p><p>s：S通道图像。　</p><p>v：V通道图像。</p><p>【实例5.6】　合并H通道图像、S通道图像和V通道图像。（实例位置：资源包\TM\sl\5\06）<br>编写一个程序，首先将图5.1从BGR色彩空间转换到HSV色彩空间，然后拆分得到的HSV图像中的通道，接着合并拆分后的通道图像，最后将合并通道后的图像从HSV色彩空间转换到BGR色彩空间，代码如下：</p><p><img src="/2020/05/27/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211118062943783.png" alt="image-20211118062943783"></p><p>上述代码的运行结果如图5.11所示。</p><p><img src="/2020/05/27/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211118063132901.png" alt="image-20211118063132901"></p><p>​                                                         图5.11　合并H通道、S通道和V通道图像后的图像</p><p>说明<br>实例5.5和实例5.6分别对BGR色彩空间和HSV色彩空间的图5.1执行先拆分通道，再合并通道的操作，执行操作后的结果图像均与图5.1保持一致，印证了“以图5.1为例，虽然拆分通道后，得到3幅不同亮度的灰度图像，但是将这3幅不同亮度的灰度图像合并后，又重新得到图5.1”这一说法的正确性。</p><h3 id="5-2-3-综合运用拆分通道和合并通道"><a href="#5-2-3-综合运用拆分通道和合并通道" class="headerlink" title="5.2.3　综合运用拆分通道和合并通道"></a>5.2.3　综合运用拆分通道和合并通道</h3><p>在HSV色彩空间内，如果保持其中两个通道的值不变，调整第3个通道的值，会得到相应的艺术效果。</p><p>【实例5.7】　只把H通道的值调整为180。（实例位置：资源包\TM\sl\5\07）<br>编写一个程序，首先将图5.1从BGR色彩空间转换到HSV色彩空间；然后拆分HSV图像中的通道；接着让S通道和V通道的值保持不变，把H通道的值调整为180；再接着合并拆分后的通道图像，把这个图像从HSV色彩空间转换到BGR色彩空间；最后显示得到的BGR图像。代码如下：</p><p><img src="/2020/05/27/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211118063157781.png" alt="image-20211118063157781"></p><p>上述代码的运行结果如图5.12所示。</p><p><img src="/2020/05/27/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211118063242770.png" alt="image-20211118063242770"></p><p>​                                                 图5.12　原图像把H通道的值调整为180的效果<br>如果让H通道和S通道的值保持不变，把V通道的值调整为255，会得到什么样的效果呢？把实例5.7第8行代码：</p><pre><code class="hljs"> h[:, :] = 180 # 将H通道的值调整为180</code></pre><p>修改为如下代码：</p><pre><code class="hljs"> v[:, :] = 255 # 将V通道的值调整为255</code></pre><p>上述代码的运行结果如图5.13所示。</p><p><img src="/2020/05/27/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211118063302849.png" alt="image-20211118063302849"></p><p>​                                                     图5.13　原图像把V通道的值调整为255的效果<br>如果让H通道和V通道的值保持不变，把S通道的值调整为255，又会得到什么样的效果呢？把实例5.7第8行代码：</p><pre><code class="hljs"> h[:, :] = 180 # 将H通道的值调整为180</code></pre><p>修改为如下代码：</p><pre><code class="hljs"> s[:, :] = 255 # 将S通道的值调整为255</code></pre><p>上述代码的运行结果如图5.14所示。</p><p><img src="/2020/05/27/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211118063503250.png" alt="image-20211118063503250"></p><p>图5.14　原图像把S通道的值调整为255的效果</p><h3 id="5-2-4-alpha通道"><a href="#5-2-4-alpha通道" class="headerlink" title="5.2.4　alpha通道"></a>5.2.4　alpha通道</h3><p>BGR色彩空间包含了3个通道，即B通道、G通道和R通道。OpenCV在BGR色彩空间的基础上，又增加了一个用于设置图像透明度的A通道，即alpha通道。这样，形成一个由B通道、G通道、R通道和A通道4个通道构成的色彩空间，即BGRA色彩空间。在BGRA色彩空间中，alpha通道在区间[0, 255]内取值；其中，0表示透明，255表示不透明。</p><p>【实例5.8】　调整A通道的值。（实例位置：资源包\TM\sl\5\08）<br>编写一个程序，首先将图5.1从BGR色彩空间转换到BGRA色彩空间；然后拆分BGRA图像中的通道；接着把BGRA图像的透明度调整为172后，合并拆分后的通道图像；再接着把BGRA图像的透明度调整为0后，合并拆分后的通道图像；最后分别显示BGRA图像、透明度为172的BGRA图像和透明度为0的BGRA图像，代码如下：</p><p><img src="/2020/05/27/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211118063529768.png" alt="image-20211118063529768"></p><p>运行上述代码后，得到如图5.15所示的3个窗口。其中，图5.15（a）是BGRA图像（见图5.1），图5.15（b）是把BGRA图像的透明度调整为172后的图像，图5.15（c）是把BGRA图像的透明度调整为0后的图像。</p><p><img src="/2020/05/27/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211118063625877.png" alt="image-20211118063625877"></p><p>​                                                                              图5.15　调整A通道的值后的效果<br>虽然在代码中已经调整了BGRA图像中A通道的值，但是显示图像的效果是一样的。为了显示3幅图像的不同效果，需要使用imwrite()方法将3幅图像保存在D盘根目录下，代码如下：</p><p><img src="/2020/05/27/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211118063708689.png" alt="image-20211118063708689"></p><p>运行上述代码后，在D盘根目录下，依次双击打开bgra_image.png、bgra_172.png和bgra_0.png，3幅图像的显示效果如图5.16～图5.18所示。<br><img src="/2020/05/27/shujufenxi/pythonOpencv%E5%9F%BA%E7%A1%80%E7%AF%87/image-20211118063742930.png" alt="image-20211118063742930"><br>PNG图像是一种典型的4通道（即B通道、G通道、R通道和A通道)图像，因此被保存的3幅图像的格式均为.png。</p><h2 id="5-3-小结"><a href="#5-3-小结" class="headerlink" title="5.3　小结"></a>5.3　小结</h2><p>当使用cvtColor()方法转换色彩空间时，虽然彩色图像能够转换为灰度图像，但是灰度图像不能转换为彩色图像。对于HSV色彩空间，如果保持其中两个通道的值不变，调整第3个通道的值，会得到相应的艺术效果。为了能够显示艺术效果，要把合并通道后的图像从HSV色彩空间转换到BGR色彩空间。当使用alpha通道设置图像的透明度时，为了能够直观地看到图像的透明效果，需先保存已经设置透明度的图像。</p>]]></content>
    
    
    <categories>
      
      <category>数据分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>openCv</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>scikit-learn初级</title>
    <link href="/2020/05/21/shujufenxi/scikit-learn%E5%88%9D%E7%BA%A7/"/>
    <url>/2020/05/21/shujufenxi/scikit-learn%E5%88%9D%E7%BA%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="第一章-scikit-learn初级"><a href="#第一章-scikit-learn初级" class="headerlink" title="第一章 scikit-learn初级"></a>第一章 scikit-learn初级</h1><p>课程介绍：本阶段课程学习人工智能机器学习入门算法以及opencv人脸识别基础。机器学习方向主要通过Scikit-learn模块来学习。人脸识别基础主要通过opencv来实现与了解。</p><h1 id="scikit-learn"><a href="#scikit-learn" class="headerlink" title="scikit-learn"></a>scikit-learn</h1><p>英文官网：<a href="https://scikit-learn.org/stable/index.html">https://scikit-learn.org/stable/index.html</a></p><p>中文官网：<a href="https://sklearn.apachecn.org/#/">https://sklearn.apachecn.org/#/</a></p><p>官网：<a href="https://scikit-learn.org/stable/index.html">https://scikit-learn.org/stable/index.html</a></p><h2 id="1-1-Scikit-Learn简介"><a href="#1-1-Scikit-Learn简介" class="headerlink" title="1.1 Scikit-Learn简介"></a>1.1 Scikit-Learn简介</h2><p>Scikit-Learn（简称Sklearn）是Python的第三方模块，它是机器学习领域中知名的Python模块之一，它对常用的机器学习算法进行了封装，包括回归（Regression）、降维（Dimensionality Reduction）、分类（Classification）和聚类（Clustering）四大机器学习算法。Scikit-Learn具有以下特点。　</p><p>简单高效的数据挖掘和数据分析工具。　</p><p>让每个人能够在复杂环境中重复使用。　</p><p>Scikit-Learn是Scipy模块的扩展，是建立在NumPy和Matplotlib模块的基础上的。利用这几大模块的优势，可以大大提高机器学习的效率。　</p><p>开源，采用BSD协议，可用于商业。</p><h2 id="1-2安装Scikit-Learn"><a href="#1-2安装Scikit-Learn" class="headerlink" title="1.2安装Scikit-Learn"></a>1.2安装Scikit-Learn</h2><p>Scikit-Learn安装要求如下。　</p><p>Python版本：高于2.7。　</p><p>NumPy版本：高于1.10.2。　</p><p>SciPy版本：高于0.13.3。</p><p>如果已经安装NumPy和Scipy，那么安装Scikit-Learn最简单的方法是使用pip工具安装。命令如下：</p><p>pip install -U scikit-learn<br>或者使用conda，命令如下：</p><p>conda install scikit-learn<br>还可以在PyCharm开发环境中安装。运行PyCharm，选择File→Settings命令，打开Settings对话框，选择Project Interpreter选项，然后单击+（添加）按钮，打开Available Packages对话框，在搜索文本框中输入需要添加的模块名称，例如scikit-learn，然后在列表中选择需要安装的模块，如图10.1所示。单击Install Package按钮即可实现Scikit-Learn模块的安装。</p><p><img src="/2020/05/21/shujufenxi/scikit-learn%E5%88%9D%E7%BA%A7/image-20211101095419172.png" alt="image-20211101095419172"></p><p>​                                                                                  图1.1　安装Scikit-Learn<br>这里需要注意：尽量选择安装0.21.2版本，否则运行程序可能会出现因为模块版本不适合而导致程序出现错误提示——“找不到指定的模块”。</p><p>查看是否安装成功 pip list</p><p>或者</p><p>import sklearn</p><p>sklearn.<strong><strong>version</strong></strong></p><h2 id="1-3-概念"><a href="#1-3-概念" class="headerlink" title="1.3  概念"></a>1.3  概念</h2><p>scikit-learn库主要功能分六大部分：分类，回归，聚类，降维，模型选择，数据预处理。</p><h3 id="1-3-1-监督学习"><a href="#1-3-1-监督学习" class="headerlink" title="1.3.1 监督学习"></a>1.3.1 监督学习</h3><p><strong>监督学习（supervised learning）</strong>的任务是学习一个模型，使模型能够对任意给定的输入，对其相应的输出做出一个好的预测。</p><p>即：利用训练数据集学习一个模型，再用模型对测试样本集进行预测。</p><p>通俗理解：每个数据点都被标记或关联一个类别或者分值。</p><p>例（类别）：输入一张图片，判断该图片中的动物是猫还是狗；</p><p>例（分值）：通过大量数据预测一辆二手车的出售价格；</p><p>监督学习的目的就是学习大量的样本（称作训练数据），从而对未来的数据点做出预测（称作测试数据）。</p><p>分类和回归</p><p>从根本上来说，分类是预测一个标签，回归是预测一个数量。</p><ul><li><p>分类是给一个样本预测离散型类别标签的问题。</p></li><li><p>回归是给一个样本预测连续输出量的问题。</p></li></ul><h3 id="1-3-2-非监督学习"><a href="#1-3-2-非监督学习" class="headerlink" title="1.3.2 非监督学习"></a>1.3.2 非监督学习</h3><p><strong>非监督学习（unsupervised learning）</strong>为直接对数据进行建模。没有给定事先标记过的训练范例，所用的数据没有属性或标签这一概念。事先不知道输入数据对应的输出结果是什么。</p><p>自动对输入的资料进行分类或分群，以寻找数据的模型和规律。</p><p>例：聚类</p><h3 id="1-3-3-强化学习"><a href="#1-3-3-强化学习" class="headerlink" title="1.3.3 强化学习"></a>1.3.3 强化学习</h3><p><strong>强化学习（Reinforcement Learning）</strong>是机器学习中的一个领域，强调如何基于环境而行动，以取得最大化的预期利益。其灵感来源于心理学中的行为主义理论，即有机体如何在环境给予的奖励或惩罚的刺激下，逐步形成对刺激的预期，产生能获得最大利益的习惯性行为。</p><p>有监督学习、无监督学习、强化学习具有不同的特点：</p><ul><li>有监督学习是有一个label（标记）的，这个label告诉算法什么样的输入对应着什么样的输出，常见的算法是分类、回归等；</li><li>无监督学习则是没有label（标记），常见的算法是聚类；</li><li>强化学习强调如何基于环境而行动，以取得最大化的预期利益。</li></ul><h2 id="1-4-数据预处理"><a href="#1-4-数据预处理" class="headerlink" title="1.4  数据预处理"></a>1.4  数据预处理</h2><p>在真实的世界中，经常需要处理大量的原始数据，这些原始数据是机器学习算法无法理解的，为了让机器学习算法理解原始数据，需要对数据进行预处理。</p><h3 id="1-4-1-准备工作"><a href="#1-4-1-准备工作" class="headerlink" title="1.4.1 准备工作"></a>1.4.1 准备工作</h3><p>python进行数据预处理，需要加载两个必要的程序包。</p><p>import numpy as np<br>from sklearn import preprocessing</p><p>data = np.array([[ 3, -1.5,  2, -5.4],<br>                 [ 0,  4,  -0.3, 2.1],<br>                 [ 1,  3.3, -1.9, -4.3]])</p><h3 id="1-4-2-详细步骤"><a href="#1-4-2-详细步骤" class="headerlink" title="1.4.2 详细步骤"></a>1.4.2 详细步骤</h3><h4 id="1-均值移除（Mean-removal）"><a href="#1-均值移除（Mean-removal）" class="headerlink" title="1.均值移除（Mean removal）"></a>1.均值移除（Mean removal）</h4><p>**通常我们会把每个特征的平均值移除，以保证特征均值为0(即标准化处理)**。这样做可以消除特征彼此之间的偏差（bias)。</p><p>sklearn.preprocessing.scale()函数<br>官方文档</p><p>sklearn.preprocessing.scale(X, axis=0, with_mean=True, with_std=True, copy=True)<br>沿着某个轴标准化数据集，以均值为中心，以分量为单位方差。</p><p>参数    数据类型    意义<br>X    {array-like, sparse matrix}    以此数据为中心缩放<br>axis    int (0 by default)    沿着计算均值和标准差的轴。如果是0，独立的标准化每个特征，如果是1则标准化每个样本（即行）<br>with_mean    boolean, True by default    如果是True，缩放之前先中心化数据<br>with_std    boolean, True by default    如果是True，以单位方差法缩放数据（或者等价地，单位标准差）<br>copy    boolean, optional, default True    False：原地执行行标准化并避免复制（如果输入已经是一个numpy数组或者scipy.sparse CSC矩阵以及axis是1）</p><p>[x1,x2,x3,x4]</p><p>var=((x1-mean)^2+(x2-mean)^2+(x3-mean)^2+(x4-mean)^2)/4</p><p>std=sqrt(var)</p><p>#mean removal</p><p>data_standardized = preprocessing.scale(data)<br>print “\nMean =”, data_standardized.mean(axis=0)<br>print “Std deviation =”, data_standardized.std(axis=0)</p><p>范数：</p><h4 id="2-范围缩放（Scaling"><a href="#2-范围缩放（Scaling" class="headerlink" title="2.范围缩放（Scaling)"></a>2.范围缩放（Scaling)</h4><p>数据点中每个特征的数值范围可能变化很大，以此，有时将特征的数值范围缩放到合理的大小是非常重要的。</p><p>官网：<a href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.MinMaxScaler.html#sklearn.preprocessing.MinMaxScaler">https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.MinMaxScaler.html#sklearn.preprocessing.MinMaxScaler</a></p><p>方法介绍：</p><p>fit(): Method calculates the parameters μ and σ and saves them as internal objects.<br>解释：简单来说，就是求得训练集X的均值，方差，最大值，最小值,这些训练集X固有的属性。</p><p>transform(): Method using these calculated parameters apply the transformation to a particular dataset.<br>解释：在fit的基础上，进行标准化，降维，归一化等操作（看具体用的是哪个工具，如PCA，StandardScaler等）。</p><p>fit_transform(): joins the fit() and transform() method for transformation of dataset.<br>解释：fit_transform是fit和transform的组合，既包括了训练又包含了转换。<br>transform()和fit_transform()二者的功能都是对数据进行某种统一处理（比如标准化~N(0,1)，将数据缩放(映射)到某个固定区间，归一化，正则化等）</p><p>#min max scaling</p><p>data_scaler = preprocessing.MinMaxScaler(feature_range=(0, 1))<br>data_scaled = data_scaler.fit_transform(data)<br>print(“\nMin max scaled data:\n”, data_scaled)</p><h4 id="3-归一化（normalization"><a href="#3-归一化（normalization" class="headerlink" title="3.归一化（normalization)"></a>3.归一化（normalization)</h4><p>数据归一化用于需要对特征向量的值进行调整时，以保证每个特征向量的值都缩放到相同的数值范围。机器学习中最常用的归一化形式就是将特征向量调整为L1范数。</p><p>L1归一化：将每个数据除以L1范数(所有数据的绝对值之和)</p><p>L2归一化：将每个数据除以L2范数(所有数据的绝对值之和的平方)</p><p>L0归一化：将每个数据除以L0范数(非零数的个数)</p><p>##normalization</p><p>data_normalized = preprocessing.normalize(data, norm=’l1’)<br>print (“\nL1 normalized data:\n”, data_normalized)</p><p>这个方法经常用于确保数据点没有因为特征的基本性质而产生较大的差异，即确保数据处于同一数量级，提高不同特征数据的可比性。</p><h5 id="L0，L1范数和L2范数"><a href="#L0，L1范数和L2范数" class="headerlink" title="L0，L1范数和L2范数"></a>L0，L1范数和L2范数</h5><p><img src="/2020/05/21/shujufenxi/scikit-learn%E5%88%9D%E7%BA%A7/image-20211207164714720.png" alt="image-20211207164714720"></p><h5 id="L1和L2范数在机器学习中的用途"><a href="#L1和L2范数在机器学习中的用途" class="headerlink" title="L1和L2范数在机器学习中的用途"></a>L1和L2范数在机器学习中的用途</h5><p><a href="https://zhuanlan.zhihu.com/p/28023308">https://zhuanlan.zhihu.com/p/28023308</a></p><p>注意：虽然在数学概念上存在Lp范数，但是在机器学习函数中只支持L1和L2范数。</p><p>例1:使用numpy生成一组随机数，并使用归一化进行预处理</p><h4 id="4-二值化（Binarization）"><a href="#4-二值化（Binarization）" class="headerlink" title="4.二值化（Binarization）"></a>4.二值化（Binarization）</h4><p>二值化用于将数值特征向量转换为布尔类型的向量。</p><p>#binarization</p><p>data_binarized = preprocessing.Binarizer(threshold=1.4).transform(data)<br>print(“\nBinarized data:\n”, data_binarized) </p><h4 id="5-独热编码（one-hot-encoding"><a href="#5-独热编码（one-hot-encoding" class="headerlink" title="5.独热编码（one-hot encoding)"></a>5.独热编码（one-hot encoding)</h4><p>通常，需要处理的数值都是稀疏的，散乱的分布在空间中，然而我们并不需要存储这些大数值，这时就需要使用独热编码。可以把独热编码看做一种收紧特征向量的工具。它把特征向量的每个特征与特征的非重复总数相对应，通过one-of-k的形式对每个特征进行编码。</p><p>#one hot encoding</p><p>encoder = preprocessing.OneHotEncoder()<br>encoder.fit([</p><p>[0, 2, 1, 12], </p><p>[1, 3, 5, 3], </p><p>[2, 3, 2, 12],</p><p> [1, 2, 4, 3]])<br>encoded_vector = encoder.transform([[2, 3, 5, 3]]).toarray()<br>print (“\nEncoded vector:\n”, encoded_vector)</p><p>#第一个特征（即为第一列）为[0,1,2,1],其中三类特征值[0,1,2],因此One-Hot Code可将[0,1,2]表示为:[100,010,001]<br>#第一个特征有三种值：采用三个编码：[100,010,001]</p><p>#同理第二个特征列可将两类特征值[2,3]表示为[10,01]</p><p>#第三个特征将4类特征值[1,2,4,5]表示为[1000,0100,0010,0001]</p><p>#第四个特征将2类特征值[3,12]表示为[10,01]</p><h3 id="1-4-3-标记编码"><a href="#1-4-3-标记编码" class="headerlink" title="1.4.3 标记编码"></a>1.4.3 标记编码</h3><p>在监督学习中，经常需要处理各种各样的标记。这些标记可能是数字，也可能是单词。如果标记是数字，那么算法可以直接使用它们，但是许多情况下，标记都需要以人们可理解的形式存在。因此，人们通常会用单词标记训练数据集。标记编码就是把单词标记转换成数值形式，让算法懂得如何操作标记。</p><p>import numpy as np<br>from sklearn import preprocessing</p><p>label_encoder = preprocessing.LabelEncoder()<br>input_classes = [‘audi’, ‘ford’, ‘audi’, ‘toyota’, ‘ford’, ‘bmw’]<br>label_encoder.fit(input_classes)</p><p>#print classes</p><p>print “\nClass mapping:”<br>for i, item in enumerate(label_encoder.classes_):<br>    print item, ‘–&gt;’, i</p><p>#transform a set of classes</p><p>labels = [‘toyota’, ‘ford’, ‘audi’]<br>encoded_labels = label_encoder.transform(labels)<br>print “\nLabels =”, labels<br>print “Encoded labels =”, list(encoded_labels)</p><p>#inverse transform</p><p>encoded_labels = [2, 1, 0, 3, 1]<br>decoded_labels = label_encoder.inverse_transform(encoded_labels)<br>print “\nEncoded labels =”, encoded_labels<br>print “Decoded labels =”, list(decoded_labels)</p><h2 id="1-5-线性回归模型"><a href="#1-5-线性回归模型" class="headerlink" title="1.5 线性回归模型"></a>1.5 线性回归模型</h2><p>Scikit-Learn已经为我们设计好了线性模型（sklearn.linear_model），在程序中直接调用即可，无须编写过多代码就可以轻松实现线性回归分析。首先了解一下线性回归析。<br>线性回归是利用数理统计中的回归分析来确定两种或两种以上变量间相互依赖的定量关系的一种统计分析与预测方法，运用十分广泛。</p><p>在线性回归分析中，只包括一个自变量和一个因变量，且二者的关系可用一条直线近似表示，这种回归分析称为<strong>一元线性回归分析</strong>；如果线性回归分析中包括两个或两个以上的自变量，且因变量和自变量之间是线性关系，则称为<strong>多元线性回归分析</strong>。</p><p>在Python中，无须理会烦琐的线性回归求解数学过程，直接使用Scikit-Learn的linear_model模块就可以实现线性回归分析。</p><p>linear_model模块提供了很多线性模型，包括最小二乘法回归、岭回归、<strong>Lasso、贝叶斯回归</strong>等。本节主要介绍最小二乘法回归和岭回归。</p><p>5x1+6x2=10</p><p>x1-x2=5</p><p>首先导入linear_model模块，程序代码如下：</p><p>from sklearn import linear_model<br>导入linear_model模块后，在程序中就可以使用相关函数实现线性回归分析。</p><h3 id="1-5-1-最小二乘法回归"><a href="#1-5-1-最小二乘法回归" class="headerlink" title="1.5.1　最小二乘法回归"></a>1.5.1　最小二乘法回归</h3><p>线性回归是数据挖掘中的基础算法之一，线性回归的思想其实就是解一组方程，得到回归系数，不过在出现误差项之后，方程的解法就存在了改变，一般使用最小二乘法进行计算，所谓“二乘”就是平方的意思，最小二乘法也称最小平方和，其目的是通过最小化误差的平方和，使得预测值与真值无限接近。</p><p>最小二乘原理补充：</p><p><img src="/2020/05/21/shujufenxi/scikit-learn%E5%88%9D%E7%BA%A7/image-20211116054806678.png" alt="image-20211116054806678"></p><p><img src="/2020/05/21/shujufenxi/scikit-learn%E5%88%9D%E7%BA%A7/image-20211116054851514.png" alt="image-20211116054851514"></p><p>linear_model模块的LinearRegression()函数用于实现最小二乘法回归。LinearRegression()函数拟合一个带有回归系数的线性模型，使得真实数据和预测数据（估计值）之间的残差平方和最小，与真实数据无限接近。LinearRegression()函数语法如下：</p><p>linear_model.LinearRegression(fit_intercept=True,normalize=False,copy_X=True,n_jobs=NoNone)<br>参数说明：　</p><p>fit_intercept：布尔型值，是否需要计算截距，默认值为True。　</p><p>normalize：布尔型值，是否需要标准化，默认值为False，与参数fit_intercept有关。当fit_intercept参数值为False时，将忽略该参数；当fit_intercept参数值为True时，则回归前对回归量X进行归一化处理，取均值相减，再除以L2范数（L2范数是指向量各元素的平方和然后开方）。　</p><p>copy_X：布尔型值，选择是否复制X数据，默认值为True，如果值为False，则覆盖X数据。　</p><p>n_jobs：整型，代表CPU工作效率的核数，默认值为1，-1表示跟CPU核数一致。</p><p>主要属性：　</p><p>coef_：数组或形状，表示线性回归分析的回归系数。　</p><p>intercept_：数组，表示截距。<br>主要方法：　</p><p>fit(X,y,sample_weight=None)：拟合线性模型。　</p><p>predict(X)：使用线性模型返回预测数据。　</p><p>score(X,y,sample_weight=None)：返回预测的确定系数R^2。<br>LinearRegression()函数调用fit()方法来拟合数组X、y，并且将线性模型的回归系数存储在其成员变量coef_属性中。</p><p>【示例01】　智能预测房价。（示例位置：资源包\MR\Code\10\01）<br>智能预测房价，假设某地房屋面积和价格关系如图10.2所示。下面使用LinearRegression()函数预测面积为170平方米的房屋的单价。</p><p><img src="/2020/05/21/shujufenxi/scikit-learn%E5%88%9D%E7%BA%A7/image-20211101095833224.png" alt="image-20211101095833224"></p><p>​                                                                                            图10.2　房屋价格表<br>程序代码如下：</p><p><img src="/2020/05/21/shujufenxi/scikit-learn%E5%88%9D%E7%BA%A7/image-20211101095853611.png" alt="image-20211101095853611"></p><p>运行程序，输出结果如下：</p><p>回归系数：[1853.37423313  -21.7791411 ]</p><p>截距：7215.950920245397</p><p>预测值：[16487.11656442]</p><h3 id="1-5-2-岭回归"><a href="#1-5-2-岭回归" class="headerlink" title="1.5.2　岭回归"></a>1.5.2　岭回归</h3><p>线性回归的主要问题的对异常值敏感。在真实的世界的数据收集过程中，经常会遇到错误的度量结果。而线性回归使用的普通最小二乘法，其目标是使平方误差最小化。这时，由于异常误差的绝对值很大，因此会引起问题，从而破坏整个模型。为了避免整个问题，我们引入了<strong>正则化项的系数</strong>作为阈值来消除异常值的影响。这个方法称为岭回归。</p><p>岭回归是在最小二乘法回归基础上，加入了对表示回归系数的L2范数约束。岭回归是缩减法的一种，相当于对回归系数的大小施加了限制。</p><p>岭回归详解：</p><p><img src="/2020/05/21/shujufenxi/scikit-learn%E5%88%9D%E7%BA%A7/image-20211116055823554.png" alt="image-20211116055823554"></p><p><img src="/2020/05/21/shujufenxi/scikit-learn%E5%88%9D%E7%BA%A7/image-20211116055857220.png" alt="image-20211116055857220"></p><p>岭回归的特点：<br>岭回归是一种改良的最小二乘估计法，通过放弃最小二乘法的无偏性，以损失部分信息、降低精度为代价获得回归系数，它是更为符合实际、更可靠的回归方法，对存在离群点的数据的拟合要强于最小二乘法。</p><p>不同与线性回归的无偏估计，岭回归的优势在于它的无偏估计，更趋向于将部分系数向0收缩。因此，它可以缓解多重共线问题，以及过拟合问题。但是由于岭回归中并没有将系数收缩到0，而是使得系数整体变小，因此，某些时候模型的解释性会大大降低，也无法从根本上解决多重共线问题。</p><p>岭回归主要使用linear_model模块的Ridge()函数实现。语法如下：</p><p>linear_model.Ridge(alpha=1.0,fit_intercept=True,normalize=False,copy_X=True,max_iter=None,tol=0.001,solver=<br>‘auto’,random_state=None)<br>参数说明：　</p><p>alpha：权重。　</p><p>fit_intercept：布尔型值，是否需要计算截距，默认值为True。　</p><p>normalize：输入的样本特征归一化，默认值为False。　</p><p>copy_X：复制或者重写。　</p><p>max_iter：最大迭代次数。</p><p>tol：浮点型，控制求解的精度。　</p><p>solver：求解器，其值包括auto、svd、cholesky、sparse_cg和lsqr，默认值为auto。</p><p>主要属性：</p><p>coef_：数组或形状，表示线性回归分析的回归系数。</p><p>主要方法：　</p><p>_fit(X,y)：拟合线性模型。　</p><p>_predict(X)：使用线性模型返回预测数据。<br>Ridg()函数使用fit()方法将线性模型的回归系数存储在其成员变量coef_属性中。</p><p>【示例02】　使用岭回归函数实现智能预测房价。（示例位置：资源包\MR\Code\10\02）<br>使用岭回归函数Ridg()实现智能预测房价，程序代码如下：</p><p><img src="/2020/05/21/shujufenxi/scikit-learn%E5%88%9D%E7%BA%A7/image-20211101100017254.png" alt="image-20211101100017254"></p><p>运行程序，输出结果如下：</p><p>回归系数：[10.00932795 16.11613094]截距：6935.001421210872预测值：[9744.80897725]</p><h2 id="1-6-支持向量机"><a href="#1-6-支持向量机" class="headerlink" title="1.6 支持向量机"></a>1.6 支持向量机</h2><p>支持向量机（SVM）可用于监督学习算法，主要包括分类、回归和异常检测。支持向量分类的方法可以被扩展用作解决回归问题，这个方法被称作支持向量回归。</p><p>本节介绍支持向量回归函数——LinearSVR()函数。LinearSVR()类是一个支持向量回归的函数，支持向量回归不仅适用于线性模型，还可以用于对数据和特征之间的非线性关系的研究。避免多重共线性问题，从而提高泛化性能，解决高维问题，语法如下：</p><p>sklearn.svm.LinearSVR(epsilon = 0.0, tol = 0.0001, C = 1.0, loss =’epsilon_insensitive’, fit_intercept = True,<br>intercept_scaling = 1.0, dual = True, verbose = 0, random_state = None, max_iter = 1000)<br>参数说明：　</p><p>epsilon：float类型值，默认值为0.0。　</p><p>tol：float类型值，终止迭代的标准值，默认值为0.0001。　</p><p>C：float类型值，罚项参数，该参数越大，使用的正则化越少，默认值为1.0。　</p><p>loss：string类型值，损失函数，该参数有以下两种选项。　</p><p>epsilon_insensitive：默认值，不敏感损失（标准SVR）是L1损失。　</p><p>squared_epsilon_insensitive：平方不敏感损失是L2损失。　</p><p>fit_intercept：boolean类型值，是否计算此模型的截距。如果设置值为False，则不会在计算中使用截距（即数据预计已经居中）。默认值为True。　</p><p>intercept_scaling：float类型值，当fit_intercept为True时，实例向量x变为[x,self.intercept_scaling]。此时相当于添加了一个特征，该特征将对所有实例都是常数值。　</p><p>dual：boolean类型值，选择算法以解决对偶或原始优化问题。当设置值为True时，可解决对偶问题；当设置值为False时，可解决原始问题。默认值为True。　</p><p>verbose：int类型值，是否开启verbose输出，默认值为0。</p><p>random_state：int类型值，随机数生成器的种子，用于在清洗数据时使用。默认值为None。　</p><p>max_iter：int类型值，要运行的最大迭代次数。默认值为1000。</p><p>两个主要的属性：　</p><p>coef_：赋予特征的权重，返回array数据类型。</p><p>intercept_：决策函数中的常量，返回array数据类型。</p><p>【示例03】　波士顿房价预测。（示例位置：资源包\MR\Code\10\03）</p><p>变量名    说明<br>CRIM    城镇人口犯罪率<br>ZN    超过25000平方英尺的住宅用地所占比例<br>INDUS    城镇非零售业务地区的比例<br>CHAS    查尔斯河虚拟变量(如果土地在河边=1；否则是0)<br>NOX    一氧化氮浓度(每1000万份)<br>RM    平均每居民房数<br>AGE    在1940年之前建成的所有者占用单位的比例<br>DIS    与五个波士顿就业中心的加权距离<br>RAD    辐射状公路的可达性指数<br>TAX    每10,000美元的全额物业税率<br>RTRATIO    城镇师生比例<br>B    1000(Bk-0.63)^2其中Bk是城镇黑人的比例<br>LSTAT    人口中地位较低人群的百分数<br>MEDV    (目标变量/类别属性)以1000美元计算的自有住房的中位数</p><p>通过Scikit-Learn自带的数据集“波士顿房价”，实现房价预测，程序代码如下：</p><p><img src="/2020/05/21/shujufenxi/scikit-learn%E5%88%9D%E7%BA%A7/image-20211101100311355.png" alt="image-20211101100311355"></p><p>运行程序，输出结果如下：</p><p><img src="/2020/05/21/shujufenxi/scikit-learn%E5%88%9D%E7%BA%A7/image-20211101100341186.png" alt="image-20211101100341186"></p><h2 id="1-7-决策树回归器"><a href="#1-7-决策树回归器" class="headerlink" title="1.7 决策树回归器"></a>1.7 决策树回归器</h2><p>决策树是一个树状模型，每个节点都做出一个决策，从而影响最终结果。叶子节点表示输出数值，分支表示根据输入特征做出的中间决策。AdaBoost算法是指自适应增强算法，这是一种利用其它系统增强模型准确性的技术。这种技术是将不同版本的算法结果进行组合，用加权汇总的方法获得最终结果，被称为弱学习器。Adaboost算法在每个阶段获取的信息都会反馈到模型中，这样学习器就可以在后一阶段重点训练难以分类的样本。这种学习方式可以增强系统的准确性。</p><p><a href="https://www.cnblogs.com/liuwu265/p/4692347.html">https://www.cnblogs.com/liuwu265/p/4692347.html</a></p><p>例1:波士顿房价预估</p><p>import numpy as np<br>from sklearn.ensemble import RandomForestRegressor, AdaBoostRegressor<br>from sklearn.tree import DecisionTreeRegressor<br>from sklearn import datasets<br>from sklearn.metrics import mean_squared_error, explained_variance_score<br>from sklearn.utils import shuffle<br>import matplotlib.pyplot as plt</p><p>housing_data = datasets.load_boston() </p><p>#Shuffle the data</p><p>X, y = shuffle(housing_data.data, housing_data.target, random_state=7)</p><p>#Split the data 80/20 (80% for training, 20% for testing)</p><p>num_training = int(0.8 * len(X))<br>X_train, y_train = X[:num_training], y[:num_training]<br>X_test, y_test = X[num_training:], y[num_training:]</p><p>#决策树模型</p><p>dt_regressor = DecisionTreeRegressor(max_depth=4)<br>dt_regressor.fit(X_train, y_train)</p><p>#AdaBoost决策树</p><p>ab_regressor = AdaBoostRegressor(DecisionTreeRegressor(max_depth=4), n_estimators=400, random_state=7)<br>ab_regressor.fit(X_train, y_train)</p><p>#Evaluate performance of Decision Tree regressor</p><p>y_pred_dt = dt_regressor.predict(X_test)<br>mse = mean_squared_error(y_test, y_pred_dt)<br>evs = explained_variance_score(y_test, y_pred_dt)<br>print(“\n#### Decision Tree performance ####”)<br>print(“Mean squared error =”, round(mse, 2))<br>print(“Explained variance score =”, round(evs, 2)) </p><p>#Evaluate performance of AdaBoost</p><p>y_pred_ab = ab_regressor.predict(X_test)<br>mse = mean_squared_error(y_test, y_pred_ab)<br>evs = explained_variance_score(y_test, y_pred_ab)<br>print(“\n#### AdaBoost performance ####”)<br>print(“Mean squared error =”, round(mse, 2))<br>print(“Explained variance score =”, round(evs, 2)) </p><h2 id="1-7-聚类"><a href="#1-7-聚类" class="headerlink" title="1.7　聚类"></a>1.7　聚类</h2><h3 id="1-7-1-什么是聚类"><a href="#1-7-1-什么是聚类" class="headerlink" title="1.7.1　什么是聚类"></a>1.7.1　什么是聚类</h3><p>聚类类似于分类，不同的是聚类所要求划分的类是未知的，也就是说不知道应该属于哪类，而是通过一定的算法自动分类。在实际应用中，聚类是一个将在某些方面相似的据进行分类组织的过程（简单地说就是将相似数据聚在一起），其示意图如图10.3和图10.4所示。</p><p><img src="/2020/05/21/shujufenxi/scikit-learn%E5%88%9D%E7%BA%A7/image-20211101100624704.png" alt="image-20211101100624704"></p><p>​                                                                                                         图10.3　聚类前</p><p><img src="/2020/05/21/shujufenxi/scikit-learn%E5%88%9D%E7%BA%A7/image-20211101100611630.png" alt="image-20211101100611630"></p><p>​                                                                                                   图10.4　聚类后<br>聚类主要应用领域如下。　</p><p>商业：聚类分析被用来发现不同的客户群，并且通过购买模式刻画不同客户群的特征。　</p><p>生物：聚类分析被用来对动植物分类和对基因进行分类，获取对种群固有结构的认识。　</p><p>保险行业：聚类分析通过一个高的平均消费来鉴定汽车保险单持有者的分组，同时根据住宅类型、价值和地理位置来判断一个城市的房产分组。　</p><p>互联网：聚类分析被用来在网上进行文档归类。　</p><p>电子商务：聚类分析在电子商务网站数据挖掘中也是很重要的一个方面，通过分组聚类出具有相似浏览行为的客户，并分析客户的共同特征，可以更好地帮助电商了解自己的客户，向客户提供更合适的服务。</p><h3 id="1-7-2-聚类算法"><a href="#1-7-2-聚类算法" class="headerlink" title="1.7.2　聚类算法"></a>1.7.2　聚类算法</h3><p>k-means算法是一种聚类算法，它是一种无监督学习算法，目的是将相似的对象归到同一个簇中。簇内的对象越相似，聚类的效果就越好。<br>传统的聚类算法包括划分方法、层次方法、基于密度方法、基于网格方法和基于模型方法。</p><p>本节主要介绍k-means聚类算法，它是划分方法中较典型的一种，也可以称为k均聚类算法。下面介绍什么是k均值聚类以及相关算法。</p><p>1．k-means聚类</p><p>k-means聚类也称为k均值聚类，是著名的划分聚类的算法，由于简洁和高效使得它成为所有聚类算法中应用最为广泛的一种。k均值聚类是给定一个数据点集合和需要的聚类数目k，k由用户指定，k均值算法根据某个距离函数反复把数据分入k个聚类中。</p><p>2．算法<br>随机选取k个点作为初始质心（质心即簇中所有点的中心），然后将数据集中的每个点分配到一个簇中，具体来讲，为每个点找距其最近的质心，并将其分配给该质心所对应的簇。这一步完成之后，将每个簇的质心更新为该簇所有点的平均值。这个过程将不断重复直到满足某个终止条件。终止条件可以是以下任何一个。　</p><p>没有（或最小数目）对象被重新分配给不同的聚类。　</p><p>没有（或最小数目）聚类中心再发生变化。　</p><p>误差平方和局部最小。</p><p>伪代码：</p><p><img src="/2020/05/21/shujufenxi/scikit-learn%E5%88%9D%E7%BA%A7/image-20211101100743922.png" alt="image-20211101100743922"></p><p>通过以上介绍相信读者对k-means聚类算法已经有了初步的认识，而在Python中应用该算法无须手动编写代码，因为Python第三方模块Scikit-Learn已经帮我们写好了，在性能和稳定性上比自己写的好得多，只需在程序中调用即可，没必要自己造轮子。</p><h3 id="1-7-3-聚类模块"><a href="#1-7-3-聚类模块" class="headerlink" title="1.7.3　聚类模块"></a>1.7.3　聚类模块</h3><p>Scikit-Learn的cluster模块用于聚类分析，该模块提供了很多聚类算法，下面主要介绍KMeans方法，该方法通过k-means聚类算法实现聚类分析。<br>首先导入sklearn.cluster模块的KMeans方法，程序代码如下：</p><p>from sklearn.cluster import KMeans<br>接下来，在程序中就可以使用KMeans()方法了。KMeans()方法的语法如下：</p><p>KMeans(n_clusters=8,init=’k-means++’,n_init=10,max_iter=300,tol=1e-4,precompute_distances=’auto’,verbose=<br>0,random_state=None,copy_x=True,n_jobs=None,algorithm=’auto’)<br>参数说明：　</p><p>n_clusters：整型，默认值为8，是生成的聚类数，即产生的质心（centroid）数。　</p><p>init：参数值为k-means++、random或者传递一个数组向量。默认值为k-means++。　</p><p>k-means++：用一种特殊的方法选定初始质心从而加速迭代过程的收敛。　</p><p>random：随机从训练数据中选取初始质心。如果传递数组类型，则应该是shape(n_clusters,n_features)的形式，并给出初始质心。　</p><p>n_init：整型，默认值为10，用不同的质心初始化值运行算法的次数。　</p><p>max_iter：整型，默认值为300，每执行一次k-means算法的最大迭代次数。　</p><p>tol：浮点型，默认值1e-4（科学技术法，即1乘以10的-4次方），控制求解的精度。　</p><p>precompute_distances：参数值为auto、True或者False。用于预先计算距离，计算速度更快但占用更多内存。　</p><p>​            auto：如果样本数乘以聚类数大于12e6（科学技术法，即12乘以10的6次方），则不预先计算距离。</p><p>​            True：总是预先计算距离。　</p><p>​            False：永远不预先计算距离。　</p><p>verbose：整型，默认值为0，冗长的模式。　</p><p>random_state：整型或随机数组类型。用于初始化质心的生成器（generator）。如果值为一个整数，则确定一个种子（seed）。默认值为NumPy的随机数生成器。　</p><p>copy_x：布尔型，默认值为True。如果值为True，则原始数据不会被改变；如果值为False，则会直接在原始数据上做修改，并在函数返回值时将其还原。但是在计算过程中由于有对数据均值的加减运算，所以数据返回后，原始数据同计算前数据可能会有细小差别。　</p><p>n_jobs：整型，指定计算所用的进程数。如果值为-1，则用所有的CPU进行运算；如果值为1，则不进行并行运算，这样方便调试；如果值小于-1，则用到的CPU数为（n_cpus+1+n_jobs），例如n_jobs值为-2，则用到的CPU数为总CPU数减1。　</p><p>algorithm：表示k-means算法法则，参数值为auto、full或elkan，默认值为auto。</p><p>主要属性：　</p><p>cluster_centers_：返回数组，表示分类簇的均值向量。　</p><p>_labels_：返回数组，表示每个样本数据所属的类别标记。　</p><p>inertia_：返回数组，表示每个样本数据距离它们各自最近簇的中心之和。<br>主要方法：</p><p>fit(X[,y])：计算k-means聚类。　</p><p>fit_predictt(X[,y])：计算簇质心并给每个样本数据预测类别。　</p><p>predict(X)：给每个样本估计最接近的簇。　</p><p>score(X[,y])：计算聚类误差。</p><p>【示例04】　对一组数据聚类。（示例位置：资源包MR\Code\10\04）<br>对一组数据聚类，程序代码如下：</p><p><img src="/2020/05/21/shujufenxi/scikit-learn%E5%88%9D%E7%BA%A7/image-20211101101115664.png" alt="image-20211101101115664"></p><p>运行程序，输出结果如下：</p><p><img src="/2020/05/21/shujufenxi/scikit-learn%E5%88%9D%E7%BA%A7/image-20211101101127730.png" alt="image-20211101101127730"></p><h3 id="1-7-4-聚类数据生成器"><a href="#1-7-4-聚类数据生成器" class="headerlink" title="1.7.4　聚类数据生成器"></a>1.7.4　聚类数据生成器</h3><p>1.7.3节列举了一个简单的聚类示例，但是聚类效果并不明显。本节生成了专门的聚类算法的测试数据，可以更好地诠释聚类算法，展示聚类效果。</p><p>Scikit-Learn的make_blobs()方法用于生成聚类算法的测试数据，直观地说，make_blobs()方法可以根据用户指定的特征数量、中心点数量、范围等生成几类数据，这些数据可用于测试聚类算法的效果。</p><p>make_blobs()方法的语法如下：</p><p><img src="/2020/05/21/shujufenxi/scikit-learn%E5%88%9D%E7%BA%A7/image-20211101101212613.png" alt="image-20211101101212613"></p><p>常用参数说明：　</p><p>n_samples：待生成的样本的总数。　</p><p>n_features：每个样本的特征数。　</p><p>centers：类别数。　</p><p>cluster_std：每个类别的方差，例如，生成两类数据，其中一类比另一类具有更大的方差，可以将cluster_std设置为[1.0,3.0]。</p><p>【示例05】　生成用于聚类的测试数据。（示例位置：资源包\MR\Code\10\05）<br>生成用于聚类的数据（500个样本，每个样本有两个特征），程序代码如下：</p><p>01  from sklearn.datasets import make_blobs</p><p>02  from matplotlib import pyplot<br>03  x,y = make_blobs(n_samples=500, n_features=2, centers=3)</p><p>接下来，通过KMeans()方法对测试数据进行聚类，程序代码如下：</p><p>01  from sklearn.cluster import KMeans<br>02  y_pred = KMeans(n_clusters=4, random_state=9).fit_predict(x)<br>03  plt.scatter(x[:, 0], x[:, 1], c=y_pred)<br>04  plt.show()<br>运行程序，效果如图10.5所示。</p><p><img src="/2020/05/21/shujufenxi/scikit-learn%E5%88%9D%E7%BA%A7/image-20211101101258102.png" alt="image-20211101101258102"></p><p>​                                                                                         图10.5　聚类散点图<br>从分析结果得知：相似的数据聚在一起，分成了4堆，也就是4类，并以不同的颜色显示，看上去清晰直观。</p><h2 id="项目一：线性回归器"><a href="#项目一：线性回归器" class="headerlink" title="项目一：线性回归器"></a>项目一：线性回归器</h2><p>假设有一个数据文件data_singlevar.txt，文件里用逗号分隔符分割字段，第一个字段是输入值，第二个字段是与逗号前面的输入值相对应的输出值。建立一个线性回归模型，并检验模型的准确度。</p><p>（1）读取数据，其中x是数据，y是标记</p><p>import sys</p><p>import numpy as np</p><p>filename = ‘data_singlevar.txt’</p><p>#filename = sys.argv[1]</p><p>X = []<br>y = []<br>with open(filename, ‘r’) as f:<br>    for line in f.readlines():<br>        xt, yt = [float(i) for i in line.split(‘,’)]<br>        X.append(xt)<br>        y.append(yt)</p><p>（2）建立机器学习模型，需要用一种方法来验证模型，检查模型是否达到一定的满意度。为了实现这个方法，通常将数据分成两组：训练数据集（training dataset）和测试数据集（testing dataset）。训练数据集用来建立模型，测试数据集用来验证模型对未知数据的学习效果。因此先把数据分成训练数据与测试数据集：</p><p>#Train/test split</p><p>num_training = int(0.8 * len(X))<br>num_test = len(X) - num_training</p><p>#训练数据</p><p>X_train = np.array(X[:num_training]).reshape((num_training,1))<br>y_train = np.array(y[:num_training])</p><p>#测试数据</p><p>X_test = np.array(X[num_training:]).reshape((num_test,1))<br>y_test = np.array(y[num_training:])</p><p>（3）创建一个回归器对象</p><p>#Create linear regression object</p><p>from sklearn import linear_model</p><p>linear_regressor = linear_model.LinearRegression()</p><p>（4）利用训练数据集训练线性回归器，向fit方法提供输入数据即可训练模型。画图看是否拟合；</p><p>#Train the model using the training sets</p><p>linear_regressor.fit(X_train, y_train)</p><p>#Predict the output</p><p>y_test_pred = linear_regressor.predict(X_test)</p><p>#Plot outputs</p><p>import matplotlib.pyplot as plt</p><p>plt.scatter(X_test, y_test, color=’green’)<br>plt.plot(X_test, y_test_pred, color=’black’, linewidth=4)<br>plt.xticks(())<br>plt.yticks(())<br>plt.show()</p><p>（5）查看模型的准确性</p><p>#Measure performance</p><p>import sklearn.metrics as sm</p><p>print (“Mean absolute error =”, round(sm.mean_absolute_error(y_test, y_test_pred), 2) )<br>print (“Mean squared error =”, round(sm.mean_squared_error(y_test, y_test_pred), 2) )<br>print (“Median absolute error =”, round(sm.median_absolute_error(y_test, y_test_pred), 2) )<br>print (“Explain variance score =”, round(sm.explained_variance_score(y_test, y_test_pred), 2) )<br>print (“R2 score =”, round(sm.r2_score(y_test, y_test_pred), 2))</p><p>评价指标：</p><p>平均绝对误差（mean absolute error）：绝对误差的平均值</p><p>均方误差（mean squared error):所有数据点的误差的平方的均值。</p><p>中位数绝对误差（median absolute error）：给定数据集的所有数据点的误差的中位数。这个指标的主要优点是可以消除异常值（outlier）的干扰。测试数据集中的单个坏点不会影响这个误差指标，均值误差会受到异常点的影响。</p><p>解释方差（explained variance score)：这个分数用于衡量我们的模型对数据集波动的解释能力。如果得分1.0分，那么表明我们的模型是完美的。</p><p>R方得分（R2 score)：这个指标读作“R方”，是指确定性相关系数。用于衡量模型对未知样本预测的效果。最好的得分是1.0。值也可以是复数。</p><p>（6）保存模型，下次使用时直接加载</p><p>#Model persistence</p><p>import pickle</p><p>output_model_file = ‘3_model_linear_regr.pkl’</p><p>with open(output_model_file, ‘wb’) as f:<br>    pickle.dump(linear_regressor, f)</p><p>with open(output_model_file, ‘rb’) as f:<br>    model_linregr = pickle.load(f)</p><p>y_test_pred_new = model_linregr.predict(X_test)<br>print(“\nNew mean absolute error =”, round(sm.mean_absolute_error(y_test, y_test_pred_new), 2) ) </p><h2 id="项目二-二手房房价分析与预测"><a href="#项目二-二手房房价分析与预测" class="headerlink" title="项目二　二手房房价分析与预测"></a>项目二　二手房房价分析与预测</h2><p>衣食住行，住房一直以来都是热门话题，而房价更是大家时刻关心的问题。虽然新商品房听着上档次，但是二手房是现房交易，并且具有地段较好、配套设施完善、产权权属清晰、选择面更广等优势，使得二手房越来越受到广大消费者的青睐。由此，越来越多的人关注二手房，对房价、面积、地理位置、装修程度等进行多维度对比与分析，从而找到既适合自己又具备一定升值空间的房子。</p><h2 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1　概述"></a>2.1　概述</h2><p>随着现代科技化的不断进步，信息化将是科技发展中的重要元素之一，而人们每天都要面对海量的数据，如医疗数据、人口数据、人均收入等，因此数据分析将会得到广泛应用。数据分析在实际应用时可以帮助人们在海量数据中找到具有决策意义的重要信息。<br>本章将通过数据分析方法实现“二手房数据分析预测系统”，用于对二手房数据进行分析、统计，并根据数据中的重要特征实现房屋价格的预测，最后通过可视化图表方式进行数据的显示功能。</p><h2 id="2-2-项目效果预览"><a href="#2-2-项目效果预览" class="headerlink" title="2.2　项目效果预览"></a>2.2　项目效果预览</h2><p>在二手房数据分析预测系统中，查看二手房各种数据分析图表时，需要在主窗体工具栏中单击对应的工具栏按钮。主窗体运行效果如图13.1所示。</p><p><img src="/2020/05/21/shujufenxi/scikit-learn%E5%88%9D%E7%BA%A7/image-20211101105726717.png" alt="image-20211101105726717"></p><p>​                                                                                                图13.1　主窗体<br>在主窗体工具栏中单击“各区二手房均价分析”按钮，显示各区域二手房均价，如图13.2所示。</p><p><img src="/2020/05/21/shujufenxi/scikit-learn%E5%88%9D%E7%BA%A7/image-20211101105815676.png" alt="image-20211101105815676"></p><p>​                                                                                                    图13.2　各区二手房均价分析<br>在主窗体工具栏中单击“各区二手房数量所占比例”按钮，了解城市所属区域二手房的销售数量和占比情况，如图13.3所示。<br>经过分析得知：二手房数据中房子的装修程度也是购买者关心的一个重要元素。在主窗体工具栏中单击“全市二手房装修程度分析”按钮，分析全市二手房装修程度，如图13.4所示。</p><p><img src="/2020/05/21/shujufenxi/scikit-learn%E5%88%9D%E7%BA%A7/image-20211101105848608.png" alt="image-20211101105848608"></p><p>​                                                                              图13.3　各区二手房数量所占比例</p><p><img src="/2020/05/21/shujufenxi/scikit-learn%E5%88%9D%E7%BA%A7/image-20211101105916747.png" alt="image-20211101105916747"></p><p>​                                                                                           图13.4　全市二手房装修程度分析<br>二手房的户型类别很多，如果需要查看所有二手房户型中比较热门的户型均价时，则在主窗体工具栏中单击“热门户型均价分析”按钮，分析热门户型均价，如图13.5所示。<br>分析二手房数据时，首先分析特征数据，然后通过回归算法的函数预测二手房的售价。在主窗体工具栏中单击“二手房售价预测”按钮，显示二手房售价预测的折线图，如图13.6所示。</p><p><img src="/2020/05/21/shujufenxi/scikit-learn%E5%88%9D%E7%BA%A7/image-20211101110020403.png" alt="image-20211101110020403"></p><p>​                                                                                          图13.5　热门户型均价分析</p><p><img src="/2020/05/21/shujufenxi/scikit-learn%E5%88%9D%E7%BA%A7/image-20211101110046986.png" alt="image-20211101110046986"></p><p>​                                                                                                            图13.6　二手房售价预测</p><h2 id="2-3-项目准备"><a href="#2-3-项目准备" class="headerlink" title="2.3　项目准备"></a>2.3　项目准备</h2><p>本项目的开发及运行环境如下。　</p><p>操作系统：Windows 7、Windows 10。　</p><p>语言：Python 3.7。　</p><p>开发环境：PyCharm。　</p><p>内置模块：sys。　</p><p>第三方模块：PyQt5（5.11.3）、PyQt5-tools（5.11.3.1.4）、Pandas（1.0.3）、xlrd（1.2.0）、xlwt（1.3.0）、Scipy（1.2.1）、NumPy（1.16.1）、Matplotlib（3.0.2）、Scikit-Learn（0.21.2）。</p><h2 id="2-4-图表工具模块"><a href="#2-4-图表工具模块" class="headerlink" title="2.4　图表工具模块"></a>2.4　图表工具模块</h2><p>图表工具模块为自定义工具模块，该模块中主要定义用于显示可视化数据图表的函数，用于实现饼形图、折线图以及条形图的绘制与显示工作。图表工具模块创建完成后根据数据分析的类型调用对应的图表函数，就可以实现数据的可视化操作。</p><h3 id="2-4-1-绘制饼形图"><a href="#2-4-1-绘制饼形图" class="headerlink" title="2.4.1　绘制饼形图"></a>2.4.1　绘制饼形图</h3><p>在实现绘制饼形图时，首先需要创建chart.py文件，该文件为图表工具的自定义模块。然后在该文件中导入matplotlib模块与pyplot子模块。接下来为了避免中文乱码，需要使用rcParams变量。<br>绘制饼形图的函数名称为pie_chart()，用于显示各区二手房数量所占比例。pie_chart()函数需要以下3个参数：size为饼形图中每个区二手房数量；label为每个区对应的名称；title为图表的标题。<br>程序代码如下：（源码位置：资源包\MR\Code\13\house_data_analysis\chart.py）</p><p><img src="/2020/05/21/shujufenxi/scikit-learn%E5%88%9D%E7%BA%A7/image-20211101110146661.png" alt="image-20211101110146661"></p><h3 id="2-4-2-绘制折线图"><a href="#2-4-2-绘制折线图" class="headerlink" title="2.4.2　绘制折线图"></a>2.4.2　绘制折线图</h3><p>绘制折线图的函数名称为broken_line()，用于显示真实房价与预测房价的折线图。该函数需要以下3个参数：y为二手房的真实价格；y_pred为二手房的预测价格；title为图表的标题。<br>程序代码如下：（源码位置：资源包\MR\Code\13\house_data_analysis\chart.py）</p><p><img src="/2020/05/21/shujufenxi/scikit-learn%E5%88%9D%E7%BA%A7/image-20211101110214640.png" alt="image-20211101110214640"></p><h3 id="2-4-3-绘制条形图"><a href="#2-4-3-绘制条形图" class="headerlink" title="2.4.3　绘制条形图"></a>2.4.3　绘制条形图</h3><p>绘制条形图的函数一共分为3个，分别用于显示各区二手房均价、全市二手房装修程度以及热门户型均价。下面介绍定义函数的具体方式。<br>1．绘制各区二手房均价的条形图<br>绘制各区二手房均价的条形图为纵向条形图，函数名称为average_price_bar()，该函数需要以下3个参数：x为全市中各区域的数据；y为各区域的均价数据；title为图表的标题。<br>程序代码如下：（源码位置：资源包\MR\Code\13\house_data_analysis\chart.py）</p><p><img src="/2020/05/21/shujufenxi/scikit-learn%E5%88%9D%E7%BA%A7/image-20211101110253761.png" alt="image-20211101110253761"></p><p>2．绘制全市二手房装修程度的条形图<br>绘制全市二手房装修程度的条形图为纵向条形图，函数名称为renovation_bar()，该函数需要以下3个参数：x为装修类型的数据；y为每种装修类型所对应的数量；title为图表的标题。<br>程序代码如下：（源码位置：资源包\MR\Code\13\house_data_analysis\chart.py）</p><p><img src="/2020/05/21/shujufenxi/scikit-learn%E5%88%9D%E7%BA%A7/image-20211101110314134.png" alt="image-20211101110314134"></p><p>3．绘制热门户型均价的条形图<br>绘制热门户型均价的条形图为水平条形图，函数名称为bar()，该函数需要以下3个参数：price为热门户型的均价；type为热门户型的名称；title为图表的标题。<br>程序代码如下：（源码位置：资源包\MR\Code\13\house_data_analysis\chart.py）</p><p><img src="/2020/05/21/shujufenxi/scikit-learn%E5%88%9D%E7%BA%A7/image-20211101110356475.png" alt="image-20211101110356475"></p><h2 id="2-5-项目实现过程"><a href="#2-5-项目实现过程" class="headerlink" title="2.5　项目实现过程"></a>2.5　项目实现过程</h2><h3 id="2-5-1-数据清洗"><a href="#2-5-1-数据清洗" class="headerlink" title="2.5.1　数据清洗"></a>2.5.1　数据清洗</h3><p>在实现数据分析前需要先对数据进行清洗工作，清洗数据的主要目的是为了减小数据分析的误差。清洗数据时首先需要读取数据，然后观察数据中是否存在无用值、空值以及数据类型是否需要进行转换等。清洗二手房数据的具体步骤如下所示。<br>（1）读取二手房数据文件，显示部分数据。<br>程序代码如下：（源码位置：资源包\MR\Code\13\house_data_analysis\house_analysis.py）</p><p>01  import pandas as as pd                 #导入数据统计模块<br>02  data = pd.read_csv(‘data.csv’)          #读取csv数据文件<br>03  print(data.head())                      #打印文件内容的头部信息<br>运行程序，输出结果如图13.7所示。</p><p><img src="/2020/05/21/shujufenxi/scikit-learn%E5%88%9D%E7%BA%A7/image-20211101110416616.png" alt="image-20211101110416616"></p><p>​                                                                                  图13.7　二手房数据（部分数据）<br>观察上述数据，首先“Unnamed: 0”索引列对于数据分析没有任何帮助，然后“总价”“建筑面积”“单价”列所对应的数据不是数值类型，所以无法进行计算。接下来对这些数据进行处理。<br>（2）将索引列“Unnamed: 0”删除；然后将数据中的所有空值删除；最后分别将“总价”“建筑面积”“单价”列所对应数据中的字符删除仅保留数字部分，再将数字转换为float类型，再次输出数据。<br>程序代码如下：（源码位置：资源包\MR\Code\13\house_data_analysis\house_analysis.py）</p><p><img src="/2020/05/21/shujufenxi/scikit-learn%E5%88%9D%E7%BA%A7/image-20211101110741933.png" alt="image-20211101110741933">运行程序，输出结果如图13.8所示。</p><p><img src="/2020/05/21/shujufenxi/scikit-learn%E5%88%9D%E7%BA%A7/image-20211101110803692.png" alt="image-20211101110803692"></p><p>​                                                                           图13.8　处理后的二手房数据（部分数据）</p><h3 id="2-5-2-区域二手房均价分析"><a href="#2-5-2-区域二手房均价分析" class="headerlink" title="2.5.2　区域二手房均价分析"></a>2.5.2　区域二手房均价分析</h3><p>实现区域二手房均价分析前，首先需要将数据按所属区域进行划分，然后计算每个区域的二手房均价，最后将区域及对应的房屋均价信息通过纵向条形图显示，具体步骤如下所示。<br>（1）通过groupby()方法实现二手房区域的划分，然后通过mean()方法计算出每个区域的二手房均价，最后分别通过index属性与values属性获取所有区域信息与对应的均价。<br>程序代码如下：（源码位置：资源包\MR\Code\13\house_data_analysis\house_analysis.py）</p><p><img src="/2020/05/21/shujufenxi/scikit-learn%E5%88%9D%E7%BA%A7/image-20211101110827332.png" alt="image-20211101110827332"></p><p>（2）在主窗体初始化类中创建show_average_price()方法，用于绘制并显示各区二手房均价分析图。程序代码如下：（源码位置：资源包\MR\Code\13\house_data_analysis\show_window.py）</p><p><img src="/2020/05/21/shujufenxi/scikit-learn%E5%88%9D%E7%BA%A7/image-20211101110953838.png" alt="image-20211101110953838"></p><p>（3）指定显示各区二手房均价分析图，按钮事件所对应的方法。<br>程序代码如下：（源码位置：资源包\MR\Code\13\house_data_analysis\show_window.py）</p><p>01 #显示各区二手房均价分析图，按钮事件<br>02 main.btn_1.triggered.connect(main.show_average_price)</p><p>（4）在主窗体工具栏中单击“各区二手房均价分析”按钮，显示各区二手房均价分析图，如图13.9所示。</p><p><img src="/2020/05/21/shujufenxi/scikit-learn%E5%88%9D%E7%BA%A7/image-20211101111015267.png" alt="image-20211101111015267"></p><p>​                                                                             图13.9　各区二手房均价分析图</p><h3 id="2-5-3-区域二手房数据及占比分析"><a href="#2-5-3-区域二手房数据及占比分析" class="headerlink" title="2.5.3　区域二手房数据及占比分析"></a>2.5.3　区域二手房数据及占比分析</h3><p>在实现各区房子数量比例时，首先需要将数据中每个区域进行分组并获取每个区域的房子数量，然后获取每个区域与对应的二手房数量，最后计算每个区域二手房数量的百分比。具体步骤如下所示。<br>（1）通过groupby()方法对房子区域进行分组，并使用size()方法获取每个区域的分组数量（区域对应的房子数量），然后使用index属性与values属性分别获取每个区域与对应的二手房数量，最后计算每个区域房子数量的百分比。<br>程序代码如下：（源码位置：资源包\MR\Code\13\house_data_analysis\house_analysis.py）</p><p><img src="/2020/05/21/shujufenxi/scikit-learn%E5%88%9D%E7%BA%A7/image-20211101111114194.png" alt="image-20211101111114194"></p><p>（2）在主窗体初始化类中创建show_house_number()方法，用于绘制并显示各区二手房数量所占比例的分析图。<br>程序代码如下：（源码位置：资源包\MR\Code\13\house_data_analysis\show_window.py）</p><p><img src="/2020/05/21/shujufenxi/scikit-learn%E5%88%9D%E7%BA%A7/image-20211101111129394.png" alt="image-20211101111129394"></p><p>（3）指定显示各区二手房数量所占比例图，按钮事件所对应的方法。<br>程序代码如下：（源码位置：资源包\MR\Code\13\house_data_analysis\show_window.py）</p><p>01 #显示各区二手房数量所占比例图，按钮事件<br>02 main.btn_2.triggered.connect(main.show_house_number)<br>（4）在主窗体工具栏中单击“各区二手房数量所占比例”按钮，显示各区二手房数量及占比分析图，如图13.10所示。</p><p><img src="/2020/05/21/shujufenxi/scikit-learn%E5%88%9D%E7%BA%A7/image-20211101111150978.png" alt="image-20211101111150978"></p><p>​                                                                          图13.10　各区二手房数量所占比例分析图</p><h3 id="2-5-4-全市二手房装修程度分析"><a href="#2-5-4-全市二手房装修程度分析" class="headerlink" title="2.5.4　全市二手房装修程度分析"></a>2.5.4　全市二手房装修程度分析</h3><p>在实现全市二手房装修程度分析时，首先需要将二手房的装修程度进行分组并将每个分组对应的数量统计出来，再将装修程度分类信息与对应的数量进行数据的分离工作，具体步骤如下所示。<br>（1）通过groupby()方法对房子的装修程度进行分组，并使用size()方法获取每个装修程度分组的数量，然后使用index属性与values属性分别获取每个装修程度分组与对应的数量。<br>程序代码如下：（源码位置：资源包\MR\Code\13\house_data_analysis\house_analysis.py）</p><p><img src="/2020/05/21/shujufenxi/scikit-learn%E5%88%9D%E7%BA%A7/image-20211101111235322.png" alt="image-20211101111235322"></p><p>（2）在主窗体初始化类中创建show_renovation()方法，用于绘制并显示全市房子装修程度的分析图。<br>程序代码如下：（源码位置：资源包\MR\Code\13\house_data_analysis\show_window.py）</p><p><img src="/2020/05/21/shujufenxi/scikit-learn%E5%88%9D%E7%BA%A7/image-20211101111257695.png" alt="image-20211101111257695"></p><p>（3）指定显示全市二手房装修程度分析图，按钮事件所对应的方法。<br>程序代码如下：（源码位置：资源包\MR\Code\13\house_data_analysis\show_window.py）</p><p>01 #显示全市二手房装修程度分析图，按钮事件<br>02 main.btn_3.triggered.connect(main.show_renovation)<br>（4）在主窗体工具栏中单击“全市二手房装修程度分析”按钮，显示全市二手房装修程度分析图，如图13.11所示。</p><p><img src="/2020/05/21/shujufenxi/scikit-learn%E5%88%9D%E7%BA%A7/image-20211101111320801.png" alt="image-20211101111320801"></p><p>​                                                                      图13.11　全市二手房装修程度分析图</p><h3 id="2-5-5-热门户型均价分析"><a href="#2-5-5-热门户型均价分析" class="headerlink" title="2.5.5　热门户型均价分析"></a>2.5.5　热门户型均价分析</h3><p>在实现热门户型均价分析时，首先需要将户型进行分组并获取每个分组所对应的数量，然后对户型分组数量进行降序处理，提取前5组户型数据，作为热门户型的数据，最后计算每个户型的均价。具体步骤如下所示。<br>（1）通过groupby()方法对房子的户型进行分组，并使用size()方法获取每个户型分组的数量，使用sort_values()方法对户型分组数量进行降序处理。然后通过head(5)方法，提取前5组户型数据。再通过mean()方法计算每个户型的均价，最后使用index属性与values属性分别获取户型与对应的均价。<br>程序代码如下：（源码位置：资源包\MR\Code\13\house_data_analysis\house_analysis.py）</p><p><img src="/2020/05/21/shujufenxi/scikit-learn%E5%88%9D%E7%BA%A7/image-20211101111410258.png" alt="image-20211101111410258"></p><p>（2）在主窗体初始化类中创建show_type()方法，绘制并显示热门户型均价的分析图。<br>程序代码如下：（源码位置：资源包\MR\Code\13\house_data_analysis\show_window.py）</p><p><img src="/2020/05/21/shujufenxi/scikit-learn%E5%88%9D%E7%BA%A7/image-20211101111432393.png" alt="image-20211101111432393"></p><p>（3）指定显示热门户型均价分析图，按钮事件所对应的方法。<br>程序代码如下：（源码位置：资源包\MR\Code\13\house_data_analysis\show_window.py）</p><p>01 #显示热门户型均价分析图，按钮事件<br>02 main.btn_4.triggered.connect(main.show_type)<br>（4）在主窗体工具栏中单击“热门户型均价分析”按钮，显示热门户型均价分析图，效果如图13.12所示。</p><p><img src="/2020/05/21/shujufenxi/scikit-learn%E5%88%9D%E7%BA%A7/image-20211101111504958.png" alt="image-20211101111504958"></p><p>​                                                                                    图13.12　热门户型均价分析图</p><h3 id="2-5-6-二手房房价预测"><a href="#2-5-6-二手房房价预测" class="headerlink" title="2.5.6　二手房房价预测"></a>2.5.6　二手房房价预测</h3><p>在实现二手房房价预测时，需要提供二手房源数据中的参考数据（特征值），这里将“户型”和“建筑面积”作为参考数据来进行房价的预测，所以需要观察“户型”数据是否符合分析条件。如果参考数据不符合分析条件，则需要再次对数据进行清洗处理。再通过源数据中已知的参考数据“户型”和“建筑面积”进行未知房价的预测。实现的具体步骤如下所示。<br>（1）查看源数据中“户型”和“建筑面积”数据，确认数据是否符合数据分析条件。<br>程序代码如下：（源码位置：资源包\MR\Code\13\house_data_analysis\house_analysis.py）</p><p><img src="/2020/05/21/shujufenxi/scikit-learn%E5%88%9D%E7%BA%A7/image-20211101111609998.png" alt="image-20211101111609998"></p><p>运行程序，输出结果如图13.13所示。</p><p><img src="/2020/05/21/shujufenxi/scikit-learn%E5%88%9D%E7%BA%A7/image-20211101111628674.png" alt="image-20211101111628674"></p><p>​                                                             图13.13　户型和建筑面积（部分数据）<br>（2）从输出结果得知：“户型”数据中包含文字信息，而文字信息并不能实现数据分析时的拟合工作，所以需要将“室”“厅”“卫”进行独立字段的处理。<br>程序代码如下：（源码位置：资源包\MR\Code\13\house_data_analysis\house_analysis.py）</p><p><img src="/2020/05/21/shujufenxi/scikit-learn%E5%88%9D%E7%BA%A7/image-20211101111649911.png" alt="image-20211101111649911"></p><p>运行程序，输出结果如图13.14所示。</p><p><img src="/2020/05/21/shujufenxi/scikit-learn%E5%88%9D%E7%BA%A7/image-20211101111733193.png" alt="image-20211101111733193"></p><p>​                                                                           图13.14　处理后的户型数据（部分数据）<br>（3）将数据中没有参考意义的数据删除，其中包含“小区名字”“户型”“朝向”“楼层”“装修”“区域”“单价”“空值”，然后将“建筑面积”小于300平方米的房子信息筛选出来。<br>程序代码如下：（源码位置：资源包\MR\Code\13\house_data_analysis\house_analysis.py）</p><p><img src="/2020/05/21/shujufenxi/scikit-learn%E5%88%9D%E7%BA%A7/image-20211101111800005.png" alt="image-20211101111800005"></p><p>运行程序，输出结果如图13.15所示。</p><p><img src="/2020/05/21/shujufenxi/scikit-learn%E5%88%9D%E7%BA%A7/image-20211101111814905.png" alt="image-20211101111814905"></p><p>​                                                            图13.15　“建筑面积”小于300平米的数据（部分数据）<br>（4）添加自定义预测数据，其中包含“总价”“建筑面积”“室”“厅”“卫”，总价数据为None，其他数据为模拟数据。然后进行数据的标准化，定义特征数据与目标数据，最后训练回归模型进行未知房价的预测。<br>程序代码如下：（源码位置：资源包\MR\Code\13\house_data_analysis\house_analysis.py）</p><p><img src="/2020/05/21/shujufenxi/scikit-learn%E5%88%9D%E7%BA%A7/image-20211101111836971.png" alt="image-20211101111836971"></p><p>查看打印的“真实值”和“预测值”，其中索引编号</p><p>2505和2506均为添加自定义的预测数据，输出结果如图13.16所示。（由于数据过多，省略部分数据）</p><p><img src="/2020/05/21/shujufenxi/scikit-learn%E5%88%9D%E7%BA%A7/image-20211101111933722.png" alt="image-20211101111933722"></p><p>​                                                                 图13.16　真实值和预测值（省略部分数据）<br>从输出结果得知：“总价”一列为房价的真实数据，而“y_pred”一列为房价的预测数据，其中索引为2505和2506为模拟的未知数据，所以“总价”列中的数据为空，而右侧的数据是根据已知的参考数据预测而来的。<br>（5）在主窗体初始化类中创建show_total_price()方法，用于绘制并显示二手房售价预测折线图。<br>程序代码如下：（源码位置：资源包\MR\Code\13\house_data_analysis\show_window.py）</p><p>01  def show_total_price(self):<br>02             true_price,forecast_price = house_analysis.get_price_forecast()   #获取预测房价<br>03             chart.broken_line(true_price,forecast_price,’二手房售价预测’)     #绘制及显示图表<br>（6）指定显示全市二手房户售价预测图，按钮事件所对应的方法。<br>程序代码如下：（源码位置：资源包\MR\Code\13\house_data_analysis\show_window.py）</p><p>01 #显示全市二手房户售价预测图，按钮事件<br>02 main.btn_5.triggered.connect(main.show_total_price)<br>（7）在主窗体工具栏中单击“二手房售价预测”按钮，显示全市二手房房价预测分析图，效果如图13.17所示。</p><p><img src="/2020/05/21/shujufenxi/scikit-learn%E5%88%9D%E7%BA%A7/image-20211101112023856.png" alt="image-20211101112023856"></p><p>​                                                                     图13.17　全市二手房房价预测折线图</p><p>说明<br>为了清晰地体现二手房房价预测数据，以上选择了展示部分数据，即索引为2490以后的预测房价，其中预测房价多出的部分为索引2505和2506的预测房价。</p><h2 id="2-6-小结"><a href="#2-6-小结" class="headerlink" title="2.6　小结"></a>2.6　小结</h2><h1 id="本章主要使用Python开发了二手房房价分析与预测系统，该项目主要应用了Pandas和Scikit-Learn模块。其中Pandas模块主要用于实现数据的预处理以及数据的分类等，而Scikit-Learn模块主要用于实现数据的回归模型以及预测功能，最后通过绘图模块Matplotlib，将分析后的数据绘制成图表，从而形成更直观的可视化数据。在开发中，数据分析是该项目的重点与难点，需要读者认真领会其中的算法，方便读者开发其他项目。"><a href="#本章主要使用Python开发了二手房房价分析与预测系统，该项目主要应用了Pandas和Scikit-Learn模块。其中Pandas模块主要用于实现数据的预处理以及数据的分类等，而Scikit-Learn模块主要用于实现数据的回归模型以及预测功能，最后通过绘图模块Matplotlib，将分析后的数据绘制成图表，从而形成更直观的可视化数据。在开发中，数据分析是该项目的重点与难点，需要读者认真领会其中的算法，方便读者开发其他项目。" class="headerlink" title="本章主要使用Python开发了二手房房价分析与预测系统，该项目主要应用了Pandas和Scikit-Learn模块。其中Pandas模块主要用于实现数据的预处理以及数据的分类等，而Scikit-Learn模块主要用于实现数据的回归模型以及预测功能，最后通过绘图模块Matplotlib，将分析后的数据绘制成图表，从而形成更直观的可视化数据。在开发中，数据分析是该项目的重点与难点，需要读者认真领会其中的算法，方便读者开发其他项目。"></a>本章主要使用Python开发了二手房房价分析与预测系统，该项目主要应用了Pandas和Scikit-Learn模块。其中Pandas模块主要用于实现数据的预处理以及数据的分类等，而Scikit-Learn模块主要用于实现数据的回归模型以及预测功能，最后通过绘图模块Matplotlib，将分析后的数据绘制成图表，从而形成更直观的可视化数据。在开发中，数据分析是该项目的重点与难点，需要读者认真领会其中的算法，方便读者开发其他项目。</h1>]]></content>
    
    
    <categories>
      
      <category>数据分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>scikit-learn</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>numpy补充</title>
    <link href="/2020/04/18/shujufenxi/numpy%E8%A1%A5%E5%85%85/"/>
    <url>/2020/04/18/shujufenxi/numpy%E8%A1%A5%E5%85%85/</url>
    
    <content type="html"><![CDATA[<h1 id="Numpy补充"><a href="#Numpy补充" class="headerlink" title="Numpy补充"></a>Numpy补充</h1><h1 id="一-数组补充"><a href="#一-数组补充" class="headerlink" title="一.数组补充"></a>一.数组补充</h1><h2 id="1-np-alltrue"><a href="#1-np-alltrue" class="headerlink" title="1.np.alltrue()"></a>1.np.alltrue()</h2><p>判断数组的元素是否都为True，是否都是非0</p><h2 id="2-复数数组的建立"><a href="#2-复数数组的建立" class="headerlink" title="2.复数数组的建立"></a>2.复数数组的建立</h2><p>i^2=-1</p><p>f1=np.array([10+2j,8j,2.1+3j])</p><p>f1.dtype</p><p>注意事项：Numpy的数组元素要求统一类型，不能出现既是整型又是字符型的现象，如果不小心输入了不同类型的元素，array会把其他类型的元素自动转换成字符串型。</p><h2 id="3-np-eye-N-M-k-0-dtype-lt-class’float’-gt-order-’C’"><a href="#3-np-eye-N-M-k-0-dtype-lt-class’float’-gt-order-’C’" class="headerlink" title="3.np.eye(N,M,k=0,dtype=&lt;class’float’&gt;,order=’C’)"></a>3.np.eye(N,M,k=0,dtype=&lt;class’float’&gt;,order=’C’)</h2><p>k=0表示主对角线，k=正整数表示上对角线，k=负整数表示下对角线</p><p>返回对角线为1，其他位置均为0的二维数组</p><h2 id="4-repeat（a-repeats-axis-None）"><a href="#4-repeat（a-repeats-axis-None）" class="headerlink" title="4.repeat（a,repeats,axis=None）"></a>4.repeat（a,repeats,axis=None）</h2><p>建立每个元素重复N次的数组。</p><p>a为集合对象</p><p>repeats为指定元素重复次数，在多维数组的情况下，axis可以指定重复维度</p><h2 id="5-数组属性"><a href="#5-数组属性" class="headerlink" title="5.数组属性"></a>5.数组属性</h2><p>(1) ndim属性，返回数组的维度</p><p>arr1=[[1,2,3],[3,4,5],[5,6,7]]</p><p>arr1.ndim</p><p>（2）shape返回数组的形状大小</p><p>（3）size返回数组的元素个数</p><p>（4）dtype返回数组的元素类型</p><p>（5）itemsize 返回数组元素字节大小</p><p>属性不加小括号</p><h2 id="6-数组的使用"><a href="#6-数组的使用" class="headerlink" title="6.数组的使用"></a>6.数组的使用</h2><p>方法加小括号</p><h3 id="（1）reshape-方法"><a href="#（1）reshape-方法" class="headerlink" title="（1）reshape 方法"></a>（1）reshape 方法</h3><p>改变数组的形状</p><p>arr1=[[1,2,3,4],[3,4,5,6],[5,6,7,8]]</p><p>arr2=arr1.reshape(4,3)</p><p>print(arr2)</p><p>注意：reshape方法的参数元组（x,y）,x*y必须等于数组元素的个数，否则执行该方法会报错</p><h3 id="（2）all方法"><a href="#（2）all方法" class="headerlink" title="（2）all方法"></a>（2）all方法</h3><p>判断指定的数组元素是否都是非0，是返回True，否则返回False</p><p>m1=np.ones(9).all()</p><p>print(m1)</p><p>np.array([1,0,2]).all()</p><p>np.array([1,0,2],[1,2,3]).all(axis=1)从行方向上判断每行的值是否均为0</p><p>axis指向维度的方向，其值为0表示第二维的方向列方向，值为1表示第一维的方向</p><h3 id="（3）any方法"><a href="#（3）any方法" class="headerlink" title="（3）any方法"></a>（3）any方法</h3><p>判断数组的元素有非0值，有则返回True，否则返回False</p><p>t1=np.array([[1,0,3],[0,0,2]])</p><p>t1.any(axis=0)</p><h3 id="（4）copy方法"><a href="#（4）copy方法" class="headerlink" title="（4）copy方法"></a>（4）copy方法</h3><p>复制数组副本</p><p>arr2=arr1</p><p>id(arr1)</p><p>id(arr2)</p><p>arr0=arr1.copy()</p><p>id(arr0)</p><p>使用copy的方法在计算机的内存生成一个新的数组副本，修改一个数组的元素不会影响另一个数组的元素。</p><h3 id="（5）astype方法"><a href="#（5）astype方法" class="headerlink" title="（5）astype方法"></a>（5）astype方法</h3><p>改变元素类型</p><p>arr1=np.ones(9,dtype=int)</p><p>print(arr1.astype(float))</p><h2 id="7-函数"><a href="#7-函数" class="headerlink" title="7.函数"></a>7.函数</h2><p>1.简单去最接近的整数</p><p>rint(x)</p><p>np.rint([0.49,1.4,1.5,0.6])</p><p>2.向0方向舍入取最接近的整数</p><p>fix(x)</p><p>np.fix([0.0001,0.7,0,3],[10.1,10.3,10.7])</p><h2 id="8-乱序和随机抽取"><a href="#8-乱序和随机抽取" class="headerlink" title="8 .乱序和随机抽取"></a>8 .乱序和随机抽取</h2><p>1.radom.permutation(x)</p><p>当x为标量时，生成一个[0,n)的乱序数组，当X为可变集合时，对集合里面的值进行乱序排列</p><p>2.random.shuffle(x)</p><p>对x乱序处理</p><p>3.random.choice(a,size=None,replace=True,p=None)</p><p>从a抽取size个，replace=False不重复p权重</p><h2 id="9-数组的对接、分割"><a href="#9-数组的对接、分割" class="headerlink" title="9.数组的对接、分割"></a>9.数组的对接、分割</h2><p>（1）数组对接</p><p>hstack（），vstack（）</p><p>（2）数组分割</p><p>hsplit(arr,N)实现水平分割，N为分割数</p><p>vsplit(arr,N)实现垂直分割，N为分割数</p><h2 id="10-索引以及索引省略"><a href="#10-索引以及索引省略" class="headerlink" title="10.索引以及索引省略"></a>10.索引以及索引省略</h2><h3 id="10-1-索引"><a href="#10-1-索引" class="headerlink" title="10.1 索引"></a>10.1 索引</h3><p>arr[1][2]</p><p>arr[1,2]</p><h4 id="1-数组索引"><a href="#1-数组索引" class="headerlink" title="1.数组索引"></a>1.数组索引</h4><p>(1)一维</p><p>arr1=np.array([‘a’，‘b’，‘c’，‘d’，‘e’])</p><p>idx=np.array([1,2,3])</p><p>arr1[idx]</p><p>（2）二维</p><p>arr1=np.array([[‘a’，‘b’，‘c’，‘d’，‘e’],[‘a’，‘b’，‘c’，‘d’，‘e’],[‘a’，‘b’，‘c’，‘d’，‘e’],[‘a’，‘b’，‘c’，‘d’，‘e’]])</p><p>x=np.array([0,1,2])</p><p>y=np.array([0,1,2])</p><p>arr1[x,y]</p><p>(3)布尔下标</p><p>arr1=np.arange(9).reshape(3,3)</p><p>b1=np.array([[‘True’,’False’,’False’],[‘False’,’True’,’True’],[‘False’,’False’,’True’]])</p><p>arr1[b1]</p><p>结果：过滤，得到指定true位置的值，返回结果一维</p><p>b2=np.array([‘True’,’False’,’True’])#形状一致</p><p>arr1[b2]</p><p>结果：保留行，二维</p><h3 id="10-2-索引省略"><a href="#10-2-索引省略" class="headerlink" title="10.2 索引省略"></a>10.2 索引省略</h3><p>当确定不了维度时，可以通过下标右边…（省略号）或者直接省略下边的方法来读取数组</p><p>n3[1,…]等价于n3[1,]或者n3[1]</p><p>从下标左侧开始省略，只能用“…”的形式，不能用n3[,2]的形式</p><p>n3[…,2]</p><p>当下标从中间维度省略</p><p>n3[1,…,2]不能使用n3[1,,2]</p><h2 id="11-数组运算"><a href="#11-数组运算" class="headerlink" title="11.数组运算"></a>11.数组运算</h2><h3 id="1-基本运算"><a href="#1-基本运算" class="headerlink" title="1.基本运算"></a>1.基本运算</h3><p>+，-，*，/</p><p>//取整  arr1//arr2</p><h3 id="2-位运算"><a href="#2-位运算" class="headerlink" title="2.位运算"></a>2.位运算</h3><p>&amp;按位与</p><p>|按位或</p><p>~非运算</p><p>&lt;&lt;左移</p><p>右移&gt;&gt;</p><h2 id="12-数组增删改查"><a href="#12-数组增删改查" class="headerlink" title="12.数组增删改查"></a>12.数组增删改查</h2><p>1.删除</p><p>delete（）</p><p>2.增加</p><p>insert(arr,obj,values,axis=None)</p><p>指定列</p><p>b1=np.ones(9).reshape(3,3)</p><p>np.insert(b1,3,[2,2,2],axis=1)</p><p>指定行</p><p>b1=np.ones(9).reshape(3,3)</p><p>np.insert(b1,3,[2,2,2],axis=0)</p><p>3.将指定值附加到数组末尾</p><p>append(aee,values,axis=None),axis=1在行反向上增加</p><p>z1=np.zeros(9).reshape(3,3)</p><p>np.append(z1,b1,axis=1)在行上增加</p><h1 id="二、矩阵和线性代数补充"><a href="#二、矩阵和线性代数补充" class="headerlink" title="二、矩阵和线性代数补充"></a>二、矩阵和线性代数补充</h1><h2 id="1-行列式求值"><a href="#1-行列式求值" class="headerlink" title="1.行列式求值"></a>1.行列式求值</h2><p>det(a)函数</p><p>v1=np.linalg.det(a)</p><p>‘%.2f%’%(v1)</p><h2 id="2-特殊值行列式"><a href="#2-特殊值行列式" class="headerlink" title="2.特殊值行列式"></a>2.特殊值行列式</h2><h3 id="（1）-范德蒙行列式"><a href="#（1）-范德蒙行列式" class="headerlink" title="（1）.范德蒙行列式"></a>（1）.范德蒙行列式</h3><p>vander(x,N=None,increasing=False)x为一维集合，N为默认要产生的列数，N不指定时，N=len(x),increasing为False，从右往左计算</p><p>vm=np.vander([1,2,3])</p><p>vm</p><p>array([[1,1,1],[4,2,1],[9,3,1]])</p><h3 id="（2）-下三角行列式"><a href="#（2）-下三角行列式" class="headerlink" title="（2）.下三角行列式"></a>（2）.下三角行列式</h3><p>tril(m,k=0)主对角线上方的元素都为0,k指定主对角线以及上方0元素的位置，默认k=0,当k=-1时，主对角线也为0，当k=1时，从主对角线往右斜上方扩展一行处开始为0</p><p>t1=np.array([[1,2,3],[4,5,6],[7,8,9]])</p><p>np.tril(t1)</p><p>该函数还可以提供主对角线元素</p><p>np.tril([1,2,3])</p><p>返回值：</p><p>array([1,0,0],</p><p>​           [1,2,0],</p><p>​           [1,2,3])</p><h3 id="（3）-上三角行列式"><a href="#（3）-上三角行列式" class="headerlink" title="（3）.上三角行列式"></a>（3）.上三角行列式</h3><p>triu(arr,k=0)</p><p>使用方法同tril</p><h3 id="（4）-获取主对角线的值"><a href="#（4）-获取主对角线的值" class="headerlink" title="（4）.获取主对角线的值"></a>（4）.获取主对角线的值</h3><p>diag(arr,k=0)k往左下方移动使用负数，右上方使用正数</p><p>arr=np.arange(9).reshape(3,3)</p><p>d=np.diag(arr)</p><h2 id="3-线性代数求解"><a href="#3-线性代数求解" class="headerlink" title="3.线性代数求解"></a>3.线性代数求解</h2><p>1.线性方程求解</p><p>solve(a,b)   a为系数矩阵，b为常数项矩阵，返回求解x未知数矩阵对应的公式ax=b</p><p>x1-x2-x3=2</p><p>2x1-x2-3x3=1</p><p>3x1- 2x2-5x3=0</p><p>系数矩阵A=[[1,-1,1],[2,-1,-3],[3,2,-5]],常数项矩阵b=[2,1,0],求x=[x1,x2,x3]</p><p>代码：</p><p>A=np.matrix([[1,-1,1],[2,-1,-3],[3,2,-5]])</p><p>b=[2,1,0]</p><p>x=np.linalg.solve(A,b)</p><p>要求系数矩阵行列式的值不为0</p><h1 id="三、文件处理"><a href="#三、文件处理" class="headerlink" title="三、文件处理"></a>三、文件处理</h1><p>计算机文件可以存储文字、数字、图片、视频、声音等信息，也可以永久形式记录计算机的数据处理及算计结果。计算机文件以一定格式主要存放于硬盘介质上，供用户使用时调用。计算机文件主要分文本文件和二进制文件。</p><p>文本文件主要指以ASCII码方式存储的文件，具体内容包括了英文、数字、特殊符号，也包括了Unicode码（主要是UTF-8、UTF-16L）方式下的中文、日文等双字节多字节语言内容。常见的文本文件格式（及扩展名）包括了txt、doc、docx、wps、pdf、 chm、rtf、xml、csv等。</p><h2 id="1-文本文件"><a href="#1-文本文件" class="headerlink" title="1.文本文件"></a>1.文本文件</h2><h3 id="（1）、将数组保存到文本文件"><a href="#（1）、将数组保存到文本文件" class="headerlink" title="（1）、将数组保存到文本文件."></a>（1）、将数组保存到文本文件.</h3><p>函数savetxt(fname, X, fmt=’%.18e’, delimiter=’ ‘, newline=’\n’, header=’’,footer=’’, comments=’# ‘, encoding=None)</p><p>*参数：</p><p>*（1）fname：指定文件名或文件句柄，如果文件名以<code>.gz</code>结尾，则文件会自动保存为压缩gzip格式。</p><p>*（2）X：集合对象，为需要保存的数据。</p><p>*（3）fmt：为指定存储格式，字符串型，可选。如’%.2f’要求保留的浮点数为两位小数，这种情况下忽略分隔符。’%.4e’为复数格式。</p><p>*（4）delimite：可选，分隔列的字符串或字符。如’,’。</p><p>*（5）newline：数据行之间的分隔符，字符串或字符分隔线，可选，默认值为’\n’。</p><p>*（6）header：可选，在文件开头写入的字符串。</p><p>*（7）footer：可选，在文件末尾写入的字符串。</p><p>*（8）comments：可选，将被添加到文件头或尾的标记信息，默认值为’#’。</p><p>*（9）encoding：可选，用于编码输出文件的编码，默认编码为’ latin1’。</p><p>例1、将数组保存到文本文件</p><p>import numpy as np</p><p>data=np.arange(12).reshape(3,4)</p><p>np.savetext(r’/A1.txt’,data,delimiter=’,’)</p><p>加 r 会把字符串转变为非转义的原始字符串。</p><h3 id="（2）从文本文件加载数据"><a href="#（2）从文本文件加载数据" class="headerlink" title="（2）从文本文件加载数据"></a>（2）从文本文件加载数据</h3><p><em><strong>函数</strong></em>*loadtxt(fname, dtype=&lt;class ‘float’&gt;, comments=’#’, delimiter=None,converters=None,skiprows=0, usecols=None, unpack=False, ndmin=0,encoding=’bytes’,max_rows=None)</p><p>*参数：</p><p>*（1）fname：指定要读取的文件，文件名或生成器。如果文件扩展名为.gz或.bz2，则首先解压缩该文件。请注意，生成器支持返回Python 3版本的字节字符串。</p><p>*（2）dtype（数据类型），可选，结果数组的数据类型;默认值浮点数。</p><p>*（3）comments（注释），str或str的序列，可选。</p><p>*（4）delimiter（分隔符）：str，可选，指定要读取文件里用于分隔值的字符串，默认值为空格。</p><p>*（5）converters（转换器）：dict，可选，将列号映射到将列字符串解析为所需值的函数的字典。例如，如果第0列是日期字符串：converters = {0：datestr2num}。默认值：无。</p><p>*（6）skiprows（跳行）：跳过前几行读取，必须是整型，可选，默认值为0。</p><p>*（7）usecols：指定需要读取的列（必须是整数），0为第一列，例如，usecols =（1,2,4）将提取第2列、第3列和第5列。默认值None为读取所有列。</p><p>*（8）unpack（解包）：bool，可选，如果为True，则返回的数组被转置，因此可以使用x，y，z = loadtxt（…）解压缩参数。与结构化数据类型一起使用时，将为每个字段返回数组。默认值为False。</p><p>*（9）ndmin（指定返回数组的维度）：整型，可选，返回的数组至少具有ndmin维度。否则将以一维数组形式返回。合法值：0（默认值），1或2。</p><p>*（10）encoding：str，可选，用于解码输入文件的编码。不适用于输入流。特殊值’bytes’启用向后兼容性解决方法，尽可能接收字节数组作为结果，并将’latin1’编码字符串传递给转换器。重写此值以接收unicode数组并将字符串作为输入传递给转换器。如果设置为“无”，则使用系统默认值。默认值为’bytes’。</p><p>*（11）max_rows读取指定范围的行内容：整型，可选，在跳过指定行后，读取max_rows行内容。默认是读取所有行。</p><p><img src="/2020/04/18/shujufenxi/numpy%E8%A1%A5%E5%85%85/image-20211101050632607.png" alt="image-20211101050632607"></p><h3 id="（3）使用正则表达式解析从文本文件构造数组"><a href="#（3）使用正则表达式解析从文本文件构造数组" class="headerlink" title="（3）使用正则表达式解析从文本文件构造数组"></a>（3）使用正则表达式解析从文本文件构造数组</h3><p>函数fromregex(file,regexp,dtype, encoding=None)，</p><p>*（1）file，要读取的文件名或文件对象。</p><p>*（2）regexp，用于解析文件的正则表达式，正则表达式中的组对应于dtype中的字段。</p><p>*（3）dtype，指定生成数组的数据类型，可以指定类型值，也可以时集合类型。</p><p>*（4）encoding，字符串，可选。用于解码输入文本文件的编码。</p><p>with open(‘test.dat’, ‘w’) as f:</p><p>​    f.write(“2000 Tom\n3000 Go\n3333  John”)</p><p>regexp = r”(\d+)\s+(…)” #匹配数字(\d+)，空白\s+，任何东西(…)</p><p>output = np.fromregex(‘test.dat’, regexp,[(‘Number’, np.int64), (‘key’, ‘S3’)])</p><p>output</p><p><img src="/2020/04/18/shujufenxi/numpy%E8%A1%A5%E5%85%85/image-20211101051157264.png" alt="image-20211101051157264"></p><h2 id="2-二进制文件"><a href="#2-二进制文件" class="headerlink" title="2.二进制文件"></a>2.二进制文件</h2><h3 id="（1）将数组保存为Numpy（扩展名为-npy-格式的二进制文件"><a href="#（1）将数组保存为Numpy（扩展名为-npy-格式的二进制文件" class="headerlink" title="（1）将数组保存为Numpy（扩展名为.npy)格式的二进制文件"></a>（1）将数组保存为Numpy（扩展名为.npy)格式的二进制文件</h3><p>*以二进制数据形式存储数据的文件，用专业工具（如Debug、WinHex、U_Edit）打开时往往显示的是十六进制（相比二进制十六进制更方便读写）。图形文件、可执行程序、后缀名为bin的驱动程序都属于二进制文件。</p><p>*将数组保存为NumPy（扩展名为.npy）格式的二进制文件。</p><p>函数save(file, arr,allow_pickle=True, fix_imports=True)</p><p>*（1）file，指定需要保存的Numpy格式的二进制格式的文件名。</p><p>*（2）arr，类似数组的需要存储的数据对象。</p><p>*（3）allow_pickle，在默认值True情况下允许使用Python pickles保存对象数组；若为False则禁止使用pickle方式。</p><p>*（4）fix_imports，默认值为True，则pickle将尝试将新的Python 3名称映射到Python 2中使用的旧模块名称，以便使用Python 2可读取pickle数据流。</p><p>A1=np.arange(9).reshape(3,3)</p><p>np.save(‘testB’,A1)         </p><h3 id="（2）从-npy，-npz或pickled文件加载数组或pickle对象"><a href="#（2）从-npy，-npz或pickled文件加载数组或pickle对象" class="headerlink" title="（2）从.npy，.npz或pickled文件加载数组或pickle对象"></a>（2）从.npy，.npz或pickled文件加载数组或pickle对象</h3><p>函数load(file,mmap_mode=None,allow_pickle=True,fix_imports=True,encoding=’ASCII’)</p><p>* （1）file，指定需要读取的二进制文件名，字符串、pathlib.Path。</p><p>* （2）mmap_mode，读写模式，可选参数值包括了None、’r+’、’w+’、’c’。  如果不是None，则使用给定模式对文件进行内存映射。它可以像任何ndarray一样访问和切片。 内存映射对于访问大型文件的小片段而不将整个文件读入内存特别有用。</p><p>* （3）allow_pickle，布尔，允许加载存储在npy文件中的pickled对象数组。 禁止pickle的原因包括安全性，因为加载pickle数据可以执行任意代码。 如果不允许使用pickle，则加载对象数组将失败。默认值True。pickle模块用来实现python对象的序列化和反序列化。通常地pickle将python对象序列化为二进制流或文件。</p><p>* （4）fix_imports，布尔，仅在Python 3上加载Python 2生成的pickle文件时才有用，其中包括包含对象数组的npy / npz文件。</p><p>* （5）encoding，读取Python 2字符串时要使用的编码。 仅在Python 3中加载Python 2生成的pickle文件时才有用，其中包括包含对象数组的npy / npz文件。 不允许使用“latin1”，“ASCII”和“bytes”以外的值，因为它们可能会破坏数值数据。 默认值’ASCII’。</p><p>B1=np.load(‘testB.npy’)               #读取上列生成的二进制文件</p><p>B1</p><h3 id="3-多个数组以未压缩-npz格式保存到单个文件中"><a href="#3-多个数组以未压缩-npz格式保存到单个文件中" class="headerlink" title="(3)多个数组以未压缩.npz格式保存到单个文件中"></a>(3)多个数组以未压缩.npz格式保存到单个文件中</h3><p>函数savez（file,*args,**kwds)</p><p>x1=np.linspace(1,10,10)</p><p>y1=np.sin(x1)</p><p>np.savez(‘Z1’,x1,y1)</p><p>z1=np.load(‘Z1.npz’)</p><p>for get in Z1.items():</p><p>​    print(get)</p><p>​    print(type(get))</p><h3 id="4-根据文本或二进制文件中的数据构造数组"><a href="#4-根据文本或二进制文件中的数据构造数组" class="headerlink" title="(4)根据文本或二进制文件中的数据构造数组"></a>(4)根据文本或二进制文件中的数据构造数组</h3><p>函数fromfile(file,dtype=float,count=-1,sep=’’)</p><p>file文件名字</p><p>dtype要生成的数组类型</p><p>count要读取的文件的项目数，-1表示所有项目</p><p>sep为项目之间的分隔符</p><p>z1=np.fromfile(‘a.jpg’)</p><p>z1</p><h2 id="3-其他文件"><a href="#3-其他文件" class="headerlink" title="3.其他文件"></a>3.其他文件</h2><p>通用数据源文件（文件，http，ftp，…）</p><p>DataSource(destpath=’.’)对象，DataSource对象的方法支持可以是本地文件或远程文件/ URL的操作。 文件也可以是压缩的或未压缩的。 DataSource对象隐藏了下载文件的一些低级细节，允许简单地设置有效的文件路径（或URL）并获取文件对象。参数destpath，指定下载源文件的目录的路径；当destpath值为None，将创建一个临时目录，默认路径是当前目录。</p><p>ds=np.DataSource(path.abspath(path.curdir))</p><p>if ds.exists(r’<a href="https://docs.scipy.org/doc/numpy/numpy-user-1.16.1.pdf&#39;">https://docs.scipy.org/doc/numpy/numpy-user-1.16.1.pdf&#39;</a>):</p><p>​        ds.open(r’<a href="https://docs.scipy.org/doc/numpy/numpy-user-1.16.1.pdf&#39;">https://docs.scipy.org/doc/numpy/numpy-user-1.16.1.pdf&#39;</a>)</p><p>else:</p><pre><code class="hljs">     print(&#39;没有文件下载&#39;)</code></pre><p>​     </p>]]></content>
    
    
    <categories>
      
      <category>数据分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>numpy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据统计分析案例</title>
    <link href="/2020/03/28/shujufenxi/%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90%E6%A1%88%E4%BE%8B/"/>
    <url>/2020/03/28/shujufenxi/%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90%E6%A1%88%E4%BE%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="第9章-数据统计分析案例"><a href="#第9章-数据统计分析案例" class="headerlink" title="第9章　数据统计分析案例"></a>第9章　数据统计分析案例</h1><p>本章以案例为主，通过简单的知识讲解使读者了解数据统计分析中常用的分析方法，如对比分析，同比、定比和环比分析，贡献度分析，差异化分析，相关性分析和时间序列分析的概念。通过典型案例，将数据统计分析方法与前面学习的内容相结合，力求将所学内容应用到实践中。</p><h1 id="9-1-对比分析"><a href="#9-1-对比分析" class="headerlink" title="9.1　对比分析"></a>9.1　对比分析</h1><h2 id="9-1-1-什么是对比分析"><a href="#9-1-1-什么是对比分析" class="headerlink" title="9.1.1　什么是对比分析"></a>9.1.1　什么是对比分析</h2><p>对比分析法是将两个或两个以上的数据进行比较，分析其中的差异，从而揭示这些事物代表的发展变化情况和规律性。<br>特点：非常直观地看出事物某方面的变化或差距，而且可以准确、量化地表示出变化的差距是多少。<br>对比分析法通常是把两个相互联系的指标数据进行比较，从数量上展示和说明研究对象规模的大小、水平的高低、速度的快慢，以及各种关系是否协调。对比分析一般来说有以下几种对比方法：纵向对比、横向对比、标准对比、实际与计划对比。</p><h2 id="9-1-2-案例：对比分析各品牌销量表现TOP10"><a href="#9-1-2-案例：对比分析各品牌销量表现TOP10" class="headerlink" title="9.1.2　案例：对比分析各品牌销量表现TOP10"></a>9.1.2　案例：对比分析各品牌销量表现TOP10</h2><p>案例位置：资源包\MR\Code\09\example\01<br>对比国产各品牌汽车2020年1月销量，效果如图9.1所示。<br>程序代码如下：</p><p><img src="/2020/03/28/shujufenxi/%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90%E6%A1%88%E4%BE%8B/image-20211101091340914.png" alt="image-20211101091340914"></p><p><img src="/2020/03/28/shujufenxi/%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90%E6%A1%88%E4%BE%8B/image-20211101091429952.png" alt="image-20211101091429952"></p><p>​                                                                                     图9.1　对比分析各品牌销量表现TOP10</p><h1 id="9-2-同比、定比和环比分析"><a href="#9-2-同比、定比和环比分析" class="headerlink" title="9.2　同比、定比和环比分析"></a>9.2　同比、定比和环比分析</h1><p>在数据分析中，有一个重要的分析方法，叫趋势分析法，即将两期或连续数期报告中某一指标进行对比，确定其增减变动的方向、数额和幅度，以确定该指标的变动趋势。趋势分析法中的指标，有同比分析、定比（定基比）分析和环比分析，以及同比增长率分析、定比（定基比）增长率分析和环比增长率分析。</p><h2 id="9-2-1-同比、定比和环比概述"><a href="#9-2-1-同比、定比和环比概述" class="headerlink" title="9.2.1　同比、定比和环比概述"></a>9.2.1　同比、定比和环比概述</h2><p>首先了解一下同比、定比和环比的概念。　</p><p>同比：本期数据与历史同期数据比较。例如，2021年11月份与2020年11月份相比较。　</p><p>定比：本期数据与特定时期的数据比较。例如，2021年11月与2019年12月份相比较。　</p><p>环比：本期数据与上期数据比较。例如，2021年11月份与2020年10月份相比较。</p><p>同比的好处是可以排除一部分季节因素；环比的好处是可以更直观地表明阶段性的变换，但是会受季节性因素影响；定比常用于财务数据分析。下面来看一个生活中经常出现的场景。　同比：去年这个这时候这条裙子我还能穿，现在穿不进去啦！　定比：年龄，50岁是25岁的两倍。　环比：这个月好像比上个月胖了。<br>下面简单介绍一下同比、定比和环比计算的公式。</p><h3 id="1．同比"><a href="#1．同比" class="headerlink" title="1．同比"></a>1．同比</h3><p>同比的计算公式如下：</p><p><img src="/2020/03/28/shujufenxi/%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90%E6%A1%88%E4%BE%8B/image-20211101091544403.png" alt="image-20211101091544403"></p><h3 id="2．定比"><a href="#2．定比" class="headerlink" title="2．定比"></a>2．定比</h3><p>定比的计算公式如下：</p><p><img src="/2020/03/28/shujufenxi/%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90%E6%A1%88%E4%BE%8B/image-20211101091601809.png" alt="image-20211101091601809"></p><h3 id="3．环比"><a href="#3．环比" class="headerlink" title="3．环比"></a>3．环比</h3><p>环比增长率反映本期比上期增长了多少，公式如下：</p><p><img src="/2020/03/28/shujufenxi/%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90%E6%A1%88%E4%BE%8B/image-20211101091624602.png" alt="image-20211101091624602"></p><p>环比发展速度是本期水平与前一期水平之比，反映前后两期的发展变化情况，公式如下：</p><p><img src="/2020/03/28/shujufenxi/%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90%E6%A1%88%E4%BE%8B/image-20211101091640229.png" alt="image-20211101091640229"></p><h2 id="9-2-2-案例1：京东电商单品销量同比增长情况分析"><a href="#9-2-2-案例1：京东电商单品销量同比增长情况分析" class="headerlink" title="9.2.2　案例1：京东电商单品销量同比增长情况分析"></a>9.2.2　案例1：京东电商单品销量同比增长情况分析</h2><p>案例位置：资源包\MR\Code\09\example\02\01<br>下面分析2020年2月与2019年2月相比，京东电商《零基础学Python（全彩版）》一书销量同比增长情况，效果如图9.2所示。<br>从分析结果得知：上海、武汉同比增长较小。</p><p><img src="/2020/03/28/shujufenxi/%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90%E6%A1%88%E4%BE%8B/image-20211101091708101.png" alt="image-20211101091708101"></p><p>​                                                                                                              图9.2　同比分析<br>程序代码如下：</p><p><img src="/2020/03/28/shujufenxi/%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90%E6%A1%88%E4%BE%8B/image-20211101091740885.png" alt="image-20211101091740885"></p><h2 id="9-2-3-案例2：单品销量定比分析"><a href="#9-2-3-案例2：单品销量定比分析" class="headerlink" title="9.2.3　案例2：单品销量定比分析"></a>9.2.3　案例2：单品销量定比分析</h2><p>案例位置：资源包\MR\Code\09\example\02\02<br>下面实现京东电商《零基础学Python（全彩版）》一书2019年销量定比分析，以2019年1月为基期，基点为1，效果如图9.3所示。</p><p><img src="/2020/03/28/shujufenxi/%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90%E6%A1%88%E4%BE%8B/image-20211101091933203.png" alt="image-20211101091933203"></p><p>​                                                                                                      图9.3　定比分析<br>从图9.3中可以看到，6月开始呈现连续小幅度增长，到11月开始大幅度增长，定比指数较10月提高了3.028个点。<br>程序代码如下：</p><p><img src="/2020/03/28/shujufenxi/%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90%E6%A1%88%E4%BE%8B/image-20211101092002261.png" alt="image-20211101092002261"></p><h2 id="9-2-4-案例3：单品销量环比增长情况分析"><a href="#9-2-4-案例3：单品销量环比增长情况分析" class="headerlink" title="9.2.4　案例3：单品销量环比增长情况分析"></a>9.2.4　案例3：单品销量环比增长情况分析</h2><p>案例位置：资源包\MR\Code\09\example\02\03<br>下面分析京东电商《零基础学Python（全彩版）》一书2019年销量环比增长情况，效果如图9.4所示。</p><p><img src="/2020/03/28/shujufenxi/%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90%E6%A1%88%E4%BE%8B/image-20211101092041392.png" alt="image-20211101092041392"></p><p>​                                                                                                    图9.4　环比分析<br>程序代码如下：</p><p><img src="/2020/03/28/shujufenxi/%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90%E6%A1%88%E4%BE%8B/image-20211101092113806.png" alt="image-20211101092113806"></p><p>实用技巧<br>在使用Matplotlib绘制图表时，发现了一个警告Warining，如图9.5所示。</p><p><img src="/2020/03/28/shujufenxi/%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90%E6%A1%88%E4%BE%8B/image-20211101092157969.png" alt="image-20211101092157969"></p><p>​                                                                                                                  图9.5　警告信息<br>完整警告信息如下：<br>MatplotlibDeprecationWarning:<br>Adding an axes using the same arguments as a previous axes currently reuses the earlier instance. In a future version, a new instance will always be created and returned. Meanwhile, this warning can be suppressed, and the future behavior ensured, by passing a unique label to each axes instance.<br>“Adding an axes using the same arguments as a previous axes “<br>解决方法：<br>出现上述警告，原因是在创建画布fig=plt.figure()后就设置了图表标题或坐标轴标签，将图表标题或坐标轴标签相关代码放置在定义子图ax=fig.add_subplot(111)代码后就不会出现警告信息了。</p><h1 id="9-3-贡献度分析（帕累托法则）"><a href="#9-3-贡献度分析（帕累托法则）" class="headerlink" title="9.3　贡献度分析（帕累托法则）"></a>9.3　贡献度分析（帕累托法则）</h1><h2 id="9-3-1-什么是贡献度分析"><a href="#9-3-1-什么是贡献度分析" class="headerlink" title="9.3.1　什么是贡献度分析"></a>9.3.1　什么是贡献度分析</h2><p>贡献度分析又称80/20法则、二八法则、帕累托法则、帕累托定律、最省力法则或不平衡原则。<br>该法则是由意大利经济学家“帕累托”提出的。80/20法则认为：原因和结果、投入和产出、努力和报酬之间本来存在着无法解释的不平衡。例如，一个公司80%的利润常常来自20%的产品，那么使用贡献度分析就可以分析获利最高的20%的产品。<br>下面简单介绍一下贡献率相关算法。</p><p><img src="/2020/03/28/shujufenxi/%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90%E6%A1%88%E4%BE%8B/image-20211101092249403.png" alt="image-20211101092249403"></p><p>通过上述公式得出累计贡献率，当累计贡献率接近80%时（不一定正好是80%)，然后找到该产品在图表中相应的位置并进行标注。说明<br>真正的比例不一定正好是80%:20%。80/20法则表明在多数情况下该关系很可能是不平衡的，并且接近于80/20。</p><h2 id="9-3-2-案例：产品贡献度分析"><a href="#9-3-2-案例：产品贡献度分析" class="headerlink" title="9.3.2　案例：产品贡献度分析"></a>9.3.2　案例：产品贡献度分析</h2><p>案例位置：资源包\MR\Code\09\example\03<br>下面分析淘宝电商全彩系列图书2018年上半年销售收入占比80%的产品。首先，使用9.3.1节中的公式计算产品累计贡献率，结果如图9.6所示。从图9.6中可以看出，到图书编号B13时，累计贡献率就已达到了0.817665（接近总销售收入的80%），其中共有10种产品，接下来在图表中进行标注，如图9.7所示。</p><p><img src="/2020/03/28/shujufenxi/%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90%E6%A1%88%E4%BE%8B/image-20211101092358482.png" alt="image-20211101092358482"></p><p>​                                                                                         图9.6　输出累计贡献率</p><p><img src="/2020/03/28/shujufenxi/%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90%E6%A1%88%E4%BE%8B/image-20211101092428830.png" alt="image-20211101092428830"></p><p>​                                                                                                   图9.7　产品贡献度分析<br>程序代码如下：</p><p><img src="/2020/03/28/shujufenxi/%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90%E6%A1%88%E4%BE%8B/image-20211101092455112.png" alt="image-20211101092455112"></p><h1 id="9-4-差异化分析"><a href="#9-4-差异化分析" class="headerlink" title="9.4　差异化分析"></a>9.4　差异化分析</h1><h2 id="9-4-1-差异化概述"><a href="#9-4-1-差异化概述" class="headerlink" title="9.4.1　差异化概述"></a>9.4.1　差异化概述</h2><p>任何事物都存在差异，如同上课听讲，有人津津有味，有人昏昏欲睡。<br>那么，通过差异化分析，比较不同事物之间在某个指标上存在的差异，根据差异定制不同的策略。对于产品而言，差异化分析是指企业在其提供给顾客的产品上，通过各种方法满足顾客的偏好，使顾客能够把它同其他竞争企业提供的同类产品有效地区别开来，从而使企业在市场竞争中占据有利的地位。<br>比较常见的有性别差异、年龄差异。通过差异化分析比较不同性别之间在某个指标上存在的差异，通过分析结果对不同性别定制不同的方案。例如，分析不同性别的同学在学习成绩上的差异，了解男生和女生之间的这些差异，因材施教，定制不同的弥补弱项的方案。对于女生，可以有意识地培养她的思维能力；而对于男生，可以买些书籍，来增强他薄弱的方面。<br>年龄差异化分析，了解不同年龄的需求，投其所好，使企业的利润最大化。例如，网购、自媒体、汽车、旅游等行业，通过年龄差异化分析，找出不同年龄段用户群体的喜好，从而增加产品销量。</p><h2 id="9-4-2-案例：学生成绩性别差异分析"><a href="#9-4-2-案例：学生成绩性别差异分析" class="headerlink" title="9.4.2　案例：学生成绩性别差异分析"></a>9.4.2　案例：学生成绩性别差异分析</h2><p>案例位置：资源包\MR\Code\09\example\04<br>“女孩喜欢毛绒玩具，男孩喜欢车”这大概是天生的。<br>科学研究表明，男孩和女孩的差别在相当程度上是由生理基础决定的。通过高科技扫描就可以发现，男孩和女孩的大脑都会有某些部位比对方相应的部位更发达、更忙碌。<br>随着孩子的成长，这种天生的性别差异就会对孩子的学习有所影响，并且不断强化。而反过来，学习的本身也在改变着大脑的机能发育。因为当孩子玩耍和学习时，相对应的脑细胞就会更加活跃且随时更新，而那些不经常使用的部分将会逐渐退化萎缩。<br>下面我们用数据说话，通过雷达图分析男生、女生各科成绩差异，效果如图9.8所示。</p><p><img src="/2020/03/28/shujufenxi/%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90%E6%A1%88%E4%BE%8B/image-20211101093258671.png" alt="image-20211101093258671"></p><p>​                                                                                 图9.8　男生、女生各科成绩差异分析<br>从分析结果得知：男生数学和物理高于女生，而女生在英语和语文上略占优势。针对性别差异造成学习成绩的差距，应该采取因材施教，从而提高女生的数学和物理成绩</p><p>男生的语文和英语成绩。<br>程序代码如下：</p><p><img src="/2020/03/28/shujufenxi/%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90%E6%A1%88%E4%BE%8B/image-20211101093347266.png" alt="image-20211101093347266"></p><h1 id="9-5-相关性分析"><a href="#9-5-相关性分析" class="headerlink" title="9.5　相关性分析"></a>9.5　相关性分析</h1><h2 id="9-5-1-相关性概述"><a href="#9-5-1-相关性概述" class="headerlink" title="9.5.1　相关性概述"></a>9.5.1　相关性概述</h2><p>任何事物之间都存在一定的联系。例如，夏天温度的高低与空调的销量就存在相关性。当温度升高时，空调的销量也会相应提高。<br>相关性分析是指对多个具备相关关系的数据进行分析，从而衡量数据之间的相关程度或密切程度。相关性可以应用到所有数据的分析过程中。如果一组数据的改变引发另一组数据朝相同方向变化，那么这两组数据存在正相关性，例如，身高与体重，一般个子高的人体重会重一些，个子矮的人体重会轻一些；如果一组数据的改变引发另一组数据朝相反方向变化，那么这两组数据存在负相关性，例如，运动与体重。</p><h2 id="9-5-2-案例：广告展现量与费用成本相关性分析"><a href="#9-5-2-案例：广告展现量与费用成本相关性分析" class="headerlink" title="9.5.2　案例：广告展现量与费用成本相关性分析"></a>9.5.2　案例：广告展现量与费用成本相关性分析</h2><p>案例位置：资源包\MR\Code\09\example\05<br>为了促进销售，电商营销必然要投入广告，这样就会产生广告展现量和费用成本相关的数据。通常情况下，我们认为费用高，广告效果就好，它们之间必然存在联系，但仅通过主观判断没有说服力，无法证明数据之间关系的真实存在，也无法度量它们之间关系的强弱。因此，我们要通过相关性分析来找出数据之间的关系。<br>下面来看一下费用成本与广告展现量相关数据情况（由于数据太多，只显示部分数据），如图9.9和图9.10所示。</p><p><img src="/2020/03/28/shujufenxi/%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90%E6%A1%88%E4%BE%8B/image-20211101093655985.png" alt="image-20211101093655985"></p><p>​                                                                                                图9.9　费用成本</p><p><img src="/2020/03/28/shujufenxi/%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90%E6%A1%88%E4%BE%8B/image-20211101093722813.png" alt="image-20211101093722813"></p><p>​                                                                                                图9.10　广告展现量<br>相关性分析方法很多，简单的相关性分析方法是将数据进行可视化处理，单纯从数据的角度很难发现数据之间的趋势和联系，而将数据绘制成图表后就可以直观地看出数据之间的趋势和联系。<br>下面通过散点图看一看广告展现量与费用成本的相关性，效果如图9.11所示。</p><p><img src="/2020/03/28/shujufenxi/%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90%E6%A1%88%E4%BE%8B/image-20211101093751243.png" alt="image-20211101093751243"></p><p>​                                                                                                            图9.11　散点图<br>首先对数据进行简单处理，由于“费用.xlsx”表中同一天会产生多个类型的费用，所以需要按天统计费用，然后将“展现量.xlsx”和“费用.xlsx”两张表的数据合并，最后绘制散点图，程序代码如下：</p><p><img src="/2020/03/28/shujufenxi/%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90%E6%A1%88%E4%BE%8B/image-20211101093837899.png" alt="image-20211101093837899"></p><p>虽然图表清晰地展示了广告展现量与费用成本的相关性，但无法判断数据之间有什么关系，相关关系也没有准确地度量，并且数据超过两组时也无法完成各组数据的相关性分析。<br>下面再介绍一种方法——相关系数方法。相关系数是反映数据之间关系密切程度的统计指标，相关系数的取值区间为1～-1。1表示数据之间完全正相关（线性相关）；-1表示数据之间完全负相关；0表示数据之间不相关。数据越接近0表示相关关系越弱，越接近1表示相关关系越强。<br>计算相关系数需要一定的计算公式，而在Python中无须使用烦琐的公式，通过DataFrame对象提供的corr()函数就可以轻松实现，关键代码如下：</p><p>data.corr()<br>运行程序，输出结果如图9.12所示。</p><p><img src="/2020/03/28/shujufenxi/%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90%E6%A1%88%E4%BE%8B/image-20211101093902187.png" alt="image-20211101093902187"></p><pre><code class="hljs">                                                                                             图9.12　各组数据的相关系数</code></pre><p>从分析结果得知：“费用”与“费用”自身的相关性是1，与“展现量”“点击量”的相关系数分别是0.856013、0.858597；“展现量”与“展现量”自身的相关性是1，与“点击量”“订单金额”的相关系数分别是0.938554、0.728037。那么，除了“商品关注数”相关系数比较低，其他都很高，可以看出“费用”与“展现量”“点击量”等有一定的正相关性，而且相关性很强。<br>相关系数的优点是可以通过数字对变量的关系进行度量，并且带有方向性，1表示正相关，-1表示负相关，越靠近0相关性越弱。缺点是无法利用这种关系对数据进行预测。</p><h1 id="9-6-时间序列分析"><a href="#9-6-时间序列分析" class="headerlink" title="9.6　时间序列分析"></a>9.6　时间序列分析</h1><h2 id="9-6-1-时间序列概述"><a href="#9-6-1-时间序列概述" class="headerlink" title="9.6.1　时间序列概述"></a>9.6.1　时间序列概述</h2><p>顾名思义，时间序列就是按照时间顺序排列的一组数据序列。时间序列分析就是找出数据变化发展的规律，从而预测未来的走势。<br>时间序列分析有以下几种表现形式。　长期趋势变化：受某种因素的影响，数据依据时间变化，按某种规则稳步增长或下降。使用的分析方法有移动平均法、指数平滑法等。　季节性周期变化：受季节更替等因素影响，数据依据固定周期规则性的变化。季节性周期变化，不局限于自然季节，还包括月、周等短期周期。例如，空调、羽绒服、冷饮的销售，双十一、双十二流量在一周之内的波动等。采用的方法为季节指数。　循环变化：指一种较长时间的上、下起伏周期性波动，一般循环时间为2～15年。　随机性变化：由许多不确定因素引起的数据变化，在时间序列中无法预计。</p><h2 id="9-6-2-案例：年增长趋势和季节性波动分析"><a href="#9-6-2-案例：年增长趋势和季节性波动分析" class="headerlink" title="9.6.2　案例：年增长趋势和季节性波动分析"></a>9.6.2　案例：年增长趋势和季节性波动分析</h2><p>案例位置：资源包\MR\Code\09\example\06<br>下面分析淘宝店铺近3年增长趋势和季节性波动，如图9.13所示。从分析结果得出，近3年淘宝店铺收入呈现持续稳定增长趋势，但2019年有所下降，季节性波动比较明显，每年的第4季度是销售“旺季”。<br>程序代码如下：</p><p><img src="/2020/03/28/shujufenxi/%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90%E6%A1%88%E4%BE%8B/image-20211101094004956.png" alt="image-20211101094004956"></p><p><img src="/2020/03/28/shujufenxi/%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90%E6%A1%88%E4%BE%8B/image-20211101094315925.png" alt="image-20211101094315925"></p><p>​                                                                                                             图9.13　年增长趋势和季节性波动</p><h1 id="9-7-小结"><a href="#9-7-小结" class="headerlink" title="9.7　小结"></a>9.7　小结</h1><p>本章通过常用的数据分析方法并结合图表，以案例的形式呈现，每一种分析方法都对应一个恰当的分析案例，一张贴切的图表，力求使读者能够真正理解数据分析，并将其应用到实际数据分析工作中。每一个案例都经过作者反复揣摩，希望能够对读者有所帮助。-</p>]]></content>
    
    
    <categories>
      
      <category>数据分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>案例</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算模块numpy</title>
    <link href="/2020/03/21/shujufenxi/%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97numpy/"/>
    <url>/2020/03/21/shujufenxi/%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97numpy/</url>
    
    <content type="html"><![CDATA[<h1 id="第8章图解数组计算模块NumPy"><a href="#第8章图解数组计算模块NumPy" class="headerlink" title="第8章图解数组计算模块NumPy"></a>第8章图解数组计算模块NumPy</h1><p>NumPy为数据分析三剑客之一，主要用于数组计算、矩阵运算和科学计算。对于本章的学习，建议初学者灵活学习，重点掌握数组创建、数组的简单操作和计算即可。<br>为了便于理解，本章运用了大量的示意图，用例简单，力求使您能够轻松地融入NumPy的学习中。通过典型案例，让您充分理解NumPy、应用NumPy。<br>下面让我们揭开NumPy神秘的面纱，开启NumPy之旅。</p><h1 id="8-1初识NumPy"><a href="#8-1初识NumPy" class="headerlink" title="8.1初识NumPy"></a>8.1初识NumPy</h1><h2 id="8-1-1NumPy概述"><a href="#8-1-1NumPy概述" class="headerlink" title="8.1.1NumPy概述"></a>8.1.1NumPy概述</h2><p>NumPy（见图8.1），更像是一个魔方（见图8.2），它是Python数组计算、矩阵运算和科学计算的核心库，NumPy这个词来源于Numerical和Python两个单词。NumPy提供了一个高性能的数组对象，让我们轻松创建一维数组、二维数组和多维数组，以及大量的函数和方法，帮助我们轻松地进行数组计算，从而广泛地应用于数据分析、机器学习、图像处理和计算机图形学、数学任务等领域当中。</p><p><img src="/2020/03/21/shujufenxi/%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97numpy/image-20211025110157989.png" alt="image-20211025110157989"></p><p>​                                                                                                            图8.1　NumPy</p><p><img src="/2020/03/21/shujufenxi/%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97numpy/image-20211025110220048.png" alt="image-20211025110220048"></p><p>​                                                                                                             图8.2　魔方<br>NumPy的用途是以数组的形式对数据进行操作。机器学习中充斥了大量的数组运算，而NumPy使得这些操作变得简单！由于NumPy是C语言实现的，所以其运算速度非常快。具体功能如下。　</p><p>有一个强大的n维数组对象ndarray。　</p><p>广播功能函数。　</p><p>线性代数、傅立叶变换、随机数生成、图形操作等功能。</p><p>整合C/C++/Fortran代码的工具。</p><h2 id="8-1-2-安装NumPy模块"><a href="#8-1-2-安装NumPy模块" class="headerlink" title="8.1.2　安装NumPy模块"></a>8.1.2　安装NumPy模块</h2><p>安装NumPy有两种方法。</p><h3 id="1．使用pip安装"><a href="#1．使用pip安装" class="headerlink" title="1．使用pip安装"></a>1．使用pip安装</h3><p>安装NumPy最简单的方法是使用pip工具，安装命令如下：</p><p>pip install pip</p><h3 id="2．在PyCharm开发环境中安装"><a href="#2．在PyCharm开发环境中安装" class="headerlink" title="2．在PyCharm开发环境中安装"></a>2．在PyCharm开发环境中安装</h3><p>（1）运行PyCharm，选择File→Settings命令，打开Settings对话框，选择Project Interpreter选项，然后单击添加模块的按钮，如图8.3所示。</p><p><img src="/2020/03/21/shujufenxi/%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97numpy/image-20211025110322698.png" alt="image-20211025110322698"></p><p>​                                                                                    图8.3　单击添加模块的按钮<br>（2）在搜索栏中输入需要添加的模块名称为numpy，然后选择需要安装的模块，如图8.4所示。单击Install Package按钮即可安装NumPy模块。</p><h3 id="3．安装验证"><a href="#3．安装验证" class="headerlink" title="3．安装验证"></a>3．安装验证</h3><p>测试是否安装成功，程序代码如下：</p><p>01  from numpy import *   #导入numpy库<br>02  print(eye(4))          #生成对角矩阵<br>运行程序，输出结果如下：</p><p><img src="/2020/03/21/shujufenxi/%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97numpy/image-20211025110347905.png" alt="image-20211025110347905"></p><p><img src="/2020/03/21/shujufenxi/%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97numpy/image-20211025111116413.png" alt="image-20211025111116413"></p><p>图8.4　在PyCharm开发环境中安装NumPy模块</p><h2 id="8-1-3-数组相关概念"><a href="#8-1-3-数组相关概念" class="headerlink" title="8.1.3　数组相关概念"></a>8.1.3　数组相关概念</h2><p>学习NumPy前，我们先了解一下数组相关概念。数组可分为一维数组、二维数组、三维数组，其中三维数组是常见的多维数组，如图8.5所示。</p><p><img src="/2020/03/21/shujufenxi/%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97numpy/image-20211025112546228.png" alt="image-20211025112546228"></p><p>​                                                                                                 图8.5　数组示意图<br>1．一维数组<br>一维数组很简单，基本和Python列表一样，区别在于数组切片针对的是原始数组（这就意味着，如果对数组进行修改，原始数组也会跟着更改）。<br>2．二维数组<br>二维数组本质是以数组作为数组元素的数组。二维数组包括行和列，类似于表格形状，又称为矩阵。<br>3．三维数组<br>三维数组是指维数为3的数组结构，也称矩阵列表。三维数组是最常见的多维数组，由于其可以用来描述三维空间中的位置或状态而被广泛使用。<br>4．轴的概念</p><p>轴是NumPy里的axis，指定某个axis，就是沿着这个axis做相关操作，其中二维数组中两个axis的指向如图8.6所示。<br>对于一维数组，情况有点特殊，它不像二维数组从上向下的操作，而是水平的，因此一维数组其axis=0指向如图8.7所示。</p><p><img src="/2020/03/21/shujufenxi/%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97numpy/image-20211025112732987.png" alt="image-20211025112732987"></p><p>​                                                                                      图8.6　二维数组两个轴</p><p><img src="/2020/03/21/shujufenxi/%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97numpy/image-20211025112750397.png" alt="image-20211025112750397"></p><p>​                                                                                     图8.7　一维数组一个轴</p><h1 id="8-2-创建数组"><a href="#8-2-创建数组" class="headerlink" title="8.2　创建数组"></a>8.2　创建数组</h1><h2 id="8-2-1-创建简单的数组"><a href="#8-2-1-创建简单的数组" class="headerlink" title="8.2.1　创建简单的数组"></a>8.2.1　创建简单的数组</h2><p>NumPy创建简单的数组主要使用array()函数，语法如下：</p><p>numpy.array(object,dtype=None,copy=True,order=’K’,subok=False,ndmin=0)<br>参数说明：　</p><p>object：任何具有数组接口方法的对象。　</p><p>dtype：数据类型。　</p><p>copy：布尔型，可选参数，默认值为True，则object对象被复制；否则，只有当__array__返回副本，object参数为嵌套序列，或者需要副本满足数据类型和顺序要求时，才会生成副本。　</p><p>order：元素在内存中的出现顺序，值为K、A、C、F。如果object参数不是数组，则新创建的数组将按行排列（C），如果值为F，则按列排列；如果object参数是一个数组，则C（按行）、F（按列）、A（原顺序）、K（元素在内存中的出现顺序）成立。　</p><p>subok：布尔型。如果值为True，则将传递子类；否则返回的数组将强制为基类数组（默认值）。　</p><p>ndmin：指定生成数组的最小维数。</p><p>【示例01】　演示如何创建数组。（示例位置：资源包\MR\Code\08\01）<br>创建几个简单的数组，效果如图8.8所示。</p><p><img src="/2020/03/21/shujufenxi/%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97numpy/image-20211025113205539.png" alt="image-20211025113205539"></p><p>​                                                                                                          图8.8　简单数组<br>程序代码如下：</p><p><img src="/2020/03/21/shujufenxi/%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97numpy/image-20211025113400111.png" alt="image-20211025113400111"></p><h3 id="1．为数组指定数据类型"><a href="#1．为数组指定数据类型" class="headerlink" title="1．为数组指定数据类型"></a>1．为数组指定数据类型</h3><p>【示例02】　为数组指定数据类型。（示例位置：资源包\MR\Code\08\02）<br>NumPy支持比Python更多种类的数据类型，通过dtype参数可以指定数组的数据类型，程序代码如下：</p><p><img src="/2020/03/21/shujufenxi/%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97numpy/image-20211025113422663.png" alt="image-20211025113422663"></p><p>运行程序，输出结果如下：</p><p>[1. 2. 3.]<br>float64<br>&lt;class ‘numpy.float64’&gt;</p><h3 id="2．数组的复制"><a href="#2．数组的复制" class="headerlink" title="2．数组的复制"></a>2．数组的复制</h3><p>【示例03】　复制数组。（示例位置：资源包\MR\Code\08\03）<br>当运算和处理数组时，为了不影响到原数组，就需要对原数组进行复制，而对复制后的数组进行修改删除等操作都不会影响到原数组。数组的复制可以通过copy参数实现，程序代码如下：</p><p><img src="/2020/03/21/shujufenxi/%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97numpy/image-20211025113521420.png" alt="image-20211025113521420"></p><p>运行程序，输出结果如下：</p><p>[1 2 3]<br>[3 2 1]<br>数组n2是数组n1的副本，从运行结果得知：虽然修改了数组n2，但是数组n1没有发生变化。</p><h3 id="3．通过ndmin参数控制最小维数"><a href="#3．通过ndmin参数控制最小维数" class="headerlink" title="3．通过ndmin参数控制最小维数"></a>3．通过ndmin参数控制最小维数</h3><p>数组可分为一维数组、二维数组和多维数组，通过ndmin参数可以控制数组的最小维数。无论给出的数据的维数是多少，ndmin参数都会根据最小维数创建指定维数的数组。</p><p>【示例04】　修改数组的维数。（示例位置：资源包\MR\Code\08\04）<br>ndmin=3，虽然给出的数组是一维的，但是同样会创建一个三维数组，程序代码如下：<br>运行程序，输出结果如下：</p><p>[[[1 2 3]]]</p><h2 id="8-2-2-不同方式创建数组"><a href="#8-2-2-不同方式创建数组" class="headerlink" title="8.2.2　不同方式创建数组"></a>8.2.2　不同方式创建数组</h2><h3 id="1．创建指定维度和数据类型未初始化的数组"><a href="#1．创建指定维度和数据类型未初始化的数组" class="headerlink" title="1．创建指定维度和数据类型未初始化的数组"></a>1．创建指定维度和数据类型未初始化的数组</h3><p>【示例05】　创建指定维度和未初始化的数组。（示例位置：资源包\MR\Code\08\05）<br>创建指定维度和数据类型未初始化的数组主要使用empty()函数，程序代码如下：</p><p>01 import numpy as np<br>02 n = np.empty([2,3])<br>03 print(n)<br>运行程序，输出结果如下：</p><p>[[2.22519099e-307 2.33647355e-307 1.23077925e-312]<br>[2.33645827e-307 2.67023123e-307 1.69117157e-306]]<br>这里，数组元素为随机值，因为它们未被初始化。如果要改变数组类型，可以使用dtype参数，如整型，dtype=int。</p><h3 id="2．创建指定维度（以0填充）的数组"><a href="#2．创建指定维度（以0填充）的数组" class="headerlink" title="2．创建指定维度（以0填充）的数组"></a>2．创建指定维度（以0填充）的数组</h3><p>【示例06】　创建指定维度（以0填充）的数组。（示例位置：资源包\MR\Code\08\06）<br>创建指定维度并以0填充的数组，主要使用zeros()函数，程序代码如下：</p><p>01  import numpy as np<br>02  n = np.zeros(3)<br>03  print(n)<br>运行程序，输出结果如下：</p><p>[0. 0. 0.]<br>输出结果默认是浮点型（float）。</p><h3 id="3．创建指定维度（以1填充）的数组"><a href="#3．创建指定维度（以1填充）的数组" class="headerlink" title="3．创建指定维度（以1填充）的数组"></a>3．创建指定维度（以1填充）的数组</h3><p>【示例07】　创建指定维度并以1填充的数组。（示例位置：资源包\MR\Code\08\07）<br>创建指定维度并以1填充的数组，主要使用ones()函数，程序代码如下：</p><p>01 import numpy as np<br>02 n = np.ones(3)<br>03 print(n)</p><p>运行程序，输出结果如下：</p><p>[1. 1. 1.]<br>4．创建指定维度和类型的数组并以指定值填充【示例08】　创建以指定值填充的数组。（示例位置：资源包\MR\Code\08\08）<br>创建指定维度和类型的数组并以指定值填充，主要使用full()函数，程序代码如下：</p><p>01  import numpy as np<br>02  n = np.full((3,3), 8)<br>03  print(n)<br>运行程序，输出结果如下：</p><p>[[8 8 8]<br> [8 8 8]<br> [8 8 8]]</p><h2 id="8-2-3-从数值范围创建数组"><a href="#8-2-3-从数值范围创建数组" class="headerlink" title="8.2.3　从数值范围创建数组"></a>8.2.3　从数值范围创建数组</h2><h3 id="1．通过arange-函数创建数组"><a href="#1．通过arange-函数创建数组" class="headerlink" title="1．通过arange()函数创建数组"></a>1．通过arange()函数创建数组</h3><p>arange()函数同Python内置range()函数相似，区别在于返回值，arange()函数返回值是数组，而range()函数返回值是列表。arange()函数的语法如下：</p><p>arange([start,] stop[, step,], dtype=None)<br>参数说明：　</p><p>start：起始值，默认值为0。　</p><p>stop：终止值（不包含）。　</p><p>step：步长，默认值为1。　</p><p>dtype：创建数组的数据类型，如果不设置数据类型，则使用输入数据的数据类型。</p><p>【示例09】　通过数值范围创建数组。（示例位置：资源包\MR\Code\08\09）<br>使用arange()函数通过数值范围创建数组，程序代码如下：</p><p>01 import numpy as np<br>02 n=np.arange(1,12,2)<br>03 print(n)<br>运行程序，输出结果如下：</p><p>[ 1  3  5  7  9 11]</p><h3 id="2．使用linspace-函数创建等差数列"><a href="#2．使用linspace-函数创建等差数列" class="headerlink" title="2．使用linspace()函数创建等差数列"></a>2．使用linspace()函数创建等差数列</h3><p>首先简单了解一下等差数列，等差数列是指如果一个数列从第二项起，每一项与它的前一项的差等于同一个常数，那么这个数列就叫作等差数列。<br>例如，一般成年男鞋的各种尺码，如图8.9所示。</p><p><img src="/2020/03/21/shujufenxi/%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97numpy/image-20211025113910259.png" alt="image-20211025113910259"></p><p>​                                                                                         图8.9　男鞋尺码对照表</p><p>马拉松赛前训练，一周每天的训练量（单位：m），如图8.10所示。</p><p><img src="/2020/03/21/shujufenxi/%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97numpy/image-20211025113928239.png" alt="image-20211025113928239"></p><p>​                                                                                        图8.10　训练计划<br>在Python中创建等差数列可以使用NumPy的linspace()函数，该函数用于创建一个一维的等差数列的数组，它与arange()函数不同，arange()函数是从开始值到结束值的左闭右开区间（即包括开始值不包括结束值），第三个参数（如果存在）是步长；而linspace()函数是从开始值到结束值的闭区间（可以通过参数endpoint=False，使结束值不是闭区间），并且第三个参数是值的个数。</p><p>知识胶囊<br>本文经常会提到诸如“左闭右开区间”“左开右闭区间”“闭区间”等，这里简单介绍一下。“</p><p>左闭右开区间”是指包括起始值但不包括终止值的一个数值区间；</p><p>“左开右闭区间”是指不包括起始值但包括终止值的一个个数值区间；</p><p>“闭区间”是指既包括起始值又包括终止值的一个数值区间。</p><p>linspace()函数语法如下：</p><p>linspace(start,stop,num=50,endpoint=True,retstep=False,dtype=None)<br>参数说明：　</p><p>start：序列的起始值。　</p><p>stop：序列的终止值，如果endpoint参数的值为True，则该值包含于数列中。　</p><p>num：要生成的等步长的样本数量，默认值为50。　</p><p>endpoint：如果值为True，数列中包含stop参数的值；反之则不包含。默认值为True。　</p><p>retstep：如果值为True，则生成的数组中会显示间距；反之则不显示。　</p><p>dtype：数组的数据类型。</p><p>【示例10】　创建马拉松赛前训练等差数列数组。（示例位置：资源包\MR\Code\08\10）<br>创建马拉松赛前训练等差数列数组，程序代码如下：</p><p>01 import numpy as np<br>02 n1 = np.linspace(7500,10000,6)<br>03 print(n1)<br>运行程序，输出结果如下：</p><p>[ 7500.  8000.  8500.  9000.  9500. 10000.]</p><h3 id="3．使用logspace-函数创建等比数列"><a href="#3．使用logspace-函数创建等比数列" class="headerlink" title="3．使用logspace()函数创建等比数列"></a>3．使用logspace()函数创建等比数列</h3><p>首先了解一下等比数列，等比数列是指从第二项起，每一项与它的前一项的比值等于同一个常数的一种数列。<br>例如，在古印度，国王要重赏发明国际象棋的大臣，对他说：我可以满足你的任何要求，大臣说：请给我的棋盘的64个格子都放上小麦，第1个格子放1粒小麦，第2个格子放2粒小麦，第3个格子放4粒小麦，第4个格子放8粒小麦，如图8.11所示。后面每个格子里放的小麦数都是前一个格子里所放小麦数的2倍，直到第64个格子。<br>在Python中创建等比数列可以使用NumPy的logspace()函数，语法如下：</p><p><img src="/2020/03/21/shujufenxi/%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97numpy/image-20211025114247449.png" alt="image-20211025114247449"></p><p>​                                                                                                            图8.11　棋盘</p><p>numpy.logspace(start, stop, num=50, endpoint=True, base=10.0, dtype=None)<br>参数说明：　</p><p>start：序列的起始值。　</p><p>stop：序列的终止值。如果endpoint参数值为True，则该值包含于数列中。　</p><p>num：要生成的等步长的数据样本数量，默认值为50。　</p><p>endpoint：如果值为True，则数列中包含stop参数值；反之则不包含。默认值为True。　</p><p>base：对数log的底数。　</p><p>dtype：数组的数据类型。</p><p>【示例11】　通过logspace()函数解决棋盘放置小麦的问题。（示例位置：资源包\MR\Code\08\11）<br>通过logspace()函数计算棋盘中每个格子里放的小麦数是前一个格子里的2倍，直到第64个格子，每个格子里放多少小麦，程序代码如下：</p><p>01  import numpy as np<br>02  n = np.logspace(0,63,64,base=2,dtype=’int’)<br>03  print(n)<br>运行程序，输出结果如图8.12所示。</p><p><img src="/2020/03/21/shujufenxi/%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97numpy/image-20211025114355783.png" alt="image-20211025114355783"></p><p>​                                                                                  图8.12　每个格子里放的小麦数</p><p>上述举例出现一个问题：后面大数出现负数，而且都是一样的，这是由于程序中指定的数据类型是int，是32位的，数据范围为-2147483648～2147483647，而我们计算后的数据远远超出了这个范围，因此便出现了溢出现象。解决这一问题，需要指定数据类型为uint64（无符号整数，数据范围为0～18446744073709551615），关键代码如下：</p><p>n = np.logspace(0,63,64,base=2,dtype=’uint64’)<br>运行程序，输出结果如图8.13所示。</p><p><img src="/2020/03/21/shujufenxi/%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97numpy/image-20211025114438288.png" alt="image-20211025114438288"></p><p>​                                                                                     图8.13　每个格子里放的小麦数<br>以上就是每个格子里需要放的小麦数，可见发明国际象棋的大臣是多么聪明。说明<br>关于NumPy数据类型的详细介绍可参见8.3.1节。</p><h2 id="8-2-4-生成随机数组"><a href="#8-2-4-生成随机数组" class="headerlink" title="8.2.4　生成随机数组"></a>8.2.4　生成随机数组</h2><p>随机数组的生成主要使用NumPy的random模块，下面介绍几种常用的随机生成数组的函数。</p><h3 id="1．rand-函数"><a href="#1．rand-函数" class="headerlink" title="1．rand()函数"></a>1．rand()函数</h3><p>rand()函数用于生成(0,1)之间的随机数组，传入一个值随机生成一维数组，传入一对值则随机生成二维数组，语法如下：</p><p>numpy.random.rand(d0,d1,d2,d3,…,dn)<br>参数d0，d1，…，dn为整数，表示维度，可以为空。</p><p>【示例12】　随机生成0～1的数组。（示例位置：资源包\MR\Code\08\12）<br>随机生成一维数组和二维数组，代码如下：<br>运行程序，输出结果如下：</p><h3 id="2．randn-函数"><a href="#2．randn-函数" class="headerlink" title="2．randn()函数"></a>2．randn()函数</h3><p>randn()函数用于从正态分布中返回随机生成的数组，语法如下：</p><p>numpy.random.randn(d0,d1,d2,d3,…,dn)<br>参数d0，d1，…，dn为整数，表示维度，可以为空。</p><p>【示例13】　随机生成满足正态分布的数组。（示例位置：资源包\MR\Code\08\13）<br>随机生成满足正态分布的数组，程序代码如下：<br>运行程序，输出结果如下：</p><h3 id="3．randint-函数"><a href="#3．randint-函数" class="headerlink" title="3．randint()函数"></a>3．randint()函数</h3><p>randint()函数与NumPy的arange()函数类似。randint()函数用于生成一定范围内的随机数组，左闭右开区间，语法如下：</p><p>numpy.random.randint(low,high=None,size=None)</p><p>参数说明：　</p><p>low：低值（起始值），整数，且当参数high不为空时，参数low应小于参数high；否则程序会出现错误。　</p><p>high：高值（终止值），整数。</p><p>size：数组维数，整数或者元组，整数表示一维数组，元组表示多维数组。默认值为空，如果为空，则仅返回一个整数。</p><p>【示例14】　生成一定范围内的随机数组。（示例位置：资源包\MR\Code\08\14）<br>生成一定范围内的随机数组，程序代码如下：</p><p><img src="/2020/03/21/shujufenxi/%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97numpy/image-20211025114630842.png" alt="image-20211025114630842"></p><p>运行程序，输出结果如下：</p><p><img src="/2020/03/21/shujufenxi/%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97numpy/image-20211025114646241.png" alt="image-20211025114646241"></p><h3 id="4．normal-函数"><a href="#4．normal-函数" class="headerlink" title="4．normal()函数"></a>4．normal()函数</h3><p>normal()函数用于生成正态分布的随机数，语法如下：</p><p>numpy.random.normal(loc,scale,size)<br>参数说明：　</p><p>loc：正态分布的均值，对应正态分布的中心。loc=0说明是一个以y轴为对称轴的正态分布。　</p><p>scale：正态分布的标准差，对应正态分布的宽度，scale值越大，正态分布的曲线越“矮胖”；scale值越小，曲线越“高瘦”。　size：表示数组维数。</p><p>【示例15】　生成正态分布的随机数组。（示例位置：资源包\MR\Code\08\15）<br>生成正态分布的随机数组，程序代码如下：</p><p>01 import numpy as np<br>02 n = np.random.normal(0, 0.1, 10)<br>03 print(n)<br>运行程序，输出结果如下：</p><p>[ 0.08530096  0.0404147  -0.00358281  0.05405901 -0.01677737 -0.02448481<br> 0.13410224 -0.09780364  0.06095256 -0.0431846 ]</p><h2 id="8-2-5-从已有的数组中创建数组"><a href="#8-2-5-从已有的数组中创建数组" class="headerlink" title="8.2.5　从已有的数组中创建数组"></a>8.2.5　从已有的数组中创建数组</h2><h3 id="1．asarray-函数"><a href="#1．asarray-函数" class="headerlink" title="1．asarray()函数"></a>1．asarray()函数</h3><p>asarray()函数用于创建数组，其与array()函数类似，语法如下：</p><p>numpy.asarray(a,dtype=None,order=None)<br>参数说明：　</p><p>a：可以是列表、列表的元组、元组、元组的元组、元组的列表或多维数组。　</p><p>dtype：数组的数据类型。　</p><p>order：值为C和F，分别代表按行排列和按列排列，即数组元素在内存中的出现顺序。</p><p>【示例16】　使用asarray()函数创建数组。（示例位置：资源包\MR\Code\08\16）<br>使用asarray()函数创建数组，程序代码如下：</p><p><img src="/2020/03/21/shujufenxi/%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97numpy/image-20211025114735631.png" alt="image-20211025114735631"></p><p>运行程序，输出结果如下：</p><p><img src="/2020/03/21/shujufenxi/%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97numpy/image-20211025114829679.png" alt="image-20211025114829679"></p><h3 id="2．frombuffer-函数"><a href="#2．frombuffer-函数" class="headerlink" title="2．frombuffer()函数"></a>2．frombuffer()函数</h3><p>NumPy的ndarray()数组对象不能像Python列表一样动态地改变其大小，在做数据采集时很不方便。下面介绍如何通过frombuffer()函数实现动态数组。frombuffer()函数接受buffer输入参数，以流的形式将读入的数据转换为数组。frombuffer()函数语法如下：</p><p>numpy.frombuffer(buffer,dtype=float,count=-1,offset=0)<br>参数说明：　</p><p>buffer：实现了__buffer__方法的对象。　</p><p>dtype：数组的数据类型。　</p><p>count：读取的数据数量，默认值为-1，表示读取所有数据。　</p><p>offset：读取的起始位置，默认值为0。</p><p>【示例17】　将字符串“mingrisoft”转换为数组。（示例位置：资源包\MR\Code\08\17）<br>将字符串“mingrisoft”转换为数组，程序代码如下：</p><p>01 import numpy as np<br>02 n=np.frombuffer(b’mingrisoft’,dtype=’S1’)<br>03 print(n)<br>关键代码解析：当buffer参数值为字符串时，Python 3默认字符串是Unicode类型，所以要转成Byte string类型，需要在原字符串前加上b。</p><h3 id="3．fromiter-函数"><a href="#3．fromiter-函数" class="headerlink" title="3．fromiter()函数"></a>3．fromiter()函数</h3><p>fromiter()函数用于从可迭代对象中建立数组对象，语法如下：</p><p>numpy.fromiter(iterable,dtype,count=-1)</p><p>参数说明：　</p><p>iterable：可迭代对象。　</p><p>dtype：数组的数据类型。　</p><p>count：读取的数据数量，默认值为-1，表示读取所有数据。</p><p>【示例18】　通过可迭代对象创建数组。（示例位置：资源包\MR\Code\08\18）<br>通过可迭代对象创建数组，程序代码如下：</p><p><img src="/2020/03/21/shujufenxi/%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97numpy/image-20211025114943273.png" alt="image-20211025114943273"></p><p>运行程序，输出结果如下：</p><p>[0 2 4 6 8]</p><h3 id="4．empty-like-函数"><a href="#4．empty-like-函数" class="headerlink" title="4．empty_like()函数"></a>4．empty_like()函数</h3><p>empty_like()函数用于创建一个与给定数组具有相同维度和数据类型且未初始化的数组，语法如下：</p><p>numpy.empty_like(prototype,dtype=None,order=’K’,subok=True)<br>参数说明：　</p><p>prototype：给定的数组。　</p><p>dtype：覆盖结果的数据类型。　</p><p>order：指定数组的内存布局。其中C（按行）、F（按列）、A（原顺序）、K（数据元素在内存中的出现顺序）。　</p><p>subok：默认情况下，返回的数组被强制为基类数组。如果值为True，则返回子类。</p><p>【示例19】　创建未初始化的数组。（示例位置：资源包\MR\Code\08\19）<br>下面使用empty_like()函数创建一个与给定数组具有相同维数、数据类型以及未初始化的数组，程序代码如下：</p><p>01 import numpy as np</p><p>02 n = np.empty_like([[1, 2], [3, 4]])<br>03 print(n)<br>运行程序，输出结果如下：</p><p>[[0 0]<br> [0 0]]</p><h3 id="5．zeros-like-函数"><a href="#5．zeros-like-函数" class="headerlink" title="5．zeros_like()函数"></a>5．zeros_like()函数</h3><p>【示例20】　创建以0填充的数组。（示例位置：资源包\MR\Code\08\20）<br>zeros_like()函数用于创建一个与给定数组维度和数据类型相同，并以0填充的数组，程序代码如下：</p><p>01 import numpy as np<br>02 n = np.zeros_like([[0.1,0.2,0.3], [0.4,0.5,0.6]])<br>03 print(n)<br>运行程序，输出结果如下：</p><p>[[0. 0. 0.]<br> [0. 0. 0.]]说明<br>参数说明请参见empty_like()函数。</p><h3 id="6．ones-like-函数"><a href="#6．ones-like-函数" class="headerlink" title="6．ones_like()函数"></a>6．ones_like()函数</h3><p>【示例21】　创建以1填充的数组。（示例位置：资源包\MR\Code\08\21）<br>ones_like()函数用于创建一个与给定数组维度和数据类型相同，并以1填充的数组，程序代码如下：</p><p>01 import numpy as np<br>02 n = np.ones_like([[0.1,0.2,0.3], [0.4,0.5,0.6]])</p><p>03 print(n)<br>运行程序，输出结果如下：</p><p>[[1. 1. 1.]<br>[1. 1. 1.]]说明<br>参数说明请参见empty_like()函数。</p><h3 id="7．full-like-函数"><a href="#7．full-like-函数" class="headerlink" title="7．full_like()函数"></a>7．full_like()函数</h3><p>full_like()函数用于创建一个与给定数组维度和数据类型相同，并以指定值填充的数组，语法如下：</p><p>numpy.full_like(a, fill_value, dtype=None, order=’K’, subok=True)<br>参数说明：　</p><p>a：给定的数组。　</p><p>fill_value：填充值。　</p><p>dtype：数组的数据类型，默认值为None，则使用给定数组的数据类型。　</p><p>order：指定数组的内存布局。其中C（按行）、F（按列）、A（原顺序）、K（数组元素在内存中的出现顺序）。　</p><p>subok：默认情况下，返回的数组被强制为基类数组。如果值为True，则返回子类。</p><p>【示例22】　创建以指定值“0.2”填充的数组。（示例位置：资源包\MR\Code\08\22）<br>创建一个与给定数组维度和数据类型相同，并以指定值“0.2”填充的数组，程序代码如下：</p><p><img src="/2020/03/21/shujufenxi/%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97numpy/image-20211025115141215.png" alt="image-20211025115141215"></p><p>运行程序，输出结果如下：</p><p>[1 1 1 1 1 1]<br>[0 0 0 0 0 0]<br>[0.2 0.2 0.2 0.2 0.2 0.2]</p><h1 id="8-3-数组的基本操作"><a href="#8-3-数组的基本操作" class="headerlink" title="8.3　数组的基本操作"></a>8.3　数组的基本操作</h1><h3 id="8-3-1-数据类型"><a href="#8-3-1-数据类型" class="headerlink" title="8.3.1　数据类型"></a>8.3.1　数据类型</h3><p>在对数组进行基本操作前，首先了解一下NumPy的数据类型。NumPy的数据类型比Python数据类型增加了更多种类的数值类型，如表8.1所示。为了区别Python数据类型，像bool、int、float、complex、str等数据类型的名称末尾都加了短下画线“_”。</p><p>​                                                                                            表8.1　NumPy数据类型表</p><p><img src="/2020/03/21/shujufenxi/%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97numpy/image-20211025115201641.png" alt="image-20211025115201641"></p><p>每一种数据类型都有相应的数据转换函数。举例如下：</p><p>np.int8(3.141)</p><p>结果为3。</p><p>np.float64(8)<br>结果为8.0。</p><p>np.float(True)<br>结果为1.0。</p><p>bool(1)<br>结果为True。<br>在创建ndarray数组时，可以直接指定数值类型，关键代码如下：</p><p>a = np.arange(8, dtype=float)<br>结果为[0. 1. 2. 3. 4. 5. 6. 7.]。</p><p>注意<br>复数不能转换成为整数类型或者浮点数，例如以下的代码会出现错误提示：</p><p>float(8+ 1j)</p><h3 id="8-3-2-数组运算"><a href="#8-3-2-数组运算" class="headerlink" title="8.3.2　数组运算"></a>8.3.2　数组运算</h3><p>不用编写循环即可对数据执行批量运算，这就是NumPy数组运算的特点，NumPy称之为矢量化。大小相等的数组之间的任何算术运算NumPy都可以实现。本节主要介绍简单的数组运算，如加、减、乘、除、幂运算等。下面创建两个简单的NumPy数组，即n1和n2，数组n1包括元素1和2，数组n2包括元素3和4，如图8.14所示。接下来实现这两个数组的运算。</p><p><img src="/2020/03/21/shujufenxi/%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97numpy/image-20211025115248732.png" alt="image-20211025115248732"></p><p>​                                                                                                              图8.14　数组示意图</p><h4 id="1．加法运算"><a href="#1．加法运算" class="headerlink" title="1．加法运算"></a>1．加法运算</h4><p>例如，加法运算是数组中对应位置的元素相加（即每行对应相加），如图8.15所示。</p><p><img src="/2020/03/21/shujufenxi/%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97numpy/image-20211025115350997.png" alt="image-20211025115350997"></p><p>​                                                                              图8.15　数组加法运算示意图</p><p>【示例23】　数组加法运算。（示例位置：资源包\MR\Code\08\23）<br>在程序中直接将两个数组相加即可，即n1+n2，程序代码如下：<br>运行程序，输出结果如下：</p><p>[4 6]</p><h4 id="2．减法、乘法和除法运算"><a href="#2．减法、乘法和除法运算" class="headerlink" title="2．减法、乘法和除法运算"></a>2．减法、乘法和除法运算</h4><p>除了加法运算，还可以实现数组的减法、乘法和除法，如图8.16所示。</p><p><img src="/2020/03/21/shujufenxi/%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97numpy/image-20211025115411699.png" alt="image-20211025115411699"></p><p>​                                                                  图8.16　数组的减法、乘法和除法运算示意图</p><p>【示例24】　数组的减法、乘法和除法运算。（示例位置：资源包\MR\Code\06\24）<br>同样，在程序中直接将两个数组相减、相乘或相除即可，程序代码如下：</p><p><img src="/2020/03/21/shujufenxi/%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97numpy/image-20211025115431957.png" alt="image-20211025115431957"></p><p>运行程序，输出结果如下：</p><p>[-2 -2]<br>[3 8]<br>[0.33333333 0.5  ]</p><h4 id="3．幂运算"><a href="#3．幂运算" class="headerlink" title="3．幂运算"></a>3．幂运算</h4><p>幂是数组中对应位置元素的幂运算，用两个“*”表示，如图8.17所示。</p><p><img src="/2020/03/21/shujufenxi/%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97numpy/image-20211025115515999.png" alt="image-20211025115515999"></p><p>​                                                                                   图8.17　数组幂运算示意图</p><p>【示例25】　数组的幂运算。（示例位置：资源包\MR\Code\08\25）<br>从图8.17中得知：数组n1的元素1和数组n2的元素3，通过幂运算得到的是1的3次幂；数组n1的元素2和数组n2的元素4，通过幂运算得到的是2的4次幂，程序代码如下：</p><p><img src="/2020/03/21/shujufenxi/%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97numpy/image-20211025115559819.png" alt="image-20211025115559819"></p><p>运行程序，输出结果如下：</p><p>[ 1 16]</p><h4 id="4．比较运算"><a href="#4．比较运算" class="headerlink" title="4．比较运算"></a>4．比较运算</h4><p>【示例26】　数组的比较运算。（示例位置：资源包\MR\Code\08\26）<br>数组的比较运算是数组中对应位置元素的比较运算，比较后的结果是布尔值数组，程序代码如下：</p><p><img src="/2020/03/21/shujufenxi/%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97numpy/image-20211025115614452.png" alt="image-20211025115614452"></p><p>运行程序，输出结果如下：</p><p>[False False]<br>[False False]</p><p>[ True  True]<br>[ True  True]</p><h4 id="5．数组的标量运算"><a href="#5．数组的标量运算" class="headerlink" title="5．数组的标量运算"></a>5．数组的标量运算</h4><p>首先了解两个概念，即标量和向量。标量其实就是一个单独的数；而向量是一组数，这组数是顺序排列的，这里我们理解为数组。那么，数组的标量运算也可以理解为是向量与标量之间的运算。<br>例如，马拉松赛前训练，一周里每天的训练量以“米”（m）为单位，下面将其转换为以“千米”为单位，如图8.18所示。</p><p><img src="/2020/03/21/shujufenxi/%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97numpy/image-20211025115659337.png" alt="image-20211025115659337"></p><p>​                                                                                             图8.18　数组的标量运算示意图</p><p>【示例27】　数组的标量运算。（示例位置：资源包\MR\Code\08\27）<br>在程序中，米转换为千米直接输入n1/1000即可，程序代码如下：</p><p><img src="/2020/03/21/shujufenxi/%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97numpy/image-20211025115723224.png" alt="image-20211025115723224"></p><p>运行程序，输出结果如下：</p><p>[ 7500  8000  8500  9000  9500 10000]<br>[ 7.5  8.   8.5  9.   9.5 10. ]<br>上述运算过程，在NumPy中叫作“广播机制”，它是一个非常有用的功能。</p><h3 id="8-3-3-数组的索引和切片"><a href="#8-3-3-数组的索引和切片" class="headerlink" title="8.3.3　数组的索引和切片"></a>8.3.3　数组的索引和切片</h3><p>NumPy数组元素是通过数组的索引和切片来访问和修改的，因此索引和切片是NumPy中最重要、最常用的操作。</p><h4 id="1．索引"><a href="#1．索引" class="headerlink" title="1．索引"></a>1．索引</h4><p>所谓数组的索引，即用于标记数组中对应元素的唯一数字，从0开始，即数组中的第一个元素的索引是0，以此类推。NumPy数组可以使用标准Python语法x[obj]的语法对数组进行索引，其中x是数组，obj是索引。</p><p>【示例28】　获取一维数组中的元素。（示例位置：资源包\MR\Code\08\28）<br>获取一维数组n1中索引为0的元素，程序代码如下：</p><p>01  import numpy as np<br>02  n1=np.array([1,2,3])   #创建一维数组<br>03  print(n1[0])           #输出一维数组的第一个元素<br>运行程序，输出结果如下：</p><p>1</p><p>【示例29】　获取二维数组中的元素。（示例位置：资源包\MR\Code\08\29）<br>再举一个例子，通过索引获取二维数组中的元素，程序代码如下：</p><p>01  import numpy as np<br>02  n1=np.array([[1,2,3],[4,5,6]])   #创建二维数组<br>03  print(n1[1] [2])                  #输出二维数组中第2行第3列的元素<br>运行程序，输出结果如下：</p><p>6</p><h4 id="2．切片式索引"><a href="#2．切片式索引" class="headerlink" title="2．切片式索引"></a>2．切片式索引</h4><p>数组的切片可以理解为对数组的分割，按照等分或者不等分，将一个数组切割为多个片段，它与Python中列表的切片操作一样。NumPy中的切片用冒号分隔切片参数来进行切片操作，语法如下：</p><p>[start:stop:step]<br>参数说明：　</p><p>start：起始索引。</p><p>stop：终止索引。　</p><p>step：步长。</p><p>【示例30】　实现简单的数组切片操作。（示例位置：资源包\MR\Code\08\30）<br>实现简单的切片操作，对数组n1进行切片式索引操作，如图8.19所示。</p><p><img src="/2020/03/21/shujufenxi/%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97numpy/image-20211026163649468.png" alt="image-20211026163649468"></p><p>​                                                                                  图8.19　切片式索引示意图<br>程序代码如下：</p><p><img src="/2020/03/21/shujufenxi/%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97numpy/image-20211026163739258.png" alt="image-20211026163739258"></p><p>运行程序，输出结果如下：</p><p>1<br>2<br>[1 2]<br>[2 3]<br>[1 2]<br>切片式索引操作需要注意以下几点。<br>（1）索引是左闭右开区间，如上述代码中的n1[0:2]，只能取到索引从0～1的元素，而取不到索引为2的元素。<br>（2）当没有start参数时，代表从索引0开始取数，如上述代码中的n1[:2]。<br>（3）start、stop和step这3个参数都可以是负数，代表反向索引。以step参数为例，如图8.20所示。</p><p><img src="/2020/03/21/shujufenxi/%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97numpy/image-20211026163851780.png" alt="image-20211026163851780"></p><p>​                                                                                        图8.20　反向索引示意图</p><p>【示例31】　常用的切片式索引操作。（示例位置：资源包\MR\Code\08\31）<br>常用的切片式索引操作，程序代码如下：</p><p><img src="/2020/03/21/shujufenxi/%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97numpy/image-20211026163919986.png" alt="image-20211026163919986"></p><p>运行程序，输出结果如下：</p><p><img src="/2020/03/21/shujufenxi/%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97numpy/image-20211026163946683.png" alt="image-20211026163946683"></p><h4 id="3．二维数组索引"><a href="#3．二维数组索引" class="headerlink" title="3．二维数组索引"></a>3．二维数组索引</h4><p>二维数组索引可以使用array[n,m]的方式，以逗号分隔，表示第n个数组的，第m个元素。</p><p>【示例32】　二维数组的简单索引操作。（示例位置：资源包\MR\Code\08\32）<br>创建一个3行4列的二维数组，实现简单的索引操作，效果如图8.21所示。</p><p><img src="/2020/03/21/shujufenxi/%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97numpy/image-20211026164056410.png" alt="image-20211026164056410"></p><p>​                                                                                                图8.21　二维数组索引示意图<br>程序代码如下：</p><p><img src="/2020/03/21/shujufenxi/%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97numpy/image-20211026164124849.png" alt="image-20211026164124849"></p><p>运行程序，输出结果如下：</p><p>[4 5 6 7]<br>6<br>[ 8  9 10 11]<br>上述代码中，n[1]表示第2个数组，n[1,2]表示第2个数组第3个元素，它等同于n[1][2]，表示数组n中第2行第3列的值，实际上n[1] [2]是先索引第一个维度得到一个数组，然后在此基础上再索引。</p><h4 id="4．二维数组切片式索引"><a href="#4．二维数组切片式索引" class="headerlink" title="4．二维数组切片式索引"></a>4．二维数组切片式索引</h4><p>【示例33】　二维数组的切片操作。（示例位置：资源包\MR\Code\08\33）<br>创建一个二维数组，实现各种切片式索引操作，效果如图8.22所示。</p><p><img src="/2020/03/21/shujufenxi/%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97numpy/image-20211026164351235.png" alt="image-20211026164351235"></p><p>​                                                                            图8.22　二维数组切片式索引示意图</p><p>程序代码如下：</p><p><img src="/2020/03/21/shujufenxi/%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97numpy/image-20211026164653494.png" alt="image-20211026164653494"></p><p>运行程序，输出结果如下：</p><p><img src="/2020/03/21/shujufenxi/%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97numpy/image-20211026164710619.png" alt="image-20211026164710619"></p><h3 id="8-3-4-数组重塑"><a href="#8-3-4-数组重塑" class="headerlink" title="8.3.4　数组重塑"></a>8.3.4　数组重塑</h3><p>数组重塑实际是更改数组的形状，例如，将原来2行3列的数组重塑为3行4列的数组。在NumPy中主要使用reshape()方法，该方法用于改变数组的形状。</p><h4 id="1．一维数组重塑"><a href="#1．一维数组重塑" class="headerlink" title="1．一维数组重塑"></a>1．一维数组重塑</h4><p>一维数组重塑就是将数组重塑为多行多列的数组。</p><p>【示例34】　将一维数组重塑为二维数组。（示例位置：资源包\MR\Code\08\34）<br>创建一个一维数组，然后通过reshape()方法将其改为2行3列的二维数组，程序代码如下：</p><p><img src="/2020/03/21/shujufenxi/%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97numpy/image-20211026164736044.png" alt="image-20211026164736044"></p><p>运行程序，输出结果如下：</p><p><img src="/2020/03/21/shujufenxi/%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97numpy/image-20211026164756364.png" alt="image-20211026164756364"></p><p>需要注意的是，数组重塑是基于数组元素不发生改变的情况，重塑后的数组所包含的元素个数必须与原数组元素个数相同，如果数组元素发生改变，程序就会报错。</p><p>【示例35】　将一行古诗转换为4行5列的二维数组。（示例位置：资源包\MR\Code\08\35）<br>将一行20列的数据转换为4行5列的二维数组，效果如图8.23所示。</p><p><img src="/2020/03/21/shujufenxi/%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97numpy/image-20211026164923273.png" alt="image-20211026164923273"></p><p>​                                                                                                 图8.23　数组重塑示意图<br>程序代码如下：</p><p><img src="/2020/03/21/shujufenxi/%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97numpy/image-20211026164947021.png" alt="image-20211026164947021"></p><p>运行程序，输出结果如下：</p><p><img src="/2020/03/21/shujufenxi/%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97numpy/image-20211026165004423.png" alt="image-20211026165004423"></p><h4 id="2．多维数组重塑"><a href="#2．多维数组重塑" class="headerlink" title="2．多维数组重塑"></a>2．多维数组重塑</h4><p>多维数组重塑同样使用reshape()方法。</p><p>【示例36】　将2行3列的数组重塑为3行2列的数组。（示例位置：资源包\MR\Code\08\36）<br>将2行3列的二维数组重塑为3行2列的二维数组，程序代码如下：</p><p><img src="/2020/03/21/shujufenxi/%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97numpy/image-20211026165037961.png" alt="image-20211026165037961"></p><p>运行程序，输出结果如下：</p><p><img src="/2020/03/21/shujufenxi/%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97numpy/image-20211026165053942.png" alt="image-20211026165053942"></p><h4 id="3．数组转置"><a href="#3．数组转置" class="headerlink" title="3．数组转置"></a>3．数组转置</h4><p>数组转置是指数组的行列转换，可以通过数组的T属性和transpose()函数实现。</p><p>【示例37】　将二维数组中的行列转置。（示例位置：资源包\MR\Code\08\37）<br>通过T属性将4行6列的二维数组中的行变成列，列变成行，程序代码如下：</p><p><img src="/2020/03/21/shujufenxi/%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97numpy/image-20211026165138211.png" alt="image-20211026165138211"></p><p>运行程序，输出结果如下：</p><p><img src="/2020/03/21/shujufenxi/%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97numpy/image-20211026165155864.png" alt="image-20211026165155864"></p><p>【示例38】　转换客户销售数据。（示例位置：资源包\MR\Code\08\38）<br>上述举例可能不太直观，下面再举一个例子，转换客户销售数据，对比效果如图8.24所示。</p><p><img src="/2020/03/21/shujufenxi/%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97numpy/image-20211026165234909.png" alt="image-20211026165234909"></p><p>​                                                                     图8.24　客户销售数据转换对比示意图<br>程序代码如下：</p><p><img src="/2020/03/21/shujufenxi/%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97numpy/image-20211026165254710.png" alt="image-20211026165254710"></p><p>运行程序，输出结果如下：</p><p><img src="/2020/03/21/shujufenxi/%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97numpy/image-20211026165309989.png" alt="image-20211026165309989"></p><p>transpose()函数也可以实现数组转置。例如，上述举例用transpose()函数实现，关键代码如下：</p><p>01  n = np.array([[‘A’,100],[‘B’,200],[‘C’,300],[‘D’,400],[‘E’,500]])<br>02  print(n.transpose())                           #transpose()函数行列转置<br>运行程序，输出结果如下：</p><p><img src="/2020/03/21/shujufenxi/%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97numpy/image-20211026165407591.png" alt="image-20211026165407591"></p><h3 id="8-3-5-数组的增、删、改、查"><a href="#8-3-5-数组的增、删、改、查" class="headerlink" title="8.3.5　数组的增、删、改、查"></a>8.3.5　数组的增、删、改、查</h3><p>数组增、删、改、查的方法有很多种，下面介绍几种常用的方法。</p><h4 id="1．数组的增加"><a href="#1．数组的增加" class="headerlink" title="1．数组的增加"></a>1．数组的增加</h4><p>数组数据的增加可以按照水平方向增加数据，也可以按照垂直方向增加数据。水平方向增加数据主要使用hstack()函数，垂直方向增加数据主要使用vstack()函数。</p><p>【示例39】　为数组增加数据。（示例位置：资源包\MR\Code\08\39）<br>创建两个二维数组，然后实现数组数据的增加，程序代码如下：</p><p><img src="/2020/03/21/shujufenxi/%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97numpy/image-20211026165507946.png" alt="image-20211026165507946"></p><p>运行程序，输出结果如下：</p><p><img src="/2020/03/21/shujufenxi/%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97numpy/image-20211026165522416.png" alt="image-20211026165522416"></p><h4 id="2．数组的删除"><a href="#2．数组的删除" class="headerlink" title="2．数组的删除"></a>2．数组的删除</h4><p>数组的删除主要使用delete()方法。</p><p>【示例40】　删除指定的数组。（示例位置：资源包\MR\Code\08\40）<br>删除指定的数组，程序代码如下：</p><p><img src="/2020/03/21/shujufenxi/%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97numpy/image-20211026165543012.png" alt="image-20211026165543012"></p><p>运行程序，输出结果如下：</p><p><img src="/2020/03/21/shujufenxi/%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97numpy/image-20211026165601688.png" alt="image-20211026165601688"></p><p>那么，对于不想要的数组或数组元素还可以通过索引和切片方法只选取需要的数组或数组元素。</p><h4 id="3．数组的修改"><a href="#3．数组的修改" class="headerlink" title="3．数组的修改"></a>3．数组的修改</h4><p>修改数组或数组元素时，直接为数组或数组元素赋值即可。</p><p>【示例41】　修改指定的数组。（示例位置：资源包\MR\Code\08\41）<br>修改指定的数组，程序代码如下：</p><p><img src="/2020/03/21/shujufenxi/%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97numpy/image-20211026165836901.png" alt="image-20211026165836901"></p><p>运行程序，输出结果如下：</p><p><img src="/2020/03/21/shujufenxi/%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97numpy/image-20211026165851666.png" alt="image-20211026165851666"></p><h4 id="4．数组的查询"><a href="#4．数组的查询" class="headerlink" title="4．数组的查询"></a>4．数组的查询</h4><p>数组的查询同样可以使用索引和切片方法来获取指定范围的数组或数组元素，还可以通过where()函数查询符合条件的数组或数组元素。where()函数语法如下：</p><p>numpy.where(condition,x,y)<br>上述语法，第一个参数为一个布尔数组，第二个参数和第三个参数可以是标量也可以是数组。满足条件（参数condition），输出参数x，不满足条件输出参数y。</p><p>【示例42】　按指定条件查询数组。（示例位置：资源包\MR\Code\08\42）<br>数组查询，大于5输出2，不大于5输出0，程序代码如下：</p><p><img src="/2020/03/21/shujufenxi/%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97numpy/image-20211026165929414.png" alt="image-20211026165929414"></p><p>运行程序，输出结果如下：</p><p>[0 1 2 3 4 5 6 7 8 9]<br>[0 0 0 0 0 0 2 2 2 2]<br>如果不指定参数x和y，则输出满足条件的数组元素的坐</p><p>标。例如，上述举例不指定参数x和y，关键代码如下：</p><p>01  n2=n1[np.where(n1&gt;5)]<br>02  print(n2)<br>运行程序，输出结果如下：</p><p>[6 7 8 9]</p><h1 id="8-4-NumPy矩阵的基本操作"><a href="#8-4-NumPy矩阵的基本操作" class="headerlink" title="8.4　NumPy矩阵的基本操作"></a>8.4　NumPy矩阵的基本操作</h1><p>在数学中经常会看到矩阵，而在程序中常用的是数组，可以简单地理解为，矩阵是数学的概念，而数组是计算机程序设计领域的概念。在NumPy中，矩阵是数组的分支，数组和矩阵有些时候是通用的，二维数组也称矩阵。下面简单介绍矩阵的基本操作。</p><h2 id="8-4-1-创建矩阵"><a href="#8-4-1-创建矩阵" class="headerlink" title="8.4.1　创建矩阵"></a>8.4.1　创建矩阵</h2><p>NumPy函数库中存在两种不同的数据类型（矩阵matrix和数组array），它们都可以用于处理行列表示的数组元素，虽然它们看起来很相似，但是在这两种数据类型上执行相同的数学运算，可能得到不同的结果。<br>在NumPy中，矩阵应用十分广泛。例如，每个图像可以被看作像素值矩阵。假设一个像素值仅为0和1，那么5×5大小的图像就是一个5×5的矩阵，如图8.25所示；而3×3大小的图像就是一个3×3的矩阵，如图8.26所示。</p><p><img src="/2020/03/21/shujufenxi/%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97numpy/image-20211026170015304.png" alt="image-20211026170015304"></p><p>​                                                                                             图8.25　5×5矩阵示意图</p><p><img src="/2020/03/21/shujufenxi/%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97numpy/image-20211026170035799.png" alt="image-20211026170035799"></p><p>​                                                                                                图8.26　3×3矩阵示意图<br>关于矩阵就简单了解到这里，下面介绍如何在NumPy中创建矩阵。</p><p>【示例43】　创建简单矩阵。（示例位置：资源包\MR\Code\08\43）<br>使用mat()函数创建矩阵，程序代码如下：</p><p><img src="/2020/03/21/shujufenxi/%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97numpy/image-20211026170127022.png" alt="image-20211026170127022"></p><p>运行程序，输出结果如下：</p><p><img src="/2020/03/21/shujufenxi/%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97numpy/image-20211026170143985.png" alt="image-20211026170143985"></p><p>从运行结果得知：mat()函数创建的是矩阵类型，array()函数创建的是数组类型，而用mat()函数创建的矩阵才能进行一些线性代数的操作。</p><p>【示例44】　使用mat()函数创建常见的矩阵。（示例位置：资源包\MR\Code\08\44）<br>下面使用mat()函数创建常见的矩阵。<br>（1）创建一个3×3的0（零）矩阵，程序代码如下：</p><p><img src="/2020/03/21/shujufenxi/%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97numpy/image-20211026170213383.png" alt="image-20211026170213383"></p><p>运行程序，输出结果如下：</p><p><img src="/2020/03/21/shujufenxi/%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97numpy/image-20211026170242743.png" alt="image-20211026170242743"></p><p>（2）创建一个2×4的1矩阵，程序代码如下：</p><p><img src="/2020/03/21/shujufenxi/%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97numpy/image-20211026170348020.png" alt="image-20211026170348020"></p><p>运行程序，输出结果如下：</p><p><img src="/2020/03/21/shujufenxi/%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97numpy/image-20211026170431915.png" alt="image-20211026170431915"></p><p>（3）使用random模块的rand()函数创建一个3×3为0～1随机产生的二维数组，并将其转换为矩阵，程序代码如下：</p><p>01  import numpy as np</p><p>02  data1 = np.mat(np.random.rand(3,3))<br>03  print(data1)<br>运行程序，输出结果如下：</p><p><img src="/2020/03/21/shujufenxi/%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97numpy/image-20211026170511819.png" alt="image-20211026170511819"></p><p>（4）创建一个1～8的随机整数矩阵，程序代码如下：</p><p>01 import numpy as np<br>02 data1 = np.mat(np.random.randint(1,8,size=(3,5)))<br>03 print(data1)<br>运行程序，输出结果如下：</p><p><img src="/2020/03/21/shujufenxi/%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97numpy/image-20211026170540232.png" alt="image-20211026170540232"></p><p>（5）创建对角矩阵，程序代码如下：</p><p><img src="/2020/03/21/shujufenxi/%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97numpy/image-20211026170625799.png" alt="image-20211026170625799"></p><p>运行程序，输出结果如下：</p><p><img src="/2020/03/21/shujufenxi/%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97numpy/image-20211026170642474.png" alt="image-20211026170642474"></p><p>（6）创建对角线矩阵，程序代码如下：</p><p><img src="/2020/03/21/shujufenxi/%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97numpy/image-20211026170716487.png" alt="image-20211026170716487"></p><p>运行程序，输出结果如下：</p><p><img src="/2020/03/21/shujufenxi/%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97numpy/image-20211026170742422.png" alt="image-20211026170742422"></p><p>说明<br>mat()函数只适用于二维矩阵，维数超过2以后，mat()</p><p>函数就不适用了，从这一点来看array()函数更具通用性。</p><h2 id="8-4-2-矩阵运算"><a href="#8-4-2-矩阵运算" class="headerlink" title="8.4.2　矩阵运算"></a>8.4.2　矩阵运算</h2><p>如果两个矩阵大小相同，我们可以使用算术运算符“+”“-”“*”“/”对矩阵进行加、减、乘、除的运算。</p><p>【示例45】　矩阵加法运算。（示例位置：资源包\MR\Code\08\45）<br>创建两个矩阵data1和data2，实现矩阵的加法运算，效果如图8.27所示。</p><p><img src="/2020/03/21/shujufenxi/%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97numpy/image-20211026170836683.png" alt="image-20211026170836683"></p><p>​                                                                  图8.27　矩阵的加法运算示意图<br>程序代码如下：</p><p><img src="/2020/03/21/shujufenxi/%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97numpy/image-20211026170917227.png" alt="image-20211026170917227"></p><p>运行程序，输出结果如下：</p><p><img src="/2020/03/21/shujufenxi/%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97numpy/image-20211026170933858.png" alt="image-20211026170933858"></p><p>【示例46】　矩阵减法、乘法和除法运算。（示例位置：资源包\MR\Code\08\46）<br>除了加法运算，还可以实现矩阵的减法、乘法和除法运算。接下来实现上述矩阵的减法和除法运算，程序代码如下：<br>运行程序，输出结果如下：</p><p><img src="/2020/03/21/shujufenxi/%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97numpy/image-20211026170952257.png" alt="image-20211026170952257"></p><p>当对上述矩阵实现乘法运算时，程序出现了错误，原因是矩阵的乘法运算，要求左边矩阵的列和右边矩阵的行数要一致。由于上述矩阵data2只有一行，所以导致程序出错。</p><p>【示例47】　修改矩阵并进行乘法运算。（示例位置：资源包\MR\Code\08\47）</p><p>将矩阵data2改为2×2矩阵，再进行矩阵的乘法运算，程序代码如下：</p><p><img src="/2020/03/21/shujufenxi/%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97numpy/image-20211026171103706.png" alt="image-20211026171103706"></p><p>运行程序，输出结果如下：</p><p><img src="/2020/03/21/shujufenxi/%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97numpy/image-20211026171125494.png" alt="image-20211026171125494"></p><p>上述举例，是两个矩阵直接相乘，称之为矩阵相乘。矩阵相乘是第一个矩阵中与该元素行号相同的元素与第二个矩阵中与该元素列号相同的元素，两两相乘后再求和，运算过程如图8.28所示。例如，1×1+2×3=7，是第一个矩阵第1行元素与第二个矩阵第1列元素，两两相乘求和得到的。</p><p><img src="/2020/03/21/shujufenxi/%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97numpy/image-20211026171144696.png" alt="image-20211026171144696"></p><p>​                                                                         图8.28　矩阵相乘运算过程示意图<br>数组运算和矩阵运算的一个关键区别是矩阵相乘使用的是点乘。点乘，也称点积，是数组中元素对应位置一一相乘之后求和的操作，在NumPy中专门提供了点乘方法，即dot()方法，该方法返回的是两个数组的点积。</p><p>【示例48】　数组相乘与数组点乘比较。（示例位置：资源包\MR\Code\08\48）<br>数组相乘与数组点乘运算，程序代码如下：</p><p><img src="/2020/03/21/shujufenxi/%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97numpy/image-20211026171207973.png" alt="image-20211026171207973"></p><p>运行程序，输出结果如下：</p><p>![</p><p>](计算模块numpy/image-20211026171222686.png)</p><p>【示例49】　矩阵元素之间的相乘运算。（示例位置：资源包\MR\Code\08\49）<br>要实现矩阵对应元素之间的相乘可以使用multiply()函数，程序代码如下：</p><p><img src="/2020/03/21/shujufenxi/%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97numpy/image-20211026171240997.png" alt="image-20211026171240997"></p><p>运行程序，输出结果如下：</p><p><img src="/2020/03/21/shujufenxi/%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97numpy/image-20211026173555512.png" alt="image-20211026173555512"></p><h2 id="8-4-3-矩阵转换"><a href="#8-4-3-矩阵转换" class="headerlink" title="8.4.3　矩阵转换"></a>8.4.3　矩阵转换</h2><h3 id="1．矩阵转置"><a href="#1．矩阵转置" class="headerlink" title="1．矩阵转置"></a>1．矩阵转置</h3><p>【示例50】　使用T属性实现矩阵转置。（示例位置：资源包\MR\Code\08\50）<br>矩阵转置与数组转置一样使用T属性，程序代码如下：</p><p>01  import numpy as np<br>02  n1 = np.mat(‘1 3 3;4 5 6;7 12 9’)            #创建矩阵，使用分号隔开数据<br>03  print(‘矩阵转置结果为：\n’,n1.T)             #矩阵转置<br>运行程序，输出结果如下：</p><p><img src="/2020/03/21/shujufenxi/%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97numpy/image-20211026173620078.png" alt="image-20211026173620078"></p><h3 id="2．矩阵求逆"><a href="#2．矩阵求逆" class="headerlink" title="2．矩阵求逆"></a>2．矩阵求逆</h3><p>【示例51】　实现矩阵逆运算。（示例位置：资源包\MR\Code\08\51）<br>矩阵要可逆，否则意味着该矩阵为奇异矩阵（即矩阵的行列式的值为0）。矩阵求逆主要使用I属性，程序代码如下：</p><p>01  import numpy as np<br>02  n1 = np.mat(‘1 3 3;4 5 6;7 12 9’)       #创建矩阵，使用分号隔开数据<br>03  print(‘矩阵的逆矩阵结果为：\n’,n1.I)    #逆矩阵<br>运行程序，输出结果如下：</p><p><img src="/2020/03/21/shujufenxi/%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97numpy/image-20211026173645127.png" alt="image-20211026173645127"></p><h1 id="8-5-NumPy常用统计分析函数"><a href="#8-5-NumPy常用统计分析函数" class="headerlink" title="8.5　NumPy常用统计分析函数"></a>8.5　NumPy常用统计分析函数</h1><h2 id="8-5-1-数学运算函数"><a href="#8-5-1-数学运算函数" class="headerlink" title="8.5.1　数学运算函数"></a>8.5.1　数学运算函数</h2><p>NumPy包含大量的数学运算的函数，包括三角函数、算术运算函数、复数处理函数等，如表8.2所示。</p><p>​                                                                                        表8.2　数学运算函数</p><p><img src="/2020/03/21/shujufenxi/%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97numpy/image-20211026173754018.png" alt="image-20211026173754018"></p><p>下面介绍几个常用的数学运算函数。</p><h3 id="1．算术函数"><a href="#1．算术函数" class="headerlink" title="1．算术函数"></a>1．算术函数</h3><h3 id="（1）加、减、乘、除"><a href="#（1）加、减、乘、除" class="headerlink" title="（1）加、减、乘、除"></a>（1）加、减、乘、除</h3><p>NumPy算术函数包含简单的加、减、乘、除运算，如add()函数、subtract()函数、multiply()函数和divide()函数。这里要注意的是，数组必须具有相同的形状或符合数组广播规则。</p><p>【示例52】　数组加、减、乘、除运算。（示例位置：资源包\MR\Code\08\52）<br>数组加、减、乘、除运算，程序代码如下：</p><p><img src="/2020/03/21/shujufenxi/%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97numpy/image-20211026173820639.png" alt="image-20211026173820639"></p><p>运行程序，输出结果如下：</p><p><img src="/2020/03/21/shujufenxi/%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97numpy/image-20211026173836746.png" alt="image-20211026173836746"></p><h3 id="（2）倒数"><a href="#（2）倒数" class="headerlink" title="（2）倒数"></a>（2）倒数</h3><p>reciprocal()函数用于返回数组中各元素的倒数。如4/3的倒数是3/4。</p><p>【示例53】　计算数组元素的倒数。（示例位置：资源包\MR\Code\08\53）<br>计算数组元素的倒数，程序代码如下：</p><p>01 import numpy as np<br>02 a = np.array([0.25, 1.75, 2, 100])<br>03 print(np.reciprocal(a))<br>运行程序，输出结果如下：</p><p>[4.  0.57142857 0.5  0.01  ]</p><h3 id="（3）求幂"><a href="#（3）求幂" class="headerlink" title="（3）求幂"></a>（3）求幂</h3><p>power()函数将第一个数组中的元素作为底数，计算它与第二个数组中相应元素的幂。</p><p>【示例54】　数组元素的幂运算。（示例位置：资源包\MR\Code\08\54）<br>对数组元素幂运算，程序代码如下：</p><p>01 import numpy as np<br>02 n1 = np.array([10, 100, 1000])<br>03 print(np.power(n1, 3))<br>04 n2= np.array([1, 2, 3])<br>05 print(np.power(n1, n2))<br>运行程序，输出结果如下：</p><p>[  1000  1000000 1000000000]<br>[    10    10000 1000000000]</p><h3 id="（4）取余"><a href="#（4）取余" class="headerlink" title="（4）取余"></a>（4）取余</h3><p>mod()函数用于计算数组之间相应元素相除后的余数。</p><p>【示例55】　对数组元素取余。（示例位置：资源包\MR\Code\08\55）<br>对数组元素取余，程序代码如下：</p><p>01  import numpy as np<br>02  n1 = np.array([10, 20, 30])<br>03  n2 = np.array([4, 5, -8])<br>04  print(np.mod(n1, n2))<br>运行程序，输出结果如下：</p><p>[ 2  0 -2]</p><p>知识胶囊<br>下面重点介绍NumPy负数取余的算法，公式如下：<br>r=a-n*[a//n]<br>其中r为余数，a是被除数，n是除数，“//”为运算取商时保留整数的下界，即偏向于较小的整数。根据负数取余的3种情况，举例如下：<br>r=30-(-8)<em>(30//(-8))=30-(-8)</em>(-4)=30-32=-2<br>r=-30-(-8)<em>(-30//(-8))=-30-(-8)</em>(3)=-30-24=-6<br>r=-30-(8)<em>(-30//(8))=-30-(8)</em>(-4)=-30+32=2</p><h3 id="2．舍入函数"><a href="#2．舍入函数" class="headerlink" title="2．舍入函数"></a>2．舍入函数</h3><h3 id="（1）四舍五入around-函数"><a href="#（1）四舍五入around-函数" class="headerlink" title="（1）四舍五入around()函数"></a>（1）四舍五入around()函数</h3><p>四舍五入在NumPy中应用比较多，主要使用around()函数，该函数返回指定小数位数的四舍五入值，语法如下：</p><p>numpy.around(a,decimals)<br>参数说明：　</p><p>a：数组。　</p><p>decimals：舍入的小数位数，默认值为0，如果为负，整数将四舍五入到小数点左侧的位置。</p><p>【示例56】　将数组中的一组数字四舍五入。（示例位置：资源包\MR\Code\08\56）<br>将数组中的一组数字四舍五入，程序代码如下：<br>运行程序，输出结果如下：</p><p>[  2.   7. 100.   0.  3.  -2.]<br>[  1.55   6.82 100.    0.12   3.14  -2.35]<br>[  0.  10. 100.   0.  0.  -0.]</p><h3 id="（2）向上取整ceil-函数"><a href="#（2）向上取整ceil-函数" class="headerlink" title="（2）向上取整ceil()函数"></a>（2）向上取整ceil()函数</h3><p>ceil()函数用于返回大于或者等于指定表达式的最小整数，即向上取整。</p><p>【示例57】　对数组元素向上取整。（示例位置：资源包\MR\Code\08\57）<br>对数组元素向上取整，程序代码如下：<br>运行程序，输出结果如下：</p><p>[-1.  2. -0.  1. 15.]</p><h3 id="（3）向下取整floor-函数"><a href="#（3）向下取整floor-函数" class="headerlink" title="（3）向下取整floor()函数"></a>（3）向下取整floor()函数</h3><p>floor()函数用于返回小于或者等于指定表达式的最大整数，即向下取整。</p><p>【示例58】　对数组元素向下取整。（示例位置：资源包\MR\Code\08\58）</p><p>对数组元素向下取整，程序代码如下：</p><p>01  import numpy as np<br>02  n = np.array([-1.8, 1.66, -0.2, 0.888, 15])     #创建数组<br>03  print(np.floor(n))                              #向下取整<br>运行程序，输出结果如下：</p><p>[-2.  1. -1.  0. 15.]</p><h3 id="3．三角函数"><a href="#3．三角函数" class="headerlink" title="3．三角函数"></a>3．三角函数</h3><p>NumPy提供了标准的三角函数，即sin()函数、cos()函数和tan()函数。</p><p>【示例59】　计算数组的正弦值、余弦值和正切值。（示例位置：资源包\MR\Code\08\59）<br>计算数组元素的正弦值、余弦值和正切值，程序代码如下：</p><p><img src="/2020/03/21/shujufenxi/%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97numpy/image-20211026174155746.png" alt="image-20211026174155746"></p><p>运行程序，输出结果如下：</p><p><img src="/2020/03/21/shujufenxi/%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97numpy/image-20211026174212800.png" alt="image-20211026174212800"></p><p>arcsin()函数、arccos()函数和arctan()函数用于返回给定角度的sin、cos和tan的反三角函数。这些函数的结果可以通过degrees()函数将弧度转换为角度。</p><p>【示例60】　将弧度转换为角度。（示例位置：资源包\MR\Code\08\60）<br>首先计算不同角度的正弦值，然后使用arcsin()函数计算角度的反正弦，返回值以弧度为单位，最后使用degrees()函数将弧度转换为角度来验证结果，程序代码如下：</p><p><img src="/2020/03/21/shujufenxi/%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97numpy/image-20211026174231238.png" alt="image-20211026174231238"></p><p>运行程序，输出结果如下：</p><p><img src="/2020/03/21/shujufenxi/%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97numpy/image-20211026174311391.png" alt="image-20211026174311391"></p><p>arccos()函数和arctan()函数的用法与arcsin()函数的用法差不多，这里不再举例。</p><h2 id="8-5-2-统计分析函数"><a href="#8-5-2-统计分析函数" class="headerlink" title="8.5.2　统计分析函数"></a>8.5.2　统计分析函数</h2><p>统计分析函数是对整个NumPy数组或某条轴的数据进行统计运算，函数介绍如表8.3所示。</p><p>​                                                                                           表8.3　统计分析函数</p><p><img src="/2020/03/21/shujufenxi/%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97numpy/image-20211026174357030.png" alt="image-20211026174357030"></p><p>下面介绍几个常用的统计函数。首先创建一个数组，如图8.29所示。</p><p><img src="/2020/03/21/shujufenxi/%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97numpy/image-20211026174437338.png" alt="image-20211026174437338"></p><p>​                                                                                          图8.29　数组示意图</p><h3 id="1．求和sum-函数"><a href="#1．求和sum-函数" class="headerlink" title="1．求和sum()函数"></a>1．求和sum()函数</h3><p>【示例61】　对数组元素求和。（示例位置：资源包\MR\Code\08\61）<br>对数组元素求和、对数组元素按行和按列求和，程序代码如下：</p><p><img src="/2020/03/21/shujufenxi/%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97numpy/image-20211026174535205.png" alt="image-20211026174535205"></p><p>运行程序，输出结果如下：</p><p><img src="/2020/03/21/shujufenxi/%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97numpy/image-20211026174553779.png" alt="image-20211026174553779"></p><h3 id="2．求平均值mean-函数"><a href="#2．求平均值mean-函数" class="headerlink" title="2．求平均值mean()函数"></a>2．求平均值mean()函数</h3><p>【示例62】　对数组元素求平均值。（示例位置：资源包\MR\Code\08\62）<br>对数组元素求平均值、对数组元素按行求平均值和按列求平均值，关键代码如下：</p><p><img src="/2020/03/21/shujufenxi/%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97numpy/image-20211026174622127.png" alt="image-20211026174622127"></p><p>运行程序，输出结果如下：</p><p><img src="/2020/03/21/shujufenxi/%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97numpy/image-20211026174644781.png" alt="image-20211026174644781"></p><h3 id="3．求最大值max-函数和最小值min-函数"><a href="#3．求最大值max-函数和最小值min-函数" class="headerlink" title="3．求最大值max()函数和最小值min()函数"></a>3．求最大值max()函数和最小值min()函数</h3><p>【示例63】　对数组元素求最大值和最小值。（示例位置：资源包\MR\Code\08\63）<br>对数组元素求最大值和最小值，关键代码如下：</p><p><img src="/2020/03/21/shujufenxi/%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97numpy/image-20211026174704524.png" alt="image-20211026174704524"></p><p>运行程序，输出结果如下：</p><p><img src="/2020/03/21/shujufenxi/%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97numpy/image-20211026174733324.png" alt="image-20211026174733324"></p><p>对二维数组求最大值在实际应用中非常广泛。例如，统计销售冠军。</p><h3 id="4．求加权平均average-函数"><a href="#4．求加权平均average-函数" class="headerlink" title="4．求加权平均average()函数"></a>4．求加权平均average()函数</h3><p>在日常生活中，常用平均数表示一组数据的“平均水平”。在一组数据里，一个数据出现的次数称为权。将一组数据与出现的次数相乘再平均就是“加权平均”。加权平均能够反映一组数据中各个数据的重要程度，以及对整体趋势的影响。加权平均在日常生活应用非常广泛，如考试成绩、股票价格、竞技比赛等。</p><p>【示例64】　计算电商各活动销售的加权平均价。（示例位置：资源包\MR\Code\08\64）<br>某电商在开学季、6.18、双十一、双十二等活动价格均不同，下面计算加权平均价，程序代码如下：</p><p><img src="/2020/03/21/shujufenxi/%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97numpy/image-20211026174836425.png" alt="image-20211026174836425"></p><p>运行程序，输出结果如下：</p><p>加权平均价：<br>34.84920634920635</p><h3 id="5．中位数median-函数"><a href="#5．中位数median-函数" class="headerlink" title="5．中位数median()函数"></a>5．中位数median()函数</h3><p>中位数用来衡量数据取值的中等水平或一般水平，可以避免极端值的影响。在数据处理过程中，当数据中存在少量异常值时，它不受其影响，基于这一特点，一般使用中位数来评价分析结果。<br>那么，什么是中位数？将各个变量值按大小顺序排列起来，形成一个数列，居于数列中间位置的那个数即为中位数。例如，1、2、3、4、5这5个数，中位数就是中间的数字3，而1、2、3、4、5、6这6个数，中位数则是中间两个数的平均值，即3.5。</p><p>知识胶囊<br>中位数与平均数不同，它不受异常值的影响。例如，将1、2、3、4、5、6改为1、2、3、4、5、288，中位数依然是3.5。</p><p>【示例65】　计算电商活动价格的中位数。（示例位置：资源包\MR\Code\08\65）<br>计算电商在开学季、6.18、双十一、双十二等活动价格的中位数，程序代码如下：<br>运行程序，输出结果如下：</p><p>数组排序：<br>[33.6 34.5 36. 37.8 39. 39.8]数组中位数为：<br>36.9</p><h3 id="6．方差、标准差"><a href="#6．方差、标准差" class="headerlink" title="6．方差、标准差"></a>6．方差、标准差</h3><p>方差、标准差的定义在第4章已经介绍过了，这里不再赘述，直接进入主题。</p><p>【示例66】　求数组的方差和标准差。（示例位置：资源包\MR\Code\08\66）<br>在NumPy中实现方差和标准差，程序代码如下：<br>运行程序，输出结果如下：</p><p>数组方差：<br>5.168055555555551数组标准差：<br>2.2733357771247853</p><h2 id="8-5-3-数组的排序"><a href="#8-5-3-数组的排序" class="headerlink" title="8.5.3　数组的排序"></a>8.5.3　数组的排序</h2><p>数组的排序是对数组元素进行排序。</p><h3 id="1．sort-函数"><a href="#1．sort-函数" class="headerlink" title="1．sort()函数"></a>1．sort()函数</h3><p>使用sort()函数进行排序，直接改变原数组，参数axis指定按行排序还是按列排序。</p><p>【示例67】　对数组元素按行和列排序。（示例位置：资源包\MR\Code\08\67）<br>对数组元素排序，程序代码如下：</p><p><img src="/2020/03/21/shujufenxi/%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97numpy/image-20211026175022606.png" alt="image-20211026175022606"></p><p>运行程序，输出结果如下：</p><p><img src="/2020/03/21/shujufenxi/%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97numpy/image-20211026175038158.png" alt="image-20211026175038158"></p><h3 id="2．argsort-函数"><a href="#2．argsort-函数" class="headerlink" title="2．argsort()函数"></a>2．argsort()函数</h3><p>使用argsort()函数对数组进行排序，返回升序排序之后数组值从小到大的索引值。</p><p>【示例68】　对数组元素升序排序。（示例位置：资源包\MR\Code\08\68）<br>对数组元素排序，程序代码如下：</p><p><img src="/2020/03/21/shujufenxi/%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97numpy/image-20211026175100199.png" alt="image-20211026175100199"></p><p>运行程序，输出结果如下：</p><p>升序排序后的索引值：<br>[6 3 2 0 5 8 1 4 7]<br>排序后的顺序重构原数组：<br>[1 2 3 4 5 6 7 8 9]</p><h3 id="3．lexsort-函数"><a href="#3．lexsort-函数" class="headerlink" title="3．lexsort()函数"></a>3．lexsort()函数</h3><p>lexsort()函数用于对多个序列进行排序。可以把它当作是对电子表格进行排序，每一列代表一个序列，排序时优先照顾靠后的列。</p><p>【示例69】　通过排序解决成绩相同学生的录取问题。（示例位置：资源包\MR\Code\08\69）<br>某重点高中，精英班录取学生按照总成绩录取。由于名额有限，因此当总成绩相同时，数学成绩高的优先录取；当总成绩和数学成绩都相同时，按照英语成绩高的优先录取。下面使用lexsort()函数对学生成绩进行排序，程序代码如下：</p><p><img src="/2020/03/21/shujufenxi/%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97numpy/image-20211026175145965.png" alt="image-20211026175145965"></p><p>运行程序，输出结果如下：</p><p><img src="/2020/03/21/shujufenxi/%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97numpy/image-20211026175200074.png" alt="image-20211026175200074"></p><p>上述举例，按照数学、英语和总分进行升序排序，总成绩620分的两名同学，按照数学成绩高的优先录取原则进行第一轮排序，总分615分的两名同学，同时他们的数学成绩也相同，则按照英语成绩高的优先录取原则进行第二轮排序。</p><h1 id="8-6-综合应用"><a href="#8-6-综合应用" class="headerlink" title="8.6　综合应用"></a>8.6　综合应用</h1><h2 id="8-6-1-案例1：NumPy实现正态分布"><a href="#8-6-1-案例1：NumPy实现正态分布" class="headerlink" title="8.6.1　案例1：NumPy实现正态分布"></a>8.6.1　案例1：NumPy实现正态分布</h2><p>案例位置：资源包\MR\Code\08\example\01<br>首先简单了解一下什么是正态分布。正态分布，也称“常态分布”，又名高斯分布，它在数据分析的许多方面有着重大的影响力。<br>正态分布是应用最广泛、最常见的一种数据分布形式。正态分布像一只倒扣的钟，两头低，中间高，左右对称，大部分数据集中在平均值附近，小部分在两端。例如，学生成绩的分布，高分和低分的成绩一般是少数，分布在两端，而大部分成绩集中在中间，如图8.30所示。<br>下面使用NumPy生成均值为0，标准差为0.1的一维正态分布样本1000个，并用图表显示出来，效果如图8.31所示。</p><p><img src="/2020/03/21/shujufenxi/%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97numpy/image-20211026175247307.png" alt="image-20211026175247307"></p><p>​                                                                             图8.30　学生成绩正态分布示意图</p><p><img src="/2020/03/21/shujufenxi/%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97numpy/image-20211026175307086.png" alt="image-20211026175307086"></p><p>​                                                                                               图8.31　正态分布图</p><p>程序代码如下：</p><p><img src="/2020/03/21/shujufenxi/%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97numpy/image-20211026175329461.png" alt="image-20211026175329461"></p><h2 id="8-6-2-案例2：NumPy用于图像灰度处理"><a href="#8-6-2-案例2：NumPy用于图像灰度处理" class="headerlink" title="8.6.2　案例2：NumPy用于图像灰度处理"></a>8.6.2　案例2：NumPy用于图像灰度处理</h2><p>案例位置：资源包\MR\Code\08\example\02<br>首先了解一下图像，图像其实是由若干像素组成，每一个像素都有明确的位置和被分配的颜色值，因此一张图像也就构成了一个像素矩阵。例如，一张灰度图片的像素块，如图8.32所示。</p><p><img src="/2020/03/21/shujufenxi/%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97numpy/image-20211026175347296.png" alt="image-20211026175347296"></p><p>​                                                                                      图8.32　灰度图片像素矩阵示意图<br>从图8.32得知：灰度图的数据是一个二维数组，颜色取值为0～255，其中，0为黑色，255为白色。从0～255逐渐由暗色变为亮色。由此可见，图像灰度处理是不是就可以通过数组计算来实现呢？<br>接下来，了解一个公式，RGB转换成灰度图像的常用公式：</p><p>Gray = R<em>0.299 + G</em>0.587 + B*0.114<br>其中，Gray表示灰度值，R、G、B表示红、绿、蓝颜色值，0.299、0.587、0.114表示灰度公式的固定值。</p><p>下面使用NumPy结合Matplotlib实现图像的灰度处理，程序代码如下：</p><p><img src="/2020/03/21/shujufenxi/%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97numpy/image-20211026175446668.png" alt="image-20211026175446668"></p><p>上述代码，显示灰度图时，需要在imshow()函数中设置参数cmap=”gray”。<br>运行程序，对比效果如图8.33和图8.34所示。</p><p><img src="/2020/03/21/shujufenxi/%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97numpy/image-20211026175502299.png" alt="image-20211026175502299"></p><p>​                                                                                                    图8.33　原图</p><p><img src="/2020/03/21/shujufenxi/%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97numpy/image-20211026175527183.png" alt="image-20211026175527183"></p><p>​                                                                                                          图8.34　灰度图像</p><h1 id="8-7-小结"><a href="#8-7-小结" class="headerlink" title="8.7　小结"></a>8.7　小结</h1><p>通过本章的学习，能够掌握NumPy的常用操作，即从数组创建到数组的基本操作和运算。对于数据统计分析来说，这些内容已经足够了；而对于人工智能、机器学习，还需要更加深入地学习NumPy相关知识。另外，当数据量非常大时，NumPy可以带来百倍以上的速度提升。</p>]]></content>
    
    
    <categories>
      
      <category>数据分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>numpy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据可视化分析图表Pyechars</title>
    <link href="/2020/02/21/shujufenxi/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8Pyechars/"/>
    <url>/2020/02/21/shujufenxi/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8Pyechars/</url>
    
    <content type="html"><![CDATA[<h1 id="第七章-第三方可视化数据分析图表Pyecharts"><a href="#第七章-第三方可视化数据分析图表Pyecharts" class="headerlink" title="第七章 第三方可视化数据分析图表Pyecharts"></a>第七章 第三方可视化数据分析图表Pyecharts</h1><p>Echarts是一个由百度开源的数据可视化工具，而Python是一门适用于数据处理和数据分析的语言，为了适应Python的需求，Pyecharts诞生了。<br>本章以Pyecharts 1.7.1版本为主，介绍Pyecharts的安装、链式调用、Pyecharts图表的组成，以及如何绘制柱状图、折线图、面积图、饼形图、箱形图、散点图、词云图、热力图、水球图和日历图。此外，本章还通过综合应用介绍南丁格尔玫瑰图、双y轴可视化数据分析图表的实现，以及饼形图与环形图组合图表的实现。接下来，就让我们开启Pyecharts的旅程。</p><h1 id="7-1-Pyecharts概述"><a href="#7-1-Pyecharts概述" class="headerlink" title="7.1　Pyecharts概述"></a>7.1　Pyecharts概述</h1><h2 id="7-1-1-Pyecharts简介"><a href="#7-1-1-Pyecharts简介" class="headerlink" title="7.1.1　Pyecharts简介"></a>7.1.1　Pyecharts简介</h2><p>Pyecharts是一个用于生成Echarts图表的类库。Echarts是百度开源的一个数据可视化JS库。用Echarts生成的图可视化效果非常好，而Pyecharts则是专门为了与Python衔接，方便在Python中直接使用的可视化数据分析图表。使用Pyecharts可以生成独立的网页格式的图表，还可以在flask、django中直接使用，非常方便。<br>Pyecharts的图表类型非常多且效果非常漂亮，例如图7.1、图7.2和图7.3所示的线性闪烁图、仪表盘图和水球图。<br>Pyecharts的图表类型主要包括Bar（柱状图／条形图）、Boxplot（箱形图）、Funnel（漏斗图）、Gauge（仪表盘）、HeatMap（热力图）、Line（折线／面积图）、Line3D（3D折线图）、Liquid（水球图）、Map（地图）、Parallel（平行坐标系）、Pie（饼图）、Polar（极坐标系）、Radar（雷达图）、Scatter（散点图）和WordCloud（词云图）等。</p><p><img src="/2020/02/21/shujufenxi/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8Pyechars/image-20211025093507338.png" alt="image-20211025093507338"></p><p>​                                                                              图7.1　线性闪烁图</p><p><img src="/2020/02/21/shujufenxi/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8Pyechars/image-20211025093610269.png" alt="image-20211025093610269"></p><p>​                                                                                           图7.2　仪表盘图</p><p><img src="/2020/02/21/shujufenxi/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8Pyechars/image-20211025093631679.png" alt="image-20211025093631679"></p><p>​                                                                                                       图7.3　水球图</p><h2 id="7-1-2-安装Pyecharts"><a href="#7-1-2-安装Pyecharts" class="headerlink" title="7.1.2　安装Pyecharts"></a>7.1.2　安装Pyecharts</h2><p>在anaconda命令提示符窗口中安装Pyecharts库。在系统搜索框中输入anaconda prompt，单击Anaconda Prompt打开Anaconda Prompt命令提示符窗口，使用pip工具安装，命令如下：</p><p>pip install pyecharts==1.7.1<br>安装成功后，将提示安装成功的字样，如“Successfully installed pyecharts-1.7.1”。说明<br>由于Pyecharts各个版本的相关代码有一些区别，因此这里建议安装与笔者相同的版本，以免造成不必要的麻烦。那么，对于已经安装完成的Pyecharts，可以使用如下方法查看Pyecharts的版本，代码如下：</p><p>import pyecharts<br>print(pyecharts.<strong>version</strong>)<br>运行程序，控制台输出结果如下：</p><p>1.7.1</p><p>如果安装版本与笔者不同，建议卸载重新安装Pyecharts 1.7.1版本。</p><h2 id="7-1-3-绘制第一张图表"><a href="#7-1-3-绘制第一张图表" class="headerlink" title="7.1.3　绘制第一张图表"></a>7.1.3　绘制第一张图表</h2><p>【示例01】　绘制简单的柱状图。（示例位置：资源包\MR\Code\07\01）<br>下面使用Pyecharts绘制一张简单的柱状图，具体步骤如下。<br>（1）从pyecharts.charts库中导入Bar模块，代码如下：</p><p>from pyecharts.charts import Bar  #从pyecharts.charts库中导入Bar模块</p><p>（2）创建一个空的Bar()对象，代码如下：</p><p>bar = Bar()<br>（3）定义x轴和y轴数据，其中x轴为月份，y轴为销量。代码如下：</p><p>01 bar.add_xaxis([“1月”, “2月”, “3月”, “4月”, “5月”, “6月”])<br>02 bar.add_yaxis(“零基础学Python”, [2567, 1888, 1359, 3400, 4050, 5500])<br>03 bar.add_yaxis(“Python趣味案例编程”, [1567, 988, 2270,3900, 2750, 3600])<br>（4）渲染图表到HTML文件中，并存放在程序所在目录下，代码如下：</p><p>bar.render(“mycharts.html”)<br>运行程序，在程序所在路径下生成一个名为mycharts.html的HTML文件，打开该文件，效果如图7.4所示。</p><p><img src="/2020/02/21/shujufenxi/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8Pyechars/image-20211025093733763.png" alt="image-20211025093733763"></p><p>​                                                                                                图7.4　绘制第一张图表<br>以上就是我们绘制的第一张Pyecharts图表。实用技巧Pyecharts 1.0以上版本对方法的链式调用<br>对于方法的调用可分为<strong>单独调用和链式调用</strong>。单独调用就是常规的一个方法一个方法的调用。而链式调用的关键在于方法化，现在很多开源库或者代码都使用链式调用。链式调用将所有需要调用的方法写在一个方法里，这样使得我们的代码看上去更加简洁易懂。<br>下面以本节的“第一张图表”为例，在调用Bar模块的各个方法时，将单独调用与链式调用进行简单对比，效果如图7.5所示。</p><p><img src="/2020/02/21/shujufenxi/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8Pyechars/image-20211025093824559.png" alt="image-20211025093824559"></p><p>​                                                                                 图7.5　单独调用与链式调用对比<br>从图7.5中可以看出，链式调用将所有需要调用的方法写在了一个方法里，这样的代码看上去更加简洁易懂。当然，如果不习惯使用链式调用，单独调用也可以。</p><h1 id="7-2-Pyecharts图表的组成"><a href="#7-2-Pyecharts图表的组成" class="headerlink" title="7.2　Pyecharts图表的组成"></a>7.2　Pyecharts图表的组成</h1><p>Pyecharts不仅具备Matplotlib图表的一些常用功能，而且还提供了独有的、别具特色的功能。<strong>主要包括主题风格的设置、提示框、视觉映射、工具箱和区域缩放</strong>等，如图7.6所示。这些功能使得Pyecharts能够绘制出各种各样、超乎想象的图表。</p><p><img src="/2020/02/21/shujufenxi/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8Pyechars/image-20211025093932297.png" alt="image-20211025093932297"></p><p>​                                                                                                    图7.6　Pyecharts图表的组成</p><h2 id="7-2-1-主题风格"><a href="#7-2-1-主题风格" class="headerlink" title="7.2.1　主题风格"></a>7.2.1　主题风格</h2><p>Pyecharts内置提供了15种不同的主题风格，并提供了便捷的定制主题的方法。主要使用Pyecharts库的options模块，通过该模块的InitOpts()方法设置图表的主题风格。下面介绍InitOpts()方法的几个关键参数。</p><p>参数说明：　</p><p>width：字符型，图表画布宽度，以像素为单位，例如width=’500px’。　</p><p>height：字符型，图表画布高度，以像素为单位，例如height=’300px’。　</p><p>chart_id：图表的ID，图表的唯一标识，主要用于多张图表时以区分每张图表。　</p><p>page_title：字符型，网页标题。　</p><p>theme：图表主题，其参数值主要由ThemeType模块提供。　</p><p>bg_color：字符型，图表背景颜色，例如bg_color=’black’或bg_color=’#fff’。</p><p>下面详细介绍一下ThemeType模块提供的15种图表主题风格，如表7.1所示。</p><p>​                                                                               表7.1　theme参数设置值</p><p><img src="/2020/02/21/shujufenxi/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8Pyechars/image-20211025094017187.png" alt="image-20211025094017187"></p><p>【示例02】　为图表更换主题。（示例位置：资源包\MR\Code\07\02）<br>下面为“第一张图表”更换主题，具体步骤如下所示。<br>（1）从pyecharts.charts库中导入Bar模块，代码如下：</p><p>from pyecharts.charts import Bar<br>（2）从pyecharts库中导入options模块，代码如下：</p><p>from pyecharts import options as opts<br>（3）从pyecharts.globals库中导入主题类型模块ThemeType，代码如下：</p><p>from pyecharts.globals import ThemeType<br>（4）设置画布大小、图表主题和图表背景颜色，代码如下：</p><p><img src="/2020/02/21/shujufenxi/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8Pyechars/image-20211025094339610.png" alt="image-20211025094339610"></p><p>（5）渲染图表到HTML文件中，并存放在程序所在目录下，代码如下：</p><p>bar.render(“mycharts1.html”)<br>运行程序，在程序所在路径下生成一个名为mycharts1.html的HTML文件，打开该文件，效果如图7.7所示。</p><p><img src="/2020/02/21/shujufenxi/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8Pyechars/image-20211025094359953.png" alt="image-20211025094359953"></p><p>​                                                                                                 图7.7　主题风格</p><h2 id="7-2-2-图表标题"><a href="#7-2-2-图表标题" class="headerlink" title="7.2.2　图表标题"></a>7.2.2　图表标题</h2><p>图表标题主要通过set_global_options()方法的title_opts参数进行设置，该参数值参考options模块的TitleOpts()方法，该方法可以实现主标题、副标题、距离设置以及文字样式等。TitleOpts()方法主要参数说明如下。　</p><p>title：字符型，默认值为None。主标题文本，支持换行符“\n”。　</p><p>title_link：字符型，默认值为None。主标题跳转URL链接。　</p><p>title_target：字符型，默认值为None。主标题跳转链接的方式，默认值为blank，表示在新窗口打开。可选参数self，表示在当前窗口打开。　</p><p>subtitle：字符型，默认值为None。副标题文本，支持换行符“\n”。　</p><p>subtitle_link：字符型，默认值为None。副标题跳转URL链接。　</p><p>subtitle_target：字符型，默认值为None。副标题跳转链接的方式，默认值为blank，表示在新窗口打开。可选参数self，表示在当前窗口打开。　</p><p>pos_left：字符型，默认值为None。标题距左侧的距离，其值可以是像10这样的具体像素值，也可以是像10%这样的相对于容器的高宽的百分比，还可以是left、center或right，标题将根据相应的位置自动对齐。　</p><p>pos_right：字符型，默认值为None。标题距右侧的距离，其值可以是像10这样的具体像素值，也可以是像10%这样的相对于容器的高宽的百分比。　</p><p>pos_top：字符型，默认值为None。标题距顶端的距离，其值可以是像10这样的具体像素值，也可以是像10%这样的相对于容器的高宽的百分比，还可以是top、middle或bottom，标题将根据相应的位置自动对齐。　</p><p>pos_bottom：字符型，默认值为None。标题距底端的距离，其值可以是像10这样的具体像素值，也可以是像10%这样的相对于容器的高宽的百分比。　</p><p>padding：标题内边距，单位为像素。默认值为各方向（上右下左）内边距为5，接受数组分别设定上右下左边距，例如padding=[10,4,5,90]。　</p><p>item_gap：数值型，主标题与副标题之间的间距，例如item_gap=3.5。　</p><p>title_textstyle_opts：主标题文字样式配置项，参考options模块的TextStyleOpts()方法。主要包括颜色、字体样式、字体的粗细、字体的大小以及对齐方式等。例如，设置标题颜色为红色，字体大小为16，代码如下：</p><p>title_textstyle_opts=opts.TextStyleOpts(color=’red’,font_size=18)　</p><p>subtitle_textstyle_opts：副标题文字样式配置项。同上。</p><p>【示例03】　为图表设置标题。（示例位置：资源包\MR\Code\07\03）<br>下面为“第一张图表”设置标题，具体步骤如下所示。<br>（1）从pyecharts.charts库中导入Bar模块，代码如下：</p><p>from pyecharts.charts import Bar<br>（2）从pyecharts库中导入options模块，代码如下：</p><p>from pyecharts import options as opts<br>（3）从pyecharts.globals库中导入主题类型模块ThemeType，代码如下：</p><p>from pyecharts.globals import ThemeType<br>（4）生成图表，设置图表标题，包括主标题、主标题字体颜色和大小、副标题、标题内边距，以及主标题与副标题之间的间距。代码如下：</p><p><img src="/2020/02/21/shujufenxi/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8Pyechars/image-20211025094612795.png" alt="image-20211025094612795"></p><p>（5）渲染图表到HTML文件中，并存放在程序所在目录下，代码如下：</p><p>bar.render(“mycharts2.html”)<br>运行程序，在程序所在路径下生成一个名为mycharts2.html的HTML文件，打开该文件，效果如图7.8所示。</p><p><img src="/2020/02/21/shujufenxi/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8Pyechars/image-20211025094645524.png" alt="image-20211025094645524"></p><p>​                                                                                                        图7.8　图表标题</p><h2 id="7-2-3-图例"><a href="#7-2-3-图例" class="headerlink" title="7.2.3　图例"></a>7.2.3　图例</h2><p>设置图例主要通过set_global_opts()方法的legend_opts参数进行设置，该参数值参考options模块的LegendOpts()方法。LegendOpts()方法主要参数说明如下。　</p><p>is_show：布尔值，是否显示图例，值为True显示图例，值为False则不显示图例。　</p><p>pos_left：字符串或数字，默认值为None。图例离容器左侧的距离，其值可以是像10这样的具体像素值，也可以是10%，表示相对于容器高宽的百分比，还可以是left、center或right，图例将根据相应的位置自动对齐。　</p><p>pos_right：字符串或数字，默认值为None。图例离容器右侧的距离，其值可以是像10这样的具体像素值，也可以是10%，表示相对于容器高宽的百分比。　</p><p>pos_top：字符串或数字，默认值为None。图例离容器顶端的距离，其值可以是像10这样的具体像素值，也可以是10%，表示相对于容器高宽的百分比，还可以是top、middle或bottom，图例将根据相应的位置自动对齐。　</p><p>pos_bottom：字符串或数字，默认值为None。图例离容器底端的距离，其值可以是像10这样的具体像素值，也可以是10%，表示相对于容器高宽的百分比。　</p><p>orient：字符串，默认值为None。图例列表的布局朝向，其值为horizontal（横向）或vertical（纵向）。</p><p>align：字符串。图例标记和文本的对齐，其值为auto、left或right，默认值为auto（自动）。根据图表的位置和orient参数（图例列表的朝向）决定。　padding：整型，图例内边距，单位为像素（px），默认值为各方向内边距为5。　</p><p>item_gap：图例之间的间隔。横向布局时为水平间隔，纵向布局时为纵向间隔。默认间隔为10。　</p><p>item_width：图例标记的宽度。默认宽度为25。　</p><p>item_height：图例标记的高度。默认高度为14。　</p><p>textstyle_opts：图例的字体样式。参考options模块的TextStyleOpts()方法。主要包括颜色、字体样式、字体的粗细、字体的大小以及对齐方式等。　</p><p>legend_icon：图例标记的样式。其值为circle（圆形）、rect（矩形）、roundRect（圆角矩形）、triangle（三角形）、diamond（菱形）、pin（大头针）、arrow（箭头）或none（无），也可以设置为图片。</p><p>【示例04】　为图表设置图例。（示例位置：资源包\MR\Code\07\04）<br>下面为“第一张图表”设置图例，具体步骤如下所示。<br>（1）从pyecharts.charts库中导入Bar模块，代码如下：</p><p>from pyecharts.charts import Bar<br>（2）从pyecharts库中导入options模块，代码如下：</p><p>from pyecharts import options as opts<br>（3）生成图表，设置图表标题和图例。其中图例主要包括图例离容器右侧的距离、图例标记的宽度和图例标记的样式，代码如下：</p><p><img src="/2020/02/21/shujufenxi/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8Pyechars/image-20211025094813219.png" alt="image-20211025094813219"></p><p>运行程序，在程序所在路径下生成一个名为mycharts3.html的HTML文件，打开该文件，效果如图7.9所示。</p><p><img src="/2020/02/21/shujufenxi/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8Pyechars/image-20211025094912334.png" alt="image-20211025094912334"></p><p>​                                                                                                  图7.9　图例</p><h2 id="7-2-4-提示框"><a href="#7-2-4-提示框" class="headerlink" title="7.2.4　提示框"></a>7.2.4　提示框</h2><p>提示框的设置主要通过set_global_opts()方法的tooltip_opts参数进行设置，该参数值参考options模块的TooltipOpts()方法。TooltipOpts()方法主要参数说明如下。　</p><p>is_show：布尔值，是否显示提示框。　</p><p>trigger：提示框触发的类型，可选参数。item数据项图形触发，主要在散点图和饼图等无类目轴的图表中使用。axis坐标轴触发，主要在柱状图和折线图等使用类目轴的图表中使用。None不触发，无提示框。　</p><p>trigger_on：提示框触发的条件，可选参数。mousemove鼠标移动时触发，click鼠标单击时触发，mousemove|click鼠标移动和单击的同时触发，none鼠标不移动或不单击时触发。　</p><p>axis_pointer_type：指示器类型，可选参数。其值如下。　</p><p>line：直线指示器。　</p><p>shadow：阴影指示器。</p><p>cross：十字线指示器。　</p><p>none：无指示器。　</p><p>background_color：提示框的背景颜色。　</p><p>border_color：提示框边框的颜色。　</p><p>border_width：提示框边框的宽度。　</p><p>textstyle_opts：提示框中文字的样式。参考options模块的TextStyleOpts()方法。主要包括颜色、字体样式、字体的粗细、字体的大小以及对齐方式等。</p><p>【示例05】　为图表设置提示框。（示例位置：资源包\MR\Code\07\05）<br>下面设置提示框的样式，具体步骤如下所示。<br>（1）导入相关模块，代码如下：</p><p>01  from pyecharts import options as opts<br>02  from pyecharts.charts import Bar<br>03  from pyecharts.globals import ThemeType<br>（2）设置图表标题和图例。其中图例主要包括图例离容器右侧的距离、图例标记的宽度和图例标记的样式，代码如下：</p><p><img src="/2020/02/21/shujufenxi/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8Pyechars/image-20211025095151357.png" alt="image-20211025095151357"></p><p>（3）生成图表，设置提示框。鼠标单击时触发提示框，设置提示框为十字线指示器，设置背景色、边框宽度和边框颜色，代码如下：</p><p><img src="/2020/02/21/shujufenxi/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8Pyechars/image-20211025095209115.png" alt="image-20211025095209115"></p><p>运行程序，在程序所在路径下生成一个名为mycharts5.html的HTML文件，打开该文件，效果如图7.10所示。</p><p><img src="/2020/02/21/shujufenxi/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8Pyechars/image-20211025095249239.png" alt="image-20211025095249239"></p><p>​                                                                                              图7.10　提示框</p><h2 id="7-2-5-视觉映射"><a href="#7-2-5-视觉映射" class="headerlink" title="7.2.5　视觉映射"></a>7.2.5　视觉映射</h2><p>视觉映射主要通过set_global_opts()方法的title_opts参数进行设置，该参数值参考options模块的VisualMapOpts()方法。VisualMapOpts()方法主要参数说明如下。　</p><p>is_show：布尔型，是否显示视觉映射配置。　</p><p>type_：映射过渡类型，可选参数，其值为color或size。　_</p><p>_min_：整型或浮点型，颜色条的最小值。　</p><p>max_：整型或浮点型，颜色条的最大值。　</p><p>range_text：颜色条两端的文本，例如，High或Low。　range_color：序列。颜色范围（过渡颜色），例如range_color=[“#FFF0F5”, “#8B008B”]。　</p><p>orient：颜色条放置方式，水平（horizontal）或者竖直（vertical）。　</p><p>pos_left：颜色条离左侧的距离。　</p><p>dimension：颜色条映射的维度。　</p><p>is_piecewise：布尔型，是否分段显示数据。【示例06】　为图表添加视觉映射。（示例位置：资源包\MR\Code\07\06）<br>下面为图表添加视觉映射，具体步骤如下所示。<br>（1）导入相关模块，代码如下：</p><p>01  from pyecharts import options as opts</p><p>02  from pyecharts.charts import Bar<br>（2）为柱状图添加数据，代码如下：</p><p><img src="/2020/02/21/shujufenxi/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8Pyechars/image-20211025101615302.png" alt="image-20211025101615302"></p><p>（3）设置图表标题和视觉映射，并生成图表，代码如下：</p><p><img src="/2020/02/21/shujufenxi/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8Pyechars/image-20211025101634254.png" alt="image-20211025101634254"></p><p>运行程序，在程序所在路径下生成一个名为mycharts6.html的HTML文件，打开该文件，效果如图7.11所示。</p><p><img src="/2020/02/21/shujufenxi/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8Pyechars/image-20211025101655610.png" alt="image-20211025101655610"></p><p>​                                                                                                 图7.11　视觉映射</p><h2 id="7-2-6-工具箱"><a href="#7-2-6-工具箱" class="headerlink" title="7.2.6　工具箱"></a>7.2.6　工具箱</h2><p>工具箱主要通过set_global_opts()方法的title_opts参数进行设置，该参数值参考options模块的ToolboxOpts()方法。ToolboxOpts()方法主要参数说明如下。　</p><p>is_show：布尔值，是否显示工具箱。　</p><p>orient：工具箱的布局朝向。可选参数，默认值为None，其值为horizontal（水平）或vertical（竖直）。　</p><p>pos_left：工具箱离容器左侧的距离。　</p><p>pos_right：工具箱离容器右侧的距离。　</p><p>pos_top：工具箱离容器顶端的距离。　</p><p>pos_bottom：工具箱离容器底端的距离。　</p><p>feature：工具箱中每个工具的配置项。</p><p>【示例07】　为图表添加工具箱。（示例位置：资源包\MR\Code\07\07）<br>下面为图表添加工具箱，具体步骤如下所示。<br>（1）导入相关模块，代码如下：</p><p>01  from pyecharts import options as opts<br>02  from pyecharts.charts import Bar<br>（2）绘制柱状图，代码如下：</p><p><img src="/2020/02/21/shujufenxi/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8Pyechars/image-20211025102300265.png" alt="image-20211025102300265"></p><p>（3）添加工具箱，并生成图表，代码如下：</p><p><img src="/2020/02/21/shujufenxi/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8Pyechars/image-20211025102427248.png" alt="image-20211025102427248">运行程序，在程序所在路径下生成一个名为mycharts7.html的HTML文件，打开该文件，效果如图7.12所示。</p><p><img src="/2020/02/21/shujufenxi/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8Pyechars/image-20211025102448491.png" alt="image-20211025102448491"></p><p>​                                                                                         图7.12　工具箱</p><h2 id="7-2-7-区域缩放"><a href="#7-2-7-区域缩放" class="headerlink" title="7.2.7　区域缩放"></a>7.2.7　区域缩放</h2><p>区域缩放工具条主要通过set_global_opts()方法的datazoom_opts参数进行设置，该参数值参考options模块的DataZoomOpts()方法。DataZooDataZoomOpts()方法主要参数说明如下。　</p><p>is_show：布尔值，是否显示区域缩放工具条。　</p><p>type_：区域缩放工具条的类型，可选参数，其值为slider或inside。　</p><p>is_realtime：布尔值，是否实时更新图表。　</p><p>range_start：数据窗口范围的起始百分比，其值为0～100，表示0%～100%。　</p><p>range_end：数据窗口范围的结束百分比，其值为0～100，表示0%～100%。　</p><p>start_value：数据窗口的起始数值。　</p><p>end_value：数据窗口范围的结束数值。　</p><p>orient：区域缩放工具条的布局方式。可选参数，默认值为None，其值为horizontal（水平）或vertical（竖直）。　</p><p>pos_left：工具箱离容器左侧的距离。　</p><p>pos_right：工具箱离容器右侧的距离。　</p><p>pos_top：工具箱离容器顶端的距离。　</p><p>pos_bottom：工具箱离容器底端的距离。</p><p>【示例08】　为图表添加区域缩放。（示例位置：资源包\MR\Code\07\08）<br>下面为图表添加区域缩放工具条，具体步骤如下所示。<br>（1）导入相关模块，代码如下：</p><p>01  from pyecharts import options as opts<br>02  from pyecharts.charts import Bar<br>（2）绘制柱状图，代码如下：</p><p><img src="/2020/02/21/shujufenxi/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8Pyechars/image-20211025102558340.png" alt="image-20211025102558340"></p><p>（3）添加区域缩放工具条，并生成图表，代码如下：</p><p><img src="/2020/02/21/shujufenxi/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8Pyechars/image-20211025102644997.png" alt="image-20211025102644997"></p><p>运行程序，在程序所在路径下生成一个名为mycharts8.html的HTML文件，打开该文件，效果如图7.13所示。</p><p><img src="/2020/02/21/shujufenxi/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8Pyechars/image-20211025102719440.png" alt="image-20211025102719440"></p><p>​                                                                                                       图7.13　区域缩放</p><h1 id="7-3-Pyecharts图表的绘制"><a href="#7-3-Pyecharts图表的绘制" class="headerlink" title="7.3　Pyecharts图表的绘制"></a>7.3　Pyecharts图表的绘制</h1><h2 id="7-3-1-柱状图——Bar模块"><a href="#7-3-1-柱状图——Bar模块" class="headerlink" title="7.3.1　柱状图——Bar模块"></a>7.3.1　柱状图——Bar模块</h2><p>绘制柱状图／条形图主要使用Bar模块实现，主要方法介绍如下。</p><p>add_xaxis()：x轴数据。　</p><p>add_yaxis()：y轴数据。　</p><p>reversal_axis()：翻转x、y轴数据。　</p><p>add_dataset()：原始数据。一般来说，原始数据表达的是二维表。</p><p>【示例09】　绘制多柱状图。（示例位置：资源包\MR\Code\07\09）<br>上述内容简单介绍了柱状图的绘制，下面通过Pandas导入Excel文件中的数据，然后绘制多柱状图，分析近7年各个电商平台的销量情况，具体步骤如下所示。<br>（1）导入相关模块，代码如下：</p><p>01  import pandas as pd<br>02  from pyecharts.charts import Bar<br>03  from pyecharts import options as opts<br>04  from pyecharts.globals import ThemeType<br>（2）导入Excel文件，代码如下：</p><p>01  #导入Excel文件<br>02  df = pd.read_excel(‘books.xlsx’,sheet_name=’Sheet2’)<br>03  #x轴和y轴数据<br>04  x=list(df[‘年份’])<br>05  y1=list(df[‘京东’])<br>06 y2=list(df[‘天猫’])<br>07 y3=list(df[‘自营’])<br>（3）绘制多柱状图，代码如下：<br>运行程序，对比效果如图7.14和图7.15所示。</p><p><img src="/2020/02/21/shujufenxi/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8Pyechars/image-20211025102857406.png" alt="image-20211025102857406"></p><p>​                                                                                                     图7.14　数据展示</p><p><img src="/2020/02/21/shujufenxi/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8Pyechars/image-20211025102918759.png" alt="image-20211025102918759"></p><p>​                                                                                             图7.15　多柱状图展示</p><h2 id="7-3-2-折线／面积图——Line模块"><a href="#7-3-2-折线／面积图——Line模块" class="headerlink" title="7.3.2　折线／面积图——Line模块"></a>7.3.2　折线／面积图——Line模块</h2><p>绘制折线／面积图主要使用Line模块的add_xaxis()方法和add_yaxis()方法实现。下面介绍add_yaxis()方法的几个主要参数。　series_name：系列名称。用于提示文本和图例标签。　</p><p>y_axis：y轴数据。　</p><p>color：标签文本的颜色。　</p><p>symbol：标记。包括circle、rect、roundRect、triangle、diamond、pin、arrow或none，也可以设置为图片。　</p><p>symbol_size：标记大小。　</p><p>is_smooth：布尔值，是否为平滑曲线。　</p><p>is_step：布尔值，是否显示为阶梯图。　</p><p>linestyle_opts：线条样式。参考series_options.LineStyleOpts。　</p><p>areastyle_opts：填充区域配置项，主要用于绘制面积图。该参数值须参考options模块的AreaStyleOpts()方法，例如areastyle_opts=opts.AreaStyleOpts(opacity=1)。</p><p>【示例10】　绘制折线图。（示例位置：资源包\MR\Code\07\10）<br>下面绘制折线图，分析近7年各个电商平台的销量情况，具体步骤如下所示。<br>（1）导入相关模块，代码如下：</p><p>01  import pandas as pd<br>02  from pyecharts.charts import Line<br>（2）绘制折线图，代码如下：<br>运行程序，在程序所在路径下生成myline1.html的HTML文件，打开该文件，效果如图7.16所示。</p><p><img src="/2020/02/21/shujufenxi/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8Pyechars/image-20211025103019599.png" alt="image-20211025103019599"></p><p>​                                                                                                         图7.16　折线图</p><p>注意</p><p>x轴数据必须为字符串，否则图表不显示。如果数据为其他类型，需要使用str()函数转换为字符串，如x_data=[str(i) for i in x]。</p><p>【示例11】　绘制面积图。（示例位置：资源包\MR\Code\07\11）<br>使用Line模块还可以绘制面积图，主要通过在add_yaxis()方法中指定areastyle_opts参数，该参数值由options模块的AreaStyleOpts()方法提供。下面绘制面积图，具体步骤如下所示。<br>（1）导入相关模块，代码如下：</p><p>01  import pandas as pd<br>02  from pyecharts.charts import Line<br>03  from pyecharts import options as opts<br>（2）绘制面积图，代码如下：</p><p><img src="/2020/02/21/shujufenxi/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8Pyechars/image-20211025103120692.png" alt="image-20211025103120692"></p><p>运行程序，在程序所在路径下生成myline2.html的HTML文件，打开该文件，效果如图7.17所示。</p><p><img src="/2020/02/21/shujufenxi/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8Pyechars/image-20211025103137908.png" alt="image-20211025103137908"></p><p>​                                                                                                  图7.17　面积图</p><h2 id="7-3-3-饼形图——Pie模块"><a href="#7-3-3-饼形图——Pie模块" class="headerlink" title="7.3.3　饼形图——Pie模块"></a>7.3.3　饼形图——Pie模块</h2><p>绘制饼形图主要使用Pie模块的add()方法实现。下面介绍add()方法的几个主要参数。　</p><p>series_name：系列名称。用于提示文本和图例标签。　</p><p>data_pair：数据项，格式为[(key1, value1), (key2, value2)]。可使用zip()函数将可迭代对象打包成元组，然后再转换为列表。　</p><p>color：系列标签的颜色。　</p><p>radius：饼图的半径，数组的第一项是内半径，第二项是外半径。默认设置为百分比，相对于容器高宽中较小的一项的一半。</p><p>rosetype：是否展开为南丁格尔玫瑰图（也称南丁格尔的玫瑰），通过半径区分数据大小。其值为radius或area，radius表示通过扇区圆心角展现数据的百分比，通过半径展现数据的大小；area表示所有扇区圆心角相同，仅通过半径展现数据的大小。知识胶囊<br>南丁格尔，英国护士和统计学家，出生于意大利的一个英国上流社会的家庭。南丁格尔被描述为“在统计的图形显示方法上，是一个真正的先驱”，她发展出极坐标图饼图的形式，或称为南丁格尔玫瑰图，相当于现代圆形直方图，以说明她在管理的野战医院内，病人死亡率在不同季节的变化。她使用极坐标图饼图，向不会阅读统计报告的国会议员，报告克里米亚战争的医疗条件。　</p><p>is_clockwise：饼图的扇区是否以顺时针显示。</p><p>【示例12】　饼形图分析各地区销量占比情况。（示例位置：资源包\MR\Code\07\12）<br>下面绘制饼形图，分析各地区销量占比情况，具体步骤如下所示。<br>（1）导入相关模块，代码如下：</p><p>01  import pandas as pd<br>02  from pyecharts.charts import Pie<br>03  from pyecharts import options as opts<br>（2）导入Excel文件，并将数据处理为列表加元组的形式，代码如下：</p><p><img src="/2020/02/21/shujufenxi/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8Pyechars/image-20211025103236326.png" alt="image-20211025103236326"></p><p>（3）创建饼形图，代码如下：</p><p><img src="/2020/02/21/shujufenxi/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8Pyechars/image-20211025103625577.png" alt="image-20211025103625577"></p><p>运行程序，在程序所在路径下生成mypie1.html的HTML文件，打开该文件，效果如图7.18所示。</p><p><img src="/2020/02/21/shujufenxi/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8Pyechars/image-20211025103706227.png" alt="image-20211025103706227"></p><p>​                                                                                               图7.18　饼形图</p><h2 id="7-3-4-箱形图——Boxplot模块"><a href="#7-3-4-箱形图——Boxplot模块" class="headerlink" title="7.3.4　箱形图——Boxplot模块"></a>7.3.4　箱形图——Boxplot模块</h2><p>【示例13】　绘制简单的箱形图。（示例位置：资源包\MR\Code\07\13）<br>绘制箱形图主要使用Boxplot模块的add_xaxis()方法和add_yaxis()方法实现。下面绘制一个简单的箱形图，程序代码如下：</p><p><img src="/2020/02/21/shujufenxi/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8Pyechars/image-20211025103730467.png" alt="image-20211025103730467"></p><p>运行程序，在程序所在路径下生成myboxplot.html的HTML文件，打开该文件，效果如图7.19所示。</p><p><img src="/2020/02/21/shujufenxi/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8Pyechars/image-20211025103753043.png" alt="image-20211025103753043"></p><p>​                                                                                                 图7.19　箱形图</p><h2 id="7-3-5-涟漪特效散点图——EffectScatter模块"><a href="#7-3-5-涟漪特效散点图——EffectScatter模块" class="headerlink" title="7.3.5　涟漪特效散点图——EffectScatter模块"></a>7.3.5　涟漪特效散点图——EffectScatter模块</h2><p>【示例14】　绘制简单的散点图。（示例位置：资源包\MR\Code\07\14）<br>绘制涟漪特效散点图主要使用EffectScatter模块的add_xaxis()方法和add_yaxis()方法实现。下面绘制一个简单的涟漪特效散点图，程序代码如下：</p><p><img src="/2020/02/21/shujufenxi/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8Pyechars/image-20211025103917833.png" alt="image-20211025103917833"></p><p>运行程序，在程序所在路径下生成myscatter.html的HTML文件，打开该文件，效果如图7.20所示。</p><p><img src="/2020/02/21/shujufenxi/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8Pyechars/image-20211025103937243.png" alt="image-20211025103937243"></p><p>​                                                                                    图7.20　涟漪特效散点图</p><h2 id="7-3-6-词云图——WordCloud模块"><a href="#7-3-6-词云图——WordCloud模块" class="headerlink" title="7.3.6　词云图——WordCloud模块"></a>7.3.6　词云图——WordCloud模块</h2><p>绘制词云图主要使用WordCloud模块的add()方法实现。下面介绍add()方法的几个主要参数。　</p><p>series_name：系列名称。用于提示文本和图例标签。　</p><p>data_pair：数据项。格式为[(word1,count1), (word2, count2)]。可使用zip()函数将可迭代对象打包成元组，然后再转换为列表。　</p><p>shape：字符型，词云图的轮廓。其值为circle、cardioid、diamond、triangle-forward、triangle、pentagon或star。　</p><p>mask_image：自定义图片（支持的图片格式为jpg、jpeg、png和ico）。该参数支持base64（一种基于64个可打印字符来表示二进制数据的方法）和本地文件路径（相对或者绝对路径都可以）。　</p><p>word_gap：单词间隔。　</p><p>word_size_range：单词字体大小范围。　</p><p>rotate_step：旋转单词角度。　</p><p>pos_left：距离左侧的距离。　</p><p>pos_top：距离顶部的距离。　</p><p>pos_right：距离右侧的距离。　</p><p>pos_bottom：距离底部的距离。　</p><p>width：词云图的宽度。　</p><p>height：词云图的高度。<br>实现词云图首先需要通过jieba模块的TextRank算法从文本中提取关键词。TextRank是一种文本排序算法，是基于著名的网页排序算法PageRank改动而来。TextRank不仅能进行关键词提取，也能做自动文摘。<br>根据某个词所连接的所有词汇的权重（权重是指某一因素或指标相对于某一事物的重要程度，这里指某个词在整段文字中的重要程度），重新计算该词汇的权重，然后把重新计算的权重传递下去，直到这种变化达到均衡态，权重数值不再发生改变。根据最后的权重值，取其中排列靠前的词汇作为关键词。</p><p>【示例15】　绘制词云图分析用户评论内容。（示例位置：资源包\MR\Code\07\15）<br>接下来绘制词云图，分析用户的评论内容。具体步骤如下所示。<br>（1）安装jieba模块，运行anaconda prompt（Anaconda），通过pip命令安装jieba模块，安装命令如下：</p><p>pip install jieba<br>（2）导入相关模块，代码如下：</p><p>01  from pyecharts.charts import WordCloud<br>02  from jieba import analyse</p><p>（3）使用TextRank算法从文本中提取关键词，代码如下：</p><p><img src="/2020/02/21/shujufenxi/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8Pyechars/image-20211025104200766.png" alt="image-20211025104200766"></p><p>（4）关键词列表，代码如下：</p><p><img src="/2020/02/21/shujufenxi/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8Pyechars/image-20211025104221304.png" alt="image-20211025104221304"></p><p>（5）绘制词云图，代码如下：</p><p>01  mywordcloud=WordCloud()<br>02  mywordcloud.add(‘’,list1,word_size_range=[20,100])<br>03  mywordcloud.render(‘wordclound.html’)<br>运行程序，在程序所在路径下生成wordclound.html的HTML文件，打开该文件，效果如图7.21所示。</p><p><img src="/2020/02/21/shujufenxi/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8Pyechars/image-20211025104247930.png" alt="image-20211025104247930"></p><p>​                                                                                               图7.21　词云图</p><h2 id="7-3-7-热力图——HeatMap模块"><a href="#7-3-7-热力图——HeatMap模块" class="headerlink" title="7.3.7　热力图——HeatMap模块"></a>7.3.7　热力图——HeatMap模块</h2><p>【示例16】　热力图统计双色球中奖号码出现的次数。（示例位置：资源包\MR\Code\07\16）</p><p>绘制热力图主要使用HeatMap模块的add_xaxis()方法和add_yaxis()方法。下面通过热力图统计2014—2019年双色球中奖号码出现的次数，具体步骤如下所示。<br>（1）导入相关模块，代码如下：</p><p>01  import pyecharts.options as opts<br>02  from pyecharts.charts import HeatMap<br>03  import pandas as pd<br>（2）导入Excel文件，并进行数据处理，代码如下：</p><p><img src="/2020/02/21/shujufenxi/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8Pyechars/image-20211025104333637.png" alt="image-20211025104333637"></p><p>（3）将数据转换为HeatMap支持的列表格式，代码如下：</p><p><img src="/2020/02/21/shujufenxi/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8Pyechars/image-20211025104354300.png" alt="image-20211025104354300"></p><p>（4）绘制热力图，代码如下：</p><p><img src="/2020/02/21/shujufenxi/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8Pyechars/image-20211025104427190.png" alt="image-20211025104427190"></p><p>运行程序，在程序所在路径下生成heatmap.html的HTML文件，打开该文件，效果如图7.22所示。</p><p><img src="/2020/02/21/shujufenxi/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8Pyechars/image-20211025104521598.png" alt="image-20211025104521598"></p><p>图7.22　热力图</p><h2 id="7-3-8-水球图——Liquid模块"><a href="#7-3-8-水球图——Liquid模块" class="headerlink" title="7.3.8　水球图——Liquid模块"></a>7.3.8　水球图——Liquid模块</h2><p>【示例17】　绘制水球图。（示例位置：资源包\MR\Code\07\17）<br>绘制水球图主要使用Liquid模块的add()方法实现。下面绘制一个简单的涟漪特效散点图，程序代码如下：<br>运行程序，在程序所在路径下生成myliquid.html的HTML文件，打开该文件，效果如图7.23所示。</p><p><img src="/2020/02/21/shujufenxi/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8Pyechars/image-20211025105150709.png" alt="image-20211025105150709"></p><p>​                                                                                                            图7.23　水球图</p><h2 id="7-3-9-日历图——Calendar模块"><a href="#7-3-9-日历图——Calendar模块" class="headerlink" title="7.3.9　日历图——Calendar模块"></a>7.3.9　日历图——Calendar模块</h2><p>【示例18】　绘制加班日历图。（示例位置：资源包\MR\Code\07\18）<br>绘制日历图主要使用Calendar模块的add()方法实现。下面绘制一个简单日历图，通过该日历图分析6月份加班情况，程序代码如下：</p><p><img src="/2020/02/21/shujufenxi/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8Pyechars/image-20211025105216401.png" alt="image-20211025105216401"></p><p>运行程序，在程序所在路径下生成calendar.html的HTML文件，打开该文件，效果如图7.24所示。</p><p><img src="/2020/02/21/shujufenxi/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8Pyechars/image-20211025105257503.png" alt="image-20211025105257503"></p><p>​                                                                                                   图7.24　日历图</p><h1 id="7-4-综合应用"><a href="#7-4-综合应用" class="headerlink" title="7.4　综合应用"></a>7.4　综合应用</h1><h2 id="7-4-1-案例1：南丁格尔玫瑰图"><a href="#7-4-1-案例1：南丁格尔玫瑰图" class="headerlink" title="7.4.1　案例1：南丁格尔玫瑰图"></a>7.4.1　案例1：南丁格尔玫瑰图</h2><p>案例位置：资源包\MR\Code\07\example\01<br>下面使用Pie模块绘制南丁格尔玫瑰图，效果如图7.25所示。<br>南丁格尔玫瑰图主要通过绘制饼形图实现，其中一个关键点是设置rosetype参数为area，具体实现步骤如下所示。<br>（1）导入相关模块，代码如下：</p><p>01  import pandas as pd<br>02  from pyecharts.charts import Pie</p><p>03  from pyecharts import options as opts</p><p><img src="/2020/02/21/shujufenxi/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8Pyechars/image-20211025105352924.png" alt="image-20211025105352924"></p><p>​                                                                                图7.25　南丁格尔玫瑰图<br>（2）导入Excel文件，并对数据进行处理，代码如下：</p><p><img src="/2020/02/21/shujufenxi/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8Pyechars/image-20211025105510687.png" alt="image-20211025105510687"></p><p>（3）绘制南丁格尔玫瑰图，代码如下：</p><p><img src="/2020/02/21/shujufenxi/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8Pyechars/image-20211025105530815.png" alt="image-20211025105530815"></p><h2 id="7-4-2-案例2：双y轴可视化数据分析图表的实现（柱形图-折线图）"><a href="#7-4-2-案例2：双y轴可视化数据分析图表的实现（柱形图-折线图）" class="headerlink" title="7.4.2　案例2：双y轴可视化数据分析图表的实现（柱形图+折线图）"></a>7.4.2　案例2：双y轴可视化数据分析图表的实现（柱形图+折线图）</h2><p>案例位置：资源包\MR\Code\07\example\02</p><p>双y轴顾名思义就是两个y轴，下面实现柱形图+折线图双y轴图表的绘制，其中柱形图y轴表示月销量，折线图y轴表示3个平台的月平均销量，效果如图7.26所示。</p><p><img src="/2020/02/21/shujufenxi/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8Pyechars/image-20211025105606632.png" alt="image-20211025105606632"></p><p>​                                                              图7.26　双y轴可视化数据分析图表<br>实现双y轴可视化数据分析图表的两个关键点：一是使用Bar模块的extend_axis()方法扩展y轴；二是对add_yaxis()方法的yaxis_index参数进行设置，该参数用于指定y轴的索引值，从0开始。双y轴索引值分别为0和1。具体实现步骤如下所示。<br>（1）导入相关模块，代码如下：</p><p>01  import pyecharts.options as opts<br>02  from pyecharts.charts import Bar, Line<br>03  import pandas as pd<br>04  import numpy<br>（2）导入Excel文件，代码如下：</p><p><img src="/2020/02/21/shujufenxi/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8Pyechars/image-20211025105630197.png" alt="image-20211025105630197"></p><p>（3）创建颜色列表，代码如下：</p><p>colors = [“#5793f3”, “#FFD700”, “#675bba”]<br>（4）求平均值并保留整数位，代码如下：</p><p>y_average=list(((df[‘京东’]+df[‘天猫’]+df[‘自营’])/3).apply(numpy.round))</p><p>（5）绘制柱形图，代码如下：</p><p><img src="/2020/02/21/shujufenxi/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8Pyechars/image-20211025105718321.png" alt="image-20211025105718321"></p><p>（6）绘制折线图，代码如下：</p><p><img src="/2020/02/21/shujufenxi/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8Pyechars/image-20211025105735016.png" alt="image-20211025105735016"></p><h2 id="7-4-3-案例3：饼形图与环形图组合图表的实现"><a href="#7-4-3-案例3：饼形图与环形图组合图表的实现" class="headerlink" title="7.4.3　案例3：饼形图与环形图组合图表的实现"></a>7.4.3　案例3：饼形图与环形图组合图表的实现</h2><p>案例位置：资源包\MR\Code\07\example\03<br>饼形图与环形图组合，其中饼形图展示“北上广”三大主要城市的销量情况，环形图展示其他省份的销量情况，效果如图7.27所示。</p><p><img src="/2020/02/21/shujufenxi/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8Pyechars/image-20211025105757566.png" alt="image-20211025105757566"></p><p>​                                                                              图7.27　饼形图与环形图组合图表<br>绘制饼形图与环形图组合图表的一个关键点是创建两个饼形图，并设置不同的半径（radius参数），具体实现步骤如下所示。<br>（1）导入相关模块，代码如下：</p><p>01  import pyecharts.options as opts</p><p>02  from pyecharts.charts import Pie<br>（2）为饼形图和环形图添加数据，代码如下：</p><p><img src="/2020/02/21/shujufenxi/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8Pyechars/image-20211025105830032.png" alt="image-20211025105830032"></p><p>（3）饼形图与环形图组合，代码如下：</p><p><img src="/2020/02/21/shujufenxi/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E5%88%86%E6%9E%90%E5%9B%BE%E8%A1%A8Pyechars/image-20211025105847941.png" alt="image-20211025105847941"></p><p>知识胶囊<br>下面介绍一下Pyecharts的文本标签配置项。　</p><p>字体基本样式：fontStyle、fontWeight、fontSize、fontFamily。　</p><p>文字颜色：color。　</p><p>文字描边：textBorderColor、textBorderWidth。　</p><p>文字阴影：textShadowColor、textShadowBlur、textShadowOffsetX、textShadowOffsetY。　</p><p>文本块或文本片段大小：lineHeight、width、height、padding。　</p><p>文本块或文本片段的对齐：align、verticalAlign。　</p><p>文本块或文本片段的边框、背景（颜色或图片）：backgroundColor、borderColor、borderWidth、borderRadius。　</p><p>文本块或文本片段的阴影：shadowColor、shadowBlur、shadowOffsetX、shadowOffsetY。　</p><p>文本块的位置和旋转：position、distance、rotate。</p><h1 id="7-5-小结"><a href="#7-5-小结" class="headerlink" title="7.5　小结"></a>7.5　小结</h1><p>相比Matplotlib和Searnborn，Pyecharts绘制出的图表更加令人惊叹，其动感效果更是Matplotlib和Searnborn无法比拟的，但也存在不足之处，其生成的图表为网页格式，不能够随时查看，需要打开文件进行浏览。Pyecharts更适合Web程序。<br>Pyecharts还有很多功能，由于篇幅有限不能一一进行介绍，希望读者在学习过程中能够举一反三，绘制出更多精彩的数据分析图表。</p>]]></content>
    
    
    <categories>
      
      <category>数据分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>pyechars</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Pandas统计分析</title>
    <link href="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/"/>
    <url>/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="第二章-Pandas统计分析"><a href="#第二章-Pandas统计分析" class="headerlink" title="第二章 Pandas统计分析"></a>第二章 Pandas统计分析</h1><p>Pandas是Python的核心数据分析支持库，它提供了大量能使我们快速便捷地处理数据的函数和方法。<br>由于Pandas相关知识非常多，本书将Pandas分为上、下两章进行讲解。本章开始Pandas入门内容，从安装开始，逐步介绍Pandas相关的入门知识，包括两个主要的数据结构，即Series对象和DataFrame对象，也包括如何导入外部数据、数据抽取，以及数据的增加、修改和删除，还包括数据清洗、索引设置、数据排序与排名等相关基础知识，这些都是在为后期数据处理和数据分析打下良好的基础。</p><h2 id="一-Pandas概述"><a href="#一-Pandas概述" class="headerlink" title="一. Pandas概述"></a>一. Pandas概述</h2><p>Pandas是数据分析三大剑客之一，是Python的核心数据分析库，它提供了快速、灵活、明确的数据结构，能够简单、直观、快速地处理各种类型的数据，具体介绍如下所示。</p><p>Pandas能够处理以下类型的数据。　</p><p>1.与SQL或Excel表类似的数据。　</p><p>2.有序和无序（非固定频率）的时间序列数据。　</p><p>3.带行、列标签的矩阵数据。</p><p>4.任意其他形式的观测、统计数据集。</p><p>Pandas提供的两个主要数据结构Series（一维数组结构）与DataFrame（二维数组结构），可以处理金融、统计、社会科学、工程等领域里的大多数典型案例，并且Pandas是基于NumPy开发的，可以与其他第三方科学计算库完美集成。<br>Pandas的功能很多，它的优势如下。　</p><p>list1=[0,1,2,3,4,5]</p><p>list2=[[0,1,2,3,4,5],[0,1,2,3,4,5]]</p><p>1.处理浮点与非浮点数据里的缺失数据，表示为<strong>NaN</strong>。　</p><p>2.大小可变，例如插入或删除DataFrame等多维对象的列。</p><p>3.自动、显式数据对齐，显式地将对象与一组标签对齐，也可以忽略标签，在Series、DataFrame计算时自动与数据对齐。　</p><p>4.强大、灵活的分组统计（groupby）功能，即数据聚合、数据转换。　</p><p>5.把Python和NumPy数据结构里不规则、不同索引的数据轻松地转换为DataFrame对象。　</p><p>6.智能标签，对大型数据集进行切片、花式索引、子集分解等操作。　</p><p>7.直观地合并（merge）、连接（join）数据集。　灵活地重塑（reshape）、透视（pivot）数据集。</p><p>8.成熟的导入、导出工具，导入文本文件（CSV等支持分隔符的文件）、Excel文件、数据库等来源的数据，导出Excel文件、文本文件等，利用超快的HDF5格式保存或加载数据。　</p><p>9.时间序列：支持日期范围生成、频率转换、移动窗口统计、移动窗口线性回归、日期位移等时间序列功能。</p><p>例1.读取excel数据</p><p>01 import pandas as pd               #导入pandas 模块<br>02 df=pd.read_excel(‘data.xlsx’)      #读取Excel 文件<br>03 df1=df.head()                      #显示前5 条数据</p><h2 id="二-seires-对象"><a href="#二-seires-对象" class="headerlink" title="二. seires 对象"></a>二. seires 对象</h2><p>Pandas是Python数据分析重要的库，而Series和DataFrame是Pandas库中两个重要的对象，也是Pandas中两个重要的数据结构，如图所示。</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018035610974.png" alt="image-20211018035610974"><br>本节将主要介绍Series对象。</p><h3 id="2-1-图解Series对象"><a href="#2-1-图解Series对象" class="headerlink" title="2.1　图解Series对象"></a>2.1　图解Series对象</h3><p>Series是Python的Pandas库中的一种数据结构，它类似一维数组，由一组数据以及与这组数据相关的标签（即索引)组成，或者仅有一组数据没有索引也可以创建一个简单的Series。Series可以存储整数、浮点数、字符串、Python对象等多种类型的数据。<br>例如，在成绩表（见图3)中包含了Series对象和DataFrame对象，其中“语文”“数学”“英语”3列中的每一列均是一个Series对象，而“语文”“数学”“英语”3列组成了一个DataFrame对象，如图4所示。</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018035821898.png" alt="image-20211018035821898"></p><p>​                                                                                           图3</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018035900680.png" alt="image-20211018035900680"></p><p>​                                                                                         图4</p><h3 id="2-2-创建一个series对象"><a href="#2-2-创建一个series对象" class="headerlink" title="2.2 创建一个series对象"></a>2.2 创建一个series对象</h3><p>创建Series对象主要使用Pandas的Series()方法，语法如下：</p><p>s=pd.Series(data,index=index)</p><p>参数说明：　</p><p>data：表示数据，支持Python字典、多维数组、标量值（即只有大小，没有方向的量。也就是说，只是一个数值，如s=pd.Series(5)）。　index：表示行标签（索引）。　</p><p>返回值：Series对象。</p><p>说明<br>当data参数是多维数组时，index长度必须与data长度一致。如果没有指定index参数，则自动创建数值型索引（从0～data数据长度-1）。</p><p>【示例02】　在成绩表添加一列“物理”成绩。（示例位置：资源包\MR\Code\03\02）创建一个Series对象，在成绩表中添加一列“物理”成绩。程序代码如下：</p><p>01 import pandas as pd<br>02 s1=pd.Series([88,60,75])<br>03 print(s1)</p><p>上述举例，如果通过Pandas模块引入Series对象，那么就可以直接在程序中使用Series对象了。主要代码如下：</p><p>01 from pandas import Series<br>02 s1=Series([88,60,75])</p><h3 id="2-3-手动设置series索引"><a href="#2-3-手动设置series索引" class="headerlink" title="2.3 手动设置series索引"></a>2.3 手动设置series索引</h3><p>创建Series对象时会自动生成整数索引，默认值从0开始至数据长度减1。例如，3.2.1节举例中使用的就是默认索引，如0、1、2。除了使用默认索引，还可以通过index参数手动设置索引。</p><p>【示例03】　手动设置索引。（示例位置：资源包\MR\Code\03\03）<br>下面手动设置索引，将3.2.1节添加的“物理”成绩的索引设置为1、2、3，也可以是“明日同学”“高同学”“七月流火”。</p><p>程序代码如下：</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018040816095.png" alt="image-20211018040816095"></p><p>运行程序，控制台输出结果如下：</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018040836315.png" alt="image-20211018040836315"></p><p>说明<br>上述结果中输出的dtype是DataFrame数据的数据类型，int为整型，后面的数字表示位数。</p><h3 id="2-4-series-位置索引"><a href="#2-4-series-位置索引" class="headerlink" title="2.4 series 位置索引"></a>2.4 series 位置索引</h3><h4 id="2-4-1-series位置索引"><a href="#2-4-1-series位置索引" class="headerlink" title="2.4.1 series位置索引"></a>2.4.1 series位置索引</h4><p>位置索引是从0开始数，[0]是Series第一个数，[1]是Series第二个数，以此类推。</p><p>【示例04】　通过位置索引获取学生物理成绩。（示例位置：资源包\MR\Code\03\04）获取第一个学生的物理成绩。程序代码如下：</p><p>01 import pandas as pd<br>02 s1=pd.Series([88,60,75])<br>03 print(s1[0])<br>运行程序，控制台输出结果如下：</p><p>88</p><p><strong>注意</strong><br><strong>Series不能使用[-1]定位索引。</strong></p><h4 id="2-4-2-series-标签索引"><a href="#2-4-2-series-标签索引" class="headerlink" title="2.4.2 series 标签索引"></a>2.4.2 series 标签索引</h4><p>Series标签索引与位置索引方法类似，用[ ]表示，里面是索引名称，注意index的数据类型是字符串，如果需要获取多个标签索引值，用[[ ]]表示（相当于[ ]中包含一个列表）。</p><p>【示例05】　通过标签索引获取学生物理成绩。（示例位置：资源包\MR\Code\03\05）通过标签索引“明日同学”和“七月流火”获取物理成绩，程序代码如下：</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018041305145.png" alt="image-20211018041305145"></p><h4 id="2-4-3-series-切片索引"><a href="#2-4-3-series-切片索引" class="headerlink" title="2.4.3 series 切片索引"></a>2.4.3 series 切片索引</h4><p>用标签索引做切片，包头包尾（即包含索引开始位置的数据，也包含索引结束位置的数据）。</p><p>【示例06】　通过切片获取数据。（示例位置：资源包\MR\Code\03\06）通过标签切片索引“明日同学”至“七月流火”获取数据。程序代码如下：</p><p>print(s1[‘明日同学’:’七月流火’])     #通过切片获取索引值</p><p>用位置索引做切片，和list列表用法一样，包头不包尾（即包含索引开始位置的数据，不包含索引结束位置的数据）。</p><p>【示例07】　通过位置切片获取数据。（示例位置：资源包\MR\Code\03\07）通过位置切片1～4获取数据，程序代码如下：</p><p>01  s2=pd.Series([88,60,75,34,68])<br>02  print(s2[1:4])<br>运行程序，控制台输出结果如下：</p><p>1  60<br>2  75<br>3  34</p><h4 id="2-4-5-获取series索引和值"><a href="#2-4-5-获取series索引和值" class="headerlink" title="2.4.5 获取series索引和值"></a>2.4.5 获取series索引和值</h4><p>获取Series索引和值主要使用Series的index和values方法。</p><p>【示例08】　获取物理成绩的索引和值。（示例位置：资源包\MR\Code\03\08）下面使用Series的index和values方法获取物理成绩的索引和值，程序代码如下：</p><p>01 import pandas as pd<br>02 s1=pd.Series([88,60,75])<br>03 print(s1.index)<br>04 print(s1.values)<br>运行程序，控制台输出结果如下：</p><p>RangeIndex(start=0, stop=3, step=1)<br>[88 60 75]</p><h2 id="三-DataFrame对象"><a href="#三-DataFrame对象" class="headerlink" title="三. DataFrame对象"></a>三. DataFrame对象</h2><p>DataFrame是Pandas库中的一种数据结构，它是由多种类型的列组成的二维表数据结构，类似于Excel、SQL或Series对象构成的字典。DataFrame是最常用的Pandas对象，它与Series对象一样支持多种类型的数据。</p><h3 id="3-1-图解DataFrame对象"><a href="#3-1-图解DataFrame对象" class="headerlink" title="3.1　图解DataFrame对象"></a>3.1　图解DataFrame对象</h3><p>DataFrame是一个二维表数据结构，由行、列数据组成的表格。DataFrame既有行索引也有列索引，它可以看作是由Series对象组成的字典，不过这些Series对象共用一个索引，如图3.11所示。</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018042136168.png" alt="image-20211018042136168"></p><p>图3.11　DataFrame结构<br>处理DataFrame表格数据时，用index表示行或用columns表示列更直观。用这种方式迭代DataFrame的列，代码更易读懂。</p><p>【示例09】　遍历DataFrame数据。（示例位置：资源包\MR\Code\03\09）遍历DataFrame数据，输出成绩表的每一列数据，程序代码如下：</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018042332305.png" alt="image-20211018042332305"></p><p>运行程序，控制台输出结果如下：</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018042319399.png" alt="image-20211018042319399"></p><p>从运行结果得知，上述代码返回的其实是Series，如图3.12所示。Pandas之所以提供多种数据结构，其目的就是为了代码易读、操作更加方便。</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018042510540.png" alt="image-20211018042510540"></p><h3 id="3-2-创建一个DataFrame对象"><a href="#3-2-创建一个DataFrame对象" class="headerlink" title="3.2 创建一个DataFrame对象"></a>3.2 创建一个DataFrame对象</h3><p>创建DataFrame主要使用Pandas的DataFrame()方法，语法如下：</p><p>pandas.DataFrame(data,index,columns,dtype,copy)<br>参数说明：　</p><p>data：表示数据，可以是ndarray数组、Series对象、列表、字典等。　</p><p>index：表示行标签（索引）。</p><p>columns：列标签（索引）。　</p><p>dtype：每一列数据的数据类型，其与Python数据类型有所不同，如object数据类型对应的是Python的字符型。</p><p>表3.1为Pandas数据类型与Python数据类型的对应表。</p><p>category作业，查询datetime64,timedela[ns],category</p><p>Timedelta在pandas中是一个表示两个datetime值之间的差(如日,秒和微妙)的类型,2个Datetime数据运算相减得出的结果就是一个Timedelta数据类型</p><p>​                                                                                          表3.1　数据类型对应表　</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018042916094.png" alt="image-20211018042916094"></p><p>copy：用于复制数据。　</p><p>返回值：DataFrame。<br>下面通过两种方法来创建DataFrame，即通过二维数组创建和通过字典创建。</p><p>1．通过二维数组创建DataFrame【示例10】　通过二维数组创建成绩表。（示例位置：资源包\MR\Code\03\10）<br>通过二维数组创建成绩表，包括语文、数学和英语，程序代码如下：</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018043105059.png" alt="image-20211018043105059"></p><p>运行程序，控制台输出结果如下：</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018043117683.png" alt="image-20211018043117683"></p><p>2．通过字典创建DataFrame<br>通过字典创建DataFrame，需要注意：字典中的value值只能是一维数组或单个的简单数据类型，如果是数组，要求所有数组长度一致；如果是单个数据，则每行都添加相同数据。</p><p>【示例11】　通过字典创建成绩表。（示例位置：资源包\MR\Code\03\11）通过字典创建成绩表，包括语文、数学、英语和班级，程序代码如下：</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018043238790.png" alt="image-20211018043238790"></p><p>运行程序，控制台输出结果如下：</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018043309599.png" alt="image-20211018043309599"></p><p>上述代码中，“班级”的value值是一个单个数据，所以每一行都添加了相同的数据“高一7班”。</p><h3 id="3-3-DataFrame重要属性和函数"><a href="#3-3-DataFrame重要属性和函数" class="headerlink" title="3.3 DataFrame重要属性和函数"></a>3.3 DataFrame重要属性和函数</h3><p>DataFrame是Pandas一个重要的对象，它的属性和函数很多，下面先简单了解DataFrame的几个重要属性和函数。重要属性介绍如表3.2所示，重要函数介绍如表3.3所示。</p><p>​                                                                                               表3.2　重要属性</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018043520943.png" alt="image-20211018043520943"></p><p>​                                                                                                  表3.3　重要函数</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018043534263.png" alt="image-20211018043534263"></p><h3 id="3-4-导入外部数据"><a href="#3-4-导入外部数据" class="headerlink" title="3.4 导入外部数据"></a>3.4 导入外部数据</h3><p>数据分析首先就要有数据。那么，数据类型有多种，本节介绍如何导入不同类型的外部数据。</p><h4 id="3-4-1-导入-xls或-xlsx文件"><a href="#3-4-1-导入-xls或-xlsx文件" class="headerlink" title="3.4.1　导入.xls或.xlsx文件"></a>3.4.1　导入.xls或.xlsx文件</h4><p>导入.xls或.xlsx文件主要使用Pandas的read_excel()方法，语法如下：</p><p>pandas.read_excel(io,sheet_name=0,header=0,names=None,index_col=None,usecols=None,squeeze=False,<br>dtype=None,engine=None,converters=None,true_values=None,false_values=None,skiprows=None,nrow=None,<br>na_values=None,keep_default_na=True,verbose=False,parse_dates=False,date_parser=None,thousands=None,<br>comment=None,skipfooter=0,conver_float=True,mangle_dupe_cols=True,**kwds)<br>常用参数说明：　</p><p>io：字符串，.xls或.xlsx文件路径或类文件对象。　</p><p>sheet_name：None、字符串、整数、字符串列表或整数列表，默认值为0。字符串用于工作表名称，整数为索引表示工作表位置，字符串列表或整数列表用于请求多个工作表，为None时获取所有工作表。参数值如表3.4所示。</p><p>​                                                                                     表3.4　sheet_name参数值　</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018043941426.png" alt="image-20211018043941426"></p><p>header：指定作为列名的行，默认值为0，即取第一行的值为列名。数据为除列名以外的数据；若数据不包含列名，则设置header=None。　</p><p>names：默认值为None，要使用的列名列表。　</p><p>index_col：指定列为索引列，默认值为None，索引0是DataFrame的行标签。</p><p>usecols：int、list列表或字符串，默认值为None。　如果为None，则解析所有列。　如果为int，则解析最后一列。　如果为list列表，则解析列号列表的列。　如果为字符串，则表示以逗号分隔的Excel列字母和列范围列表（例如“A:E”或“A,C,E:F”）。范围包括双方。　</p><p>squeeze：布尔值，默认值为False，如果解析的数据只包含一列，则返回一个Series。　</p><p>dtype：列的数据类型名称或字典，默认值为None。例如{‘a’:np.float64,’b’:np.int32}。　</p><p>skiprows：省略指定行数的数据，从第一行开始。　</p><p>skipfooter：省略指定行数的数据，从尾部数的行开始。</p><p>下面通过示例，详细介绍如何导入.xlsx文件。</p><h5 id="1．常规导入导入Excel文件。"><a href="#1．常规导入导入Excel文件。" class="headerlink" title="1．常规导入导入Excel文件。"></a>1．常规导入导入Excel文件。</h5><p>【示例12】　（示例位置：资源包\MR\Code\03\12）导入“1月.xlsx”Excel文件，程序代码如下：</p><p>01 import pandas as pd<br>02 df=pd.read_excel(‘1 月.xlsx’)<br>03 df1=df.head()          #输出前5 条数据<br>运行程序，输出前5条数据，结果如图3.13所示。<br>图3.13　1月淘宝销售数据（前5条数据）</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018044223025.png" alt="image-20211018044223025"></p><p>知识胶囊<br>导入外部数据，必然要涉及路径问题，下面来了解一下相对路径和绝对路径。　</p><p><strong>相对路径</strong>：相对路径就是以当前文件为基准进行一级级目录指向被引用的资源文件。以下是常用的表示当前目录和当前目录的父级目录的标识符。　../：表示当前文件所在目录的上一级目录。　./：表示当前文件所在的目录（可以省略）。　/：表示当前文件的根目录（域名映射或硬盘目录）。　如果使用系统默认文件路径\，那么，在Python中则需要在路径最前面加一个r，以避免路径里面的\被转义。　</p><p><strong>绝对路径</strong>：绝对路径是文件真正存在的路径，是指从硬盘的根目录（盘符）开始，进行一级级目录指向文件。</p><h5 id="2．导入指定的Sheet页"><a href="#2．导入指定的Sheet页" class="headerlink" title="2．导入指定的Sheet页"></a>2．导入指定的Sheet页</h5><p>一个Excel文件包含多个Sheet页，通过设置sheet_name参数就可以导入指定Sheet页的数据。</p><p>【示例13】　导入指定Sheet页的数据。（示例位置：资源包\MR\Code\03\13）一个Excel文件包含多家店铺的销售数据，导入其中一家店铺（莫寒）的销售数据，如图3.14所示。<br>图3.14　原始数据</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018044701218.png" alt="image-20211018044701218"></p><p>程序代码如下：</p><p>01 import pandas as pd<br>02 df=pd.read_excel(‘1 月.xlsx’,sheet_name=’莫寒’)<br>03 df1=df.head()          #输出前5条数据<br>运行程序，输出前5条数据，结果如图3.15所示。<br>除了指定Sheet页的名字，还可以指定Sheet页的顺序，从0开始。例如，sheet_name=0表示导入第一个Sheet页的数据，sheet_name=1表示导入第二个Sheet页的数据，以此类推。<br>如果不指定sheet_name参数，则默认导入第一个Sheet页的数据。</p><h5 id="3．通过行、列索引导入指定行、列数据"><a href="#3．通过行、列索引导入指定行、列数据" class="headerlink" title="3．通过行、列索引导入指定行、列数据"></a>3．通过行、列索引导入指定行、列数据</h5><p>DataFrame是二维数据结构，因此它既有行索引又有列索引。当导入Excel数据时，行索引会自动生成，如0、1、2；而列索引则默认将第0行作为列索引（如A,B,…,J）。DataFrame行、列索引的示意图如图3.16所示。</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018044837800.png" alt="image-20211018044837800"></p><p>​                                                  </p><p>​                                                                            图3.15　导入指定的Sheet页（前5条数据） </p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018044932996.png" alt="image-20211018044932996"></p><p>​                                                                                图3.16　DataFrame行、列索引示意图</p><p>【示例14】　指定行索引导入Excel数据。（示例位置：资源包\MR\Code\03\14）<br>如果通过指定行索引导入Excel数据，则需要设置index_col参数。下面将“买家会员名”作为行索引（位于第0列），导入Excel数据，程序代码如下：</p><p>01 import pandas as pd<br>02 df1=pd.read_excel(‘1 月.xlsx’,index_col=0)     #“买家会员名”为行索引<br>03 df1=df1.head()                                 #输出前5条数据<br>运行程序，输出结果如图3.17所示。</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018045103681.png" alt="image-20211018045103681"></p><p>图3.17　通过指定行索引导入Excel数据<br>如果通过指定列索引导入Excel数据，则需要设置header参数，主要代码如下：</p><p>df2=pd.read_excel(‘1月.xlsx’,header=1)        #设置第1行为列索引</p><p>运行程序，输出结果如图3.18所示。<br>如果将数字作为列索引，可以设置header参数为None，主要代码如下：</p><p>df3=pd.read_excel(‘1月.xlsx’,header=None)    #列索引为数字</p><p>运行程序，输出结果如图3.19所示。</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018045218250.png" alt="image-20211018045218250"></p><p>图3.18　通过指定列索引导入Excel数据</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018045231796.png" alt="image-20211018045231796"></p><p>图3.19　指定列索引<br>那么，为什么要指定索引呢？因为通过索引可以快速地检索数据，例如df3[0]，就可以快速检索到“买家会员名”这一列数据。</p><h5 id="4-导入指定列数据"><a href="#4-导入指定列数据" class="headerlink" title="4.导入指定列数据"></a>4.导入指定列数据</h5><p>一个Excel往往包含多列数据，如果只需要其中的几列，可以通过usecols参数指定需要的列，从0开始（表示第1列，以此类推）。</p><p>【示例15】　导入第1列数据。（示例位置：资源包\MR\Code\03\15）下面导入第1列数据（索引为0），程序代码如下：</p><p>01 import pandas as pd<br>02 df1=pd.read_excel(‘1 月.xlsx’,usecols=[0])       #导入第1列<br>03 df1.head()<br>运行程序，输出结果如图3.20所示。<br>如果导入多列，可以在列表中指定多个值。例如，导入第1列和第4列，主要代码如下：</p><p>df2=pd.read_excel(‘1月.xlsx’,usecols=[0,3])<br>也可以指定列名称，主要代码如下：</p><p>df3=pd.read_excel(‘1月.xlsx’,usecols=[‘买家会员名’,’宝贝标题’])<br>运行程序，输出结果如图3.21所示。</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018045614397.png" alt="image-20211018045614397"></p><p>​                                                                                               图3.20　导入第1列</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018045541729.png" alt="image-20211018045541729"></p><p>​                                                                                     图3.21　导入第1列和第4列数据</p><h4 id="3-4-2-导入-csv文件"><a href="#3-4-2-导入-csv文件" class="headerlink" title="3.4.2　导入.csv文件"></a>3.4.2　导入.csv文件</h4><p>导入.csv文件主要使用Pandas的read_csv()方法，语法如下：</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018045855117.png" alt="image-20211018045855117">常用参数说明：　</p><p>filepath_or_buffer：字符串，文件路径，也可以是URL链接。　</p><p>sep、delimiter：字符串，分隔符。</p><p>header：指定作为列名的行，默认值为0，即取第1行的值为列名。数据为除列名以外的数据；若数据不包含列名，则设置header=None。　</p><p>names：默认值为None，要使用的列名列表。　</p><p>index_col：指定列为索引列，默认值为None，索引0是DataFrame的行标签。　</p><p>usecols：int、list列表或字符串，默认值为None。　如果为None，则解析所有列。　如果为int，则解析最后一列。　如果为list列表，则解析列号列表的列。　如果为字符串，则表示以逗号分隔的Excel列字母和列范围列表（例如“A:E”或“A,C,E:F”）。范围包括双方。　dtype：列的数据类型名称或字典，默认值为None。例如{‘a’:np.float64,’b’:np.int32}。　</p><p>parse_dates：布尔类型值、int类型值的列表、列表或字典，默认值为False。可以通过parse_dates参数直接将某列转换成datetime64日期类型。例如，df1=pd.read_csv(‘1月.csv’, parse_dates=[‘订单付款时间’])。　</p><p>​        parse_dates为True时，尝试解析索引。　</p><p>​        parse_dates为int类型值组成的列表时，如[1,2,3]，则解析1、2、3列的值作为独立的日期列。　</p><p>​        parse_date为列表组成的列表，如[[1,3]]，则将1、3列合并，作为一个日期列使用。　</p><p>​        parse_date为字典时，如{‘总计’：[1, 3]}，则将1、3列合并，合并后的列名为“总计”。　</p><p>encoding：字符串，默认值为None，文件的编码格式。Python常用的编码格式是UTF-8。　返回值：返回一个DataFrame。</p><p>【示例16】　导入.csv文件。（示例位置：资源包\MR\Code\03\16）导入.csv文件，程序代码如下：</p><p>01 import pandas as pd<br>02 df1=pd.read_csv(‘1月.csv’<strong>,encoding=</strong>‘gbk’)        #导入.csv文件，并指定编码格式<br>03 df1=df1.head()                                   #输出前5条数据<br>运行程序，输出结果如图3.22所示。</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018050346464.png" alt="image-20211018050346464">                                                  </p><p>​                                                                                            图3.22　导入.csv文件</p><p>注意<br>上述代码中指定了编码格式，即encoding=’gbk’。Python常用的编码格式是UTF-8和gbk，默认编码格式为UTF-8。导入.csv文件时，需要通过encoding参数指定编码格式。当将Excel文件另存为.csv文件时，默认编码格式为gbk，此时当编写代码导入.csv文件时，就需要设置编码格式为gbk，与源文件编码格式保持一致；否则会提示错误。</p><h4 id="3-4-3-导入-txt文本文件"><a href="#3-4-3-导入-txt文本文件" class="headerlink" title="3.4.3　导入.txt文本文件"></a>3.4.3　导入.txt文本文件</h4><p>导入.txt文件同样使用Pandas的read_csv()方法，不同的是需要指定sep参数（如制表符\t）。read_csv()方法读取.txt文件返回一个DataFrame，像表格一样的二维数据结构，如图3.23所示。</p><p>【示例17】　导入.txt文件。（示例位置：资源包\MR\Code\03\17）<br>下面使用read_csv()方法导入1月.txt文件，主要代码如下：</p><p>01 import pandas as pd<br>02 df1=pd.read_csv(‘1月.txt’,sep=’\t’,encoding=’gbk’)<br>03 print(df1.head())<br>运行程序，输出结果如图3.24所示。</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018050613488-16345047782181.png" alt="image-20211018050613488"></p><p>​                                                                                                        图3.23　.txt文件形式</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018050642828.png" alt="image-20211018050642828"></p><p>​                                                                                                         图3.24　导入.txt文本</p><h4 id="3-4-4-导入HTML网页"><a href="#3-4-4-导入HTML网页" class="headerlink" title="3.4.4　导入HTML网页"></a>3.4.4　导入HTML网页</h4><p>导入HTML网页数据主要使用Pandas的read_html()方法，该方法用于导入带有table标签的网页表格数据，语法如下：</p><p>pandas.read_html(io,match=’.+’,flavor=None,header=None,index_col=None,skiprows=None,attrs=None,parse_<br>dates=False,thousands=’,’,encoding=None,decimal=’.’,converters=None,na_values=None,keep_default_na=True,<br>displayed_only=True)<br>常用参数说明：　</p><p>io：字符串，文件路径，也可以是URL链接。网址不接受https，可以尝试去掉https中的s后爬取，如<a href="http://www.mingribook.com./">http://www.mingribook.com。</a></p><p>match：正则表达式，返回与正则表达式匹配的表格。　</p><p>flavor：解析器默认为lxml。　</p><p>header：指定列标题所在的行，列表list为多重索引。　</p><p>index_col：指定行标题对应的列，列表list为多重索引。　</p><p>encoding：字符串，默认为None，文件的编码格式。　</p><p>返回值：返回一个DataFrame。<br>使用read_html()方法前，首先要确定网页表格是否为table类型。例如，NBA球员薪资网页（<a href="http://www.espn.com/nba/salaries%EF%BC%89%EF%BC%8C%E5%8F%B3%E5%87%BB%E8%AF%A5%E7%BD%91%E9%A1%B5%E4%B8%AD%E7%9A%84%E8%A1%A8%E6%A0%BC%EF%BC%8C%E5%9C%A8%E5%BC%B9%E5%87%BA%E7%9A%84%E5%BF%AB%E6%8D%B7%E8%8F%9C%E5%8D%95%E4%B8%AD%E9%80%89%E6%8B%A9%E2%80%9C%E6%A3%80%E6%9F%A5%E5%85%83%E7%B4%A0%E2%80%9D%E5%91%BD%E4%BB%A4%EF%BC%8C%E6%9F%A5%E7%9C%8B%E4%BB%A3%E7%A0%81%E4%B8%AD%E6%98%AF%E5%90%A6%E5%90%AB%E6%9C%89%E8%A1%A8%E6%A0%BC%E6%A0%87%E7%AD%BE">http://www.espn.com/nba/salaries），右击该网页中的表格，在弹出的快捷菜单中选择“检查元素”命令，查看代码中是否含有表格标签</a><table>…</table>的字样，如图3.25所示。确定后才可以使用read_html()方法。</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018051003748.png" alt="image-20211018051003748"></p><p>​                                                                            图3.25　<table>…</table>表格标签</p><p>【示例18】　导入NBA球员薪资数据。（示例位置：资源包\MR\Code\03\18）<br>下面使用read_html()方法导入NBA球员薪资数据，程序代码如下：</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018051015470.png" alt="image-20211018051015470"></p><p>运行程序，输出结果如图3.26所示。</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018051117577.png" alt="image-20211018051117577"></p><p>​                                                                                              图3.26　导入网页数据注意<br>运行程序，如果出现ImportError: lxml not found, please install it错误提示信息，则需要安装lxml模块。</p><h3 id="3-5-数据抽取"><a href="#3-5-数据抽取" class="headerlink" title="3.5　数据抽取"></a>3.5　数据抽取</h3><p>数据分析过程中，并不是所有的数据都是我们想要的，此时可以抽取部分数据，主要使用DataFrame对<strong>象的loc属性和iloc属性</strong>，示意图如图3.27所示。</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018051225461.png" alt="image-20211018051225461">          </p><pre><code class="hljs">                                                                                     图3.27　loc属性和iloc属性示意图</code></pre><p>对象的loc属性和iloc属性都可以抽取数据，区别如下。　</p><p>loc属性：以列名（columns）和行名（index）作为参数，当只有一个参数时，默认是行名，即抽取整行数据，包括所有列，如df.loc[‘A’]。　</p><p>iloc属性：以行和列位置索引（即0，1，2，…)作为参数，0表示第1行，1表示第2行，以此类推。当只有一个参数时，默认是行索引，即抽取整行数据，包括所有列。如抽取第1行数据，df.iloc[0]。</p><h4 id="3-5-1-抽取一行数据"><a href="#3-5-1-抽取一行数据" class="headerlink" title="3.5.1　抽取一行数据"></a>3.5.1　抽取一行数据</h4><p>抽取一行数据主要使用loc属性。【</p><p>示例19】　抽取一行考试成绩数据。（示例位置：资源包\MR\Code\03\19）抽取一行名为“明日”的考试成绩数据（包括所有列），程序代码如下：</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018051358694.png" alt="image-20211018051358694">运行程序，输出结果如图3.28所示。<br>使用iloc属性抽取第1行数据，指定行索引即可，如df.iloc[0]，输出结果同图3.28一样。</p><p>[1,2,2,3]</p><p>[[1,2,3,4]]</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018051441548.png" alt="image-20211018051441548"></p><p>​                                                                                                                图3.28　抽取一行数据</p><h4 id="3-5-2-抽取多行数据"><a href="#3-5-2-抽取多行数据" class="headerlink" title="3.5.2　抽取多行数据"></a>3.5.2　抽取多行数据</h4><p>1．抽取任意多行数据<br><strong>通过loc属性和iloc属性指定行名和行索引即可实现抽取任意多行数据。</strong></p><p>【示例20】　抽取多行考试成绩数据。（示例位置：资源包\MR\Code\03\20）抽取行名为“明日”和“高袁圆”（即第1行和第3行数据）的考试成绩数据，可以使用loc属性，也可以使用iloc属性，其输出结果都是一样的，主要代码如下：</p><p>01 df1=df.loc[[‘明日’,’高袁圆’]]<br>02 df1=df.iloc[[0,2]]<br>运行程序，输出结果如图3.29所示。</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018051606515.png" alt="image-20211018051606515"></p><p>​                                                                                                图3.29　抽取多行数据<br>2．抽取连续任意多行数据<br>在loc属性和iloc属性中合理地使用冒号（:），即可抽取连续任意多行数据。</p><p>【示例21】　抽取连续几个学生的考试成绩。（示例位置：资源包\MR\Code\03\21）抽取连续几个学生的考试成绩，主要代码如下：</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018051735968.png" alt="image-20211018051735968"></p><p>运行程序，控制台输出结果如图3.30所示。</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018051746750.png" alt="image-20211018051746750"></p><p>​                                                                                 图3.30　抽取连续任意多行数据</p><h4 id="3-5-3-抽取指定列数据"><a href="#3-5-3-抽取指定列数据" class="headerlink" title="3.5.3　抽取指定列数据"></a>3.5.3　抽取指定列数据</h4><p>抽取指定列数据，可以直接使用列名，也可以使用loc属性和iloc属性。<br>1．直接使用列名【示例22】　抽取“语文”和“数学”的考试成绩。（示例位置：资源包\MR\Code\03\22）<br>抽取列名为“语文”和“数学”的考试成绩数据，程序代码如下：</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018051846594.png" alt="image-20211018051846594"></p><p>运行程序，输出结果如图3.31所示。</p><p>2．使用loc属性和iloc属性<br>前面介绍loc属性和iloc属性均有两个参数：第一个参数代表行；第二个参数代表列。那么这里抽取指定列数据时，行参数不能省略。</p><p>【示例23】　抽取指定学科的考试成绩。（示例位置：资源包\MR\Code\03\23）<br>下面使用loc属性和iloc属性抽取指定列数据，主要代码如下：</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018052009426.png" alt="image-20211018052009426"></p><p>运行程序，控制台输出结果如图3.32所示。</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018052021825.png" alt="image-20211018052021825"></p><p>​                                                                                      图3.31　直接使用列名</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018052041459.png" alt="image-20211018052041459"></p><p>​                                                                                          图3.32　loc属性和iloc属性</p><h4 id="3-5-4-抽取指定行、列数据"><a href="#3-5-4-抽取指定行、列数据" class="headerlink" title="3.5.4　抽取指定行、列数据"></a>3.5.4　抽取指定行、列数据</h4><p>抽取指定行、列数据主要使用loc属性和iloc属性，这两个方法的两个参数都指定就可以实现指定行、列数据的抽取。</p><p>【示例24】　抽取指定学科和指定学生的考试成绩。（示例位置：资源包\MR\Code\03\24）使用loc属性和iloc属性抽取指定行、列数据，程序代码如下：</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018052200474.png" alt="image-20211018052200474"></p><p>运行程序，控制台输出结果如图3.33所示。</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018052214525.png" alt="image-20211018052214525"></p><pre><code class="hljs">                                                                               图3.33　抽取指定行、列数据</code></pre><p>在上述结果中，第一个输出结果是一个数，不是数据，是由于“df.loc[‘七月流火’,’英语’]”没有使用方括号[]，导致输出的数据不是DataFrame类型。</p><h4 id="3-5-5-按指定条件抽取数据"><a href="#3-5-5-按指定条件抽取数据" class="headerlink" title="3.5.5　按指定条件抽取数据"></a>3.5.5　按指定条件抽取数据</h4><p>DataFrame对象实现数据查询有以下3种方式。　取其中的一个元素.iat[x,x]。　基于位置的查询，如.iloc[]、iloc[2,1]。　基于行、列名称的查询，如.loc[x]。</p><p>【示例25】　抽取指定学科和指定分数的数据。（示例位置：资源包\MR\Code\03\25）抽取语文成绩大于105，数学成绩大于88的数据，程序代码如下：</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018052322850.png" alt="image-20211018052322850"></p><p>运行程序，输出结果如图3.34所示。</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018052523463.png" alt="image-20211018052523463">   </p><p>​                                                                                             图3.34　按指定条件抽取数据</p><h3 id="3-6-数据的增加、修改和删除"><a href="#3-6-数据的增加、修改和删除" class="headerlink" title="3.6　数据的增加、修改和删除"></a>3.6　数据的增加、修改和删除</h3><p>本节主要介绍如何操纵DataFrame对象中的各种数据。例如，数据的增加、修改和删除。</p><h4 id="3-6-1-增加数据"><a href="#3-6-1-增加数据" class="headerlink" title="3.6.1　增加数据"></a>3.6.1　增加数据</h4><p>DataFrame对象增加数据主要包括列数据增加和行数据增加。首先看一下原始数据，如图3.35所示。</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018052637063.png" alt="image-20211018052637063"></p><p>图3.35　原始数据</p><h5 id="1．按列增加数据"><a href="#1．按列增加数据" class="headerlink" title="1．按列增加数据"></a>1．按列增加数据</h5><p>按列增加数据，可以通过以下3种方式实现。<br>（1）直接为DataFrame对象赋值</p><p>【示例26】　增加一列“物理”成绩。（示例位置：资源包\MR\Code\03\26）<br>增加一列“物理”成绩，程序代码如下：</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018052702267.png" alt="image-20211018052702267"></p><p>运行程序，输出结果如图3.36所示。</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018052756371.png" alt="image-20211018052756371"></p><p>​                                                                                   图3.36　按列增加数据<br>（2）使用loc属性在DataFrame对象的最后增加一列</p><p>【示例27】　使用loc属性增加一列“物理”成绩。（示例位置：资源包\MR\Code\03\27）使用loc属性在DataFrame对象的最后增加一列。例如，增加“物理”一列，主要代码如下：</p><p>df.loc[:,’物理’] = [88,79,60,50]<br>在DataFrame对象最后增加一列“物理”，其值为等号右边数据。</p><p>（3）在指定位置插入一列<br>在指定位置插入一列，主要使用insert()方法。</p><p>【示例28】　在第1列后面插入“物理”成绩。（示例位置：资源包\MR\Code\03\28）<br>例如，在第1列后面插入“物理”，其值为wl的数值，主要代码如下：</p><p>01 wl =[88,79,60,50]<br>02 df.insert(1,’物理’,wl)<br>运行程序，输出结果如图3.37所示。</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018052920670.png" alt="image-20211018052920670"></p><p>​                                                                                                图3.37　使用insert()方法增加一列</p><h5 id="2．按行增加数据"><a href="#2．按行增加数据" class="headerlink" title="2．按行增加数据"></a>2．按行增加数据</h5><p>按行增加数据，可以通过以下两种方式实现。<br>（1）增加一行数据<br>增加一行数据主要使用loc属性实现。</p><p>【示例29】　在成绩表中增加一行数据。（示例位置：资源包\MR\Code\03\29）在成绩表中增加一行数据，即“钱多多”同学的成绩，主要代码如下：</p><p>df.loc[‘钱多多’] = [100,120,99]<br>（2）增加多行数据</p><p>增加多行数据主要使用<strong>字典</strong>结合**append()**方法实现。</p><p>【示例30】　在原有数据中增加几名同学的考试成绩。（示例位置：资源包\MR\Code\03\30）在原有数据中增加“钱多多”“童年”“无名”同学的考试成绩，主要代码如下：</p><p>01 df_insert=pd.DataFrame({‘语文’:[100,123,138],’数学’:[99,142,60],’英语’:[98,139,99]},index = [‘钱多多’,’童年’,’无名’])<br>02 df1 = df.append(df_insert)<br>运行程序，输出结果分别如图3.38和图3.39所示。</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018053145141.png" alt="image-20211018053145141"></p><p>​                                                                                       图3.38　增加一行数据</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018053204251.png" alt="image-20211018053204251"></p><p>​                                                                                        图3.39　增加多行数据</p><h4 id="3-6-2-修改数据"><a href="#3-6-2-修改数据" class="headerlink" title="3.6.2　修改数据"></a>3.6.2　修改数据</h4><p>修改数据包括行、列标题和数据的修改，首先看一下原始数据，如图3.40所示。</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018053230905.png" alt="image-20211018053230905"></p><p>​                                                                                               图3.40　原始数据</p><h5 id="1．修改列标题"><a href="#1．修改列标题" class="headerlink" title="1．修改列标题"></a>1．修改列标题</h5><p>修改列标题主要使用DataFrame对象的cloumns属性，直接赋值即可。</p><p>【示例31】　修改“数学”的列名。（示例位置：资源包\MR\Code\03\31）将“数学”修改为“数学（上）”，主要代码如下：</p><p>df.columns=[‘语文’,’数学（上）’,’英语’]</p><p>上述代码中，即使只修改“数学”为“数学（上）”，但是也<strong>要将所有列的标题全部写上；</strong>否则将报错。<br>下面再介绍一种方法，使用DataFrame对象的rename()方法修改列标题。</p><p>【示例32】　修改多个学科的列名。（示例位置：资源包\MR\Code\03\32）将“语文”修改为“语文（上）”、“数学”修改为“数学（上）”、“英语”修改为“英语（上）”，主要代码如下：</p><p>df.rename(columns = {‘语文’:’语文（上）’,’数学’:’数学（上）’,’英语’:’英语（上）’},inplace = True)</p><p>上述代码中，参数inplace为True，表示直接修改df；否则，不修改df，只返回修改后的数据。<br>运行程序，输出结果分别如图3.41和图3.42所示。</p><h5 id="2．修改行标题"><a href="#2．修改行标题" class="headerlink" title="2．修改行标题"></a>2．修改行标题</h5><p>修改行标题主要使用DataFrame对象的index属性，直接赋值即可。</p><p>【示例33】　将行标题统一修改为数字编号。（示例位置：资源包\MR\Code\03\33）<br>将行标题统一修改为数字编号，主要代码如下：</p><p>df.index=list(‘1234’)</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018053500036.png" alt="image-20211018053500036"></p><p>​                                                                                         图3.41　修改列标题1</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018053517247.png" alt="image-20211018053517247"></p><p>​                                                                                                 图3.42　修改列标题2</p><p>使用DataFrame对象的rename()方法也可以修改行标题。例如，将行标题统一修改为数字编号，主要代码如下：</p><p>df.rename({‘明日’:1,’七月流火’:2,’高袁圆’:3,’二月二’:4},axis=0,inplace = True)</p><h5 id="3．修改数据"><a href="#3．修改数据" class="headerlink" title="3．修改数据"></a>3．修改数据</h5><p>修改数据主要使用DataFrame对象的loc属性和iloc属性。</p><p>【示例34】　修改学生成绩数据。（示例位置：资源包\MR\Code\03\34）<br>（1）修改整行数据<br>例如，修改“明日”同学的各科成绩，主要代码如下：</p><p>df.loc[‘明日’]=[120,115,109]<br>如果各科成绩均加10分，可以直接在原有值上加10，主要代码如下：</p><p>df.loc[‘明日’]=df.loc[‘明日’]+10<br>（2）修改整列数据<br>例如，修改所有同学的“语文”成绩，主要代码如下：</p><p>df.loc[:,’语文’]=[115,108,112,118]<br>（3）修改某一数据</p><p>例如，修改“明日”同学的“语文”成绩，主要代码如下：</p><p>df.loc[‘明日’,’语文’]=115<br>（4）使用iloc属性修改数据<br>通过iloc属性指定行、列位置实现修改数据，主要代码如下：</p><p>01 df.iloc[0,0]=115                        #修改某一数据<br>02 df.iloc[:,0]=[115,108,112,118]          #修改整列数据<br>03 df.iloc[0,:]=[120,115,109]              #修改整行数据</p><h4 id="3-6-3-删除数据"><a href="#3-6-3-删除数据" class="headerlink" title="3.6.3　删除数据"></a>3.6.3　删除数据</h4><p>删除数据主要使用DataFrame对象的drop()方法。语法如下：</p><p>DataFrame.drop(labels=None, axis=0, index=None, columns=None, level=None, inplace=False, errors=’raise’)<br>参数说明：　</p><p>labels：表示行标签或列标签。　</p><p>axis：axis = 0，表示按行删除；</p><p>​            axis = 1，表示按列删除。默认值为0，即按行删除。　</p><p>index：删除行，默认值为None。　</p><p>columns：删除列，默认值为None。</p><p>level：针对有两级索引的数据。level = 0，表示按第1级索引删除整行；level = 1表示按第2级索引删除整行，默认值为None。　inplace：可选参数，对原数组做出修改并返回一个新数组。默认值为False，如果值为True，那么原数组直接就被替换。　</p><p>errors：参数值为ignore或raise，默认值为raise，如果值为ignore（忽略），则取消错误。</p><h5 id="1．删除行、列数据"><a href="#1．删除行、列数据" class="headerlink" title="1．删除行、列数据"></a>1．删除行、列数据</h5><p>【示例35】　删除学生成绩数据。（示例位置：资源包\MR\Code\03\35）<br>删除指定的学生成绩数据，主要代码如下：</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018054027938.png" alt="image-20211018054027938"></p><h5 id="2．删除特定条件的行"><a href="#2．删除特定条件的行" class="headerlink" title="2．删除特定条件的行"></a>2．删除特定条件的行</h5><p>删除满足特定条件的行，首先找到满足该条件的行索引，然后再使用drop()方法将其删除。</p><p>【示例36】　删除符合条件的学生成绩数据。（示例位置：资源包\MR\Code\03\36）<br>删除“数学”成绩中包含88的行、“语文”成绩中小于110的行，主要代码如下：</p><p>01 df.drop(index=df[df[‘数学’].<strong>isin</strong>([88])].index[0],inplace=True)      #删除“数学”成绩中包含88的行<br>02 df.drop(index=df[df[‘语文’]&lt;110].index[0],inplace=True)             #删除“语文”成绩中小于110的行说明<br>以上代码中的方法都可以实现删除指定的行、列数据，读者选择一种即可。</p><h3 id="3-7-数据清洗"><a href="#3-7-数据清洗" class="headerlink" title="3.7　数据清洗"></a>3.7　数据清洗</h3><h4 id="3-7-1-缺失值查看与处理"><a href="#3-7-1-缺失值查看与处理" class="headerlink" title="3.7.1　缺失值查看与处理"></a>3.7.1　缺失值查看与处理</h4><p>缺失值是指由于某种原因导致数据为空，这种情况一般有不处理、删除、填充／替换、插值（以均值／中位数／众数等填补）这4种处理方式。</p><h5 id="1．缺失值查看"><a href="#1．缺失值查看" class="headerlink" title="1．缺失值查看"></a>1．缺失值查看</h5><p>首先需要找到缺失值，主要使用DataFrame对象的info()方法。</p><p>【示例37】　查看数据概况。（示例位置：资源包\MR\Code\03\37）以淘宝销售数据为例，首先输出数据，然后使用info()方法查看数据，程序代码如下：</p><p>01 import pandas as pd<br>02 df=pd.read_excel(‘TB2018.xls’)<br>03 print(df)<br>04 print(df.info())</p><p>运行程序，控制台输出结果如图3.43所示。</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018054304916.png" alt="image-20211018054304916"></p><p>图3.43　缺失值查看<br>在Python中，缺失值一般用NaN表示，如图3.43所示。通过info()方法可看到“买家会员名”“买家实际支付金额”“宝贝标题”“订单付款时间”的非空数量是10，而“宝贝总数量”和“类别”的非空数量是8，那么说明这两项存在空值。</p><p>【示例38】　判断数据是否存在缺失值。（示例位置：资源包\MR\Code\03\38）<br>接下来，判断数据是否存在缺失值还可以使用isnull()方法和notnull()方法，主要代码如下：</p><p>01  print(df.isnull())<br>02  print(df.notnull())<br>运行程序，控制台输出结果如图3.44所示。</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018054406384.png" alt="image-20211018054406384"></p><p>​                                                                                              图3.44　判断缺失值<br>使用isnull()方法缺失值返回True，非缺失值返回False；而notnull()方法与isnull()方法正好相反，缺失值返回False，非缺失值返回True。<br>如果使用df[df.isnull() == False]，</p><p>则会将所有非缺失值的数据找出来，只针对Series对象。</p><h5 id="2．缺失值删除处理"><a href="#2．缺失值删除处理" class="headerlink" title="2．缺失值删除处理"></a>2．缺失值删除处理</h5><p>通过前面的判断得知数据缺失情况，下面将缺失值删除，主要使用dropna()方法，该方法用于删除含有缺失值的行，主要代码如下：</p><p>df1=df.dropna()<br>运行程序，输出结果如图3.45所示。说明<br>有些时候数据可能存在整行为空的情况，此时可以在dropna()方法中指定参数how=’all’，删除所有空行。</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018054531853.png" alt="image-20211018054531853"></p><p>​                                                                                   图3.45　缺失值删除处理1<br>从运行结果得知：dropna()方法将所有包含缺失值的数据全部删除了。那么，此时如果我们认为有些数据虽然存在缺失值，但是不影响数据分析，那么可以使用以下方法处理。例如，上述数据中只保留“宝贝总数量”不存在缺失值的数据，而类别是否缺失不关注，则可以使用notnull()方法判断，主要代码如下：</p><p>df2=df[df[‘宝贝总数量’].notnull()]<br>运行程序，输出结果如图3.46所示。</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018054627170.png" alt="image-20211018054627170"></p><p>图3.46　缺失值删除处理2</p><h5 id="3．缺失值填充处理"><a href="#3．缺失值填充处理" class="headerlink" title="3．缺失值填充处理"></a>3．缺失值填充处理</h5><p>对于缺失数据，如果比例高于30%可以选择放弃这个指标，做删除处理；低于30%尽量不要删除，而是选择将这部分数据填充，一般以0、均值、众数（大多数）填充。DataFrame对象中的fillna()函数可以实现填充缺失数据，pad/ffill表示用前一个非缺失值去填充该缺失值；backfill/bfill表示用下一个非缺失值填充该缺失值；None用于指定一个值去替换缺失值。</p><p>【示例39】　将NaN填充为0。（示例位置：资源包\MR\Code\03\39）对于用于计算的数值型数据如果为空，可以选择用0填充。例如，将“宝贝总数量”为空的数据填充为0，主要代码如下：</p><p>df[‘宝贝总数量’] = df[‘宝贝总数量’].fillna(0)<br>运行程序，输出结果如图3.47所示。</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018054749852.png" alt="image-20211018054749852"></p><p>​                                                                                                图3.47　缺失值填充处理</p><h4 id="3-7-2-重复值处理"><a href="#3-7-2-重复值处理" class="headerlink" title="3.7.2　重复值处理"></a>3.7.2　重复值处理</h4><p>对于数据中存在的重复数据，包括重复的行或者几行中某几列的值重复一般做删除处理，主要使用DataFrame对象的drop_duplicates()方法。</p><p>【示例40】　处理淘宝电商销售数据中的重复数据。（示例位置：资源包\MR\Code\03\40）下面以“1月.xlsx”淘宝销售数据为例，对其中的重复数据进行处理。<br>（1）判断每一行数据是否重复（完全相同），主要代码如下：</p><p>df1.duplicated()<br>如果返回值为False表示不重复，返回值为True表示重复。<br>（2）去除全部的重复数据，主要代码如下：</p><p>df1.drop_duplicates()<br>（3）去除指定列的重复数据，主要代码如下：</p><p>df1.drop_duplicates([‘买家会员名’])<br>（4）保留重复行中的最后一行，主要代码如下：</p><p>df1.drop_duplicates([‘买家会员名’],keep=’last’)</p><p>说明<br>以上代码中参数keep的值有3个。当keep=’first’表示保留第一次出现的重复行，是默认值；当keep为另外两个取值，即last和False时，分别表示保留最后一次出现的重复行和去除所有重复行。<br>（5）直接删除，保留一个副本，主要代码如下：</p><p>df1.drop_duplicates([‘买家会员名’,’买家支付宝账号’],inplace=Fasle)<br>inplace=True表示直接在原来的DataFrame上删除重复项，而默认值False表示删除重复项后生成一个副本。</p><h4 id="3-7-3-异常值的检测与处理"><a href="#3-7-3-异常值的检测与处理" class="headerlink" title="3.7.3　异常值的检测与处理"></a>3.7.3　异常值的检测与处理</h4><p>首先了解一下什么是异常值。在数据分析中异常值是指超出或低于正常范围的值，如年龄大于200、身高大于3米、宝贝总数量为负数等类似数据。那么这些数据如何检测呢？主要有以下几种方法。<br>（1）根据给定的数据范围进行判断，不在范围内的数据视为异常值。<br>（2）均方差。<br>在统计学中，如果一个数据分布近似正态分布（数据分布的一种形式，正态分布的概率密度函数曲线呈钟形，两头低、中间高、左右对称，因此人们又经常称之为钟形曲线），那么大约68%的数据值会在均值的一个标准差范围内，大约95%会在两个标准差范围内，大约99.7%会在3个标准差范围内。<br>（3）箱形图。<br>箱形图是显示一组数据分散情况资料的统计图。它可以将数据通过四分位数的形式进行图形化描述。箱形图通过上限和下限作为数据分布的边界。任何高于上限或低于下限的数据都可以认为是异常值，如图3.48所示。</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018055103761.png" alt="image-20211018055103761"></p><p>​                                                                                            图3.48　箱形图说明<br>有关箱形图的介绍以及如何通过箱形图识别异常值可参见第6章。<br>了解了异常值的检测，接下来介绍如何处理异常值，主要包括以下几种处理方式。<br>（1）最常用的方式是删除。<br>（2）将异常值当缺失值处理，以某个值填充。<br>（3）将异常值当特殊情况进行分析，研究异常值出现的原因。</p><h3 id="3-8-索引设置"><a href="#3-8-索引设置" class="headerlink" title="3.8 索引设置"></a>3.8 索引设置</h3><p>索引能够快速查询数据，本节主要介绍索引的作用以及索引的应用。</p><h4 id="3-8-1-索引的作用"><a href="#3-8-1-索引的作用" class="headerlink" title="3.8.1　索引的作用"></a>3.8.1　索引的作用</h4><p>索引的作用相当于图书的目录，可以根据目录中的页码快速找到所需的内容。Pandas索引的作用如下。　更方便查询数据。　使用索引可以提升查询性能。　如果索引是唯一的，Pandas会使用哈希表优化，查找数据的时间复杂度为O(1)。　如果索引不是唯一的，但是有序，Pandas会使用二分查找算法，查找数据的时间复杂度为O(logN)。　如果索引是完全随机的，那么每次查询都要扫描数据表，查找数据的时间复杂度为O(N)。　自动的数据对齐功能，示意图如图3.49所示。</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018113947441.png" alt="image-20211018113947441"></p><p>​                                                                                    图3.49　自动数据对齐示意图<br>实现上述效果，程序代码如下：</p><p>01 import pandas as pd<br>02 s1 = pd.Series([10,20,30],index= list(“abc”))<br>03 s2 = pd.Series([2,3,4],index=list(“bcd”))<br>04 print(s1 + s2)　强大的数据结构。　基于分类数的索引，提升性能。　多维索引，用于groupby多维聚合结果等。　时间类型索引，强大的日期和时间的方法支持。</p><h4 id="3-8-2-重新设置索引"><a href="#3-8-2-重新设置索引" class="headerlink" title="3.8.2　重新设置索引"></a>3.8.2　重新设置索引</h4><p>Pandas有一个很重要的方法是reindex()，它的作用是创建一个适应新索引的新对象。语法如下：</p><p>DataFrame.reindex(labels = None,index = None,columns = None,axis = None,method = None,copy = True,level =<br>None,fill_value = nan,limit = None,tolerance = None)<br>常用参数说明：　</p><p>labels：标签，可以是数组，默认值为None（无）。　</p><p>index：行索引，默认值为None。　</p><p>columns：列索引，默认值为None。</p><p>axis：轴，axis=0表示行，axis=1表示列。默认值为None。　</p><p>method：默认值为None，重新设置索引时，选择插值（一种填充缺失数据的方法）方法，其值可以是None、bfill/backfill（向后填充）、ffill/pad（向前填充）等。　</p><p>fill_value：缺失值要填充的数据。如缺失值不用NaN填充，而用0填充，则设置fill_value=0即可。</p><h5 id="1．对Series对象重新设置索引"><a href="#1．对Series对象重新设置索引" class="headerlink" title="1．对Series对象重新设置索引"></a>1．对Series对象重新设置索引</h5><p>【示例41】　重新设置物理成绩的索引。（示例位置：资源包\MR\Code\03\41）<br>在3.2.3节已经建立了一组学生的物理成绩，下面重新设置索引，程序代码如下：</p><p>01 import pandas as pd<br>02 s1=pd.Series([88,60,75],index=[1,2,3])<br>03 print(s1)<br>04 print(s1.reindex([1,2,3,4,5]))<br>运行程序，控制台输出结果对比如图3.50和图3.51所示。</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018124142285.png" alt="image-20211018124142285"></p><p>​                                                                                                              图3.50　原数据</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018124200693.png" alt="image-20211018124200693"></p><p>​                                                                                                 图3.51　重新设置索引<br>从运行结果得知：reindex()方法根据新索引进行了重新排序，并且对缺失值自动填充NaN。如果不想用NaN填充，则可以为fill_value参数指定值，如0，主要代码如下：</p><p>s1.reindex([1,2,3,4,5],fill_value=0)<br>而对于一些有一定顺序的数据，我们可能需要插值（插值是一种填充缺失数据的方法）来填充缺失的数据，可以使用method参数。</p><p>【示例42】　向前和向后填充数据。（示例位置：资源包\MR\Code\03\42）向前填充（和前面数据一样）、向后填充（和后面数据一样），主要代码如下：</p><p>01 print(s1.reindex([1,2,3,4,5],method=’ffill’))   #向前填充<br>02 print(s1.reindex([1,2,3,4,5],method=’bfill’))   #向后填充</p><h5 id="2．对DataFrame对象重新设置索引"><a href="#2．对DataFrame对象重新设置索引" class="headerlink" title="2．对DataFrame对象重新设置索引"></a>2．对DataFrame对象重新设置索引</h5><p>对于DataFrame对象，reindex()方法用于修改行索引和列索引。</p><p>【示例43】　创建成绩表并重新设置索引。（示例位置：资源包\MR\Code\03\43）通过二维数组创建成绩表，程序代码如下：</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018124525086.png" alt="image-20211018124525086">通过reindex()方法重新设置行索引，主要代码如下：</p><p>df.reindex([‘mr001’,’mr002’,’mr003’,’mr004’,’mr005’])<br>通过reindex()方法重新设置列索引，主要代码如下：</p><p>df.reindex(columns=[‘语文’,’物理’,’数学’,’英语’])<br>通过reindex()方法重新设置行索引和列索引，主要代码如下：</p><p>df.reindex(index=[‘mr001’,’mr002’,’mr003’,’mr004’,’mr005’],columns=[‘语文’,’物理’,’数学’,’英语’])<br>运行程序，控制台输出结果分别为原始数据（见图3.52）、重新设置行索引（见图3.53）、重新设置列索引（见图3.54）、重新设置行、列索引（见图3.55）。</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018124708302.png" alt="image-20211018124708302"></p><p>​                                                                                                  图3.52　原始数据</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018124737241.png" alt="image-20211018124737241"></p><p>​                                                                                                 图3.53　重新设置行索引</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018124821931.png" alt="image-20211018124821931"></p><p>​                                                                                                   图3.54　重新设置列索引</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018124905647.png" alt="image-20211018124905647"></p><h4 id="3-8-3-设置某列为行索引"><a href="#3-8-3-设置某列为行索引" class="headerlink" title="3.8.3　设置某列为行索引"></a>3.8.3　设置某列为行索引</h4><p>设置某列为行索引主要使用set_index()方法。</p><p>【示例44】　设置“买家会员名”为行索引。（示例位置：资源包\MR\Code\03\44）<br>首先，导入“1月.xlsx”Excel文件，程序代码如下：</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018125022369.png" alt="image-20211018125022369"></p><p>运行程序，输出结果如图3.56所示。<br>此时默认行索引为0、1、2、3、4，下面将“买家会员名”作为行索引，主要代码如下：</p><p>df2=df.set_index([‘买家会员名’])<br>运行程序，输出结果如图3.57所示。</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018125215478.png" alt="image-20211018125215478"></p><p>​                                                                                                图3.56　1月淘宝销售数据（部分数据）</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018125235811.png" alt="image-20211018125235811"></p><p>​                                                                                                       图3.57　设置“买家会员名”为索引<br>如果在set_index()方法中传入参数drop=True，则会删除“买家会员名”；如果传入drop=False，则会保留“买家会员名”。默认为False。</p><h4 id="3-8-4-数据清洗后重新设置连续的行索引"><a href="#3-8-4-数据清洗后重新设置连续的行索引" class="headerlink" title="3.8.4　数据清洗后重新设置连续的行索引"></a>3.8.4　数据清洗后重新设置连续的行索引</h4><p>在对Dataframe对象进行数据清洗后，例如去掉含NaN的行之后，发现行索引还是原来的行索引，对比效果如图3.58和图3.59所示。</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018125500556.png" alt="image-20211018125500556"></p><p>​                                                                                            图3.58　原数据</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018125521969.png" alt="image-20211018125521969"></p><p>​                                                                           图3.59　数据清洗后还是原来的索引</p><p>【示例45】　删除数据后重新设置索引。（示例位置：资源包\MR\Code\03\45）</p><p>如果要重新设置索引可以使用reset_index()方法，在删除缺失数据后重新设置索引，主要代码如下：</p><p>df2=df.dropna().reset_index(drop=True)<br>运行程序，输出结果如图3.60所示。</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018125620746.png" alt="image-20211018125620746"></p><p>​                                                                           图3.60　数据清洗后重新设置连续的行索引<br>另外，对于分组统计后的数据，有时也需要重新设置连续的行索引，方法同上。</p><h3 id="3-9-数据排序与排名"><a href="#3-9-数据排序与排名" class="headerlink" title="3.9　数据排序与排名"></a>3.9　数据排序与排名</h3><p>本节主要介绍数据的各种排序和排名方法。</p><h4 id="3-9-1-数据排序"><a href="#3-9-1-数据排序" class="headerlink" title="3.9.1　数据排序"></a>3.9.1　数据排序</h4><p>DataFrame数据排序主要使用sort_values()方法，该方法类似于SQL中的ORDER BY。sort_values()方法可以根据指定行／列进行排序，语法如下：</p><p>DataFrame.sort_values(by,axis=0,ascending=True,inplace=False,kind=’quicksort’,na_position=’last’,ignore_<br>index=False)<br>参数说明：　</p><p>by：要排序的名称列表。</p><p>axis：轴，axis=0表示行，axis=1表示列。默认值为0，即按行排序。　</p><p>ascending：升序或降序排序，布尔值，指定多个排序可以使用布尔值列表。默认值为True。　</p><p>inplace：布尔值，默认值为False，如果值为True，则就地排序。　</p><p>kind：指定排序算法，值为quicksort（快速排序）、mergesort（混合排序）或heapsort（堆排），默认值为quicksort。　na_position：空值（NaN）的位置，值为first空值在数据开头，值为last空值在数据最后，默认值为last。　</p><p>ignore_index：布尔值，是否忽略索引，值为True标记索引（从0开始按顺序的整数值），值为False则忽略索引。</p><h5 id="1．按一列数据排序"><a href="#1．按一列数据排序" class="headerlink" title="1．按一列数据排序"></a>1．按一列数据排序</h5><p>【示例46】　按“销量”降序排序。（示例位置：资源包\MR\Code\03\46）<br>按“销量”降序排序，排序对比效果如图3.61和图3.62所示。</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018125836428.png" alt="image-20211018125836428"></p><p>​                                                                                                     图3.61　原始数据</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018130000864.png" alt="image-20211018130000864"></p><p>​                                                                                图3.62　按“销量”降序排序实用技巧<br>Spyder变量浏览窗口本身也支持数据排序，单击需要排序的列即可实现升序或降序排序。<br>程序代码如下：</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018130020866.png" alt="image-20211018130020866"></p><h5 id="2．按多列数据排序"><a href="#2．按多列数据排序" class="headerlink" title="2．按多列数据排序"></a>2．按多列数据排序</h5><p>多列排序是按照给定列的先后顺序进行排序的。</p><p>【示例47】　按照“图书名称”和“销量”降序排序。（示例位置：资源包\MR\Code\03\47）<br>按照“图书名称”和“销量”降序排序，首先按“图书名称”降序排序，然后再按“销量”降序排序，排序后的效果如图3.63所示。</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018130140068.png" alt="image-20211018130140068"></p><p>​                                                                图3.63　按照“图书名称”和“销量”降序排序<br>主要代码如下：</p><p>df1=df.sort_values(by=[‘图书名称’,’销量’])</p><h5 id="3．对统计结果排序"><a href="#3．对统计结果排序" class="headerlink" title="3．对统计结果排序"></a>3．对统计结果排序</h5><p>【示例48】　对分组统计数据进行排序。（示例位置：资源包\MR\Code\03\48）</p><p>按“类别”分组统计销量并进行降序排序，统计排序后的效果如图3.64所示。</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018130240441.png" alt="image-20211018130240441"></p><p>​                                                                                 图3.64　按“类别”分组统计销量并降序排序<br>主要代码如下：</p><p>01 df1=df.groupby([“类别”])[“销量”].sum().reset_index()</p><p>2 df2=df1.sort_values(by=’销量’,ascending=False)</p><h5 id="4．按行数据排序"><a href="#4．按行数据排序" class="headerlink" title="4．按行数据排序"></a>4．按行数据排序</h5><p>【示例49】　按行数据排序。（示例位置：资源包\MR\Code\03\49）<br>按行排序，主要代码如下：</p><p>df=dfrow.sort_values(by=0,ascending=True,axis=1)注意<br>按行排序的数据类型要一致，否则会出现错误提示。</p><h4 id="3-9-2-数据排名"><a href="#3-9-2-数据排名" class="headerlink" title="3.9.2　数据排名"></a>3.9.2　数据排名</h4><p>排名是根据Series对象或DataFrame的某几列的值进行排名的，主要使用rank()方法，语法如下：</p><p>DataFrame.rank(axis=0,method=’average’,numeric_only=None,na_option=’keep’,ascending=True,pct=False)<br>参数说明：　</p><p>axis：轴，axis=0表示行，axis=1表示列。默认值为0，即按行排序。　</p><p>method：表示在具有相同值的情况下所使用的排序方法。设置值如下。　</p><p>average：默认值，平均排名。</p><p>min：最小值排名。　</p><p>max：最大值排名。　</p><p>first：按值在原始数据中的出现顺序分配排名。　</p><p>dense：密集排名，类似最小值排名，但是排名每次只增加1，即排名相同的数据只占一个名次。　</p><p>numeric_only：对于DataFrame对象，如果设置值为True，则只对数字列进行排序。　</p><p>na_option：空值的排序方式，设置值如下。　</p><p>keep：保留，将空值等级赋值给NaN值。　</p><p>top：如果按升序排序，则将最小排名赋值给NaN值。　</p><p>bottom：如果按升序排序，则将最大排名赋值给NaN值。　</p><p>ascending：升序或降序排序，布尔值，指定多个排序可以使用布尔值列表。默认值为True。　</p><p>pct：布尔值，是否以百分比形式返回排名。默认值为False。</p><p>1．顺序排名</p><p>【示例50】　对产品销量按顺序进行排名。（示例位置：资源包\MRCode\03\50）<br>下面对销量相同的产品，按照出现的顺序排名，程序代码如下：</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018130818619.png" alt="image-20211018130818619"></p><p>程序运行结果如图3.65所示。<br>2．平均排名</p><p>【示例51】　对产品销量进行平均排名。（示例位置：资源包\MR\Code\03\51）<br>现在对销量相同的产品，按照顺序排名的平均值作为平均排名，主要代码如下：</p><p>01 df[‘平均排名’]=df[‘销量’].rank(ascending=False)</p><p>02 df1=df[[‘图书名称’,’销量’,’平均排名’]]<br>程序运行结果如图3.66所示。<br>3．最小值排名<br>排名相同的，按顺序排名取最小值作为排名，主要代码如下：</p><p>df[‘最小值排名’]=df[‘销量’].rank(method=”min”,ascending=False)<br>4．最大值排名<br>排名相同的，按顺序排名取最大值作为排名，主要代码如下：</p><p>df[‘最大值排名’]=df[‘销量’]rank(method=”max”,ascending=False)</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018131022583.png" alt="image-20211018131022583"></p><p>​                                                                  图3.65　销量相同按出现的先后顺序排名</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018131037838.png" alt="image-20211018131037838"></p><p>​                                                                   图3.66　销量相同按顺序排名的平均值排名</p><h3 id="3-10-小结"><a href="#3-10-小结" class="headerlink" title="3.10　小结"></a>3.10　小结</h3><p>本章介绍了Pandas数据处理的基本知识，从最初的数据来源开始（创建DataFrame数据或导入外部数据）到数据抽取、数据增删改操作、数据清洗、索引，再到数据排序，常用的数据处理操作基本都涉及了，通过本章的学习基本能够独立完成一些简单的数据处理工作。</p><h1 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h1><h2 id="4-1-数据计算"><a href="#4-1-数据计算" class="headerlink" title="4.1 数据计算"></a>4.1 数据计算</h2><p>Pandas提供了大量的数据计算函数，可以实现求和、求均值、求最大值、求最小值、求中位数、求众数、求方差、标准差等，从而使得数据统计变得简单高效。</p><h3 id="4-1-1求和函数（sum"><a href="#4-1-1求和函数（sum" class="headerlink" title="4.1.1求和函数（sum())"></a>4.1.1求和函数（sum())</h3><p>DataFrame.sum(axis=None, skipna=None, level=None, numeric_only=None, min_count=0, **kwargs)<br>参数说明：　</p><p>axis：axis=1表示行，axis=0表示列，默认值为None（无）。　skipna：布尔型，表示计算结果是否排除NaN/Null值，默认值为None。</p><p>level：表示索引层级，默认值为None。　</p><p>numeric_only：仅数字，布尔型，默认值为None。　</p><p>min_count：表示执行操作所需的数目，整型，默认值为0。　**kwargs：要传递给函数的附加关键字参数。　</p><p>返回值：返回Series对象或DataFrame对象。行或列求和数据。</p><p>【示例01】　计算语文、数学和英语三科的总成绩。（示例位置：资源包\MR\Code\04\01）<br>首先，创建一组DataFrame类型的数据，包括语文、数学和英语三科的成绩，如图4.1所示。<br>程序代码如下：</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/学习记录/专高三/讲义Pandas统计分析/image-20211020032035450.png" alt="image-20211020032035450">下面使用sum()函数计算三科的总成绩，代码如下：</p><p>df[‘总成绩’]=df.sum(axis=1)</p><p>运行程序，输出结果如图4.2所示。</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/学习记录/专高三/讲义Pandas统计分析/image-20211020032210845.png" alt="image-20211020032210845"></p><p>​                                        图4.1　DataFrame数据</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/学习记录/专高三/讲义Pandas统计分析/image-20211020032230748.png" alt="image-20211020032230748"></p><p>​                                  图4.2　sum()函数计算三科的总成绩</p><h3 id="4-1-2-求均值（mean-函数）"><a href="#4-1-2-求均值（mean-函数）" class="headerlink" title="4.1.2　求均值（mean()函数）"></a>4.1.2　求均值（mean()函数）</h3><p>DataFrame.mean(axis=None, skipna=None, level=None, numeric_only=None, kwargs)<br>参数说明：　</p><p>axis：axis=1表示行，axis=0表示列，默认值为None（无）。　</p><p>skipna：布尔型，表示计算结果是否排除NaN/Null值，默认值为None。　</p><p>level：表示索引层级，默认值为None。　</p><p>numeric_only：仅数字，布尔型，默认值为None。　</p><p>kwargs：要传递给函数的附加关键字参数。　</p><p>返回值：返回Series对象或DataFrame对象。行或列平均值数据。</p><p>【示例02】　计算语文、数学和英语各科的平均分。（示例位置：资源包\MR\Code\04\02）<br>计算语文、数学和英语各科成绩的平均值，程序代码如下：</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/学习记录/专高三/讲义Pandas统计分析/image-20211020032641368.png" alt="image-20211020032641368"></p><p>运行程序，输出结果如图4.3所示。</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020032714762.png" alt="image-20211020032714762"></p><p>​                             图4.3　mean()函数计算三科成绩的平均值<br>从运行结果得知：语文平均分109，数学平均分107，英语平均分114.667。</p><h3 id="4-1-3-求最大值（max-函数）"><a href="#4-1-3-求最大值（max-函数）" class="headerlink" title="4.1.3　求最大值（max()函数）"></a>4.1.3　求最大值（max()函数）</h3><p>在Python中通过调用DataFrame对象的max()函数实现行／列数据最大值运算，语法如下：</p><p>DataFrame.max(axis=None, skipna=None, level=None, numeric_only=None, **kwargs)<br>参数说明：　**</p><p>**axis：axis=1表示行，axis=0表示列，默认值为None（无）。　skipna：布尔型，表示计算结果是否排除NaN/Null值，默认值为None。　</p><p>**level：表示索引层级，默认值为None。　</p><p>**numeric_only：仅数字，布尔型，默认值为None。　</p><p>kwargs：要传递给函数的附加关键字参数。　</p><p>返回值：返回Series对象或DataFrame对象。行或列最大值数据。</p><p>【示例03】　计算语文、数学和英语各科的最高分。（示例位置：资源包\MR\Code\04\03）<br>计算语文、数学和英语各科成绩的最大值，程序代码如下：</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/学习记录/专高三/讲义Pandas统计分析/image-20211020032850843.png" alt="image-20211020032850843"></p><p>运行程序，输出结果如图4.4所示。</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/学习记录/专高三/讲义Pandas统计分析/image-20211020033031795.png" alt="image-20211020033031795"></p><p>​                       图4.4　max()函数计算三科成绩的最大值</p><p>4.1.4　求最小值（min()函数）<br>在Python中通过调用DataFrame对象的min()函数实现行／列数据最小值运算，语法如下：</p><p>DataFrame.min(axis=None, skipna=None, level=None, numeric_only=None, **kwargs)<br>参数说明：　**</p><p>**axis：axis=1表示行，axis=0表示列，默认值为None（无）。　skipna：布尔型，表示计算结果是否排除NaN/Null值，默认值为None。　</p><p>**level：表示索引层级，默认值为None。　</p><p>**numeric_only：仅数字，布尔型，默认值为None。　</p><p>kwargs：要传递给函数的附加关键字参数。　</p><p>返回值：返回Series对象或DataFrame对象。行或列最小值数据。</p><p>【示例04】　计算语文、数学和英语各科的最低分。（示例位置：资源包\MR\Code\04\04）<br>计算语文、数学和英语各科成绩的最小值，程序代码如下：</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/学习记录/专高三/讲义Pandas统计分析/image-20211020033254349.png" alt="image-20211020033254349"></p><p>运行程序，输出结果如图4.5所示。</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/学习记录/专高三/讲义Pandas统计分析/image-20211020033314763.png" alt="image-20211020033314763"></p><h3 id="4-1-5-求中位数（median-函数）"><a href="#4-1-5-求中位数（median-函数）" class="headerlink" title="4.1.5　求中位数（median()函数）"></a>4.1.5　求中位数（median()函数）</h3><p>中位数又称中值，是统计学专有名词，是指按顺序排列的一组数据中位于中间位置的数，其不受异常值的影响。例如，年龄23、45、35、25、22、34、28这7个数，中位数就是排序后位于中间的数字，即28；而年龄23、45、35、25、22、34、28、27这8个数，中位数则是排序后位于中间两个数的平均值，即27.5。在Python中直接调用DataFrame对象的median()函数就可以轻松实现中位数的运算，语法如下：</p><p>DataFrame.median(axis=None,skipna=None,level=None,numeric_only=None,**kwargs)<br>参数说明：　**</p><p>**axis：axis=1表示行，axis=0表示列，默认值为None（无）。　skipna：布尔型，表示计算结果是否排除NaN/Null值，默认值为None。　</p><p>**level：表示索引层级，默认值为None。　</p><p>**numeric_only：仅数字，布尔型，默认值为None。　</p><p>kwargs：要传递给函数的附加关键字参数。　</p><p>返回值：返回Series对象或DataFrame对象。</p><p>【示例05】　计算学生各科成绩的中位数1。（示例位置：资源包\MR\Code\04\05）<br>下面给出一组数据（3条记录），然后使用median()函数计算语文、数学和英语各科成绩的中位数，程序代码如下：</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/学习记录/专高三/讲义Pandas统计分析/image-20211020033458773.png" alt="image-20211020033458773"></p><p>运行程序，控制台输出结果如下：</p><p>语文    130.0数学    120.0英语    130.0</p><p>【示例06】　计算学生各科成绩的中位数2。（示例位置：资源包\MR\Code\04\06）<br>下面再给出一组数据（4条记录），同样使用median()函数计算语文、数学和英语各科成绩的中位数，程序代码如下：</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/学习记录/专高三/讲义Pandas统计分析/image-20211020033625031.png" alt="image-20211020033625031"></p><p>运行程序，控制台输出结果如下：</p><p>语文    121.5数学    121.5英语    120.0</p><h3 id="4-1-6-求众数（mode-函数）"><a href="#4-1-6-求众数（mode-函数）" class="headerlink" title="4.1.6　求众数（mode()函数）"></a>4.1.6　求众数（mode()函数）</h3><p>什么是众数？众数的众字有多的意思，顾名思义，众数就是一组数据中出现最多的数称为众数，它代表了数据的一般水平。<br>在Python中通过调用DataFrame对象的mode()函数可以实现众数运算，语法如下：</p><p>DataFrame.mode(axis=0,numeric_only=False,dropna=True)<br>参数说明：　</p><p>axis：axis=1表示行，axis=0表示列，默认值为0。　</p><p>numeric_only：仅数字，布尔型，默认值为False。如果值为True，则仅适用于数字列。　</p><p>dropna：是否删除缺失值，布尔型，默认值为True。　</p><p>返回值：返回Series对象或DataFrame对象。<br>首先看一组原始数据，如图4.6所示。</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020033849240.png" alt="image-20211020033849240"></p><p>【示例07】　计算学生各科成绩的众数。（示例位置：资源包\MR\Code\04\07）<br>计算语文、数学和英语三科成绩的众数、每一行的众数和“数学”成绩的众数，程序代码如下：</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020034005721.png" alt="image-20211020034005721"></p><p>三科成绩的众数：<br>每一行的众数：</p><p>0  110<br>1  130<br>2  130<br>数学成绩的众数：</p><p>0  120</p><h3 id="4-1-7-求方差（var-函数）"><a href="#4-1-7-求方差（var-函数）" class="headerlink" title="4.1.7　求方差（var()函数）"></a>4.1.7　求方差（var()函数）</h3><p>方差用于衡量一组数据的离散程度，即各组数据与它们的平均数的差的平方，那么我们用这个结果来衡量这组数据的波动大小，并把它叫作这组数据的方差，方差越小越稳定。通过方差可以了解一个问题的波动性。下面简单介绍下方差的意义，相信通过一个简单的举例您就会了解。<br>例如，某校两名同学的物理成绩都很优秀，而参加物理竞赛的名额只有一个，那么选谁去获得名次的机率更大呢？于是根据历史数据计算出了两名同学的平均成绩，但结果是实力相当，平均成绩都是107.6，怎么办呢？这时让方差帮决定，看看谁的成绩更稳定。首先汇总物理成绩，如图4.7所示。</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020034219502.png" alt="image-20211020034219502"></p><p>​                                            图4.7　物理成绩<br>通过方差对比两名同学物理成绩的波动，如图4.8所示。</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020034235082.png" alt="image-20211020034235082"></p><p>​                                                   图4.8　方差<br>接着来看一下总体波动（方差和），“小黑”的数据是73.2，“小白”的数据是949.2，很明显“小黑”的物理成绩波动较小，发挥更稳定，所以应该选“小黑”参加物理竞赛。<br>以上举例就是方差的意义。大数据时代，它能够帮助我们解决很多身边的问题、协助我们做出合理的决策。<br>在Python中通过调用DataFrame对象的var()函数可以实现方差运算，语法如下：</p><p><strong>DataFrame.var(axis=None,skipna=None,level=None,ddof=1,numeric_only=None,kwargs)</strong><br>参数说明：　</p><p>axis：axis=1表示行，axis=0表示列，默认值为None（无）。　skipna：布尔型，表示计算结果是否排除NaN/Null值，默认值为None。　</p><p>level：表示索引层级，默认值为None。　</p><p>ddof：整型，默认值为1。自由度，计算中使用的除数是N-ddof，其中N表示元素的数量。　</p><p>numeric_only：仅数字，布尔型，默认值为None。　</p><p>kwargs：要传递给函数的附加关键字参数。　</p><p>返回值：返回Series对象或DataFrame对象。</p><p>【示例08】　通过方差判断谁的物理成绩更稳定。（示例位置：资源包\MR\Code\04\08）<br>计算“小黑”和“小白”物理成绩的方差，程序代码如下：</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020034435272.png" alt="image-20211020034435272"></p><p>运行程序，控制台输出结果如下：</p><p>小黑     18.3小白    237.3<br>从运行结果得知：“小黑”的物理成绩波动较小，发挥更稳定。这里需要注意的是，Pandas中计算的方差为无偏样本方差（即方差和／样本数-1），NumPy中计算的方差就是样本方差本身（即方差和／样本数）。</p><h3 id="4-1-8-标准差（数据标准化std-函数）"><a href="#4-1-8-标准差（数据标准化std-函数）" class="headerlink" title="4.1.8　标准差（数据标准化std()函数）"></a>4.1.8　标准差（数据标准化std()函数）</h3><p>标准差又称均方差，是方差的平方根，用来表示数据的离散程度。<br>在Python中通过调用DataFrame对象的std()函数求标准差，语法如下：</p><p>DataFrame.std(axis=None,skipna=None,level=None,ddof=1,numeric_only=None,**kwargs)<br>std()函数的参数与var()函数一样，这里不再赘述。</p><p>【示例09】　计算各科成绩的标准差。（示例位置：资源包\MR\Code\04\09）<br>使用std()函数计算标准差，程序代码如下：</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020034453875.png" alt="image-20211020034453875"></p><p>运行程序，控制台输出结果如下：</p><p>语文    11.547005数学     5.773503英语    11.5547005</p><h3 id="4-1-9-求分位数（quantile-函数）"><a href="#4-1-9-求分位数（quantile-函数）" class="headerlink" title="4.1.9　求分位数（quantile()函数）"></a>4.1.9　求分位数（quantile()函数）</h3><p>分位数也称分位点，它以概率依据将数据分割为几个等份，常用的有中位数（即二分位数）、四分位数、百分位数等。分位数是数据分析中常用的一个统计量，经过抽样得到一个样本值。例如，经常会听老师说：“这次考试竟然有20%的同学不及格！”，那么这句话就体现了分位数的应用。在Python中通过调用DataFrame对象的quantile()函数求分位数，语法如下：</p><p><strong>DataFrame.quantile(q=0.5,axis=0,numeric_only=True, interpolation=’linear’)</strong><br>参数说明：　</p><p>q：浮点型或数组，默认为0.5（50%分位数），其值为0～1。　</p><p>axis：axis=1表示行，axis=0表示列。默认值为0。　</p><p>numeric_only：仅数字，布尔型，默认值为True。　</p><p>interpolation：内插值，可选参数[{‘linear’,‘lower’,‘higher’,‘midpoint’,‘nearest’}]用于指定要使用的插值方法，当期望的分位数为数据点i～j时。　</p><p>​    linear’：i+(j-i)×分数，其中分数是指数被i和j包围的小数部分。　</p><p>​    lower：i。　</p><p>​    higher：j。　</p><p>​    nearest：i或j二者以最近者为准。　</p><p>​    midpoint：(i+j)/2。　</p><p>返回值：返回Series或DataFrame对象。</p><p>【示例10】　通过分位数确定被淘汰的35%的学生。（示例位置：资源包\MR\Code\04\10）<br>以学生成绩为例，数学成绩分别为120、89、98、78、65、102、112、56、79、45的10名同学，现根据分数淘汰35%的学生，该如何处理？首先使用quantile()函数计算35%的分位数，然后将学生成绩与分位数比较，筛选小于等于分位数的学生，程序代码如下：</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020035437337.png" alt="image-20211020035437337"></p><p>运行程序，控制台输出结果如下：</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020035513992.png" alt="image-20211020035513992"></p><p>从运行结果得知：即将被淘汰的学生有4名，分数分别为78、65、56和45。</p><p>【示例11】　计算日期、时间和时间增量数据的分位数。（示例位置：资源包\MR\Code\04\11）<br>如果参数numeric_only=False，将计算日期、时间和时间增量数据的分位数，程序代码如下：<br>运行程序，控制台输出结果如下：</p><p>A                  1.5<br>B 2019-07-02 12:00:00<br>C          1 days 12:00:00<br>Name: 0.5, dtype: object</p><h2 id="4-2-数据格式化"><a href="#4-2-数据格式化" class="headerlink" title="4.2　数据格式化"></a>4.2　数据格式化</h2><p>在进行数据处理时，尤其是在数据计算中应用求均值（mean()函数）后，发现结果中的小数位数增加了许多。此时就需要对数据进行格式化，以增加数据的可读性。例如，保留小数点位数、百分号、千位分隔符等。首先来看一组数据，如图4.9所示。</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020035851798.png" alt="image-20211020035851798"></p><p>​                                         图4.9　原始数据</p><h3 id="4-2-1-设置小数位数"><a href="#4-2-1-设置小数位数" class="headerlink" title="4.2.1　设置小数位数"></a>4.2.1　设置小数位数</h3><p>设置小数位数主要使用DataFrame对象的round()函数，该函数可以实现四舍五入，而它的decimals参数则用于设置保留小数的位数，设置后数据类型不会发生变化，依然是浮点型。语法如下：</p><p>DataFrame.round(decimals=0, *args, **kwargs)　**</p><p>decimals：每一列四舍五入的小数位数，整型、字典或Series对象。如果是整数，则将每一列四舍五入到相同的位置。否则，将字典和Series舍入到可变数目的位置；如果小数是类似于字典的，那么列名应该在键中；如果小数是级数，列名应该在索引中。没有包含在小数中的任何列都将保持原样。非输入列的小数元素将被忽略。　</p><p>args：附加的关键字参数。　</p><p>kwargs：附加的关键字参数。　</p><p>返回值：返回DataFrame对象。</p><p>【示例12】　四舍五入保留指定的小数位数。（示例位置：资源包\MR\Code\04\12）<br>使用round()函数四舍五入保留小数位数，程序代码如下：</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020040002742.png" alt="image-20211020040002742"></p><p>运行程序，控制台输出结果如下：</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020040023289.png" alt="image-20211020040023289"></p><p>当然，保留小数位数也可以用自定义函数，例如，为DataFrame对象中的各个浮点值保留两位小数，主要代码如下：</p><p>df.applymap(lambda x: ‘%.2f’%x)</p><p>注意<br>经过自定义函数处理过的数据将不再是浮点型而是对象型，如果后续计算需要数据，则应先进行数据类型转换。</p><h3 id="4-2-2-设置百分比"><a href="#4-2-2-设置百分比" class="headerlink" title="4.2.2　设置百分比"></a>4.2.2　设置百分比</h3><p>在数据分析过程中，有时需要百分比数据。那么，利用自定义函数将数据进行格式化处理，处理后的数据就可以从浮点型转换成带指定小数位数的百分比数据，主要使用apply()函数与format()函数。</p><p>【示例13】　将指定数据格式化为百分比数据。（示例位置：资源包\MR\Code\04\13）<br>将A1列的数据格式化为百分比数据，程序代码如下：</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020040234891.png" alt="image-20211020040234891"></p><p>运行程序，控制台输出结果如下：</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020040335780.png" alt="image-20211020040335780"></p><h3 id="4-2-3-设置千位分隔符"><a href="#4-2-3-设置千位分隔符" class="headerlink" title="4.2.3　设置千位分隔符"></a>4.2.3　设置千位分隔符</h3><p>由于业务需要，有时需要将数据格式化为带千位分隔符的数据。那么，处理后的数据将不再是浮点型而是对象型。</p><p>【示例14】　将金额格式化为带千位分隔符的数据。（示例位置：资源包\MR\Code\04\14）<br>将图书销售码洋格式化为带千位分隔符的数据，程序代码如下：</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020040604750.png" alt="image-20211020040604750"></p><p>运行程序，控制台输出结果如下：</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020040623599.png" alt="image-20211020040623599"></p><p>注意<br>设置千位分隔符后，对于程序来说，这些数据将不再是数值型，而是数字和逗号组成的字符串，如果由于程序需要再变成数值型就会很麻烦，因此设置千位分隔符要慎重。</p><h2 id="4-3-数据分组统计"><a href="#4-3-数据分组统计" class="headerlink" title="4.3　数据分组统计"></a>4.3　数据分组统计</h2><p>本节主要介绍分组统计函数groupby()的各种应用。</p><h3 id="4-3-1-分组统计groupby-函数"><a href="#4-3-1-分组统计groupby-函数" class="headerlink" title="4.3.1　分组统计groupby()函数"></a>4.3.1　分组统计groupby()函数</h3><p>对数据进行分组统计，主要使用DataFrame对象的groupby()函数，其功能如下。<br>（1）根据给定的条件将数据拆分成组。</p><p>（2）每个组都可以独立应用函数（如求和函数sum()、求平均值函数mean()等）。<br>（3）将结果合并到一个数据结构中。<br>groupby()函数用于将数据按照一列或多列进行分组，一般与计算函数结合使用，实现数据的分组统计，语法如下：</p><p><strong>DataFrame.groupby(by=None,axis=0,level=None,as_index=True,sort=True,group_keys=True,squeeze=False,observed=False)</strong></p><p>参数说明：　</p><p>by：映射、字典或Series对象、数组、标签或标签列表。如果by是一个函数，则对象索引的每个值都调用它；如果传递了一个字典或Series对象，则使用该字典或Series对象值来确定组；如果传递了数组ndarray，则按原样使用这些值来确定组。　</p><p>axis：axis=1表示行，axis=0表示列。默认值为0。　</p><p>level：表示索引层级，默认值为None（无）。　</p><p>as_index：布尔型，默认值为True，返回以组标签为索引的对象。　sort：对组进行排序，布尔型，默认值为True。　</p><p>group_keys：布尔型，默认值为True，调用apply()函数时，将分组的键添加到索引以标识片段。　</p><p>squeeze：布尔型，默认值为False。如果可能，减少返回类型的维度；否则返回一致类型。　</p><p>observed： <em>bool, default False</em> 布尔型, 观察者, 默认为False。当以石斑鱼为分类时，才会使用该参数。如果参数值为True，则仅显示分类石斑鱼的观测值；如果参数值为False，则显示分类石斑鱼的所有值。</p><p>返回值：返回DataFrameGroupBy，返回包含有关组的信息的groupby对象。</p><h4 id="1．按照一列分组统计"><a href="#1．按照一列分组统计" class="headerlink" title="1．按照一列分组统计"></a>1．按照一列分组统计</h4><p>【示例15】　根据“一级分类”统计订单数据。（示例位置：资源包\MR\Code\04\15）<br>按照图书“一级分类”对订单数据进行分组统计求和，程序代码如下：</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020042705196.png" alt="image-20211020042705196"></p><p>运行程序，输出结果如图4.10所示。</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020042744863.png" alt="image-20211020042744863"></p><p>​                                 图4.10　按照一列分组统计</p><h4 id="2．按照多列分组统计"><a href="#2．按照多列分组统计" class="headerlink" title="2．按照多列分组统计"></a>2．按照多列分组统计</h4><p>多列分组统计，以列表形式指定列。</p><p>【示例16】　根据两级分类统计订单数据。（示例位置：资源包\MR\Code\04\16）<br>按照图书“一级分类”和“二级分类”对订单数据进行分组统计求和，主要代码如下：</p><p>01 #抽取数据<br>02 df1=df[[‘一级分类’,’二级分类’,’7天点击量’,’订单预定’]]<br>03 df1=df1.groupby([‘一级分类’,’二级分类’]).sum()    #分组统计求和</p><p>运行程序，输出结果如图4.11所示。</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020042906442.png" alt="image-20211020042906442"></p><p>​                                    图4.11　按照多列分组统计</p><h4 id="3．分组并按指定列进行数据计算"><a href="#3．分组并按指定列进行数据计算" class="headerlink" title="3．分组并按指定列进行数据计算"></a>3．分组并按指定列进行数据计算</h4><p>前面介绍的分组统计是按照所有列进行汇总计算的，那么如何按照指定列汇总计算呢？</p><p>【示例17】　统计各编程语言的7天点击量。（示例位置：资源包\MR\Code\04\17）<br>统计各编程语言的7天点击量，首先按“二级分类”分组，然后抽取“7天点击量”列并对该列进行求和运算，主要代码如下：</p><p>df1=df1.groupby(‘二级分类’)[‘7天点击量’].sum()<br>运行程序，输出结果如图4.12所示。</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020043023795.png" alt="image-20211020043023795"></p><p>图4.12　分组并按指定列进行数据计算</p><h3 id="4-3-2-对分组数据进行迭代"><a href="#4-3-2-对分组数据进行迭代" class="headerlink" title="4.3.2　对分组数据进行迭代"></a>4.3.2　对分组数据进行迭代</h3><p>通过for循环对分组统计数据进行迭代（遍历分组数据）。</p><p>【示例18】　迭代一级分类的订单数据。（示例位置：资源包\MR\Code\04\18）<br>按照“一级分类”分组，并输出每一分类中的订单数据，主要代码如下：</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020043149194.png" alt="image-20211020043149194"></p><p>运行程序，控制台输出结果如图4.13所示。<br>上述代码中，name是groupby()函数中“一级分类”的值，group是分组后的数据。如果groupby()函数对多列进行分组，那么需要在for循环中指定多列。</p><p>【示例19】　迭代两级分类的订单数据。（示例位置：资源包\MR\Code\04\19）<br>迭代“一级分类”和“二级分类”的订单数据，主要代码如下：</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020043219251.png" alt="image-20211020043219251"></p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020043328145.png" alt="image-20211020043328145"></p><p>​                          图4.13　对分组数据进行迭代</p><h3 id="4-3-3-对分组的某列或多列使用聚合函数（agg-函数）"><a href="#4-3-3-对分组的某列或多列使用聚合函数（agg-函数）" class="headerlink" title="4.3.3　对分组的某列或多列使用聚合函数（agg()函数）"></a>4.3.3　对分组的某列或多列使用聚合函数（agg()函数）</h3><p>Python也可以实现像SQL中的分组聚合运算操作，主要通过groupby()函数与agg()函数实现。【示例20】　对分组统计结果使用聚合函数。（示例位置：资源包\MR\Code\04\20）<br>按“一级分类”分组统计“7天点击量”“订单预定”的平均值和总和，主要代码如下：</p><p>print(df1.groupby(‘一级分类’).agg([‘mean’,’sum’]))<br>运行程序，控制台输出结果如图4.14所示。</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020043531227.png" alt="image-20211020043531227"></p><p>​                 图4.14　分组统计“7天点击量”“订单预定”的平均值和总和</p><p>【示例21】　针对不同的列使用不同的聚合函数。（示例位置：资源包\MR\Code\04\21）<br>在上述示例中，还可以针对不同的列使用不同的聚合函数。例如，按“一级分类”分组统计“7天点击量”的平均值和总和、“订单预定”的总和，主要代码如下：</p><p>print(df1.groupby(‘一级分类’).agg({‘7天点击量’:[‘mean’,’sum’], ‘订单预定’:[‘sum’]}))<br>运行程序，控制台输出结果如图4.15所示。</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020043554534.png" alt="image-20211020043554534"></p><p>​           图4.15　分组统计“7天点击量”的平均值和总和、“订单预定”的总和</p><p>【示例22】　通过自定义函数实现分组统计。（示例位置：资源包\MR\Code\04\22）<br>通过自定义函数也可以实现数据分组统计。例如，统计1月份销售数据中，购买次数最多的产品，主要代码如下：</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020043631773.png" alt="image-20211020043631773"></p><p>运行程序，控制台输出结果如图4.16所示。</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020043647886.png" alt="image-20211020043647886"></p><p>​                             图4.16　统计购买次数最多的产品</p><p>从运行结果得知：“零基础学Python”是用户购买次数最多的产品。实用技巧<br>在图4.16显示的输出结果中可以看到，lambda()函数名称<lambda>被输出出来，看上去不是很美观，那么如何去掉它？方法是使用__name__方法修改函数名称，主要代码如下：</lambda></p><p>max.<strong>name</strong> = “购买次数最多”<br>运行程序，控制台输出结果如图4.17所示。</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020043747160.png" alt="image-20211020043747160"></p><p>​                         图4.17　使用__name__方法修改函数名称</p><h3 id="4-3-4-通过字典和Series对象进行分组统计"><a href="#4-3-4-通过字典和Series对象进行分组统计" class="headerlink" title="4.3.4　通过字典和Series对象进行分组统计"></a>4.3.4　通过字典和Series对象进行分组统计</h3><h4 id="1．通过字典进行分组统计"><a href="#1．通过字典进行分组统计" class="headerlink" title="1．通过字典进行分组统计"></a>1．通过字典进行分组统计</h4><p>首先创建字典建立对应关系，然后将字典传递给groupby()函数从而实现数据分组统计。</p><p>【示例23】　通过字典分组统计“北上广”销量。（示例位置：资源包\MR\Code\04\23）<br>统计各地区销量，业务要求将“北京”“上海”“广州”3个一线城市放在一起统计。那么首先创建一个字典将“北京出库销量”“上海出库销量”“广州出库销量”都对应“北上广”；然后使用groupby()函数进行分组统计。主要代码如下：</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020043824543.png" alt="image-20211020043824543"></p><p>运行程序，控制台输出结果如图4.18所示。</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020043847244.png" alt="image-20211020043847244"></p><p>​                                 图4.18　通过字典进行分组统计</p><h4 id="2．通过Series对象进行分组统计"><a href="#2．通过Series对象进行分组统计" class="headerlink" title="2．通过Series对象进行分组统计"></a>2．通过Series对象进行分组统计</h4><p>通过Series对象进行分组统计与字典的方法类似。</p><p>【示例24】　通过Series对象分组统计“北上广”销量。（示例位置：资源包\MR\Code\04\24）<br>首先，创建一个Series对象，主要代码如下：</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020043933019.png" alt="image-20211020043933019"></p><p>运行程序，输出结果如图4.19所示。<br>然后，将Series对象传递给groupby()函数实现数据分组统计，主要代码如下：</p><p>01  df1=df.groupby(s1,axis=1).sum()<br>02  print(df1)<br>运行程序，控制台输出结果如图4.20所示。</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020043959963.png" alt="image-20211020043959963"></p><p>​                             图4.19　通过Series对象进行分组统计</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020044040014.png" alt="image-20211020044040014"></p><p>​                             图4.20　分组统计结果</p><h2 id="4-4-数据移位"><a href="#4-4-数据移位" class="headerlink" title="4.4　数据移位"></a>4.4　数据移位</h2><p>什么是数据移位？例如，分析数据时需要上一条数据怎么办？当然是移动至上一条，从而得到该条数据，这就是数据移位。在Pandas中，使用shift()方法可以获得上一条数据，该方法返回向下移位后的结果，从而得到上一条数据。例如，获取某学生上一次英语成绩，如图4.21所示。</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020044117875.png" alt="image-20211020044117875"></p><p>​                              图4.21　获取学生上一次英语成绩<br>shift()方法是一个非常有用的方法，用于数据位移与其他方法结合，能实现很多难以想象的功能，语法格式如下：</p><p>DataFrame.shift(periods=1, freq=None, axis=0)<br>参数说明：　</p><p>periods：表示移动的幅度，可以是正数，也可以是负数，默认值是1，1表示移动一次。注意这里移动的都是数据，而索引是不移动的，移动之后是没有对应值的，赋值为NaN。　</p><p>freq：可选参数，默认值为None，只适用于时间序列，如果这个参数存在，那么会按照参数值移动时间索引，而数据值没有发生变化。　</p><p>axis：axis=1表示行，axis=0表示列。默认值为0。</p><p>【示例25】　统计学生英语周测成绩的升降情况。（示例位置：资源包\MR\Code\04\25）<br>使用shift()方法统计学生每周英语测试成绩的升降情况，程序代码如下：</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020044313140.png" alt="image-20211020044313140"></p><p>运行程序，控制台输出结果如图4.22所示。<br>从运行结果得知：第2次比第1次下降5分，第3次比第2次下降6分，第4次比第3次提升21分，第5次比第4次下降5分。<br>这里再扩展下，通过10次周测来一看下学生整体英语成绩的升降情况，如图4.23和图4.24所示。</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020044330897.png" alt="image-20211020044330897"></p><p>​                                     图4.22　英语升降情况</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020044547566.png" alt="image-20211020044547566"></p><p>​                               图4.23　10次周测英语成绩升降情况</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020044603814.png" alt="image-20211020044603814"></p><p>​                     图4.24　图表展示英语成绩升降情况</p><p>说明</p><p>有关图表的知识将在第6章介绍，这里先简单了解。</p><p>shift()方法还有很多方面的应用。例如这样一个场景：分析股票数据，获取的股票数据中有股票的实时价格，也有每日的收盘价“close”，此时需要将实时价格和上一个工作日的收盘价进行对比，那么通过shift()方法就可以轻松解决。shift()方法还可以应用于时间序列，感兴趣的读者可以在学习完成后续章节进行尝试和探索。</p><h2 id="4-5-数据转换"><a href="#4-5-数据转换" class="headerlink" title="4.5　数据转换"></a>4.5　数据转换</h2><p>数据转换一般包括一列数据转换为多列数据、行列转换、DataFrame转换为字典、DataFrame转换为列表和DataFrame转换为元组等。</p><h3 id="4-5-1-一列数据转换为多列数据"><a href="#4-5-1-一列数据转换为多列数据" class="headerlink" title="4.5.1　一列数据转换为多列数据"></a>4.5.1　一列数据转换为多列数据</h3><p>一列数据转换为多列数据的情况在日常工作中经常会用到，从各种系统中导出的订单号、名称、地址很多都是复合组成的（即由多项内容组成），那么，这些列在查找、统计、合并时就没办法使用，需要将它们拆分开。例如，地址信息由省市区街道门牌号等信息组成，如果按省、市或区统计数据，就需要将地址信息中的“省”“市”“区”拆分开，此时就应用到了一列数据转多列数据，通常使用以下方法。</p><h4 id="1．split-方法"><a href="#1．split-方法" class="headerlink" title="1．split()方法"></a>1．split()方法</h4><p>Pandas的DataFrame对象中的str.split()内置方法可以实现分割字符串，语法如下：</p><p>Series.str.split(pat=None, n=-1, expand=False)<br>参数说明：　</p><p>pat：字符串、符号或正则表达式，字符串分割的依据，默认以空格分割字符串。　</p><p>n：整型，分割次数，默认值是-1，0或-1都将返回所有拆分。　</p><p>expand：布尔型，分割后的结果是否转换为DataFrame，默认值是False。　</p><p>返回值：系列、索引、DataFrame或多重索引。<br>首先，我们来看一组淘宝销售订单数据（部分数据），如图4.25所示。</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020044753477.png" alt="image-20211020044753477"></p><p>图4.25　淘宝销售订单数据（部分数据）<br>从图4-25中数据得知：不仅“收货地址”是复合的，“宝贝标题”也是复合的，即由多种产品组成。</p><p>【示例26】　分割“收货地址”数据中的“省、市、区”。（示例位置：资源包\MR\Code\04\26）<br>使用split()方法先对“收货地址”进行分割，程序代码如下：</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020044817707.png" alt="image-20211020044817707"></p><p>运行程序，输出结果如图4.26所示。</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020044931041.png" alt="image-20211020044931041"></p><p>​                                  图4.26　分割后的收货地址</p><h4 id="2．join-方法与split-方法结合"><a href="#2．join-方法与split-方法结合" class="headerlink" title="2．join()方法与split()方法结合"></a>2．join()方法与split()方法结合</h4><p>【示例27】　以逗号分隔多种产品数据。（示例位置：资源包\MR\Code\04\27）<br>通过join()方法与split()方法结合，以逗号“,”分隔“宝贝标题”，主要代码如下：</p><p>df = df.join(df[‘宝贝标题’].str.split(‘, ‘, expand=True))</p><p>运行程序，输出结果如图4.27所示。</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020044959881.png" alt="image-20211020044959881"></p><p>​                                   图4.27　分隔后的“宝贝标题”<br>从运行结果得知：“宝贝标题”中含有多种产品的数据被拆分开，这样操作便于日后对每种产品的销量进行统计。<br>将DataFrame中的tuple（元组）类型数据分隔成多列</p><p>【示例28】　对元组数据进行分隔。（示例位置：资源包\MR\Code\04\28）<br>首先，创建一组包含元组的数据，程序代码如下：</p><p>01  import pandas as pd<br>02  df = pd.DataFrame({‘a’:[1,2,3,4,5], ‘b’:[(1,2), (3,4),(5,6),(7,8),(9,10)]})<br>03  print(df)</p><p>然后，使用apply()函数对元组进行分隔，主要代码如下：</p><p>df[[‘b1’, ‘b2’]] = df[‘b’].apply(pd.Series)<br>或者使用join()方法结合apply()函数，主要代码如下：</p><p>df= df.join(df[‘b’].apply(pd.Series))<br>运行程序，控制台输出原始数据如图4.28所示，结果如图4.29和图4.30所示。</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020045110497.png" alt="image-20211020045110497"></p><p>​                                            图4.28　原始数据</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020045122797.png" alt="image-20211020045122797"></p><p>​                             图4.29　apply()函数分隔元组</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020045146968.png" alt="image-20211020045146968"></p><p>​                       图4.30　join()方法结合apply()函数分隔元组</p><h3 id="4-5-2-行列转换"><a href="#4-5-2-行列转换" class="headerlink" title="4.5.2　行列转换"></a>4.5.2　行列转换</h3><p>在Pandas处理数据过程中，有时需要对数据进行行列转换或重排，主要使用stack()方法、unstack()方法和pivot()方法，下面介绍这3种方法的应用。</p><h4 id="1．stack-方法"><a href="#1．stack-方法" class="headerlink" title="1．stack()方法"></a>1．stack()方法</h4><p>stack()方法用于将原来的列索引转换成最内层的行索引，转换效果对比示意图如图4.31所示。</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020045215351.png" alt="image-20211020045215351"></p><p>​                               图4.31　转换效果对比示意图<br>stack()方法的语法如下：</p><p>DataFrame.stack(level=-1, dropna=True)<br>参数说明：　</p><p>level：索引层级，定义为一个索引或标签，或索引或标签列表，默认值是-1。　</p><p>dropna：布尔型，默认值是True，　</p><p>返回值：DataFrame对象或Series对象。</p><p>【示例29】　对英语成绩表进行行列转换。（示例位置：资源包\MR\Code\04\29）<br>将学生英语成绩表进行行列转换，程序代码如下：</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020045321517.png" alt="image-20211020045321517"></p><h4 id="2．unstack-方法"><a href="#2．unstack-方法" class="headerlink" title="2．unstack()方法"></a>2．unstack()方法</h4><p>unstack()方法与stack()方法相反，它是stack()方法的逆操作，即将最内层的行索引转换成列索引，转换效果对比如图4.32所示。</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020045341690.png" alt="image-20211020045341690"></p><p>​                   图4.32　unstack()方法转换数据示意图<br>unstack()方法的语法如下：</p><p>DataFrame.unstack(level=-1, fill_value=None)<br>参数说明：　</p><p>level：索引层级，定义为一个索引或标签，或索引或标签列表，默认值是-1。　</p><p>fill_value：整型、字符串或字典，如果unstack()方法产生丢失值，则用这个值替换NaN。　返回值：DataFrame对象或Series对象。</p><p>【示例30】　使用unstack()方法转换学生成绩表。（示例位置：资源包\MR\Code\04\30）<br>同样转换学生成绩表，主要代码如下：</p><p>01 df=pd.read_excel(‘grade.xls’,sheet_name=’英语2’)      #导入Excel文件<br>02 df = df.set_index([‘班级’,’序号’,’Unnamed: 2’])       #设置多级索引<br>03 print(df.unstack())<br>unstack()方法中有一个参数可以指定转换第几层索引，例如，unstack(0)就是把第一层行索引转换为列索引，默认是将最内层索引转换为列索引。</p><h4 id="3．pivot-方法"><a href="#3．pivot-方法" class="headerlink" title="3．pivot()方法"></a>3．pivot()方法</h4><p>pivot()方法针对列的值，即指定某列的值作为行索引，指定某列的值作为列索引，然后再指定哪些列作为索引对应的值。unstack()方法针对索引进行操作，pivot()方法针对值进行操作。但实际上，二者的功能往往可以互相实现。<br>pivot()方法的语法如下：</p><p>DataFrame.pivot(index=None, columns=None, values=None)<br>参数说明：　</p><p>index：字符串或对象，可选参数。列用于创建新DataFrame数据的索引。如果没有，则使用现有索引。　</p><p>columns：字符串或对象，列用于创建新DataFrame的列。　</p><p>values：列用于填充新DataFrame的值，如果未指定，则将使用所有剩余的列，结果将具有分层索引列。　</p><p>返回值：DataFrame对象或Series对象。</p><p>【示例31】　使用pivot()方法转换学生成绩表。（示例位置：资源包\MR\Code\04\31）<br>使用pivot()方法转换学生成绩表，主要代码如下：</p><p>01 df=pd.read_excel(‘grade.xls’,sheet_name=’英语3’)         #导入Excel文件<br>02 df1=df.pivot(index=’序号’,columns=’班级’,values=’得分’)<br>运行程序，输出结果如图4.33所示。</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020045550818.png" alt="image-20211020045550818"></p><p>图4.33　使用pivot()方法转换学生成绩表</p><h3 id="4-5-3-DataFrame转换为字典"><a href="#4-5-3-DataFrame转换为字典" class="headerlink" title="4.5.3　DataFrame转换为字典"></a>4.5.3　DataFrame转换为字典</h3><p>DataFrame转换为字典主要使用DataFrame对象的to_dict()方法，以索引作为字典的键（key），以列作为字典的值（value）。例如，有一个DataFrame对象（索引为“类别”、列为“数量”），通过to_dict()方法就会生成一个字典，示意图如图4.34所示。如果DataFrame对象包含两列，那么to_dict()方法就会生成一个两层的字典（dict），第一层是列名作为字典的键（key），第二层以索引列的值作为字典的键（key），以列值作为字典的值（value）。</p><p>【示例32】　将Excel销售数据转换为字典。（示例位置：资源包\MR\Code\04\32）<br>使用to_dict()方法将按“宝贝标题”分组统计后的部分数据转换为字典，程序代码如下：</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020045613721.png" alt="image-20211020045613721"></p><p>运行程序，控制台输出结果如图4.35所示。</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020045643137.png" alt="image-20211020045643137"></p><p>​                       图4.34　DataFrame转换为字典示意图</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020045702961.png" alt="image-20211020045702961"></p><p>​                           图4.35　DataFrame转换为字典</p><h3 id="4-5-4-DataFrame转换为列表"><a href="#4-5-4-DataFrame转换为列表" class="headerlink" title="4.5.4　DataFrame转换为列表"></a>4.5.4　DataFrame转换为列表</h3><p>DataFrame转换为列表主要使用DataFrame对象的tolist()方法。</p><p>【示例33】　将电商数据转换为列表。（示例位置：资源包\MR\Code\04\33）<br>将淘宝销售数据中的“买家会员名”转换为列表，程序代码如下：</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020045737401.png" alt="image-20211020045737401"></p><p>运行程序，控制台输出结果如图4.36所示。</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020045806297.png" alt="image-20211020045806297"></p><p>图4.36　DataFrame转换为列表</p><h3 id="4-5-5-DataFrame转换为元组"><a href="#4-5-5-DataFrame转换为元组" class="headerlink" title="4.5.5　DataFrame转换为元组"></a>4.5.5　DataFrame转换为元组</h3><p>DataFrame转换为元组，首先通过循环语句按行读取DataFrame数据，然后使用元组函数tuple()将其转换为元组。</p><p>【示例34】　将Excel数据转换为元组。（示例位置：资源包\MR\Code\04\34）<br>将Excel表中的人物关系部分数据转换成元组，程序代码如下：</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020045832962.png" alt="image-20211020045832962"></p><p>运行程序，控制台输出结果如图4.37所示。</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020045913740.png" alt="image-20211020045913740"></p><p>​                            图4.37　DataFrame转换为元组</p><h3 id="4-5-6-Excel转换为HTML网页格式"><a href="#4-5-6-Excel转换为HTML网页格式" class="headerlink" title="4.5.6　Excel转换为HTML网页格式"></a>4.5.6　Excel转换为HTML网页格式</h3><p>日常工作中，有时会涉及财务数据的处理，而Excel应用最为广泛，但是对于展示数据来说，Excel并不友好，如果你想用其他格式的文件来向用户展示，那么，HTML网页格式是不错的选择。首先使用read_excel()方法导入Excel文件，然后使用to_html()方法将DataFrame数据导出为HTML格式，这样便实现了Excel转换为HTML格式。</p><p>【示例35】　将Excel订单数据转换为HTML网页格式。（示例位置：资源包\MR\Code\04\35）<br>将淘宝部分订单数据转换为HTML网页格式，效果如图4.38所示。</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020045939834.png" alt="image-20211020045939834"></p><p>​                              图4.38　Excel转换为HTML网页格式<br>程序代码如下：</p><p>01 import pandas as pd<br>02 df=pd.read_excel(‘mrbooks.xls’)<br>03 df.to_html(‘mrbook.html’,header = True,index = False)</p><h2 id="4-6-数据合并"><a href="#4-6-数据合并" class="headerlink" title="4.6　数据合并"></a>4.6　数据合并</h2><p>DataFrame数据合并主要使用merge()方法和concat()方法。</p><h3 id="4-6-1-数据合并（merge-方法）"><a href="#4-6-1-数据合并（merge-方法）" class="headerlink" title="4.6.1　数据合并（merge()方法）"></a>4.6.1　数据合并（merge()方法）</h3><p>Pandas模块的merge()方法是按照两个DataFrame对象列名相同的列进行连接合并，两个DataFrame对象必须具有同名的列。merge()方法的语法如下：</p><p>pandas.merge(right,how=’inner’,on=None,left_on=None,right_on=None,left_index=False,right_index=False,sort=False,suffixes=(‘_x’,’_y’),copy=True,indicator=False,validate=None)<br>参数说明：　</p><p>right：合并对象，DataFrame对象或Series对象。　</p><p>how：合并类型，参数值可以是left（左合并）、right（右合并）、outer（外部合并）或inner（内部合并），默认值为inner。各个值的说明如下。　</p><p>​        left：只使用来自左数据集的键，类似于SQL左外部联接，保留键的顺序。　</p><p>​        right：只使用来自右数据集的键，类似于SQL右外部联接，保留键的顺序。　</p><p>​        outer：使用来自两个数据集的键，类似于SQL外部联接，按字典顺序对键进行排序。　</p><p>​        inner：使用来自两个数据集的键的交集，类似于SQL内部连接，保持左键的顺序。</p><p>on：标签、列表或数组，默认值为None。DataFrame对象连接的列或索引级别名称。也可以是DataFrame对象长度的数组或数组列表。</p><p>left_on：标签、列表或数组，默认值为None。要连接的左数据集的列或索引级名称，也可以是左数据集长度的数组或数组列表。　</p><p>right_on：标签、列表或数组，默认值为None。要连接的右数据集的列或索引级名称，也可以是右数据集长度的数组或数组列表。　</p><p>left_index：布尔型，默认值为False。使用左数据集的索引作为连接键。如果是多重索引，则其他数据中的键数（索引或列数）必须匹配索引级别数。</p><p>right_index：布尔型，默认值为False，使用右数据集的索引作为连接键。　</p><p>sort：布尔型，默认值为False，在合并结果中按字典顺序对连接键进行排序。如果值为False，则连接键的顺序取决于连接类型how参数。　suffixes：元组类型，默认值为(‘_x’,’_y’)。当左侧数据集和右侧数据集的列名相同时，数据合并后列名将带上“_x”和“_y”后缀。　</p><p>copy：是否复制数据，默认值为True。如果值为False，则不复制数据。　</p><p>indicator：布尔型或字符串，默认值为False。如果值为True，则添加一个列以输出名为_Merge的DataFrame对象，其中包含每一行的信息。如果是字符串，将向输出的DataFrame对象中添加包含每一行信息的列，并将列命名为字符型的值。　</p><p>validate：字符串，检查合并数据是否为指定类型。可选参数，其值说明如下。　one_to_one或“1:1”：检查合并键在左、右数据集中是否都是唯一的。　one_to_many或“1:m”：检查合并键在左数据集中是否唯一。　many_to_one或“m:1”：检查合并键在右数据集中是否唯一。　many_to_many或“m:m”：允许，但不检查。　</p><p>返回值：DataFrame对象，两个合并对象的数据集。</p><h4 id="1．常规合并"><a href="#1．常规合并" class="headerlink" title="1．常规合并"></a>1．常规合并</h4><p>【示例36】　合并学生成绩表。（示例位置：资源包\MR\Code\04\36）<br>假设一个DataFrame对象包含了学生的“语文”“数学”“英语”成绩，而另一个DataFrame对象则包含了学生的“体育”成绩，现在将它们合并，示意图如图4.39所示。</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020050304612.png" alt="image-20211020050304612"></p><p>​                 图4.39　数据合并效果对比示意图<br>程序代码如下：</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020050326358.png" alt="image-20211020050326358"></p><p>运行程序，控制台输出结果如图4.40所示。</p><p>【示例37】　通过索引合并数据。（示例位置：资源包\MR\Code\04\37）<br>如果通过索引列合并，则需要设置right_index参数和left_index参数值为True。例如，上述举例，通过列索引合并，主要代码如下：</p><p>01 df_merge=pd.merge(df1,df2,right_index=True,left_index=True)<br>02 print(df_merge)<br>运行程序，控制台输出结果如图4.41所示。</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020050352118.png" alt="image-20211020050352118"></p><p>​                           图4.40　合并结果</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020050412167.png" alt="image-20211020050412167"></p><p>​                            图4.41　通过索引列合并</p><p>【示例38】　对合并数据去重。（示例位置：资源包\MR\Code\04\38）<br>从图4.41中的运行结果得知：数据中存在重复列（如编号），如果不想要重复列，可以设置按指定列和列索引合并数据，主要代码如下：</p><p>df_merge=pd.merge(df1,df2,on=’编号’,left_index=True,right_index=True)</p><p>还可以通过how参数解决这一问题。例如，设置该参数值为left，就是让df1保留所有的行列数据，df2则根据df1的行列进行补全，主要代码如下：</p><p>df_merge=pd.merge(df1,df2,on=’编号’,how=’left’)<br>运行程序，控制台输出结果如图4.42所示。</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020050506047.png" alt="image-20211020050506047"></p><p>图4.42　合并结果</p><h4 id="2．多对一的数据合并"><a href="#2．多对一的数据合并" class="headerlink" title="2．多对一的数据合并"></a>2．多对一的数据合并</h4><p>多对一是指两个数据集（df1、df2）的共有列中的数据不是一对一的关系，例如，df1中的“编号”是唯一的，而df2中的“编号”有重复的编号，类似这种就是多对一的关系，示意图如图4.43所示。【示例39】　根据共有列进行合并数据。（示例位置：资源包\MR\Code\04\39）<br>根据共有列中的数据进行合并，df2根据df1的行列进行补全，程序代码如下：</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020050528714.png" alt="image-20211020050528714"></p><p>运行程序，控制台输出结果如图4.44所示。</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020050545631.png" alt="image-20211020050545631"></p><p>​                                     图4.43　多对一合并示意图</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020050604101.png" alt="image-20211020050604101"></p><p>​                                  图4.44　合并结果</p><h4 id="3．多对多的数据合并"><a href="#3．多对多的数据合并" class="headerlink" title="3．多对多的数据合并"></a>3．多对多的数据合并</h4><p>多对多是指两个数据集（df1、df2）的共有列中的数据不全是一对一的关系，都有重复数据，例如“编号”，示图如图4.45所示。</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020050702131.png" alt="image-20211020050702131"></p><p>​                                    图4.45　多对多示意图</p><p>【示例40】　合并数据并相互补全。（示例位置：资源包\MR\Code\04\40）<br>根据共有列中的数据进行合并，df2、df1相互补全，程序代码如下：</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020050733884.png" alt="image-20211020050733884"></p><p>运行程序，控制台输出结果如图4.46所示。</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020050749641.png" alt="image-20211020050749641"></p><p>​                                               图4.46　合并结果</p><h3 id="4-6-2-数据合并（concat-方法）"><a href="#4-6-2-数据合并（concat-方法）" class="headerlink" title="4.6.2　数据合并（concat()方法）"></a>4.6.2　数据合并（concat()方法）</h3><p>concat()方法可以根据不同的方式将数据合并，语法如下：</p><p>pandas.concat(objs,axis=0,join=’outer’,ignore_index: bool = False, keys=None, levels=None, names=None,<br>verify_integrity: bool = False, sort: bool = False, copy: bool = True)<br>参数说明：　</p><p>objs：Series、DataFrame或Panel对象的序列或映射。如果传递一个字典，则排序的键将用作键参数。　</p><p>axis：axis=1表示行，axis=0表示列。默认值为0。　</p><p>join：值为inner（内连接）或outer（外连连接），处理其他轴上的索引方式。默认值为outer。　</p><p>ignore_index：布尔值，默认值为False，保留索引，索引值为0，…，n-1。如果值为True，则忽略索引。　</p><p>keys：序列，默认值为None。使用传递的键作为最外层构建层次索引。如果为多索引，应该使用元组。　</p><p>levels：序列列表，默认值为None。用于构建MultiIndex的特定级别（唯一值）；否则，它们将从键推断。　</p><p>names：list列表，默认值为None。结果层次索引中的级别的名称。　verify_integrity：布尔值，默认值为False。检查新连接的轴是否包含重复项。　</p><p>sort：布尔值，默认值为True（1.0.0以后版本默认值为False，即不排序）。如果连接为外连接（join=’outer’），则对未对齐的非连接轴进行排序；如果连接为内连接（join=’inner’），则该参数不起作用。</p><p>copy：是否复制数据，默认值为True，如果值为False，则不复制数据。</p><p>下面介绍concat()方法不同的合并方式，其中dfs代表合并后的DataFrame对象，df1、df2等代表单个DataFrame对象，result代表合并后的结果（DataFrame对象）。</p><h4 id="1．相同字段的表首尾相接"><a href="#1．相同字段的表首尾相接" class="headerlink" title="1．相同字段的表首尾相接"></a>1．相同字段的表首尾相接</h4><p>表结构相同的数据将直接合并，表首尾相接，主要代码如下：</p><p>01  dfs= [df1, df2, df3]<br>02  result = pd.concat(dfs)<br>例如，表df1、df2和df3结构相同，如图4.47所示。合并后的效果如图4.48所示。如果想要在合并数据时标记源数据来自哪张表，则需要在代码中加入参数keys，例如表名分别为“1月”“2月”“3月”，合并后的效果如图4.49所示。</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020051001176.png" alt="image-20211020051001176"></p><p>​                          图4.47　3张相同字段的表</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020051019220.png" alt="image-20211020051019220"></p><p>​                                     图4.48　首尾相接合并后的效果</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020051035379.png" alt="image-20211020051035379"></p><p>​                        图4.49　合并后带标记（月份）的效果<br>主要代码如下：</p><p>result = pd.concat(dfs, keys=[‘1月’, ‘2月’, ‘3月’])</p><h4 id="2．横向表合并（行对齐）"><a href="#2．横向表合并（行对齐）" class="headerlink" title="2．横向表合并（行对齐）"></a>2．横向表合并（行对齐）</h4><p>当合并的数据列名称不一致时，可以设置参数axis=1，concat()方法将按行对齐，然后将不同列名的两组数据进行合并，缺失的数据用NaN填充，df1和df4合并前后效果如图4.50和图4.51所示。</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020051057217.png" alt="image-20211020051057217"></p><p>​                        图4.50　横向表合并前</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020051113896.png" alt="image-20211020051113896"></p><p>​                            图4.51　横向表合并后<br>主要代码如下：</p><p>result = pd.concat([df1, df4], axis=1)</p><h4 id="3．交叉合并"><a href="#3．交叉合并" class="headerlink" title="3．交叉合并"></a>3．交叉合并</h4><p>交叉合并，需要在代码中加上join参数，如果值为inner，结果是两张表的交集；如果值为outer，结果是两张表的并集。例如两张表交集，表df1和df4合并前后的效果如图4.52和图4.53所示。</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020051227829.png" alt="image-20211020051227829"></p><p>​                                   图4.52　交叉合并前</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020051243654.png" alt="image-20211020051243654"></p><p>​                                       图4.53　交叉合并后<br>主要代码如下：</p><p>result = pd.concat([df1, df4], axis=1, join=’inner’)</p><h4 id="4．指定表对齐数据（行对齐）"><a href="#4．指定表对齐数据（行对齐）" class="headerlink" title="4．指定表对齐数据（行对齐）"></a>4．指定表对齐数据（行对齐）</h4><p>如果指定参数join_axes，就可以指定根据哪张表来对齐数据。例如，根据df4对齐数据，就会保留表df4的数据，然后将表df1的数据与之合并，行数不变，合并前后的效果与如图4.54和图4.55所示。</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020051305083.png" alt="image-20211020051305083"></p><p>​                          图4.54　指定表对齐数据合并前</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020051320918.png" alt="image-20211020051320918"></p><p>​                           图4.55　指定表对齐数据合并后<br>主要代码如下：</p><p>result = pd.concat([df1, df4], axis=1, join_axes=[df4.index])</p><h2 id="4-7-数据导出"><a href="#4-7-数据导出" class="headerlink" title="4.7　数据导出"></a>4.7　数据导出</h2><h3 id="4-7-1-导出为-xlsx文件"><a href="#4-7-1-导出为-xlsx文件" class="headerlink" title="4.7.1　导出为.xlsx文件"></a>4.7.1　导出为.xlsx文件</h3><p>导出数据为Excel，主要使用DataFrame对象的to_excel()方法，语法如下：</p><p>DataFrame.to_excel(excel_writer,sheet_name=’Sheet1’,na_rep=’’,float_format=None,columns=None,header=True,<br>index=True,index_label=None,startrow=0,startcol=0,engine=None,merge_cells=True, encoding=None, inf_rep=’inf’,<br>verbose=True, freeze_panes=None)<br>参数说明：　</p><p>excel_writer：字符串或ExcelWriter对象。　</p><p>sheet_name：字符串，默认值为Sheet1，包含DataFrame的表的名称。　</p><p>na_rep：字符串，默认值为’ ‘。缺失数据的表示方式。　</p><p>float_format：字符串，默认值为None，格式化浮点数的字符串。　columns：序列，可选参数，要编辑的列。　</p><p>header：布尔型或字符串列表，默认值为True。列名称，如果给定字符串列表，则表示它是列名称的别名。　</p><p>index：布尔型，默认值为True，行名（索引）。　</p><p>index_label：字符串或序列，默认值为None。如果需要，可以使用索引列的列标签；如果没有给出，标题和索引为True，则使用索引名称；如果数据文件使用多索引，则需使用序列。</p><p>startrow：指定从哪一行开始写入数据。　</p><p>startcol：指定从哪一列开始写入数据。　</p><p>engine：字符串，默认值为None，指定要使用的写引擎，如openpyxl或xlsxwriter。也可以通过io.excel.xlsx.writer、io.excel.xls.writer和io.excel.xlsm.writer进行设置。　</p><p>merge_cells：布尔型，默认值为True。　</p><p>encoding：指定Excel文件的编码方式，默认值为None。　</p><p>inf_rep：字符串，默认值为“正”，表示无穷大。　</p><p>verbose：布尔型，默认值为True。在错误日志中显示更多信息。　freeze_panes：整数的元组，长度2，默认值为None。指定要冻结的行列。</p><p>【示例41】　将处理后的数据导出为Excel文件。（示例位置：资源包\MR\Code\04\41）<br>将数据合并后的结果导出为Excel文件，主要代码如下：</p><p>df_merge.to_excel(‘merge.xlsx’)<br>运行程序，数据将导出为Excel文件，如图4.56所示。</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020051510137.png" alt="image-20211020051510137"></p><p>​                         图4.56　导出为Excel文件</p><p>上述举例，如果需要指定Sheet页名称，可以通过sheet_name参数指定，主要代码如下：</p><p>df1.to_excel(‘df1.xlsx’,sheet_name=’df1’)</p><h3 id="4-7-2-导出为-csv文件"><a href="#4-7-2-导出为-csv文件" class="headerlink" title="4.7.2　导出为.csv文件"></a>4.7.2　导出为.csv文件</h3><p>导出数据为.csv文件，主要使用DataFrame对象的to_csv()方法，语法如下：</p><p>DataFrame.to_csv(path_or_buf=None,sep=’,’,na_rep=’’,float_format=None,columns=None,header=True,index=<br>True,index_label=None,mode=’w’,encoding=None,compression=’infer’,quoting=None,quotechar=’”‘,line_terminator=<br>None,chunksize=None,date_format=None,doublequote=True, escapechar=None, decimal=’.’,errors=’strict’)<br>参数说明：　</p><p>path_or_buf：要保存的路径及文件名。　</p><p>sep：分隔符，默认值为”,”。　</p><p>na_rep：指定空值的输出方式，默认值为空字符串。　</p><p>float_format：浮点数的输出格式，要用双引号括起来。　</p><p>columns：指定要导出的列，用列名列表表示，默认值为None。　</p><p>header：是否输出列名，默认值为True。　</p><p>index：是否输出索引，默认值为True。　</p><p>index_label：索引列的列名，默认值为None。　</p><p>mode：Python写入模式，默认值为w。　</p><p>encoding：编码方式，默认值为utf-8。　</p><p>compression：压缩模式，默认值为infer。　</p><p>quoting：导出.csv文件是否用引号，默认值为0，表示不加双引号；如果值为1，则每个字段都会加上引号，数值也会被当作字符串看待。</p><p>quotechar：引用字符，当quoting=1时可以指定引号字符为双引号（” “）或单引号（’ ‘）。　</p><p>line_terminator：换行符，默认值为\n。</p><p>chunksize：一次写入.csv文件的行数，当DataFrame对象数据特别大时需要分批写入。　</p><p>date_format：日期输出格式。　</p><p>doublequote：是否添加双引用符，默认值为True。　</p><p>escapechar：设置转义字符。　</p><p>decimal：可识别十进制分隔符的字符。　</p><p>errors：指定如何处理编码和解码错误，默认值为strict（严格的）。</p><p>【示例42】　将处理后的数据导出为.csv文件。（示例位置：资源包\MR\Code\04\42）<br>下面介绍to_csv()方法常用功能，举例如下，df为DataFrame对象。<br>（1）相对位置，保存在程序所在路径下，代码如下：</p><p>df.to_csv(‘Result.csv’)<br>（2）绝对位置，代码如下：</p><p>df.to_csv(‘d:\Result.csv’)<br>（3）分隔符。使用问号（？）分隔符分隔需要保存的数据，代码如下：</p><p>df.to_csv(‘Result.csv’,sep=’?’)<br>（4）替换空值，缺失值保存为NA，代码如下：</p><p>df.to_csv(‘Result1.csv’,na_rep=’NA’)<br>（5）格式化数据，保留两位小数，代码如下：</p><p>df.to_csv(‘Result1.csv’,float_format=’%.2f’)<br>（6）保留某列数据，保存索引列和name列，代码如下：</p><p>df.to_csv(‘Result.csv’,columns=[‘name’])<br>（7）是否保留列名，不保留列名，代码如下：</p><p>df.to_csv(‘Result.csv’,header=False)<br>（8）是否保留行索引，不保留行索引，代码如下：</p><p>df.to_csv(‘Result.csv’,index=False)</p><h3 id="4-7-3-导出多个Sheet"><a href="#4-7-3-导出多个Sheet" class="headerlink" title="4.7.3　导出多个Sheet"></a>4.7.3　导出多个Sheet</h3><p>导出多个Sheet，应首先使用pd.ExcelWriter()方法打开一个Excel文件，然后再使用to_excel()方法导出指定的Sheet。</p><p>【示例43】　导出Excel中多个Sheet页的数据。（示例位置：资源包\MR\Code\04\43）<br>导出指定Sheet页中的数据，主要代码如下：</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020051720411.png" alt="image-20211020051720411"></p><h2 id="4-8-日期数据处理"><a href="#4-8-日期数据处理" class="headerlink" title="4.8　日期数据处理"></a>4.8　日期数据处理</h2><h3 id="4-8-1-DataFrame的日期数据转换"><a href="#4-8-1-DataFrame的日期数据转换" class="headerlink" title="4.8.1　DataFrame的日期数据转换"></a>4.8.1　DataFrame的日期数据转换</h3><p>日常工作中，有一个非常麻烦的事情就是日期的格式可以有很多种表达，我们看到同样是2020年2月14日，可以有很多种格式，如图4.57所示。那么，我们需要先将这些格式统一后才能进行后续的工作。Pandas提供了to_datetime()方法可以帮助我们解决这一问题。<br>to_datetime()方法可以用来批量处理日期数据转换，对于处理大数据非常实用和方便，它可以将日期数据转换成你需要的各种格式。例如，将2/14/20和14-2-2020转换为日期格式2020-02-14。to_datetime()方法的语法如下：</p><p>pandas.to_datetime(arg,errors=’ignore’,dayfirst=False,yearfirst=False,utc=None,box=True,format=None,exact=<br>True,unit=None,infer_datetime_format=False,origin=’unix’,cache=False)<br>参数说明：　</p><p>arg：字符串、日期时间、字符串数组。　</p><p>errors：值为ignore、raise或coerce，具体说明如下，默认值为ignore，即忽略错误。　</p><p>ignore：无效的解析将返回原值。　</p><p>raise：无效的解析将引发异常。　</p><p>coerce：无效的解析将被设置为NaT，即无法转换为日期的数据将被转换为NaT。　</p><p>dayfirst：第一个为天，布尔型，默认值为False。例如02/09/2020，如果值为True，则解析日期的第一个为天，即2020-09-02；如果值为False，则解析日期与原日期一致，即2020-02-09。　</p><p>yearfirst：第一个为年，布尔型，默认值为False。例如14-Feb-20，如果值为True，则解析日期的第一个为年，即2014-02-20；如果值为False，则解析日期与原日期一致，即2020-02-14。　</p><p>utc：默认值为None。返回utc即协调世界时间。　</p><p>box：布尔值，默认值为True，如果值为True，则返回DatetimeIndex；如果值为False，则返回ndarray。　</p><p>format：格式化显示时间的格式。字符串，默认值为None。　</p><p>exact：布尔值，默认值为True。如果为True，则要求格式完全匹配；如果为False，则允许格式与目标字符串中的任何位置匹配。　</p><p>unit：默认值为None，参数的单位（D、s、、ms、μs、ns）表示时间的单位。　</p><p>infer_datetime_format：默认值为False。如果没有格式，则尝试根据第一个日期时间字符串推断格式。　</p><p>origin：默认值为unix。定义参考日期。数值将被解析为单位数。　</p><p>cache：默认值为False。如果值为True，则使用唯一、转换日期的缓存应用日期时间转换。在解析重复日期字符串，特别是带有时区偏移的字符串时，可能会产生明显的加速。只有在至少有50个值时才使用缓存。越界值的存在将使缓存不可用，并可能减慢解析速度。　</p><p>返回值：日期时间。</p><p>【示例44】　将各种日期字符串转换为指定的日期格式。（示例位置：资源包\MR\Code\04\44）<br>将2020年2月14日的各种格式转换为日期格式，程序代码如下：</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020051913944.png" alt="image-20211020051913944"></p><p>运行程序，控制台输出结果如图4.58所示。</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020051928130.png" alt="image-20211020051928130"></p><p>​                   图4.57　日期的多种格式转换</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020051944812.png" alt="image-20211020051944812"></p><p>​                 图4.58　2020年2月14日的各种格式转换为日期格式<br>还可以实现从DataFrame对象中的多列，如年、月、日各列组合成一列日期。键值是常用的日期缩略语。</p><p>组合要求：　</p><p>必选：year、month、day。　</p><p>可选：hour、minute、second、millisecond（毫秒）、microsecond（微秒）、nanosecond（纳秒）。</p><p>【示例45】　将一组数据组合为日期数据。（示例位置：资源包\MR\Code\04\45）<br>将一组数据组合为日期数据，主要代码如下：<br>运行程序，控制台输出结果如图4.59所示。</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020052022697.png" alt="image-20211020052022697"></p><p>​                                        图4.59　日期组合</p><h3 id="4-8-2-dt对象的使用"><a href="#4-8-2-dt对象的使用" class="headerlink" title="4.8.2　dt对象的使用"></a>4.8.2　dt对象的使用</h3><p>dt对象是Series对象中用于获取日期属性的一个访问器对象，通过它可以获取日期中的年、月、日、星期数、季节等，还可以判断日期是否处在年底。语法如下：</p><p>  Series.dt()<br>参数说明：　</p><p>返回值：返回与原始系列相同的索引系列。如果Series不包含类日期值，则引发错误。　</p><p>dt对象提供了year、month、day、dayofweek、dayofyear、is_leap_year、quarter、weekday_name等属性和方法。</p><p>例如，year可以获取“年”、month可以获取“月”、quarter可以直接得到每个日期分别是第几个季度，weekday_name可以直接得到每个日期对应的是周几。</p><p>【示例46】　获取日期中的年、月、日、星期数等。（示例位置：资源包\MR\Code\04\46）<br>使用dt对象获取日期中的年、月、日、星期数、季节等。<br>（1）获取年、月、日，代码如下：</p><p>df[‘年’],df[‘月’],df[‘日’]=df[‘日期’].dt.year,df[‘日期’].dt.month,df[‘日期’].dt.day<br>（2）从日期判断出所处星期数，代码如下：</p><p>df[‘星期几’]=df[‘日期’].dt.day_name()<br>（3）从日期判断所处季度，代码如下：</p><p>df[‘季度’]=df[‘日期’].dt.quarter<br>（4）从日期判断是否为年底最后一天，代码如下：</p><p>df[‘是否年底’]=df[‘日期’].dt.is_year_end<br>运行程序，控制台输出结果如图4.60所示。</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020052128703.png" alt="image-20211020052128703"></p><p>​                               图4.60　dt对象日期转换</p><h3 id="4-8-3-获取日期区间的数据"><a href="#4-8-3-获取日期区间的数据" class="headerlink" title="4.8.3　获取日期区间的数据"></a>4.8.3　获取日期区间的数据</h3><p>获取日期区间的数据的方法是直接在DataFrame对象中输入日期或日期区间，但前提必须设置日期为索引，举例如下。　</p><p>获取2018年的数据。</p><p>df1[‘2018’]　</p><p>获取2017—2018年的数据。</p><p>df1[‘2017’:’2018’]　</p><p>获取某月（2018年7月）的数据。</p><p>df1[‘2018-07’]　</p><p>获取具体某天（2018年5月6日）的数据。</p><p>df1[‘2018-05-06’:’2018-05-06’]</p><p>【示例47】　获取指定日期区间的订单数据。（示例位置：资源包\MR\Code\04\47）<br>获取2018年5月11日至6月10日的订单，结果如图4.61所示。<br>程序代码如下：</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020052236563.png" alt="image-20211020052236563"></p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020052256160.png" alt="image-20211020052256160"></p><p>​            图4.61　2018年5月11日至6月10日的订单（省略部分数据）</p><h3 id="4-8-4-按不同时期统计并显示数据"><a href="#4-8-4-按不同时期统计并显示数据" class="headerlink" title="4.8.4　按不同时期统计并显示数据"></a>4.8.4　按不同时期统计并显示数据</h3><h4 id="1．按时期统计数据"><a href="#1．按时期统计数据" class="headerlink" title="1．按时期统计数据"></a>1．按时期统计数据</h4><p>按时期统计数据主要通过DataFrame对象的resample()方法结合数据计算函数实现。resample()方法主要应用于时间序列频率转换和重采样，它可以从日期中获取年、月、日、星期、季节等，结合数据计算函数就可以实现按年、月、日、星期或季度等不同时期统计数据。举例如下所示。<br>（1）按年统计数据，代码如下：</p><p>df1=df1.resample(‘AS’).sum()<br>（2）按季度统计数据，代码如下：</p><p>df2.resample(‘Q’).sum()<br>（3）按月度统计数据，代码如下：</p><p>df1.resample(‘M’).sum()<br>（4）按星期统计数据，代码如下：</p><p>df1.resample(‘W’).sum()<br>（5）按天统计数据，代码如下：</p><p>df1.resample(‘D’).sum()</p><p>实用技巧<br>按日期统计数据过程中，可能会出现如图4.62所示的错误提示。</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020052356675.png" alt="image-20211020052356675"></p><p>图4.62　错误提示</p><p>完整错误描述：<br>TypeError: Only valid with DatetimeIndex, TimedeltaIndex or PeriodIndex, but got an instance of’Index’<br>出现上述错误，是由于resample()函数要求索引必须为日期型。<br>解决方法：将数据的索引转换为datetime类型，主要代码如下：</p><p>df1.index = pd.to_datetime(df1.index)</p><h4 id="2．按时期显示数据"><a href="#2．按时期显示数据" class="headerlink" title="2．按时期显示数据"></a>2．按时期显示数据</h4><p>DataFrame对象的to_period()方法可以将时间戳转换为时期，从而实现按时期显示数据，前提是日期必须设置为索引。语法如下：</p><p>DataFrame.to_period(freq=None, axis=0, copy=True)<br>参数说明：　</p><p>freq：字符串，周期索引的频率，默认值为None。　</p><p>axis：行列索引，axis=0表示行索引，axis=1表示列索引。默认值为0，即表示行索引。　</p><p>copy：是否复制数据，默认值为True，如果值为False，则不复制数据。　返回值：带周期索引的时间序列。</p><p>【示例48】　从日期中获取不同的时期。（示例位置：资源包\MR\Code\04\48）<br>从日期中获取不同的时期，主要代码如下：</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020052452293.png" alt="image-20211020052452293"></p><h4 id="3．按时期统计并显示数据"><a href="#3．按时期统计并显示数据" class="headerlink" title="3．按时期统计并显示数据"></a>3．按时期统计并显示数据</h4><p>（1）按年统计并显示数据，代码如下：</p><p>df2.resample(‘AS’).sum().to_period(‘A’)<br>控制台输出结果如图4.63所示。<br>（2）按季度统计并显示数据，代码如下：</p><p>Q_df=df2.resample(‘Q’).sum().to_period(‘Q’)</p><p>控制台输出结果如图4.64所示。</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020052536700.png" alt="image-20211020052536700"></p><p>​                            图4.63　按年统计并显示数据</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020052550813.png" alt="image-20211020052550813"></p><p>​                      图4.64　按季度统计并显示数据<br>（3）按月统计并显示数据，代码如下：</p><p>df2.resample(‘M’).sum().to_period(‘M’)<br>控制台输出结果如图4.65所示。<br>（4）按星期统计并显示数据（前5条数据），代码如下：</p><p>df2.resample(‘W’).sum().to_period(‘W’).head()<br>控制台输出结果如图4.66所示。</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020052622774.png" alt="image-20211020052622774"></p><p>​                          图4.65　按月统计并显示数据</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020052640893.png" alt="image-20211020052640893"></p><p>​                      图4.66　按星期统计并显示数据</p><h2 id="4-9-时间序列"><a href="#4-9-时间序列" class="headerlink" title="4.9　时间序列"></a>4.9　时间序列</h2><h3 id="4-9-1-重采样（Resample-方法）"><a href="#4-9-1-重采样（Resample-方法）" class="headerlink" title="4.9.1　重采样（Resample()方法）"></a>4.9.1　重采样（Resample()方法）</h3><p>通过前面的学习，我们学会了如何生成不同频率的时间索引，按小时、按天、按周、按月等，如果想对数据做不同频率的转换，该怎么办？在Pandas中对时间序列的频率的调整称为重新采样，即将时间序列从一个频率转换到另一个频率的处理过程。例如，每天一个频率转换为每5天一个频率，如图4.67所示。</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020052720517.png" alt="image-20211020052720517"></p><p>​                                       图4.67　时间频率<br>重采样主要使用resample()方法，该方法用于对常规时间序列重新采样和频率转换，包括降采样和升采样两种。首先了解下resample()方法，语法如下：</p><p>DataFrame.resample(rule,how=None,axis=0,fill_method=None,closed=None,label=None,convention=’start’,kind=<br>None,loffset=None,limit=None,base=0,on=None,level=None)<br>参数说明：　</p><p>rule：字符串，偏移量表示目标字符串或对象转换。　</p><p>how：用于产生聚合值的函数名或数组函数。例如mean、ohlc和np.max等，默认值为mean，其他常用的值为first、last、median、max和min。　</p><p>axis：整型，表示行列，axis=0表示列，axis=1表示行。默认值为0，即表示列。　fill_method：升采样时所使用的填充方法，ffill()方法（用前值填充）或bfill()方法（用后值填充），默认值为None。　</p><p>closed：降采样时，时间区间的开和闭，与数学里区间的概念一样，其值为right或left，right表示左开右闭（即左边值不包括在内），left表示左闭右开（即右边值不包括在内），默认值为right左开右闭。　</p><p>label：降采样时，如何设置聚合值的标签。例如，10:30—10:35会被标记成10:30还是10:35，默认值为None。　</p><p>convention：当重采样时，将低频率转换到高频率所采用的约定，其值为start或end，默认值为start。　</p><p>kind：聚合到时期（period）或时间戳（timestamp），默认聚合到时间序列的索引类型，默认值为None。　</p><p>loffset：聚合标签的时间校正值，默认值为None。例如，-1s或Second(-1)用于将聚合标签调早1秒。　</p><p>limit：向前或向后填充时，允许填充的最大时期数，默认值为None。</p><p>　base：整型，默认值为0。对于均匀细分1天的频率，聚合间隔的“原点”。例如，对于5min频率，base的范围可以是0～4。　on：字符串，可选参数，默认值为None。对DataFrame对象使用列代替索引进行重新采样。列必须与日期时间类似。　</p><p>level：字符串或整型，可选参数，默认值为None。用于多索引，重新采样的级别名称或级别编号，级别必须与日期时间类似。　</p><p>返回值：重新采样对象。</p><p>【示例49】　一分钟的时间序列转换为3分钟的时间序列。（示例位置：资源包\MR\Code\04\49）<br>首先创建一个包含9个一分钟的时间序列，然后使用resample()方法转换为3分钟的时间序列，并对索引列进行求和计算，如图4.68所示。</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020052840027.png" alt="image-20211020052840027"></p><p>​                          图4.68　时间序列转换<br>程序代码如下：</p><p>01  import pandas as pd<br>02  index = pd.date_range(‘02/02/2020’, periods=9, freq=’T’)</p><p>03  series = pd.Series(range(9), index=index)<br>04  print(series)<br>05  print(series.resample(‘3T’).sum())</p><h3 id="4-9-2-降采样处理"><a href="#4-9-2-降采样处理" class="headerlink" title="4.9.2　降采样处理"></a>4.9.2　降采样处理</h3><p>降采样是周期由高频率转向低频率。例如，将5min股票交易数据转换为日交易，按天统计的销售数据转换为按周统计。<br>数据降采样会涉及数据的聚合。例如，天数据变成周数据，那么就要对1周7天的数据进行聚合，聚合的方式主要包括求和、求均值等。例如，淘宝店铺每天销售数据（部分数据），如图4.69所示。</p><p>【示例50】　按周统计销售数据。（示例位置：资源包\MR\Code\04\50）<br>使用resample()方法来做降采样处理，频率为“周”，也就是将上述销售数据处理为每周（每7天）求和一次数据，程序代码如下：</p><p>01 import pandas as pd<br>02 df=pd.read_excel(‘time.xls’)<br>03 df1 = df.set_index(‘订单付款时间’)  #设置“订单付款时间”为索引<br>04 print(df1.resample(‘W’).sum().head())<br>运行程序，控制台输出结果如图4.70所示。<br>在参数说明中，我们列出了closed参数的解释，如果把closed参数值设置为left，结果如图4.71所示。</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020052938423.png" alt="image-20211020052938423"></p><p>​              图4.69　淘宝店铺每天销售数据（部分数据）</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020053019859.png" alt="image-20211020053019859"></p><p>​                                       图4.70　周数据统计1</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020053036196.png" alt="image-20211020053036196"></p><p>​                              图4.71　周数据统计2</p><h3 id="4-9-3-升采样处理"><a href="#4-9-3-升采样处理" class="headerlink" title="4.9.3　升采样处理"></a>4.9.3　升采样处理</h3><p>升采样是周期由低频率转向高频率。将数据从低频率转换到高频率时，就不需要聚合了，将其重采样到日频率，默认会引入缺失值。<br>例如，原来是按周统计的数据，现在变成按天统计。升采样会涉及数据的填充，根据填充的方法不同，填充的数据也不同。下面介绍3种填充方法。　不填充。空值用NaN代替，使用asfreq()方法。　用前值填充。用前面的值填充空值，使用ffill()方法或者pad()方法。为了方便记忆，ffill()方法可以使用它的第一个字母“f”代替，代表forward，向前的意思。　用后值填充，使用bfill()方法，可以使用字母“b”代替，代表back，向后的意思。</p><p>【示例51】　每6小时统计一次数据。（示例位置：资源包\MR\Code\04\51）<br>下面创建一个时间序列，起始日期是2020-02-02，一共两天，每天对应的数值分别是1和2，通过升采样处理为每6小时统计一次数据，空值以不同的方式填充，程序代码如下：</p><p>01  import pandas as pd<br>02  import numpy as np<br>03  rng = pd.date_range(‘20200202’, periods=2)<br>04  s1 = pd.Series(np.arange(1,3), index=rng)</p><p>05  s1_6h_asfreq = s1.resample(‘6H’).asfreq()</p><p>06  print(s1_6h_asfreq)</p><p>07  s1_6h_pad = s1.resample(‘6H’).pad()<br>08  print(s1_6h_pad)</p><p>09  s1_6h_ffill = s1.resample(‘6H’).ffill()<br>10  print(s1_6h_ffill)</p><p>11  s1_6h_bfill = s1.resample(‘6H’).bfill()<br>12  print(s1_6h_bfill)<br>运行程序，控制台输出结果如图4.72所示。</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020053124798.png" alt="image-20211020053124798"></p><p>​                          图4.72　6小时数据统计</p><h3 id="4-9-4-时间序列数据汇总（ohlc-函数）"><a href="#4-9-4-时间序列数据汇总（ohlc-函数）" class="headerlink" title="4.9.4　时间序列数据汇总（ohlc()函数）"></a>4.9.4　时间序列数据汇总（ohlc()函数）</h3><p>在金融领域，经常会看到开盘（open）、收盘（close）、最高价（high）和最低价（low）数据，而在Pandas中经过重新采样的数据也可以实现这样的结果，通过调用ohlc()函数得到数据汇总结果，即开始值（open）、结束值（close）、最高值（high）和最低值（low）。ohlc()函数的语法如下：</p><p>resample.ohlc()<br>ohlc()函数返回DataFrame对象，每组数据的open（开）、high（高）、low（低）和close（关）值。</p><p>【示例52】　统计数据的open、high、low和close值。（示例位置：资源包\MR\Code\04\52）<br>下面是一组5分钟的时间序列，通过ohlc()函数获取该时间序列中每组时间的开始值、最高值、最低值和结束值，程序代码如下：</p><p>01  import pandas as pd<br>02  import numpy as np<br>03  rng = pd.date_range(‘2/2/2020’,periods=12,freq=’T’)<br>04  s1 = pd.Series(np.arange(12),index=rng)<br>05  print(s1.resample(‘5min’).ohlc())<br>运行程序，控制台输出结果如图4.73所示。</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020053212045.png" alt="image-20211020053212045"></p><p>​                          图4.73　时间序列数据汇总</p><h3 id="4-9-5-移动窗口数据计算（rolling-函数）"><a href="#4-9-5-移动窗口数据计算（rolling-函数）" class="headerlink" title="4.9.5　移动窗口数据计算（rolling()函数）"></a>4.9.5　移动窗口数据计算（rolling()函数）</h3><p>通过重采样可以得到想要的任何频率的数据，但是这些数据也是一个时点的数据，那么就存在这样一个问题：时点的数据波动较大，某一点的数据就不能很好地表现它本身的特性，于是就有了“移动窗口”的概念，简单地说，为了提升数据的可靠性，将某个点的取值扩大到包含这个点的一段区间，用区间来进行判断，这个区间就是窗口。<br>下面举例说明，图4.74显示了移动窗口数据示意图，其中时间序列代表1号到15号每天的销量数据，接下来以3天为一个窗口，将该窗口从左至右依次移动，统计出3天的平均值作为这个点的值，如3号的销量是1号、2号和3号的平均值。</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020053234231.png" alt="image-20211020053234231"></p><p>​                      图4.74　移动窗口数据示意图<br>通过上述示意图相信您已经理解了移动窗口，在Pandas中可以通过rolling()函数实现移动窗口数据的计算，语法如下：</p><p>DataFrame.rolling(window, min_periods=None, center=False, win_type=None, on=None, axis=0, closed=None)</p><p>参数说明：　</p><p>window：时间窗口的大小，有两种形式，即int或offset。如果使用int，则数值表示计算统计量的观测值的数量，即向前几个数据；如果使用offset，则表示时间窗口的大小。　</p><p>min_periods：每个窗口最少包含的观测值数量，小于这个值的窗口结果为NA。值可以是int，默认值为None。offset情况下，默认值为1。</p><p>center：把窗口的标签设置为居中。布尔型，默认值为False，居右。</p><p>win_type：窗口的类型。截取窗的各种函数。字符串类型，默认值为None。　</p><p>on：可选参数。对于DataFrame对象，是指定要计算移动窗口的列，值为列名。　</p><p>axis：整型，axis=0表示列，axis=1表示行。默认值为0，即对列进行计算。　</p><p>closed：定义区间的开闭，支持int类型的窗口。对于offset类型默认是左开右闭（默认值为right）。可以根据情况指定left。　</p><p>返回值：为特定操作而生成的窗口或移动窗口子类。</p><p>【示例53】　创建淘宝每日销量数据。（示例位置：资源包\MR\Code\04\53）<br>首先创建一组淘宝每日销量数据，程序代码如下：</p><p>01  import pandas as pd<br>02  index=pd.date_range(‘20200201’,’20200215’)<br>03  data=[3,6,7,4,2,1,3,8,9,10,12,15,13,22,14]<br>04  s1_data=pd.Series(data,index=index)<br>05  print(s1_data)<br>运行程序，控制台输出结果如图4.75所示。</p><p>【示例54】　使用rolling()函数计算3天的均值。（示例位置：资源包\MR\Code\04\54）</p><p>下面使用rolling()函数计算2020-02-01至2020-02-15中每3天的均值，窗口个数为3，代码如下：</p><p>s1_data.rolling(3).mean()<br>运行程序，看下rolling()函数是如何计算的？在图4.76中，当窗口开始移动时，第一个时间点2020-02-01和第二个时间点2020-02-02的数值为空，这是因为窗口个数为3，它们前面有空数据，所以均值为空；而到第三个时间点2020-02-03时，它前面的数据是2020-02-01至2020-02-03，所以3天的均值是5.333333；以此类推。</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020053403924.png" alt="image-20211020053403924"></p><p>​                                     图4.75　原始数据</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020053419587.png" alt="image-20211020053419587"></p><p>​                       图4.76　2020-02-01至2020-02-15移动窗口均值1</p><p>【示例55】　用当天的数据代表窗口数据。（示例位置：资源包\MR\Code\04\55）<br>在计算第一个时间点2020-02-01的窗口数据时，虽然数据不够窗口长度3，但是至少有当天的数据，那么能否用当天的数据代表窗口数据呢？答案是肯定的，通过设置min_periods参数即可，它表示窗口最少包含的观测值，小于这个值的窗口长度显示为空，等于或大于时都有值，主要代码如下：</p><p>s1_data.rolling(3,min_periods=1).mean()</p><p>运行程序，对比效果如图4.77所示。<br>上述举例，我们再扩展下，通过图表观察原始数据与移动窗口数据的平稳性，如图4.78所示。其中实线代表移动窗口数据，其走向更平稳，这也是学习移动窗口rolling()函数的原因。</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020053518298.png" alt="image-20211020053518298"></p><p>​                 图4.77　2020-02-01至2020-02-15移动窗口均值2</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020053531782.png" alt="image-20211020053531782"></p><p>​                     图4.78　移动窗口数据的平稳性说明<br>虚线代表原始数据，实线代表移动窗口数据。</p><h2 id="4-10-综合应用"><a href="#4-10-综合应用" class="headerlink" title="4.10　综合应用"></a>4.10　综合应用</h2><h3 id="4-10-1-案例1：Excel多表合并"><a href="#4-10-1-案例1：Excel多表合并" class="headerlink" title="4.10.1　案例1：Excel多表合并"></a>4.10.1　案例1：Excel多表合并</h3><p>案例位置：资源包\MR\Code\04\example\01<br>在日常工作中，几乎我们每天都有大量的数据需要处理，桌面上总是布满密密麻麻的Excel表，这样看上去非常凌乱，其实我们完全可以将其中类别相同的Excel表合并到一起，这样不但不会丢失数据，而且还可以有效地分析数据。下面使用concat()方法将指定文件夹内的所有Excel表合并，程序代码如下：</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020053607260.png" alt="image-20211020053607260"></p><h3 id="4-10-2-案例2：股票行情数据分析"><a href="#4-10-2-案例2：股票行情数据分析" class="headerlink" title="4.10.2　案例2：股票行情数据分析"></a>4.10.2　案例2：股票行情数据分析</h3><p>案例位置：资源包\MR\Code\04\example\02<br>股票数据包括开盘价、收盘价、最高价、最低价、成交量等多个指标。其中，收盘价是当日行情的标准，也是下一个交易日开盘价的依据，可以预测未来证券市场行情，因此当投资者对行情分析时，一般采用收盘价作为计算依据。<br>下面使用rolling()函数计算某股票20天、50天和200天的收盘价均值并生成走势图（也称K线图），如图4.79所示。</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020053723586.png" alt="image-20211020053723586"></p><p>​                                       图4.79　股票行情分析</p><p>程序代码如下：</p><p><img src="/2020/02/19/shujufenxi/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020053800663.png" alt="image-20211020053800663"></p><p>实用技巧<br>默认情况下，图表嵌入控制台（IPython console）中并以静态方式显示，无法进行移动、放大、缩小等操作。此时需要在工具中的首选项窗口进行设置，方法为选择Tools→Preferences命令，打开Preferences（首选项）窗口，在左侧列表中选择IPython console（IPython控制台），在右侧窗口选择Graphics（图形）选项卡，然后在Backend（后端）下拉列表框中选择Automatic（自动）或者Qt5，单击Apply（应用）按钮。设置完成后重新启动Spyder才生效。</p><h2 id="4-11-小结"><a href="#4-11-小结" class="headerlink" title="4.11　小结"></a>4.11　小结</h2><p>本章是Pandas的进阶学习，有一定难度，但同时也更能够体现Pandas的强大之处，不仅可以完成数据处理工作，而且还能够实现数据的统计分析。Pandas提供的大量函数使统计分析工作变得简单高效。别具特色的“数据位移”是一个非常有用的方法，与其他方法结合，能够实现很多难以想象的功能，数据转换将DataFrame与Python数据类型之间进行灵活转换。不仅如此，对于日期数据的处理、时间序列也都提供了专门的函数和方法，使得量化数据得心应手。</p>]]></content>
    
    
    <categories>
      
      <category>数据分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端工程化</title>
    <link href="/2019/06/07/js/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    <url>/2019/06/07/js/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h4 id="什么是前端工程化？"><a href="#什么是前端工程化？" class="headerlink" title="什么是前端工程化？"></a>什么是前端工程化？</h4><h5 id="1-小白眼中的前端开发"><a href="#1-小白眼中的前端开发" class="headerlink" title="1.小白眼中的前端开发"></a>1.小白眼中的前端开发</h5><ul><li>会写HTML+CSS+Javascript就会前端开发</li><li>需要美化界面样式，就拽一个bootstrap组件过来</li><li>需要操作DOM或者Ajax请求，就拽jQuery过来</li><li>需要快死实现界面布局，就拽layUI过来</li></ul><h5 id="2-实际的前端开发"><a href="#2-实际的前端开发" class="headerlink" title="2.实际的前端开发"></a>2.实际的前端开发</h5><ul><li>模块化（js模块化，css模块化，资源模块化）</li><li>组件化（复用现有的UI结构，样式，行为）</li><li>规范化（目录结构的划分，编码规范化，接口规范化，文档规范化）</li><li>自动化（自动化构建，自动部署，自动化测试）</li></ul><h5 id="3-什么是前端工程化"><a href="#3-什么是前端工程化" class="headerlink" title="3.什么是前端工程化"></a>3.什么是前端工程化</h5><ul><li>前端工程化是指：在企业的前端项目开发中，把前端开发所需的工具，技术，流程，经验等进行规范化，标准化。</li><li>企业开发中的vue和react项目，都是基于工程化的方式进行开发的。</li><li>好处：前端自成体系，有一套标准开发方案和流程。</li></ul><h5 id="4-前端工程化解决方案"><a href="#4-前端工程化解决方案" class="headerlink" title="4.前端工程化解决方案"></a>4.前端工程化解决方案</h5><p>早期的前端工程化解决方案</p><ul><li><a href="https://www.gruntjs.net/">grund</a></li><li><a href="https://www.gulpjs.com.cn/">gulp</a></li></ul><p>目前流行的前端工程化解决方案</p><ul><li><a href="https://www.webpackjs.com/">webpack</a></li><li><a href="https://zh.parceljs.org/">parcel</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>javascript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工程化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浏览器渲染机制</title>
    <link href="/2019/06/06/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%A8%A1%E5%9D%97/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6/"/>
    <url>/2019/06/06/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%A8%A1%E5%9D%97/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h4 id="渲染机制"><a href="#渲染机制" class="headerlink" title="渲染机制"></a>渲染机制</h4><h4 id="浏览器渲染机制"><a href="#浏览器渲染机制" class="headerlink" title="浏览器渲染机制"></a>浏览器渲染机制</h4><h5 id="1-渲染机制步骤步骤："><a href="#1-渲染机制步骤步骤：" class="headerlink" title="1.渲染机制步骤步骤："></a>1.渲染机制步骤步骤：</h5><ul><li>处理<code>HTML</code>并构建<code>DOM</code>树</li><li>处理<code>css</code>构建<code>cssdom</code>树</li><li>将<code>DOM</code>与<code>cssdom</code>合并成一个渲染树</li><li>根据渲染树来布局，计算每个节点的位置</li><li>调用<code>GPU</code>绘制，合成图层，显示在屏幕上</li></ul><p><img src="/2019/06/06/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%A8%A1%E5%9D%97/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6/98.png"></p><p>在构建cssdom树时，会阻塞渲染，直至cssdom树构建完成。并且构建cssdom树是一个十分消耗性能的过程，所以尽量保证层级扁平，减少过度层叠，越是具体的css选择器，执行速度越慢。</p><p>css是阻塞渲染的资源。需要将他尽早，尽快的下载到客户端，以便缩短首次渲染的时间。</p><p>当html解析到script标签时，会暂停构建dom，完成后才会从暂停的地方重新开始。也就是说，如果你想首屏渲染的越快，就越不应该在首屏就加载js文件。并且css也会影响js的执行，只有当解析完样式才会执行js，所以也可以认为这种情况下，css也会暂停构建dom。</p><h5 id="2-图层"><a href="#2-图层" class="headerlink" title="2.图层"></a>2.图层</h5><blockquote><p>一般来说，可以把普通文档流看成一个图层。特定的属性可以生成一个新的图层。不同的图层渲染互不影响，所以对于某些频繁需要渲染的建议单独生成一个新图层，提高性能。但也不能生成过多的图层，会引起反作用。</p></blockquote><p>通过以下几个常用属性可以生成新图层</p><ul><li><code>3D</code>变换：<code>translate3d</code>,<code>reanslatez</code></li><li><code>will-change</code></li><li><code>video</code>,<code>iframe</code>标签</li><li>通过动画实现的<code>opacity</code>动画转换</li><li><code>position：fixed</code></li></ul><h5 id="3-重绘与回流"><a href="#3-重绘与回流" class="headerlink" title="3.重绘与回流"></a>3.重绘与回流</h5><blockquote><ul><li>重绘(repaint)：当元素样式的改变不影响布局时，浏览器将使用重绘对元素进行更新，此时由于只需要UI层面的重新像素绘制，因此，损耗较少</li></ul></blockquote><blockquote><ul><li>回流(reflow)：当元素的尺寸，结构或触发某些属性时，浏览器会重新渲染页面，称为回流。此时，浏览器需要重新经过计算，计算后还需要重新页面布局，因此是较重的操作。会触发回流的操作：</li></ul></blockquote><p>触发回流和重绘的操作：</p><ul><li>页面初次渲染</li><li>浏览器窗口大小发生改变</li><li>元素尺寸，位置，内容发生改变</li><li>元素字体大小变化</li><li>添加或者删除可见的dom元素</li><li>激活css伪类（列如：hover）</li><li>查询某些属性或调用某些方法<ul><li><code>clientWidth、clientHeight、clientTop、clientLeft</code></li><li>``offsetWidth、offsetHeight、offsetTop、offsetLeft`</li><li><code>scrollWidth、scrollHeight、scrollTop、scrollLeft</code></li><li>``getComputedStyle()`</li><li><code>getBoundingClientRect()</code></li><li><code>scrollTo()</code></li></ul></li></ul><blockquote><p>回流必定触发重绘，重绘不不一定触发回流。重绘的开销小，回流的代价高。</p></blockquote><p>避免回流的优化：</p><ul><li>css层面：<ul><li>不要使用css表达式</li><li>避免table布局</li><li>避免多层嵌套样式</li></ul></li><li>js层面：<ul><li>避免频繁操作DOM，可以创建一个documentFragment文档流片段，在它上面应用所有dom操作，最后再把它添加到文档中。</li><li>避免频繁操作样式</li><li>可以先为元素设置不可见：<code>display：none</code>，操作结束后在显示出来。</li></ul></li></ul><h5 id="4-javascript会阻塞dom生成"><a href="#4-javascript会阻塞dom生成" class="headerlink" title="4.javascript会阻塞dom生成"></a>4.javascript会阻塞dom生成</h5><blockquote><p>javascript 会阻塞dom生成，而样式文件又会阻塞javascriot执行，所以在实际的工程中需要重点关注javascript文件和样式表文件，使用不当会影响页面性能的</p></blockquote><blockquote><p>当渲染进程接收html文件字节流时，会先开启一个与解析线程，如果遇到javascipt文件或者css文件，那么与解析线程会提前下载这些数据</p></blockquote><ul><li>如果代码里引用了外部的css文件，那么在执行javascript之前，还需要等待外部的css文件下载完成，并解析生成cssdom对象之后，才能执行javascript脚本。</li><li>而javascript引擎在解析javascript之前，是不知道javascript是否操作了cssdom的，所以渲染引擎在遇到javascript脚本时，不管脚本是否操作了cssdom，都会执行css文件下载，解析操作，在执行javascript脚本。</li><li>不管css文件和javascript文件谁先到达，都要等到css文件下载完成并生成cssdom，然后在执行javascript脚本，最后再继续构建dom，构建布局树，绘制页面。</li></ul><h5 id="5-缩短白屏时长的策略"><a href="#5-缩短白屏时长的策略" class="headerlink" title="5.缩短白屏时长的策略"></a>5.缩短白屏时长的策略</h5><ul><li>通过内联 JavaScript、内联 CSS 来移除这两种类型的文件下载，这样获取到 HTML 文件之后就可以直接开始渲染流程了。</li><li>但并不是所有的场合都适合内联，那么还可以尽量减少文件大小，比如通过 webpack 等工具移除一些不必要的注释，并压缩 JavaScript 文件。</li><li>还可以将一些不需要在解析 HTML 阶段使用的 JavaScript 标记上 sync 或者 defer</li><li>对于大的 CSS 文件，可以通过媒体查询属性，将其拆分为多个不同用途的 CSS 文件，这样只有在特定的场景下才会加载特定的 CSS 文件。</li></ul>]]></content>
    
    
    <categories>
      
      <category>浏览器模块</category>
      
    </categories>
    
    
    <tags>
      
      <tag>浏览器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浏览器事件循环</title>
    <link href="/2019/06/05/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%A8%A1%E5%9D%97/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/"/>
    <url>/2019/06/05/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%A8%A1%E5%9D%97/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/</url>
    
    <content type="html"><![CDATA[<h4 id="说说你对事件循环的理解"><a href="#说说你对事件循环的理解" class="headerlink" title="说说你对事件循环的理解"></a>说说你对事件循环的理解</h4><p>event loop过程1：</p><ul><li><p>同步代码，一行一行在call stack（执行栈）执行</p></li><li><p>遇到异步，会先“记录”下，等待时机（定时，网络请求等）</p></li><li><p>时机到了，就移动到 Callback Queue （回调队列）</p></li></ul><p>event loop过程2：</p><ul><li><p>如Call Stack为空（及代码执行完）Event loop 开始工作</p></li><li><p>轮询查找Callback Queue，如有则移动到 Call Stack执行</p></li><li><p>然后继续轮询查找（永动机一样）</p></li></ul><p><img src="/2019/06/05/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%A8%A1%E5%9D%97/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/69.png"></p><p><img src="/2019/06/05/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%A8%A1%E5%9D%97/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/70.png"></p><h5 id="宏任务："><a href="#宏任务：" class="headerlink" title="宏任务："></a>宏任务：</h5><ul><li><p>我们可以将每次执行栈执行的代码当做是一个宏任务（包括每次从事件队列中获取一个事件回调并放到执行栈中执行）</p></li><li><p>每一个宏任务会从头到尾执行完毕，不会执行其他</p><blockquote><p>浏览器为了能够使js内部宏任务与dom任务有序的执行，会在一个宏任务执行结束后，在下一个宏任务执行开始前，对页面进行重新渲染。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">// 宏任务--&gt;渲染--&gt;宏任务--&gt;渲染--&gt;渲染．．<br></code></pre></td></tr></table></figure></blockquote><ul><li>js代码</li><li>setTimeout</li><li>Ajax</li><li>Dom事件</li></ul></li></ul><h5 id="微任务："><a href="#微任务：" class="headerlink" title="微任务："></a>微任务：</h5><ul><li>我们已经知道 宏任务结束后，会执行渲染，然后执行下一个 宏任务。</li><li>而微任务可以理解成在当前 宏任务执行后立即执行的任务。</li><li>也就是说，<strong>当 宏任务执行完，会在渲染前，将执行期间所产生的所有 微任务都执行完</strong>。<ul><li>Promise async/</li><li>nextTick（Node.js）</li><li>MutaionObserver</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>浏览器模块</category>
      
    </categories>
    
    
    <tags>
      
      <tag>eventloop</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浏览器的跨标签页通讯,架构</title>
    <link href="/2019/06/05/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%A8%A1%E5%9D%97/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E8%B7%A8%E6%A0%87%E7%AD%BE%E9%A1%B5%E9%80%9A%E8%AE%AF-%E6%9E%B6%E6%9E%84-%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6/"/>
    <url>/2019/06/05/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%A8%A1%E5%9D%97/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E8%B7%A8%E6%A0%87%E7%AD%BE%E9%A1%B5%E9%80%9A%E8%AE%AF-%E6%9E%B6%E6%9E%84-%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h4 id="1-跨标签页通讯"><a href="#1-跨标签页通讯" class="headerlink" title="1.跨标签页通讯"></a>1.跨标签页通讯</h4><blockquote><p>不同标签页面间的通讯，本质与哪里就是去运用一些可以 共享的中间介质，因此比较常用的有以下方法：</p></blockquote><ul><li>通过父页面<code>windowopen()</code>和子页面<code>postmessage</code><ul><li>异步下通过<code>windowopen(&#39;about：blank&#39;)</code>和<code>tablocationhref=&#39;*&#39;</code></li></ul></li><li>色湖之同域下共享的<code>localStorage</code>与监听<code>windowonstorage</code><ul><li>重复写入相同的值无法触发</li><li>会受到浏览器隐身模式等限制</li></ul></li><li>共同设置<code>cookie</code>与不断轮询脏检查(<code>setInterval</code>)</li><li>借助服务端或者中间层实现。</li></ul><h4 id="2-浏览器架构"><a href="#2-浏览器架构" class="headerlink" title="2.浏览器架构"></a>2.浏览器架构</h4><ul><li>用户主界面</li><li>主进程</li><li>内核<ul><li>渲染引擎</li><li><code>JS</code>引擎<ul><li>执行栈</li></ul></li></ul></li><li>事件触发线程<ul><li>消息队列<ul><li>微任务</li><li>宏任务</li></ul></li></ul></li><li>网络异步线程</li><li>定时器线程</li></ul>]]></content>
    
    
    <categories>
      
      <category>浏览器模块</category>
      
    </categories>
    
    
    <tags>
      
      <tag>浏览器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue响应式原理</title>
    <link href="/2019/05/27/vue2/vue2%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/"/>
    <url>/2019/05/27/vue2/vue2%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p> <img src="/2019/05/27/vue2/vue2%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/15.png" alt="img"> </p><p>Vue2.x响应式原理：</p><p>vue创建一个实例时，首先会遍历data属性。采用数据劫持结合发布者订阅者的方式。使用es5的object.defindeproperty 方法将他们转化成getter，setter，并在内部追踪相关依赖。在属性被访问和修改时通知变化。也就是observer使用object.defindproerty来监听数据的读写。读取数据时，调用get方法通知dep去收集订阅者（watcher）。添加到道dep的一个属性subs数理。 dep有很多属性，其中就有一个subsadd添加订阅者的方法。修改1数据时，调用set方法，通知dep数据发生了改变。使用dep.notify方法遍历subs数组里面的每个watcher。调用watcher的update（）方法。创建出一个新的dom树，与原来旧的dom树作对比，根据差异性，从而更新视图。</p><p> <img src="/2019/05/27/vue2/vue2%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/vue.jpeg" alt="img"> </p><p> **Object.defineProperty()**，那么它的用法是什么，以及优缺点是什么呢？ </p><ul><li>可以检测对象中数据发生的修改</li><li>对于复杂的对象，层级很深的话，是不友好的，需要经行深度监听，这样子就需要递归到底，这也是它的缺点。</li><li>对于一个对象中，如果你新增加属性，删除属性，**Object.defineProperty()**是不能观测到的，那么应该如何解决呢？可以通过<code>Vue.set()</code>和<code>Vue.delete()</code>来实现。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 模拟 Vue 中的 data 选项 </span><br><span class="hljs-keyword">let</span> data = &#123;<br>    <span class="hljs-attr">msg</span>: <span class="hljs-string">&#x27;hello&#x27;</span><br>&#125;<br><span class="hljs-comment">// 模拟 Vue 的实例 </span><br><span class="hljs-keyword">let</span> vm = &#123;&#125;<br><span class="hljs-comment">// 数据劫持:当访问或者设置 vm 中的成员的时候，做一些干预操作</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(vm, <span class="hljs-string">&#x27;msg&#x27;</span>, &#123;<br>  <span class="hljs-comment">// 可枚举(可遍历)</span><br>  <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-comment">// 可配置(可以使用 delete 删除，可以通过 defineProperty 重新定义) </span><br>  <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-comment">// 当获取值的时候执行 </span><br>  get () &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;get: &#x27;</span>, data.<span class="hljs-property">msg</span>)<br>    <span class="hljs-keyword">return</span> data.<span class="hljs-property">msg</span> <br>  &#125;,<br>  <span class="hljs-comment">// 当设置值的时候执行 </span><br>  set (newValue) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;set: &#x27;</span>, newValue) <br>    <span class="hljs-keyword">if</span> (newValue === data.<span class="hljs-property">msg</span>) &#123;<br>      <span class="hljs-keyword">return</span><br>    &#125;<br>    data.<span class="hljs-property">msg</span> = newValue<br>    <span class="hljs-comment">// 数据更改，更新 DOM 的值 </span><br>    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#app&#x27;</span>).<span class="hljs-property">textContent</span> = data.<span class="hljs-property">msg</span><br>  &#125; <br>&#125;)<br><br><span class="hljs-comment">// 测试</span><br>vm.<span class="hljs-property">msg</span> = <span class="hljs-string">&#x27;Hello World&#x27;</span> <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(vm.<span class="hljs-property">msg</span>)<br></code></pre></td></tr></table></figure><p>Vue3.响应式原理：</p><p> <code>Vue3.x</code>改用<code>Proxy</code>替代<code>Object.defineProperty</code>。因为<code>Proxy</code>可以直接监听<code>对象和数组</code>的变化，并且有多达13种拦截方法。</p><p>代理，顾名思义，就是在要访问的对象之前增加⼀个中间层，这样就不直接访问对象，⽽是通过中间层做⼀个中转，通过操作代理对象，来实现修改目标对象。</p><p> <strong>监测数组的时候可能触发多次get/set，那么如何防止触发多次呢？</strong> </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 模拟 Vue 中的 data 选项 </span><br><span class="hljs-keyword">let</span> data = &#123;<br>  <span class="hljs-attr">msg</span>: <span class="hljs-string">&#x27;hello&#x27;</span>,<br>  <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> <br>&#125;<br><span class="hljs-comment">// 模拟 Vue 实例</span><br><span class="hljs-keyword">let</span> vm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(data, &#123;<br>  <span class="hljs-comment">// 当访问 vm 的成员会执行</span><br>  get (target, key) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;get, key: &#x27;</span>, key, target[key])<br>    <span class="hljs-keyword">return</span> target[key]<br>  &#125;,<br>  <span class="hljs-comment">// 当设置 vm 的成员会执行</span><br>  set (target, key, newValue) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;set, key: &#x27;</span>, key, newValue)<br>    <span class="hljs-keyword">if</span> (target[key] === newValue) &#123;<br>      <span class="hljs-keyword">return</span><br>    &#125;<br>    target[key] = newValue<br>    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#app&#x27;</span>).<span class="hljs-property">textContent</span> = target[key]<br>  &#125;<br>&#125;)<br><br><span class="hljs-comment">// 测试</span><br>vm.<span class="hljs-property">msg</span> = <span class="hljs-string">&#x27;Hello World&#x27;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(vm.<span class="hljs-property">msg</span>)<br></code></pre></td></tr></table></figure><p>总结：</p><ul><li>Vue<ul><li>记录传入的选项，设置 <code>$data/$el</code></li><li>把 <code>data</code> 的成员注入到 <code>Vue</code> 实例</li><li>负责调用 <code>Observer</code> 实现数据响应式处理(数据劫持)</li><li>负责调用 <code>Compiler</code> 编译指令/插值表达式等</li></ul></li><li>Observer<ul><li>数据劫持<ul><li>负责把 <code>data</code> 中的成员转换成 <code>getter/setter</code></li><li>负责把多层属性转换成 <code>getter/setter</code></li><li>如果给属性赋值为新对象，把新对象的成员设置为 <code>getter/setter</code></li></ul></li><li>添加 <code>Dep</code> 和 <code>Watcher</code> 的依赖关系</li><li>数据变化发送通知</li></ul></li><li>Compiler<ul><li>负责编译模板，解析指令/插值表达式</li><li>负责页面的首次渲染过程</li><li>当数据变化后重新渲染</li></ul></li><li>Dep<ul><li>收集依赖，添加订阅者(<code>watcher</code>)</li><li>通知所有订阅者</li></ul></li><li>Watcher<ul><li>自身实例化的时候往<code>dep</code>对象中添加自己</li><li>当数据变化<code>dep</code>通知所有的 <code>Watcher</code> 实例更新视图</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>vue2</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WebpackProxy工作原理,解决跨域</title>
    <link href="/2019/04/12/webpack/WebpackProxy%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F/"/>
    <url>/2019/04/12/webpack/WebpackProxy%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F/</url>
    
    <content type="html"><![CDATA[<h4 id="Webpack-Proxy工作原理？为什么能解决跨域？"><a href="#Webpack-Proxy工作原理？为什么能解决跨域？" class="headerlink" title="Webpack Proxy工作原理？为什么能解决跨域？"></a>Webpack Proxy工作原理？为什么能解决跨域？</h4><h5 id="1-是什么"><a href="#1-是什么" class="headerlink" title="1. 是什么"></a><strong>1. 是什么</strong></h5><p><code>webpack proxy</code>，即<code>webpack</code>提供的代理服务</p><p>基本行为就是接收客户端发送的请求后转发给其他服务器</p><p>其目的是为了便于开发者在开发模式下解决跨域问题（浏览器安全策略限制）</p><p>想要实现代理首先需要一个中间服务器，<code>webpack</code>中提供服务器的工具为<code>webpack-dev-server</code></p><h5 id="2-webpack-dev-server"><a href="#2-webpack-dev-server" class="headerlink" title="2. webpack-dev-server"></a><strong>2. webpack-dev-server</strong></h5><p><code>webpack-dev-server</code>是 <code>webpack</code> 官方推出的一款开发工具，将自动编译和自动刷新浏览器等一系列对开发友好的功能全部集成在了一起</p><p>目的是为了提高开发者日常的开发效率，「只适用在开发阶段」</p><p>关于配置方面，在<code>webpack</code>配置对象属性中通过<code>devServer</code>属性提供，如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// ./webpack.config.js</span><br><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>)<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-attr">devServer</span>: &#123;<br>        <span class="hljs-attr">contentBase</span>: path.<span class="hljs-title function_">join</span>(__dirname, <span class="hljs-string">&#x27;dist&#x27;</span>),<br>        <span class="hljs-attr">compress</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-attr">port</span>: <span class="hljs-number">9000</span>,<br>        <span class="hljs-attr">proxy</span>: &#123;<br>            <span class="hljs-string">&#x27;/api&#x27;</span>: &#123;<br>                <span class="hljs-attr">target</span>: <span class="hljs-string">&#x27;https://api.github.com&#x27;</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>devServetr</code>里面<code>proxy</code>则是关于代理的配置，该属性为对象的形式，对象中每一个属性就是一个代理的规则匹配</p><p>属性的名称是需要被代理的请求路径前缀，一般为了辨别都会设置前缀为<code>/api</code>，值为对应的代理匹配规则，对应如下：</p><ul><li><code>target</code>：表示的是代理到的目标地址</li><li><code>pathRewrite</code>：默认情况下，我们的 <code>/api-hy</code> 也会被写入到URL中，如果希望删除，可以使用<code>pathRewrite</code></li><li><code>secure</code>：默认情况下不接收转发到<code>https</code>的服务器上，如果希望支持，可以设置为<code>false</code></li><li><code>changeOrigin</code>：它表示是否更新代理后请求的 <code>headers</code> 中<code>host</code>地址</li></ul><p> <strong>2. 工作原理</strong> </p><blockquote><p><code>proxy</code>工作原理实质上是利用<code>http-proxy-middleware</code> 这个<code>http</code>代理中间件，实现请求转发给其他服务器 </p></blockquote><p>举个例子：</p><p>在开发阶段，本地地址为<code>http://localhost:3000</code>，该浏览器发送一个前缀带有<code>/api</code>标识的请求到服务端获取数据，但响应这个请求的服务器只是将请求转发到另一台服务器中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<br><span class="hljs-keyword">const</span> proxy = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http-proxy-middleware&#x27;</span>);<br><br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>();<br><br>app.<span class="hljs-title function_">use</span>(<span class="hljs-string">&#x27;/api&#x27;</span>, <span class="hljs-title function_">proxy</span>(&#123;<span class="hljs-attr">target</span>: <span class="hljs-string">&#x27;http://www.example.org&#x27;</span>, <span class="hljs-attr">changeOrigin</span>: <span class="hljs-literal">true</span>&#125;));<br>app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>);<br><br><span class="hljs-comment">// http://localhost:3000/api/foo/bar -&gt; http://www.example.org/api/foo/bar</span><br></code></pre></td></tr></table></figure><h5 id="3-跨域"><a href="#3-跨域" class="headerlink" title="3. 跨域"></a><strong>3. 跨域</strong></h5><blockquote><p>在开发阶段， <code>webpack-dev-server</code> 会启动一个本地开发服务器，所以我们的应用在开发阶段是独立运行在 <code>localhost</code>的一个端口上，而后端服务又是运行在另外一个地址上 </p></blockquote><p>所以在开发阶段中，由于浏览器同源策略的原因，当本地访问后端就会出现跨域请求的问题</p><p>通过设置<code>webpack proxy</code>实现代理请求后，相当于浏览器与服务端中添加一个代理者</p><p>当本地发送请求的时候，代理服务器响应该请求，并将请求转发到目标服务器，目标服务器响应数据后再将数据返回给代理服务器，最终再由代理服务器将数据响应给本地</p><p><img src="/2019/04/12/webpack/WebpackProxy%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F/tt.png"></p><p> 在代理服务器传递数据给本地浏览器的过程中，两者同源，并不存在跨域行为，这时候浏览器就能正常接收数据 </p><blockquote><p>注意：<code>「服务器与服务器之间请求数据并不会存在跨域行为，跨域行为是浏览器安全策略限制」</code> </p></blockquote>]]></content>
    
    
    <categories>
      
      <category>webpack</category>
      
    </categories>
    
    
    <tags>
      
      <tag>webpack_proxy原理，跨域</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>介绍babel原理</title>
    <link href="/2019/04/10/webpack/%E4%BB%8B%E7%BB%8Dbabel%E5%8E%9F%E7%90%86/"/>
    <url>/2019/04/10/webpack/%E4%BB%8B%E7%BB%8Dbabel%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h4 id="介绍一下-webpack-scope-hosting"><a href="#介绍一下-webpack-scope-hosting" class="headerlink" title="介绍一下 webpack scope hosting"></a>介绍一下 webpack scope hosting</h4><p> 作用域提升，将分散的模块划分到同一个作用域中，避免了代码的重复引入，有效减少打包后的代码体积和运行时的内存损耗； </p><br><h4 id="介绍一下-babel原理"><a href="#介绍一下-babel原理" class="headerlink" title="介绍一下 babel原理"></a>介绍一下 babel原理</h4><blockquote><p><code>babel</code> 的编译过程分为三个阶段：<strong>parsing</strong>、<strong>transforming</strong>、<strong>generating</strong>，以 ES6 编译为 ES5 作为例子： </p></blockquote><ol><li><code>ES6</code> 代码输入；</li><li><code>babylon</code> 进行解析得到 AST；</li><li><code>plugin</code> 用 <code>babel-traverse</code> 对 <code>AST</code>树进行遍历编译，得到新的 <code>AST</code>树；</li><li>用 <code>babel-generator</code> 通过 <code>AST</code>树生成 <code>ES5</code> 代码。</li></ol>]]></content>
    
    
    <categories>
      
      <category>webpack</category>
      
    </categories>
    
    
    <tags>
      
      <tag>babel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>介绍Rollup</title>
    <link href="/2019/04/10/webpack/%E4%BB%8B%E7%BB%8DRollup/"/>
    <url>/2019/04/10/webpack/%E4%BB%8B%E7%BB%8DRollup/</url>
    
    <content type="html"><![CDATA[<h4 id="介绍一下Rollup"><a href="#介绍一下Rollup" class="headerlink" title="介绍一下Rollup"></a>介绍一下Rollup</h4><p>Rollup 是一款 ES Modules 打包器。它也可以将项目中散落的细小模块打包为整块代码，从而使得这些划分的模块可以更好地运行在浏览器环境或者 Node.js 环境。</p><blockquote><p>Rollup 是一款 ES Modules 打包器。它也可以将项目中散落的细小模块打包为整块代码，从而使得这些划分的模块可以更好地运行在浏览器环境或者 Node.js 环境。 </p></blockquote><h5 id="Rollup优势："><a href="#Rollup优势：" class="headerlink" title="Rollup优势："></a><strong>Rollup优势：</strong></h5><ul><li>输出结果更加扁平，执行效率更高；</li><li>自动移除未引用代码；</li><li>打包结果依然完全可读</li></ul><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a><strong>缺点</strong></h5><ul><li><p>加载非 ESM 的第三方模块比较复杂；</p></li><li><p>因为模块最终都被打包到全局中，所以无法实现 <code>HMR</code>；</p></li><li><p>浏览器环境中，代码拆分功能必须使用 <code>Require.js</code> 这样的 <code>AMD</code> 库</p></li></ul><blockquote><ul><li>我们发现如果我们开发的是一个应用程序，需要大量引用第三方模块，同时还需要 HMR 提升开发体验，而且应用过大就必须要分包。那这些需求 Rollup 都无法满足。</li><li>如果我们是开发一个 JavaScript 框架或者库，那这些优点就特别有必要，而缺点呢几乎也都可以忽略，所以在很多像 React 或者 Vue 之类的框架中都是使用的 Rollup 作为模块打包器，而并非 Webpack</li></ul></blockquote><p> <strong>总结一下</strong>：<code>Webpack 大而全，Rollup 小而美</code>。 </p><p>在对它们的选择上，我的基本原则是：<code>应用开发使用 Webpack，类库或者框架开发使用 Rollup</code>。</p><p>不过这并不是绝对的标准，只是经验法则。因为 Rollup 也可用于构建绝大多数应用程序，而 Webpack 同样也可以构建类库或者框架。</p><p><img src="/2019/04/10/webpack/%E4%BB%8B%E7%BB%8DRollup/tt.png"></p>]]></content>
    
    
    <categories>
      
      <category>webpack</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Roollup</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>介绍TreeShaking</title>
    <link href="/2019/04/08/webpack/%E4%BB%8B%E7%BB%8DTreeShaking/"/>
    <url>/2019/04/08/webpack/%E4%BB%8B%E7%BB%8DTreeShaking/</url>
    
    <content type="html"><![CDATA[<h4 id="介绍一下tree-shaking"><a href="#介绍一下tree-shaking" class="headerlink" title="介绍一下tree-shaking"></a>介绍一下tree-shaking</h4><h5 id="作用："><a href="#作用：" class="headerlink" title="作用："></a><strong>作用：</strong></h5><p> 它表示在打包的时候会去除一些无用的代码 </p><h5 id="原理："><a href="#原理：" class="headerlink" title="原理："></a><strong>原理</strong>：</h5><ul><li><code>ES6</code>的模块引入是静态分析的，所以在编译时能正确判断到底加载了哪些模块</li><li>分析程序流，判断哪些变量未被使用、引用，进而删除此代码</li></ul><h5 id="特点："><a href="#特点：" class="headerlink" title="特点："></a><strong>特点：</strong></h5><ul><li>在生产模式下它是默认开启的，但是由于经过<code>babel</code>编译全部模块被封装成<code>IIFE</code>，它存在副作用无法被<code>tree-shaking</code>掉</li><li>可以在<code>package.json</code>中配置<code>sideEffects</code>来指定哪些文件是有副作用的。它有两种值，一个是布尔类型，如果是<code>false</code>则表示所有文件都没有副作用；如果是一个数组的话，数组里的文件路径表示改文件有副作用</li><li><code>rollup</code>和<code>webpack</code>中对<code>tree-shaking</code>的层度不同，例如对<code>babel</code>转译后的<code>class</code>，如果<code>babel</code>的转译是宽松模式下的话(也就是<code>loose</code>为<code>true</code>)，<code>webpack</code>依旧会认为它有副作用不会<code>tree-shaking</code>掉，而<code>rollup</code>会。这是因为<code>rollup</code>有程序流分析的功能，可以更好的判断代码是否真正会产生副作用。</li></ul><h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a><strong>原理</strong></h5><ul><li><code>ES6 Module</code> 引入进行静态分析，故而编译的时候正确判断到底加载了那些模块</li><li>静态分析程序流，判断那些模块和变量未被使用或者引用，进而删除对应代码</li></ul><blockquote><p>依赖于<code>import/export</code> </p></blockquote><p> 通过导入所有的包后再进行条件获取。如下： </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> foo <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;foo&quot;</span>;<br><span class="hljs-keyword">import</span> bar <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;bar&quot;</span>;<br><br><span class="hljs-keyword">if</span>(condition) &#123;<br>    <span class="hljs-comment">// foo.xxxx</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// bar.xxx</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>ES6的import语法完美可以使用tree shaking，因为可以在代码不运行的情况下就能分析出不需要的代码 </p></blockquote><p> <strong>CommonJS的动态特性模块意味着tree shaking不适用</strong>。因为它是不可能确定哪些模块实际运行之前是需要的或者是不需要的。在ES6中，进入了完全静态的导入语法：import。这也意味着下面的导入是不可行的： </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 不可行，ES6 的import是完全静态的</span><br><span class="hljs-keyword">if</span>(condition) &#123;<br>    myDynamicModule = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;foo&quot;</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    myDynamicModule = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;bar&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>webpack</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Three_Shaking</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>webpack层面如何做优化</title>
    <link href="/2019/04/06/webpack/webpack%E5%B1%82%E9%9D%A2%E5%A6%82%E4%BD%95%E5%81%9A%E4%BC%98%E5%8C%96/"/>
    <url>/2019/04/06/webpack/webpack%E5%B1%82%E9%9D%A2%E5%A6%82%E4%BD%95%E5%81%9A%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h4 id="webpack-层面如何做性能优化"><a href="#webpack-层面如何做性能优化" class="headerlink" title="webpack 层面如何做性能优化"></a>webpack 层面如何做性能优化</h4><h5 id="优化前的准备工作"><a href="#优化前的准备工作" class="headerlink" title="优化前的准备工作"></a>优化前的准备工作</h5><p>准备基于时间的分析工具：我们需要一类插件，来帮助我们统计项目构建过程中在编译阶段的耗时情况。speed-measure-webpack-plugin 分析插件加载的时间<br>使用 webpack-bundle-analyzer 分析产物内容<br>代码优化:</p><blockquote><p>无用代码消除，是许多编程语言都具有的优化手段，这个过程称为 DCE (dead code elimination)，即 删除不可能执行的代码；</p></blockquote><p>例如我们的 UglifyJs，它就会帮我们在生产环境中删除不可能被执行的代码，例如:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> fn = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><span class="hljs-comment">// 下面代码便属于 不可能执行的代码；</span><br><span class="hljs-comment">// 通过 UglifyJs (Webpack4+ 已内置) 便会进行 DCE；</span><br><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">return</span> a;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>摇树优化 (Tree-shaking)，这是一种形象比喻。我们把打包后的代码比喻成一棵树，这里其实表示的就是，通过工具 “摇” 我们打包后的 js 代码，将没有使用到的无用代码 “摇” 下来 (删除)。即 消除那些被 引用了但未被使用 的模块代码。</p></blockquote><ul><li>原理: 由于是在编译时优化，因此最基本的前提就是语法的静态分析，ES6的模块机制 提供了这种可能性。不需要运行时，便可进行代码字面上的静态分析，确定相应的依赖关系。</li><li>问题: 具有 副作用 的函数无法被tree-shaking<ul><li>在引用一些第三方库，需要去观察其引入的代码量是不是符合预期；</li><li>尽量写纯函数，减少函数的副作用；</li><li>可使用 <code>webpack-deep-scope-plugin</code>，可以进行作用域分析，减少此类情况的发生，但仍需要注意；</li></ul></li></ul><p><strong>code-spliting: 代码分割技术</strong>，将代码分割成多份进行 懒加载 或 异步加载，避免打包成一份后导致体积过大，影响页面的首屏加载；</p><ul><li><code>Webpack</code> 中使用 <code>SplitChunksPlugin</code> 进行拆分；</li><li>按 页面 拆分: 不同页面打包成不同的文件；</li><li>按 功能 拆分:<ul><li>将类似于播放器，计算库等大模块进行拆分后再懒加载引入；</li><li>提取复用的业务代码，减少冗余代码；</li></ul></li><li>按 文件修改频率 拆分: 将第三方库等不常修改的代码单独打包，而且不改变其文件 hash 值，能最大化运用浏览器的缓存；</li></ul><p><strong>scope hoisting</strong>: 作用域提升，将分散的模块划分到同一个作用域中，避免了代码的重复引入，有效减少打包后的代码体积和运行时的内存损耗；</p><h5 id="编译性能优化"><a href="#编译性能优化" class="headerlink" title="编译性能优化:"></a>编译性能优化:</h5><ul><li>升级至 最新 版本的 <code>webpack</code>，能有效提升编译性能；</li><li> 使用 <code>dev-server</code> / 模块热替换 (<code>HMR</code>) 提升开发体验； </li><li>监听文件变动 忽略 node_modules 目录能有效提高监听时的编译效率；</li><li>缩小编译范围<ul><li><code>modules</code>: 指定模块路径，减少递归搜索；</li><li><code>mainFields</code>: 指定入口文件描述字段，减少搜索；</li><li><code>noParse</code>: 避免对非模块化文件的加载；</li><li><code>includes/exclude</code>: 指定搜索范围/排除不必要的搜索范围；</li><li><code>alias</code>: 缓存目录，避免重复寻址；</li></ul></li><li>babel-loader<ul><li>忽略<code>node_moudles</code>，避免编译第三方库中已经被编译过的代码</li><li>使用<code>cacheDirectory</code>，可以缓存编译结果，避免多次重复编译</li></ul></li><li>多进程并发<ul><li><code>webpack-parallel-uglify-plugin</code>: 可多进程并发压缩 js 文件，提高压缩速度；</li><li><code>HappyPack</code>: 多进程并发文件的 <code>Loader</code> 解析；</li></ul></li><li>第三方库模块缓存:<ul><li><code>DLLPlugin</code> 和 <code>DLLReferencePlugin</code> 可以提前进行打包并缓存，避免每次都重新编译；</li></ul></li><li>使用分析<ul><li><code>Webpack Analyse / webpack-bundle-analyzer</code> 对打包后的文件进行分析，寻找可优化的地方</li><li>配置profile：true，对各个编译阶段耗时进行监控，寻找耗时最多的地方</li></ul></li><li>source-map:<ul><li>开发: <code>cheap-module-eval-source-map</code></li><li>生产: <code>hidden-source-map</code>；</li></ul></li></ul><h5 id="优化webpack打包速度"><a href="#优化webpack打包速度" class="headerlink" title="优化webpack打包速度"></a>优化webpack打包速度</h5><ul><li>减少文件搜索范围<ul><li>比如通过别名</li><li><code>loader</code> 的 <code>test</code>，<code>include &amp; exclude</code></li></ul></li><li><code>Webpack4</code> 默认压缩并行</li><li><code>Happypack</code> 并发调用</li><li><code>babel</code> 也可以缓存编译</li><li><code>Resolve</code> 在构建时指定查找模块文件的规则</li><li>使用<code>DllPlugin</code>，不用每次都重新构建</li><li> <code>externals</code> 和 <code>DllPlugin</code> 解决的是同一类问题：将依赖的框架等模块从构建过程中移除。它们的区别在于 </li><li>在 Webpack 的配置方面，<code>externals</code> 更简单，而 <code>DllPlugin</code> 需要独立的配置文件。</li><li><code>DllPlugin</code> 包含了依赖包的独立构建流程，而 <code>externals</code> 配置中不包含依赖框架的生成方式，通常使用已传入 CDN 的依赖包</li><li><code>externals</code> 配置的依赖包需要单独指定依赖模块的加载方式：全局对象、CommonJS、AMD 等</li><li>在引用依赖包的子模块时，<code>DllPlugin</code> 无须更改，而 <code>externals</code> 则会将子模块打入项目包中</li></ul><h5 id="优化打包体积"><a href="#优化打包体积" class="headerlink" title="优化打包体积"></a>优化打包体积</h5><ul><li>提取第三方库或通过引用外部文件的方式引入第三方库</li><li>代码压缩插件<code>UglifyJsPlugin</code></li><li>服务器启用<code>gzip</code>压缩</li><li>按需加载资源文件 <code>require.ensure</code></li><li>优化<code>devtool</code>中的<code>source-map</code></li><li>剥离<code>css</code>文件，单独打包</li><li>去除不必要插件，通常就是开发环境与生产环境用同一套配置文件导致</li><li><code>Tree Shaking</code> 在构建打包过程中，移除那些引入但未被使用的无效代码</li><li>开启scope hosting<ul><li>体积更小</li><li>创建函数作用域更小</li><li>代码可读性更好</li></ul></li></ul><p><img src="/2019/04/06/webpack/webpack%E5%B1%82%E9%9D%A2%E5%A6%82%E4%BD%95%E5%81%9A%E4%BC%98%E5%8C%96/tt.png"></p><br><p><img src="/2019/04/06/webpack/webpack%E5%B1%82%E9%9D%A2%E5%A6%82%E4%BD%95%E5%81%9A%E4%BC%98%E5%8C%96/oo.png"></p>]]></content>
    
    
    <categories>
      
      <category>webpack</category>
      
    </categories>
    
    
    <tags>
      
      <tag>优化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>webpack热更新原理</title>
    <link href="/2019/04/04/webpack/webpack%E7%83%AD%E6%9B%B4%E6%96%B0%E5%8E%9F%E7%90%86/"/>
    <url>/2019/04/04/webpack/webpack%E7%83%AD%E6%9B%B4%E6%96%B0%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p><img src="/2019/04/04/webpack/webpack%E7%83%AD%E6%9B%B4%E6%96%B0%E5%8E%9F%E7%90%86/rr.png"></p><h5 id="HMR-的基本流程图"><a href="#HMR-的基本流程图" class="headerlink" title="HMR 的基本流程图"></a><strong>HMR 的基本流程图</strong></h5><p><img src="/2019/04/04/webpack/webpack%E7%83%AD%E6%9B%B4%E6%96%B0%E5%8E%9F%E7%90%86/tt.png"></p><ul><li>当修改了一个或多个文件；</li><li>文件系统接收更改并通知 <code>webpack</code>；</li><li><code>webpack</code> 重新编译构建一个或多个模块，并通知 HMR 服务器进行更新；</li><li><code>HMR Server</code> 使用 <code>webSocket</code> 通知 <code>HMR runtime</code> 需要更新，<code>HMR</code> 运行时通过 <code>HTTP</code> 请求更新 <code>jsonp</code></li><li><code>HMR</code> 运行时替换更新中的模块，如果确定这些模块无法更新，则触发整个页面刷新</li></ul><h5 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h5><hr><blockquote><ul><li><a href="https://interview2.poetries.top/docs/simply.html#_4-webpack-%E7%83%AD%E6%9B%B4%E6%96%B0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86">https://interview2.poetries.top/docs/simply.html#_4-webpack-%E7%83%AD%E6%9B%B4%E6%96%B0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86</a></li></ul></blockquote>]]></content>
    
    
    <categories>
      
      <category>webpack</category>
      
    </categories>
    
    
    <tags>
      
      <tag>热更新</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>介绍webpack_Plugin</title>
    <link href="/2019/04/03/webpack/%E4%BB%8B%E7%BB%8Dwebpack-Plugin/"/>
    <url>/2019/04/03/webpack/%E4%BB%8B%E7%BB%8Dwebpack-Plugin/</url>
    
    <content type="html"><![CDATA[<h4 id="介绍webpack中的plugin？"><a href="#介绍webpack中的plugin？" class="headerlink" title="介绍webpack中的plugin？"></a>介绍webpack中的plugin？</h4><p>plugin是插件，对于webpack本身的扩展，是一个扩展器。</p><p>配置方式：写在plugins属性中传入new实例对象，他是个数组，可以写多个插件。</p><ul><li>UglifyJsPlugin: 压缩、混淆代码；</li><li>CommonsChunkPlugin: 代码分割；</li><li>ProvidePlugin: 自动加载模块；</li><li>html-webpack-plugin: 加载 html 文件，并引入 css / js 文件；</li><li>extract-text-webpack-plugin / mini-css-extract-plugin: 抽离样式，生成 css 文件； DefinePlugin: 定义全局变量；</li><li>optimize-css-assets-webpack-plugin: CSS 代码去重；</li><li>webpack-bundle-analyzer: 代码分析；</li><li>compression-webpack-plugin: 使用 gzip 压缩 js 和 css；</li><li>happypack: 使用多进程，加速代码构建；</li><li>EnvironmentPlugin: 定义环境变量；</li></ul><h5 id="下面介绍几个常用的插件用法："><a href="#下面介绍几个常用的插件用法：" class="headerlink" title="下面介绍几个常用的插件用法："></a>下面介绍几个常用的插件用法：</h5><ul><li>HtmlWebpackPlugin<ul><li> ⾃动生成⼀个 <code>html</code> ⽂文件，并把打包生成的<code>js</code> 模块引⼊到该 <code>html</code> 中 </li></ul></li><li>clean-webpack-plugin<ul><li> 删除（清理）构建目录 </li></ul></li><li>mini-css-extract-plugin<ul><li>提取css到一个单独文件中</li></ul></li><li>copy-webpack-plugin<ul><li>复制文件或目录到执行区域。</li></ul></li></ul><h5 id="loader和plugin的区别？"><a href="#loader和plugin的区别？" class="headerlink" title="loader和plugin的区别？"></a>loader和plugin的区别？</h5><ul><li>对于loader，它是一个转换器，将A文件进行编译形成B文件，这里操作的是文件，比如将A.scss转换为A.css，单纯的文件转换过程。</li><li>plugin是一个插件，在webpack中相当于一个扩展器。是对现有webpack功能的一个扩展。针对于loader结束后，在webpack打包过程中并不是直接进行操作的，而是遵循事件机制工作的。会监听webpack打包过程中的某些节点，执行广泛的任务。</li></ul><h5 id="一个最简单的-plugin-是这样的"><a href="#一个最简单的-plugin-是这样的" class="headerlink" title="一个最简单的 plugin 是这样的:"></a><strong>一个最简单的 plugin 是这样的:</strong></h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Plugin</span>&#123;<br>  <span class="hljs-comment">// 注册插件时，会调用 apply 方法</span><br>  <span class="hljs-comment">// apply 方法接收 compiler 对象</span><br>  <span class="hljs-comment">// 通过 compiler 上提供的 Api，可以对事件进行监听，执行相应的操作</span><br>  <span class="hljs-title function_">apply</span>(<span class="hljs-params">compiler</span>)&#123;<br>  <span class="hljs-comment">// compilation 是监听每次编译循环</span><br>  <span class="hljs-comment">// 每次文件变化，都会生成新的 compilation 对象并触发该事件</span><br>    compiler.<span class="hljs-title function_">plugin</span>(<span class="hljs-string">&#x27;compilation&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">compilation</span>) &#123;&#125;)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p> <strong>注册插件:</strong> </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// webpack.config.js</span><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">export</span> = &#123;<br><span class="hljs-attr">plugins</span>:[<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Plugin</span>(options),<br>]<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h5><hr><blockquote><ul><li><a href="https://interview2.poetries.top/docs/simply.html#_3-%E4%BB%8B%E7%BB%8D-plugin">https://interview2.poetries.top/docs/simply.html#_3-%E4%BB%8B%E7%BB%8D-plugin</a></li></ul></blockquote>]]></content>
    
    
    <categories>
      
      <category>webpack</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Plugin</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>介绍webpack_Loader</title>
    <link href="/2019/03/29/webpack/%E4%BB%8B%E7%BB%8Dwebpack-Loader/"/>
    <url>/2019/03/29/webpack/%E4%BB%8B%E7%BB%8Dwebpack-Loader/</url>
    
    <content type="html"><![CDATA[<h4 id="介绍webpack中的loader？"><a href="#介绍webpack中的loader？" class="headerlink" title="介绍webpack中的loader？"></a>介绍webpack中的loader？</h4><p>webpack默认情况下，只支持对js，json文件打包。像css，less，png图片啊这些类型文件，webpack需要采用相对应的loader（模块加载器）进行解析转换。</p><h5 id="loader配置（module-rules）："><a href="#loader配置（module-rules）：" class="headerlink" title="loader配置（module.rules）："></a>loader配置（module.rules）：</h5><ul><li>rules是一个数组的形式，因此我们可以配置多个loader。</li><li>每一个loader对应一个对象形式，属性test为匹配的规则，一般情况下为正则表达式。</li><li>属性use针对匹配到文件类型，调用对应的loader进行处理。</li></ul><br><h5 id="常见的loader："><a href="#常见的loader：" class="headerlink" title="常见的loader："></a>常见的loader：</h5><ul><li><p>style-loader：将css添加到dom的内联样式标签style中。</p></li><li><p>css-loader： 允许css文件通过import和url,引用css文件对应的资源。</p></li><li><p>sass-loader / less-loader：css预处理器，提高了开发效率。</p></li><li><p>babel-loader： 用babel将es6/es7 代码转换成es5。</p></li><li><p>file-loader： 加载文件资源，如 字体/图片 等。</p></li><li><p>url-loader：对于图片格式的模块，可以选择性的把图片转成base64格式的字符串，并打包到js中，对小体积的图片比较合适，大图片不合适。</p></li></ul><h5 id="编写原则"><a href="#编写原则" class="headerlink" title="编写原则:"></a><strong>编写原则:</strong></h5><ul><li>单一原则: 每个 Loader 只做一件事；</li><li>链式调用: Webpack 会按顺序链式调用每个 Loader；</li><li>统一原则: 遵循 Webpack制定的设计规则和结构，输入与输出均为字符串，各个 Loader 完全独立，即插即用；</li></ul><h5 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h5><hr><blockquote><ul><li><a href="https://interview2.poetries.top/docs/simply.html#_2-%E4%BB%8B%E7%BB%8D-loader">https://interview2.poetries.top/docs/simply.html#_2-%E4%BB%8B%E7%BB%8D-loader</a></li></ul></blockquote>]]></content>
    
    
    <categories>
      
      <category>webpack</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Loader</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>webpack构建流程</title>
    <link href="/2019/03/28/webpack/webpack%E6%9E%84%E5%BB%BA%E6%B5%81%E7%A8%8B/"/>
    <url>/2019/03/28/webpack/webpack%E6%9E%84%E5%BB%BA%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h4 id="介绍一下-webpack-的构建流程"><a href="#介绍一下-webpack-的构建流程" class="headerlink" title="介绍一下 webpack 的构建流程"></a>介绍一下 webpack 的构建流程</h4><h5 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a><strong>核心概念</strong></h5><ul><li><code>entry</code>：入口配置。webpack从入口开始根据模块间依赖关系递归解析和处理所有资源文件。</li><li><code>output</code>：出口配置。经打包后的文件写入的位置。</li><li><code>loader</code>：模块转换器。纯文件转换。因为webpack默认只认识js，json文件。</li><li><code>plugin</code>：扩展插件。插件可以扩展 Webpack 的功能。</li><li><code>module</code>：模块。除了js范畴内的<code>es module、commonJs、AMD</code>等，<code>css @import、url(...)</code>、图片、字体等在webpack中都被视为模块。</li></ul><h5 id="打包流程"><a href="#打包流程" class="headerlink" title="打包流程"></a>打包流程</h5><ul><li>初始化参数：从配置文件和 Shell 语句中读取并合并参数，得出最终的配置参数。</li><li>开始编译：从上一步得到的参数初始化 <code>Compiler</code> 对象，加载所有配置的插件，执行对象的 <code>run</code> 方法开始执行编译。</li><li>确定入口：根scope据配置中的 <code>entry</code> 找出所有的入口文件。</li><li>编译模块：从入口文件出发，调用所有配置的 <code>loader</code> 对模块进行翻译，再找出该模块依赖的模块，这个步骤是递归执行的，直至所有入口依赖的模块文件都经过本步骤的处理。</li><li>完成模块编译：经过第 4 步使用 loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系。</li><li>输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 <code>chunk</code>，再把每个 <code>chunk</code> 转换成一个单独的文件加入到输出列表，这一步是可以修改输出内容的最后机会。</li><li>输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。</li></ul><p><img src="/2019/03/28/webpack/webpack%E6%9E%84%E5%BB%BA%E6%B5%81%E7%A8%8B/tt.png"></p><br><p>从配置文件中读取所需要的参数，初始化compiler对象，并且加载所有的插件，执行run方法开始编译。找到entry入口文件。调用loader对模板进行递归解析翻译。等确定每个模块的依赖关系后，将他们组装成一个个包含多个模块的chunk。确定好内容后，根据出口配置将打包后的文件写入到具体位置。</p><h5 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h5><hr><blockquote><ul><li><a href="https://interview2.poetries.top/docs/simply.html#_10-%E7%A7%BB%E5%8A%A8%E7%AB%AF%E4%BC%98%E5%8C%96">https://interview2.poetries.top/docs/simply.html#_10-%E7%A7%BB%E5%8A%A8%E7%AB%AF%E4%BC%98%E5%8C%96</a></li></ul></blockquote>]]></content>
    
    
    <categories>
      
      <category>webpack</category>
      
    </categories>
    
    
    <tags>
      
      <tag>webpack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mvvm的理解</title>
    <link href="/2019/03/21/vue2/mvvm%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <url>/2019/03/21/vue2/mvvm%E7%9A%84%E7%90%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h4 id="对于mvvm的理解？"><a href="#对于mvvm的理解？" class="headerlink" title="对于mvvm的理解？"></a>对于mvvm的理解？</h4><p>mvvm就是modle-view-viewmodule。mvvm是一种设计思想。</p><ul><li>modle：模型层，用于处理逻辑和服务器的交互。</li><li>view：视图层，用于将数据渲染在页面上。UI视图。</li><li>view-model：视图模型层，用来连接model和view，是model和view之间的通信桥梁。达到数据驱动视图的效果。</li></ul><p>mvvm模式简化了界面与业务的依赖，解决了数据频繁更新。mvvm在使用当中，利用双向数据绑定技术，使得model变化时，viewmodel会自动更新，而viewmodel变化时，view也会自动变化。</p>]]></content>
    
    
    <categories>
      
      <category>vue2</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mvvm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>react中keys作用</title>
    <link href="/2018/10/19/react/react%E4%B8%ADkeys%E4%BD%9C%E7%94%A8/"/>
    <url>/2018/10/19/react/react%E4%B8%ADkeys%E4%BD%9C%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h4 id="React-中-keys-的作用是什么？"><a href="#React-中-keys-的作用是什么？" class="headerlink" title="React 中 keys 的作用是什么？"></a><strong>React 中 keys 的作用是什么？</strong></h4><blockquote><p><code>keys</code>是<code>react</code>用于追踪那些列表中元素被修改，被添加或者被移除的辅助标识。</p></blockquote><p>在开发过程中，我们需要保证某个元素的<code>key</code>值在同级元素中具有唯一性。在<code>react diff</code>算法中，react会借助元素<code>key</code>值来判断该元素新创建的还是被移动而来的元素，从而减少不必要的元素重渲染。此外，<code>react</code>还借助<code>key</code>值来判断元素与本地状态的关联关系，因此我们绝不可忽视转换函数中<code>key</code>的重要性。</p><h5 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h5><blockquote><ul><li><a href="https://interview2.poetries.top/excellent-docs/6-React.html#_1%E3%80%81react-%E4%B8%AD-keys-%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88">https://interview2.poetries.top/excellent-docs/6-React.html#_1%E3%80%81react-%E4%B8%AD-keys-%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88</a></li></ul></blockquote>]]></content>
    
    
    <categories>
      
      <category>react</category>
      
    </categories>
    
    
    <tags>
      
      <tag>react</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ES6新增Set、Map两种数据结构</title>
    <link href="/2018/08/17/js/ES6%E6%96%B0%E5%A2%9ESet%E3%80%81Map%E4%B8%A4%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <url>/2018/08/17/js/ES6%E6%96%B0%E5%A2%9ESet%E3%80%81Map%E4%B8%A4%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h4 id="你是怎么理解ES6新增Set、Map两种数据结构的？"><a href="#你是怎么理解ES6新增Set、Map两种数据结构的？" class="headerlink" title="你是怎么理解ES6新增Set、Map两种数据结构的？"></a>你是怎么理解ES6新增Set、Map两种数据结构的？</h4><p><code>Set</code>是一种叫做集合的数据结构，<code>Map</code>是一种叫做字典的数据结构</p><h5 id="一、Set"><a href="#一、Set" class="headerlink" title="一、Set"></a>一、Set</h5><p> <code>Set</code>是<code>es6</code>新增的数据结构，类似于数组，但是成员的值都是唯一的，没有重复的值，我们一般称为集合 </p><h6 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h6><p><code>Set</code>的实例关于增删改查的方法：</p><ul><li><p>add()</p><ul><li><p>添加某个值，返回 <code>Set</code> 结构本身，当添加实例中已经存在的元素，<code>set</code>不会进行处理添加</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">s.<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>).<span class="hljs-title function_">add</span>(<span class="hljs-number">2</span>).<span class="hljs-title function_">add</span>(<span class="hljs-number">2</span>); <span class="hljs-comment">// 2只被添加了一次</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>delete()</p><ul><li> 删除某个值，返回一个布尔值，表示删除是否成功 </li></ul>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">s.<span class="hljs-title function_">delete</span>(<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure></li><li><p>has()</p><ul><li> 返回一个布尔值，判断该值是否为<code>Set</code>的成员 </li></ul>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">s.<span class="hljs-title function_">has</span>(<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure></li><li><p>clear()</p><ul><li> 清除所有成员，没有返回值 </li></ul>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">s.<span class="hljs-title function_">clear</span>()<br></code></pre></td></tr></table></figure></li></ul><h6 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h6><p><code>Set</code>实例遍历的方法有如下：</p><ul><li>keys()：返回键名的遍历器</li><li>values()：返回键值的遍历器</li><li>entries()：返回键值对的遍历器</li><li>forEach()：使用回调函数遍历每个成员</li></ul><h5 id="二、Map"><a href="#二、Map" class="headerlink" title="二、Map"></a>二、Map</h5><p><code>Map</code>类型是键值对的有序列表，而键和值都可以是任意类型，相当于一个字典。<code>Map</code>本身是一个构造函数，用来生成 <code>Map</code> 数据结构。</p><h6 id="增删改查-1"><a href="#增删改查-1" class="headerlink" title="增删改查"></a>增删改查</h6><p><code>Map</code> 结构的实例针对增删改查有以下属性和操作方法：</p><ul><li><p>size 属性</p><ul><li> <code>size</code>属性返回 Map 结构的成员总数。 </li></ul>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();<br>map.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;foo&#x27;</span>, <span class="hljs-literal">true</span>);<br>map.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;bar&#x27;</span>, <span class="hljs-literal">false</span>);<br><br>map.<span class="hljs-property">size</span> <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure></li><li><p>set()</p><ul><li><p>设置键名<code>key</code>对应的键值为<code>value</code>，然后返回整个 Map 结构</p><p>如果<code>key</code>已经有值，则键值会被更新，否则就新生成该键</p><p>同时返回的是当前<code>Map</code>对象，可采用链式写法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> m = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();<br><br>m.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;edition&#x27;</span>, <span class="hljs-number">6</span>)        <span class="hljs-comment">// 键是字符串</span><br>m.<span class="hljs-title function_">set</span>(<span class="hljs-number">262</span>, <span class="hljs-string">&#x27;standard&#x27;</span>)     <span class="hljs-comment">// 键是数值</span><br>m.<span class="hljs-title function_">set</span>(<span class="hljs-literal">undefined</span>, <span class="hljs-string">&#x27;nah&#x27;</span>)    <span class="hljs-comment">// 键是 undefined</span><br>m.<span class="hljs-title function_">set</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;a&#x27;</span>).<span class="hljs-title function_">set</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;b&#x27;</span>).<span class="hljs-title function_">set</span>(<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;c&#x27;</span>) <span class="hljs-comment">// 链式操作</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>get()</p><ul><li> <code>get</code>方法读取<code>key</code>对应的键值，如果找不到<code>key</code>，返回<code>undefined</code> </li></ul>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> m = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();<br><br><span class="hljs-keyword">const</span> hello = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;hello&#x27;</span>);&#125;;<br>m.<span class="hljs-title function_">set</span>(hello, <span class="hljs-string">&#x27;Hello ES6!&#x27;</span>) <span class="hljs-comment">// 键是函数</span><br><br>m.<span class="hljs-title function_">get</span>(hello)  <span class="hljs-comment">// Hello ES6!</span><br></code></pre></td></tr></table></figure></li><li><p>has()</p><ul><li> <code>has</code>方法返回一个布尔值，表示某个键是否在当前 Map 对象之中 </li></ul>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> m = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();<br><br>m.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;edition&#x27;</span>, <span class="hljs-number">6</span>);<br>m.<span class="hljs-title function_">set</span>(<span class="hljs-number">262</span>, <span class="hljs-string">&#x27;standard&#x27;</span>);<br>m.<span class="hljs-title function_">set</span>(<span class="hljs-literal">undefined</span>, <span class="hljs-string">&#x27;nah&#x27;</span>);<br><br>m.<span class="hljs-title function_">has</span>(<span class="hljs-string">&#x27;edition&#x27;</span>)     <span class="hljs-comment">// true</span><br>m.<span class="hljs-title function_">has</span>(<span class="hljs-string">&#x27;years&#x27;</span>)       <span class="hljs-comment">// false</span><br>m.<span class="hljs-title function_">has</span>(<span class="hljs-number">262</span>)           <span class="hljs-comment">// true</span><br>m.<span class="hljs-title function_">has</span>(<span class="hljs-literal">undefined</span>)     <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure></li><li><p>delete()</p><ul><li> <code>delete</code>方法删除某个键，返回<code>true</code>。如果删除失败，返回<code>false</code> </li></ul>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> m = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();<br>m.<span class="hljs-title function_">set</span>(<span class="hljs-literal">undefined</span>, <span class="hljs-string">&#x27;nah&#x27;</span>);<br>m.<span class="hljs-title function_">has</span>(<span class="hljs-literal">undefined</span>)     <span class="hljs-comment">// true</span><br><br>m.<span class="hljs-title function_">delete</span>(<span class="hljs-literal">undefined</span>)<br>m.<span class="hljs-title function_">has</span>(<span class="hljs-literal">undefined</span>)       <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure></li><li><p>clear()</p><ul><li> <code>clear</code>方法清除所有成员，没有返回值 </li></ul>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();<br>map.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;foo&#x27;</span>, <span class="hljs-literal">true</span>);<br>map.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;bar&#x27;</span>, <span class="hljs-literal">false</span>);<br><br>map.<span class="hljs-property">size</span> <span class="hljs-comment">// 2</span><br>map.<span class="hljs-title function_">clear</span>()<br>map.<span class="hljs-property">size</span> <span class="hljs-comment">// 0</span><br></code></pre></td></tr></table></figure></li></ul><h6 id="遍历-1"><a href="#遍历-1" class="headerlink" title="遍历"></a>遍历</h6><p><code>Map</code>结构原生提供三个遍历器生成函数和一个遍历方法：</p><ul><li>keys()：返回键名的遍历器</li><li>values()：返回键值的遍历器</li><li>entries()：返回所有成员的遍历器</li><li>forEach()：遍历 Map 的所有成员</li></ul><h5 id="三、WeakSet-和-WeakMap"><a href="#三、WeakSet-和-WeakMap" class="headerlink" title="三、WeakSet 和 WeakMap"></a>三、WeakSet 和 WeakMap</h5><h6 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h6><p>创建<code>WeakSet</code>实例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> ws = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakSet</span>();<br></code></pre></td></tr></table></figure><p><code>WeakSet</code>可以接受一个具有 <code>Iterable</code>接口的对象作为参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> a = [[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]];<br><span class="hljs-keyword">const</span> ws = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakSet</span>(a);<br><span class="hljs-comment">// WeakSet &#123;[1, 2], [3, 4]&#125;</span><br></code></pre></td></tr></table></figure><p>在<code>API</code>中<code>WeakSet</code>与<code>Set</code>有两个区别：</p><ul><li>没有遍历操作的<code>API</code></li><li>没有<code>size</code>属性</li></ul><p><code>WeackSet</code>只能成员只能是引用类型，而不能是其他类型的值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> ws=<span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakSet</span>();<br><br><span class="hljs-comment">// 成员不是引用类型</span><br><span class="hljs-keyword">let</span> weakSet=<span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakSet</span>([<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(weakSet) <span class="hljs-comment">// 报错</span><br><br><span class="hljs-comment">// 成员为引用类型</span><br><span class="hljs-keyword">let</span> obj1=&#123;<span class="hljs-attr">name</span>:<span class="hljs-number">1</span>&#125;<br><span class="hljs-keyword">let</span> obj2=&#123;<span class="hljs-attr">name</span>:<span class="hljs-number">1</span>&#125;<br><span class="hljs-keyword">let</span> ws=<span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakSet</span>([obj1,obj2]); <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(ws) <span class="hljs-comment">//WeakSet &#123;&#123;…&#125;, &#123;…&#125;&#125;</span><br></code></pre></td></tr></table></figure><p><code>WeakSet</code>里面的引用只要在外部消失，它在 <code>WeakSet</code>里面的引用就会自动消失</p><h6 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h6><p><code>WeakMap</code>结构与<code>Map</code>结构类似，也是用于生成键值对的集合</p><p>在<code>API</code>中<code>WeakMap</code>与<code>Map</code>有两个区别：</p><ul><li><p>没有遍历操作的<code>API</code></p></li><li><p>没有<code>clear</code>清空方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// WeakMap 可以使用 set 方法添加成员</span><br><span class="hljs-keyword">const</span> wm1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakMap</span>();<br><span class="hljs-keyword">const</span> key = &#123;<span class="hljs-attr">foo</span>: <span class="hljs-number">1</span>&#125;;<br>wm1.<span class="hljs-title function_">set</span>(key, <span class="hljs-number">2</span>);<br>wm1.<span class="hljs-title function_">get</span>(key) <span class="hljs-comment">// 2</span><br><br><span class="hljs-comment">// WeakMap 也可以接受一个数组，</span><br><span class="hljs-comment">// 作为构造函数的参数</span><br><span class="hljs-keyword">const</span> k1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">const</span> k2 = [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>];<br><span class="hljs-keyword">const</span> wm2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakMap</span>([[k1, <span class="hljs-string">&#x27;foo&#x27;</span>], [k2, <span class="hljs-string">&#x27;bar&#x27;</span>]]);<br>wm2.<span class="hljs-title function_">get</span>(k2) <span class="hljs-comment">// &quot;bar&quot;</span><br></code></pre></td></tr></table></figure></li></ul><p> <code>WeakMap</code>只接受对象作为键名（<code>null</code>除外），不接受其他类型的值作为键名 </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakMap</span>();<br>map.<span class="hljs-title function_">set</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br><span class="hljs-comment">// TypeError: 1 is not an object!</span><br>map.<span class="hljs-title function_">set</span>(<span class="hljs-title class_">Symbol</span>(), <span class="hljs-number">2</span>)<br><span class="hljs-comment">// TypeError: Invalid value used as weak map key</span><br>map.<span class="hljs-title function_">set</span>(<span class="hljs-literal">null</span>, <span class="hljs-number">2</span>)<br><span class="hljs-comment">// TypeError: Invalid value used as weak map key</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>javascript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>es6结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>es6对象新增的扩展</title>
    <link href="/2018/07/30/js/es6%E5%AF%B9%E8%B1%A1%E6%96%B0%E5%A2%9E%E7%9A%84%E6%89%A9%E5%B1%95/"/>
    <url>/2018/07/30/js/es6%E5%AF%B9%E8%B1%A1%E6%96%B0%E5%A2%9E%E7%9A%84%E6%89%A9%E5%B1%95/</url>
    
    <content type="html"><![CDATA[<h5 id="对象新增了哪些扩展？"><a href="#对象新增了哪些扩展？" class="headerlink" title="对象新增了哪些扩展？"></a>对象新增了哪些扩展？</h5><h5 id="属性的简写"><a href="#属性的简写" class="headerlink" title="属性的简写"></a>属性的简写</h5><ul><li><p>ES6中，当对象键名与对应值名相等的时候，可以进行简写 。 方法也能够进行简写 。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> baz = &#123;<span class="hljs-attr">foo</span>:foo&#125;<br><br><span class="hljs-comment">// 等同于</span><br><span class="hljs-keyword">const</span> baz = &#123;foo&#125;<br><br><br><br><span class="hljs-keyword">const</span> o = &#123;<br>  <span class="hljs-title function_">method</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello!&quot;</span>;<br>  &#125;<br>&#125;;<br><br><span class="hljs-comment">// 等同于</span><br><br><span class="hljs-keyword">const</span> o = &#123;<br>  <span class="hljs-attr">method</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello!&quot;</span>;<br>  &#125;<br>&#125;<br><br><br><span class="hljs-comment">//在函数内作为返回值，也会变得方便很多</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getPoint</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> x = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">const</span> y = <span class="hljs-number">10</span>;<br>  <span class="hljs-keyword">return</span> &#123;x, y&#125;;<br>&#125;<br><br><span class="hljs-title function_">getPoint</span>()<br><span class="hljs-comment">// &#123;x:1, y:10&#125;</span><br></code></pre></td></tr></table></figure><p>​    </p></li><li><p>注意：简写的对象方法不能用作构造函数，否则会报错 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = &#123;<br>  <span class="hljs-title function_">f</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">foo</span> = <span class="hljs-string">&#x27;bar&#x27;</span>;<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">new</span> obj.<span class="hljs-title function_">f</span>() <span class="hljs-comment">// 报错</span><br></code></pre></td></tr></table></figure></li></ul><h5 id="属性名表达式"><a href="#属性名表达式" class="headerlink" title="属性名表达式"></a>属性名表达式</h5><ul><li><p>ES6 允许字面量定义对象时，将表达式放在括号内 , 表达式还可以用于定义方法名 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> lastWord = <span class="hljs-string">&#x27;last word&#x27;</span>;<br><br><span class="hljs-keyword">const</span> a = &#123;<br>  <span class="hljs-string">&#x27;first word&#x27;</span>: <span class="hljs-string">&#x27;hello&#x27;</span>,<br>  [lastWord]: <span class="hljs-string">&#x27;world&#x27;</span><br>&#125;;<br><br>a[<span class="hljs-string">&#x27;first word&#x27;</span>] <span class="hljs-comment">// &quot;hello&quot;</span><br>a[lastWord] <span class="hljs-comment">// &quot;world&quot;</span><br>a[<span class="hljs-string">&#x27;last word&#x27;</span>] <span class="hljs-comment">// &quot;world&quot;</span><br><br><br><br><br><span class="hljs-keyword">let</span> obj = &#123;<br>  [<span class="hljs-string">&#x27;h&#x27;</span> + <span class="hljs-string">&#x27;ello&#x27;</span>]() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;hi&#x27;</span>;<br>  &#125;<br>&#125;;<br><br>obj.<span class="hljs-title function_">hello</span>() <span class="hljs-comment">// hi</span><br></code></pre></td></tr></table></figure></li></ul><h5 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h5><ul><li> <code>this</code>关键字总是指向函数所在的当前对象，ES6 又新增了另一个类似的关键字<code>super</code>，指向当前对象的原型对象 </li></ul>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> proto = &#123;<br>  <span class="hljs-attr">foo</span>: <span class="hljs-string">&#x27;hello&#x27;</span><br>&#125;;<br><br><span class="hljs-keyword">const</span> obj = &#123;<br>  <span class="hljs-attr">foo</span>: <span class="hljs-string">&#x27;world&#x27;</span>,<br>  <span class="hljs-title function_">find</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">super</span>.<span class="hljs-property">foo</span>;<br>  &#125;<br>&#125;;<br><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">setPrototypeOf</span>(obj, proto); <span class="hljs-comment">// 为obj设置原型对象</span><br>obj.<span class="hljs-title function_">find</span>() <span class="hljs-comment">// &quot;hello&quot;</span><br></code></pre></td></tr></table></figure><h5 id="属性的遍历"><a href="#属性的遍历" class="headerlink" title="属性的遍历"></a>属性的遍历</h5><p>ES6 一共有 5 种方法可以遍历对象的属性。</p><ul><li>for…in：循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）</li><li>Object.keys(obj)：返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名</li><li>Object.getOwnPropertyNames(obj)：回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名</li><li>Object.getOwnPropertySymbols(obj)：返回一个数组，包含对象自身的所有 Symbol 属性的键名</li><li>Reflect.ownKeys(obj)：返回一个数组，包含对象自身的（不含继承的）所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举</li></ul><p>上述遍历，都遵守同样的属性遍历的次序规则：</p><ul><li>首先遍历所有数值键，按照数值升序排列</li><li>其次遍历所有字符串键，按照加入时间升序排列</li><li>最后遍历所有 Symbol 键，按照加入时间升序排</li></ul><h5 id="对象新增的方法"><a href="#对象新增的方法" class="headerlink" title="对象新增的方法"></a>对象新增的方法</h5><ul><li>Object.is()</li><li>Object.assign()</li><li>Object.getOwnPropertyDescriptors()</li><li>Object.setPrototypeOf()，Object.getPrototypeOf()</li><li>Object.keys()，Object.values()，Object.entries()</li><li>Object.fromEntries()</li></ul>]]></content>
    
    
    <categories>
      
      <category>javascript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>es6对象</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>es6数组新增的扩展</title>
    <link href="/2018/07/29/js/es6%E6%95%B0%E7%BB%84%E6%96%B0%E5%A2%9E%E7%9A%84%E6%89%A9%E5%B1%95/"/>
    <url>/2018/07/29/js/es6%E6%95%B0%E7%BB%84%E6%96%B0%E5%A2%9E%E7%9A%84%E6%89%A9%E5%B1%95/</url>
    
    <content type="html"><![CDATA[<h4 id="数组新增了哪些扩展？"><a href="#数组新增了哪些扩展？" class="headerlink" title="数组新增了哪些扩展？"></a>数组新增了哪些扩展？</h4><h5 id="扩展运算符的引用"><a href="#扩展运算符的引用" class="headerlink" title="扩展运算符的引用   ..."></a>扩展运算符的引用   <code>...</code></h5><ul><li><p>主要用于函数调用，将一个数组变为参数序列。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">push</span>(<span class="hljs-params">array, ...items</span>) &#123;<br>  array.<span class="hljs-title function_">push</span>(...items);<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">x, y</span>) &#123;<br>  <span class="hljs-keyword">return</span> x + y;<br>&#125;<br><br><span class="hljs-keyword">const</span> numbers = [<span class="hljs-number">4</span>, <span class="hljs-number">38</span>];<br><span class="hljs-title function_">add</span>(...numbers) <span class="hljs-comment">// 42</span><br></code></pre></td></tr></table></figure></li><li><p>能够更简单的实现数组复制。也可进行数组合并。可以将字符串转化为真正的数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//数组复制</span><br><span class="hljs-keyword">const</span> a1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>];<br><span class="hljs-keyword">const</span> [...a2] = a1;<br><span class="hljs-comment">// [1,2]</span><br><br><span class="hljs-comment">//数组合并</span><br><span class="hljs-keyword">const</span> arr1 = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>];<br><span class="hljs-keyword">const</span> arr2 = [<span class="hljs-string">&#x27;c&#x27;</span>];<br><span class="hljs-keyword">const</span> arr3 = [<span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>];<br>[...arr1, ...arr2, ...arr3]<br><span class="hljs-comment">// [ &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27; ]</span><br><br><br>[...<span class="hljs-string">&#x27;hello&#x27;</span>]<br><span class="hljs-comment">// [ &quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot; ]</span><br></code></pre></td></tr></table></figure></li></ul><p>注意：</p><ul><li><p>如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则报错。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> [...butLast, last] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br><span class="hljs-comment">// 报错</span><br><br><span class="hljs-keyword">const</span> [first, ...middle, last] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br><span class="hljs-comment">// 报错</span><br></code></pre></td></tr></table></figure></li></ul><h5 id="构造函数新增的方法"><a href="#构造函数新增的方法" class="headerlink" title="构造函数新增的方法"></a>构造函数新增的方法</h5><ul><li><p>Array.from()</p><ul><li> 将两类对象转为真正的数组：类似数组的对象和可遍历<code>（iterable）</code>的对象（包括 <code>ES6</code> 新增的数据结构 <code>Set</code> 和 <code>Map</code>） </li></ul>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arrayLike = &#123;<br>    <span class="hljs-string">&#x27;0&#x27;</span>: <span class="hljs-string">&#x27;a&#x27;</span>,<br>    <span class="hljs-string">&#x27;1&#x27;</span>: <span class="hljs-string">&#x27;b&#x27;</span>,<br>    <span class="hljs-string">&#x27;2&#x27;</span>: <span class="hljs-string">&#x27;c&#x27;</span>,<br>    <span class="hljs-attr">length</span>: <span class="hljs-number">3</span><br>&#125;;<br><span class="hljs-keyword">let</span> arr2 = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(arrayLike); <span class="hljs-comment">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span><br></code></pre></td></tr></table></figure><ul><li> 还可以接受第二个参数，用来对每个元素进行处理，将处理后的值放入返回的数组 </li></ul>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], <span class="hljs-function">(<span class="hljs-params">x</span>) =&gt;</span> x * x)<br><span class="hljs-comment">// [1, 4, 9]</span><br></code></pre></td></tr></table></figure></li><li><p>Array.of()</p><ul><li> 用于将一组值，转换为数组 </li></ul>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Array</span>.<span class="hljs-title function_">of</span>(<span class="hljs-number">3</span>, <span class="hljs-number">11</span>, <span class="hljs-number">8</span>) <span class="hljs-comment">// [3,11,8]</span><br></code></pre></td></tr></table></figure><ul><li><p>没有参数的时候，返回一个空数组</p><p>当参数只有一个的时候，实际上是指定数组的长度</p><p>参数个数不少于 2 个时，<code>Array()</code>才会返回由参数组成的新数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Array</span>() <span class="hljs-comment">// []</span><br><span class="hljs-title class_">Array</span>(<span class="hljs-number">3</span>) <span class="hljs-comment">// [, , ,]</span><br><span class="hljs-title class_">Array</span>(<span class="hljs-number">3</span>, <span class="hljs-number">11</span>, <span class="hljs-number">8</span>) <span class="hljs-comment">// [3, 11, 8]</span><br></code></pre></td></tr></table></figure></li></ul></li></ul><h5 id="实例对象新增的方法"><a href="#实例对象新增的方法" class="headerlink" title="实例对象新增的方法"></a>实例对象新增的方法</h5><p>关于数组实例对象新增的方法有如下：</p><ul><li><p>copyWithin()</p></li><li><p>find()、findIndex()</p><ul><li> <code>find()</code>用于找出第一个符合条件的数组成员    参数是一个回调函数，接受三个参数依次为当前的值、当前的位置和原数组 </li></ul>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">[<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">10</span>, <span class="hljs-number">15</span>].<span class="hljs-title function_">find</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">value, index, arr</span>) &#123;<br>  <span class="hljs-keyword">return</span> value &gt; <span class="hljs-number">9</span>;<br>&#125;) <span class="hljs-comment">// 10</span><br></code></pre></td></tr></table></figure><ul><li> <code>findIndex</code>返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回<code>-1</code> </li></ul>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">[<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">10</span>, <span class="hljs-number">15</span>].<span class="hljs-title function_">findIndex</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">value, index, arr</span>) &#123;<br>  <span class="hljs-keyword">return</span> value &gt; <span class="hljs-number">9</span>;<br>&#125;) <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure></li><li><p>fill()</p><ul><li> 使用给定值，填充一个数组 </li></ul>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">[<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>].<span class="hljs-title function_">fill</span>(<span class="hljs-number">7</span>)<br><span class="hljs-comment">// [7, 7, 7]</span><br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">3</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-number">7</span>)<br><span class="hljs-comment">// [7, 7, 7]</span><br></code></pre></td></tr></table></figure></li><li><p>entries()，keys()，values()</p><ul><li> <code>keys()</code>是对键名的遍历、<code>values()</code>是对键值的遍历，<code>entries()</code>是对键值对的遍历 </li></ul>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> index <span class="hljs-keyword">of</span> [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>].<span class="hljs-title function_">keys</span>()) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(index);<br>&#125;<br><span class="hljs-comment">// 0</span><br><span class="hljs-comment">// 1</span><br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> elem <span class="hljs-keyword">of</span> [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>].<span class="hljs-title function_">values</span>()) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(elem);<br>&#125;<br><span class="hljs-comment">// &#x27;a&#x27;</span><br><span class="hljs-comment">// &#x27;b&#x27;</span><br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> [index, elem] <span class="hljs-keyword">of</span> [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>].<span class="hljs-title function_">entries</span>()) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(index, elem);<br>&#125;<br><span class="hljs-comment">// 0 &quot;a&quot;</span><br><span class="hljs-comment">// 1 &quot;b&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>includes()</p><ul><li> 用于判断数组是否包含给定的值 </li></ul>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].<span class="hljs-title function_">includes</span>(<span class="hljs-number">2</span>)     <span class="hljs-comment">// true</span><br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].<span class="hljs-title function_">includes</span>(<span class="hljs-number">4</span>)     <span class="hljs-comment">// false</span><br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-title class_">NaN</span>].<span class="hljs-title function_">includes</span>(<span class="hljs-title class_">NaN</span>) <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><ul><li><p>方法的第二个参数表示搜索的起始位置，默认为<code>0</code> 参数为负数则表示倒数的位置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].<span class="hljs-title function_">includes</span>(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>);  <span class="hljs-comment">// false</span><br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].<span class="hljs-title function_">includes</span>(<span class="hljs-number">3</span>, -<span class="hljs-number">1</span>); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>flat()，flatMap()</p><ul><li> 将数组扁平化处理，返回一个新数组，对原数据没有影响 </li></ul>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]].<span class="hljs-title function_">flat</span>()<br><span class="hljs-comment">// [1, 2, 3, 4]</span><br></code></pre></td></tr></table></figure><ul><li> <code>flat()</code>默认只会“拉平”一层，如果想要“拉平”多层的嵌套数组，可以将<code>flat()</code>方法的参数写成一个整数，表示想要拉平的层数，默认为1 </li></ul>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, [<span class="hljs-number">3</span>, [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>]]].<span class="hljs-title function_">flat</span>()<br><span class="hljs-comment">// [1, 2, 3, [4, 5]]</span><br><br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, [<span class="hljs-number">3</span>, [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>]]].<span class="hljs-title function_">flat</span>(<span class="hljs-number">2</span>)<br><span class="hljs-comment">// [1, 2, 3, 4, 5]</span><br></code></pre></td></tr></table></figure><ul><li> <code>flatMap()</code>方法对原数组的每个成员执行一个函数相当于执行<code>Array.prototype.map()</code>，然后对返回值组成的数组执行<code>flat()</code>方法。该方法返回一个新数组，不改变原数组 </li></ul>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 相当于 [[2, 4], [3, 6], [4, 8]].flat()</span><br>[<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>].<span class="hljs-title function_">flatMap</span>(<span class="hljs-function">(<span class="hljs-params">x</span>) =&gt;</span> [x, x * <span class="hljs-number">2</span>])<br><span class="hljs-comment">// [2, 4, 3, 6, 4, 8]</span><br></code></pre></td></tr></table></figure></li></ul><h5 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h5><hr><blockquote><ul><li><a href="https://es6.ruanyifeng.com/#docs/array">https://es6.ruanyifeng.com/#docs/array</a></li></ul></blockquote>]]></content>
    
    
    <categories>
      
      <category>javascript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>es6数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>redux中间件</title>
    <link href="/2018/07/02/react/redux%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    <url>/2018/07/02/react/redux%E4%B8%AD%E9%97%B4%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h4 id="redux中间件"><a href="#redux中间件" class="headerlink" title="redux中间件"></a>redux中间件</h4><blockquote><p>中间件提供第三方插件的模式，自定义拦截<code>action</code>    -&gt;    <code>reducer</code>  的过程。变成  <code>action</code>   -&gt;   <code>middlewares</code>     -&gt;     <code>reducer</code>。  这种机制可以让我们改变数据流，实现如异步  <code>action</code>，  <code>action</code>  过滤，日志输出，异常报告等功能。</p></blockquote><ul><li><code>redux-logger</code>：提供日志输出</li><li><code>redux-thunk</code>：处理异步操作</li><li><code>redux-promise</code>：处理异步操作，<code>actionCreator</code>的返回值是<code>promise</code></li></ul>]]></content>
    
    
    <categories>
      
      <category>react</category>
      
    </categories>
    
    
    <tags>
      
      <tag>react</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>虚拟dom提高性能</title>
    <link href="/2018/06/13/react/%E8%99%9A%E6%8B%9Fdom%E6%8F%90%E9%AB%98%E6%80%A7%E8%83%BD/"/>
    <url>/2018/06/13/react/%E8%99%9A%E6%8B%9Fdom%E6%8F%90%E9%AB%98%E6%80%A7%E8%83%BD/</url>
    
    <content type="html"><![CDATA[<h4 id="为什么虚拟dom会提高性能？"><a href="#为什么虚拟dom会提高性能？" class="headerlink" title="为什么虚拟dom会提高性能？"></a>为什么虚拟dom会提高性能？</h4><blockquote><p>虚拟<code>dom</code>相当于在<code>js</code>和真实<code>dom</code>中间加了一个缓存，利用<code>om diff</code>算法避免了没有必要的<code>dom</code>操作，从而提高性能。</p></blockquote><p>具体实现步骤如下：</p><ul><li>用<code>javascript</code>对象结构标识Dom树的结构；然后用这个树构建一个真正的dom树，插到文档当中</li><li>当状态变更的时候，重新构造一颗新的对象树。然后用新的树和旧的树进行比较，记录两颗树差异</li><li>把第二棵树所记录的差异应用到第一颗所构建的真正dom树上，视图就更新。</li></ul>]]></content>
    
    
    <categories>
      
      <category>react</category>
      
    </categories>
    
    
    <tags>
      
      <tag>react</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>react的diff算法</title>
    <link href="/2018/06/10/react/react%E7%9A%84diff%E7%AE%97%E6%B3%95/"/>
    <url>/2018/06/10/react/react%E7%9A%84diff%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h4 id="react中的diff算法？"><a href="#react中的diff算法？" class="headerlink" title="react中的diff算法？"></a>react中的diff算法？</h4><ul><li>把树形结构按照层级分解，只比较同级元素。</li><li>给列表结构的每个单元添加唯一的<code>key</code>属性，方便比较。</li><li><code>react</code>只会匹配相同的<code>class</code>的<code>component</code>（这里面的<code>class</code>指的是组件的名字）</li><li>合并操作，调用<code>component</code>的<code>setState</code>方法的时候，<code>react</code>将其标记为<code> dirty</code>。到每一个事件循环结束，<code>react</code>检查所有标记<code>dirty</code>的<code>component</code>重新绘制。</li><li>选择性子树渲染。开发人员可以重写<code>shouldComponentUpdate</code>提高<code>diff</code>的性能</li></ul>]]></content>
    
    
    <categories>
      
      <category>react</category>
      
    </categories>
    
    
    <tags>
      
      <tag>react</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>react一些知识点</title>
    <link href="/2018/06/05/react/react%E4%B8%80%E4%BA%9B%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <url>/2018/06/05/react/react%E4%B8%80%E4%BA%9B%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h4 id="shouldComponentUpdate-的作用-？"><a href="#shouldComponentUpdate-的作用-？" class="headerlink" title="shouldComponentUpdate 的作用 ？"></a><strong>shouldComponentUpdate 的作用</strong> ？</h4><p>使用shouldComponentUpdate是优化性能的一个方式。shouldComponentUpdate可以手动的判断组件是否更新渲染，根据组件的是否渲染，来返回一个布尔值。true或者false。从而避免不必要的更新。</p><h4 id="如何告诉-React-它应该编译生产环境版-？"><a href="#如何告诉-React-它应该编译生产环境版-？" class="headerlink" title="如何告诉 React 它应该编译生产环境版 ？"></a><strong>如何告诉 React 它应该编译生产环境版</strong> ？</h4><p>通常情况下我们会使用<code>webpack</code>的<code>DefinePlugin</code>方法来将NODE_ENV变量值设置为<code>production</code>。编译版本中<code>react</code>会忽略<code>proptype</code>验证以及其他的警告信息，同时还会降低代码库的大小。<code>react</code>使用了<code>uglify</code>插件来移除生产环境下不必要的注释等信息。</p><h4 id="概述下-React-中的事件处理逻辑-？"><a href="#概述下-React-中的事件处理逻辑-？" class="headerlink" title="概述下 React 中的事件处理逻辑 ？"></a><strong>概述下 React 中的事件处理逻辑</strong> ？</h4><p>为了解决快于浏览器兼容性的问题，<code>react</code>会将浏览器原生事件封装为合成事件传入设置的事件处理器中。这里的合成时间提供了于原生时间相同的接口，不过他们屏蔽了底层浏览器的细节差异，保证了行为的一致性。另外有意思的是，<code>react</code>并没有直接将事件附着到子元素上，而是以单一事件监听器的方式将所有的事件发送到顶层进行处理。这样<code>react</code>在更新DOM的时候就不许哟啊考虑如何去处理附着在dom上的事件监听器，最终达到优化性能的目的。</p><h4 id="createElement-与-cloneElement-的区别是什么-？"><a href="#createElement-与-cloneElement-的区别是什么-？" class="headerlink" title="createElement 与 cloneElement 的区别是什么 ？"></a><strong>createElement 与 cloneElement 的区别是什么</strong> ？</h4><p><code>createElement</code>函数是JSX编译后使用创建<code>react Element</code>的函数。</p><p><code>cloneElement</code>是用于复制某个元素并传入新的props。</p>]]></content>
    
    
    <categories>
      
      <category>react</category>
      
    </categories>
    
    
    <tags>
      
      <tag>react</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>防抖与节流</title>
    <link href="/2018/06/05/js/%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/"/>
    <url>/2018/06/05/js/%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<br><h4 id="什么是防抖和节流？"><a href="#什么是防抖和节流？" class="headerlink" title="什么是防抖和节流？"></a>什么是防抖和节流？</h4><ul><li>防抖：在一定时间内执行某个事件被触发或者是函数，如果在这个时间内再次触发该事件，则重新计时。只执行最后一次。</li><li>节流：持续触发一个事件，每隔一段时间，只执行一次事件。控制事件执行的次数以及事件触发的频率。从而提高性能。</li></ul><p>简单来说：</p><p>节流: n 秒内只运行一次，若在 n 秒内重复触发，只有一次生效。</p><p>防抖: n 秒后在执行该事件，若在 n 秒内被重复触发，则重新计时，执行最后一次事件。</p><br><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><p>相同点：</p><ul><li>都可以通过使用 <code>setTimeout</code> ，结合闭包实现。</li><li>目的都是为了，降低执行的频率，节省资源。</li></ul><p>不同点：</p><ul><li>防抖，在一段连续操作结束后，处理回调，利用<code>clearTimeout</code>和<code>setTimeout</code>来实现。        节流，在一段连续的操作后，每隔一段时间只执行一次，触发频率高的事件中使用来提高性能。</li><li>防抖关注一定时间连续触发的事件，只在最后执行一次。  节流，每隔多少时间，执行一次。</li></ul><br><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>防抖：</p><ul><li>搜索框搜索输入。   只需用户输入完毕之后，发送请求。</li><li>手机号，邮箱验证输入检测。</li><li>窗口大小resize。     只需窗口调整完成后，计算窗口大小。防止重新渲染。</li></ul><p>节流：</p><ul><li>滚动条滚动，加载更多数据等。</li><li>盒子拖动触发事件。</li><li>搜索框，搜索联想功能。</li></ul>]]></content>
    
    
    <categories>
      
      <category>javascript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>防抖-节流</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>react三个知识点</title>
    <link href="/2018/06/02/react/react%E4%B8%89%E4%B8%AA%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <url>/2018/06/02/react/react%E4%B8%89%E4%B8%AA%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h4 id="React-中-refs-的作用是什么-？"><a href="#React-中-refs-的作用是什么-？" class="headerlink" title="React 中 refs 的作用是什么 ？"></a><strong>React 中 refs 的作用是什么</strong> ？</h4><p>refs是react 提供给我们安全访问dom的一个方法（句柄）。</p><p>可以使用refs属性，在回调函数中第一个参数拿到绑定refs属性的dom值。</p><h4 id="传入-setState-函数的第二个参数的作用是什么？"><a href="#传入-setState-函数的第二个参数的作用是什么？" class="headerlink" title="传入 setState 函数的第二个参数的作用是什么？"></a><strong>传入 setState 函数的第二个参数的作用是什么？</strong></h4><p>setState第一个参数是个对象，第二个参数是个函数。在修改完状态，页面重新渲染的时候。就会触法这个函数。可以用来监听状态是否更新。</p><h4 id="在生命周期中的哪一步你应该发起-AJAX-请求"><a href="#在生命周期中的哪一步你应该发起-AJAX-请求" class="headerlink" title="在生命周期中的哪一步你应该发起 AJAX 请求 ?"></a><strong>在生命周期中的哪一步你应该发起 AJAX 请求</strong> ?</h4><p>在componentDidmount（）生命周期函数中执行。</p><p>原因：</p><p>在react下一代调和算法中，会通过开始或停止来优化性能。这回影响到comonentWillmount触发的次数。触发次数不确定，可能会多次调用componentWillmount（）生命周期方法。如果键ajax请求放到这个生命周期里明显不是一个明智的选择。</p><p>如果将ajax请求放在其他生命周期里，我们不能保证是在挂载完毕后才发出请求。 如果数据在挂载之前就已经完成了，并使用setState将数据添加到组件状态中，对于为挂载的组件则会报错。而在componentDidmount中使用就会避免这个问题。</p>]]></content>
    
    
    <categories>
      
      <category>react</category>
      
    </categories>
    
    
    <tags>
      
      <tag>react</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>jsonp原理及实现</title>
    <link href="/2018/05/25/js/jsonp%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/"/>
    <url>/2018/05/25/js/jsonp%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h3><p> jsonp是一种跨域通信的手段，它的原理其实很简单： </p><ul><li>首先是利用script标签的src属性来实现跨域。</li><li>通过将前端方法作为参数传递到服务器端，然后由服务器端注入参数之后再返回，实现服务器端向客户端通信。</li><li>由于使用script标签的src属性，因此只支持get方法</li></ul><h3 id="2、实现流程"><a href="#2、实现流程" class="headerlink" title="2、实现流程"></a>2、实现流程</h3><ol><li> 设定一个script标签 。</li></ol>   <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;script src=<span class="hljs-string">&quot;http://jsonp.js?callback=xxx&quot;</span>&gt;&lt;/script&gt;<br></code></pre></td></tr></table></figure><ol start="2"><li> callback定义了一个函数名，而远程服务端通过调用指定的函数并传入参数来实现传递参数，将fn(response)传递回客户端 。</li></ol>   <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">$callback = !<span class="hljs-title function_">empty</span>($_GET[<span class="hljs-string">&#x27;callback&#x27;</span>]) ? $_GET[<span class="hljs-string">&#x27;callback&#x27;</span>] : <span class="hljs-string">&#x27;callback&#x27;</span>;<br>echo $callback.<span class="hljs-string">&#x27;(.json_encode($data).)&#x27;</span>;<br></code></pre></td></tr></table></figure><ol start="3"><li> 客户端接收到返回的js脚本，开始解析和执行fn(response) 。</li></ol><h3 id="3、jsonp简单实现"><a href="#3、jsonp简单实现" class="headerlink" title="3、jsonp简单实现"></a>3、jsonp简单实现</h3><p> 一个简单的jsonp实现，其实就是拼接url，然后将动态添加一个script元素到头部。 </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">jsonp</span>(<span class="hljs-params">req</span>)&#123;<br>    <span class="hljs-keyword">var</span> script = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;script&#x27;</span>);<br>    <span class="hljs-keyword">var</span> url = req.<span class="hljs-property">url</span> + <span class="hljs-string">&#x27;?callback=&#x27;</span> + req.<span class="hljs-property">callback</span>.<span class="hljs-property">name</span>;<br>    script.<span class="hljs-property">src</span> = url;<br>    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementsByTagName</span>(<span class="hljs-string">&#x27;head&#x27;</span>)[<span class="hljs-number">0</span>].<span class="hljs-title function_">appendChild</span>(script); <br>&#125;<br></code></pre></td></tr></table></figure><p> <strong>前端js示例</strong> </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">hello</span>(<span class="hljs-params">res</span>)&#123;<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;hello &#x27;</span> + res.<span class="hljs-property">data</span>);<br>&#125;<br><span class="hljs-title function_">jsonp</span>(&#123;<br>    url : <span class="hljs-string">&#x27;&#x27;</span>,<br>    callback : hello <br>&#125;);<br></code></pre></td></tr></table></figure><p> <strong>服务器端代码</strong> </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>);<br><span class="hljs-keyword">var</span> urllib = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;url&#x27;</span>);<br><br><span class="hljs-keyword">var</span> port = <span class="hljs-number">8080</span>;<br><span class="hljs-keyword">var</span> data = &#123;<span class="hljs-string">&#x27;data&#x27;</span>:<span class="hljs-string">&#x27;world&#x27;</span>&#125;;<br><br>http.<span class="hljs-title function_">createServer</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">req,res</span>)&#123;<br>    <span class="hljs-keyword">var</span> params = urllib.<span class="hljs-title function_">parse</span>(req.<span class="hljs-property">url</span>,<span class="hljs-literal">true</span>);<br>    <span class="hljs-keyword">if</span>(params.<span class="hljs-property">query</span>.<span class="hljs-property">callback</span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(params.<span class="hljs-property">query</span>.<span class="hljs-property">callback</span>);<br>        <span class="hljs-comment">//jsonp</span><br>        <span class="hljs-keyword">var</span> str = params.<span class="hljs-property">query</span>.<span class="hljs-property">callback</span> + <span class="hljs-string">&#x27;(&#x27;</span> + <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(data) + <span class="hljs-string">&#x27;)&#x27;</span>;<br>        res.<span class="hljs-title function_">end</span>(str);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        res.<span class="hljs-title function_">end</span>();<br>    &#125;<br>    <br>&#125;).<span class="hljs-title function_">listen</span>(port,<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;jsonp server is on&#x27;</span>);<br>&#125;);<br><br></code></pre></td></tr></table></figure><p> 然而，这个实现虽然简单，但有一些不足的地方：</p><ol><li>我们传递的回调必须是一个全局方法，我们都知道要尽量减少全局的方法。</li><li>需要加入一些参数校验，确保接口可以正常执行。 </li></ol><h3 id="4、-可靠的jsonp实现"><a href="#4、-可靠的jsonp实现" class="headerlink" title="4、 可靠的jsonp实现"></a>4、 可靠的jsonp实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs javascript">(<span class="hljs-keyword">function</span> (<span class="hljs-params"><span class="hljs-variable language_">global</span></span>) &#123;<br>    <span class="hljs-keyword">var</span> id = <span class="hljs-number">0</span>,<br>        container = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementsByTagName</span>(<span class="hljs-string">&quot;head&quot;</span>)[<span class="hljs-number">0</span>];<br><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">jsonp</span>(<span class="hljs-params">options</span>) &#123;<br>        <span class="hljs-keyword">if</span>(!options || !options.<span class="hljs-property">url</span>) <span class="hljs-keyword">return</span>;<br><br>        <span class="hljs-keyword">var</span> scriptNode = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&quot;script&quot;</span>),<br>            data = options.<span class="hljs-property">data</span> || &#123;&#125;,<br>            url = options.<span class="hljs-property">url</span>,<br>            callback = options.<span class="hljs-property">callback</span>,<br>            fnName = <span class="hljs-string">&quot;jsonp&quot;</span> + id++;<br><br>        <span class="hljs-comment">// 添加回调函数</span><br>        data[<span class="hljs-string">&quot;callback&quot;</span>] = fnName;<br><br>        <span class="hljs-comment">// 拼接url</span><br>        <span class="hljs-keyword">var</span> params = [];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> data) &#123;<br>            params.<span class="hljs-title function_">push</span>(<span class="hljs-built_in">encodeURIComponent</span>(key) + <span class="hljs-string">&quot;=&quot;</span> + <span class="hljs-built_in">encodeURIComponent</span>(data[key]));<br>        &#125;<br>        url = url.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&quot;?&quot;</span>) &gt; <span class="hljs-number">0</span> ? (url + <span class="hljs-string">&quot;&amp;&quot;</span>) : (url + <span class="hljs-string">&quot;?&quot;</span>);<br>        url += params.<span class="hljs-title function_">join</span>(<span class="hljs-string">&quot;&amp;&quot;</span>);<br>        scriptNode.<span class="hljs-property">src</span> = url;<br><br>        <span class="hljs-comment">// 传递的是一个匿名的回调函数，要执行的话，暴露为一个全局方法</span><br>        <span class="hljs-variable language_">global</span>[fnName] = <span class="hljs-keyword">function</span> (<span class="hljs-params">ret</span>) &#123;<br>            callback &amp;&amp; <span class="hljs-title function_">callback</span>(ret);<br>            container.<span class="hljs-title function_">removeChild</span>(scriptNode);<br>            <span class="hljs-keyword">delete</span> <span class="hljs-variable language_">global</span>[fnName];<br>        &#125;<br><br>        <span class="hljs-comment">// 出错处理</span><br>        scriptNode.<span class="hljs-property">onerror</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>            callback &amp;&amp; <span class="hljs-title function_">callback</span>(&#123;<span class="hljs-attr">error</span>:<span class="hljs-string">&quot;error&quot;</span>&#125;);<br>            container.<span class="hljs-title function_">removeChild</span>(scriptNode);<br>            <span class="hljs-variable language_">global</span>[fnName] &amp;&amp; <span class="hljs-keyword">delete</span> <span class="hljs-variable language_">global</span>[fnName];<br>        &#125;<br><br>        scriptNode.<span class="hljs-property">type</span> = <span class="hljs-string">&quot;text/javascript&quot;</span>;<br>        container.<span class="hljs-title function_">appendChild</span>(scriptNode)<br>    &#125;<br><br>    <span class="hljs-variable language_">global</span>.<span class="hljs-property">jsonp</span> = jsonp;<br><br>&#125;)(<span class="hljs-variable language_">this</span>);<br><br></code></pre></td></tr></table></figure><p> <strong>使用示例</strong> </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">jsonp</span>(&#123;    url : <span class="hljs-string">&quot;www.example.com&quot;</span>,   <br> data : &#123;id : <span class="hljs-number">1</span>&#125;,    callback : <span class="hljs-keyword">function</span> (<span class="hljs-params">ret</span>)<br>&#123;    <br>     <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(ret);    &#125;&#125;);<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>javascript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jsonp原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>var,let,const的区别</title>
    <link href="/2018/03/28/js/var-let-const%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2018/03/28/js/var-let-const%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h4 id="说说var、let、const之间的区别？"><a href="#说说var、let、const之间的区别？" class="headerlink" title="说说var、let、const之间的区别？"></a>说说var、let、const之间的区别？</h4><hr><h5 id="Var："><a href="#Var：" class="headerlink" title="Var："></a>Var：</h5><p>用var声明的变量既是全局变量，也是顶层变量。</p><p>注意：顶层变量，在浏览器环境里指的是window对象，在node指的是global对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-property">a</span>) <span class="hljs-comment">// 10</span><br></code></pre></td></tr></table></figure><ul><li><p>使用var存在变量提升的情况</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a)  <span class="hljs-comment">//undefind</span><br><span class="hljs-keyword">var</span> a = <span class="hljs-number">20</span><br></code></pre></td></tr></table></figure></li><li><p> 使用<code>var</code>，我们能够对一个变量进行多次声明，后面声明的变量会覆盖前面的变量声明 。</p></li></ul>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">20</span><br><span class="hljs-keyword">var</span> a = <span class="hljs-number">30</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a)   <span class="hljs-comment">//30</span><br></code></pre></td></tr></table></figure><ul><li><p>在函数中使用var声明变量，该变量是局部的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">20</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">change</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">var</span> a = <span class="hljs-number">30</span><br>&#125;<br><span class="hljs-title function_">change</span>()<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a)  <span class="hljs-comment">// 20 </span><br></code></pre></td></tr></table></figure></li><li><p>在函数中不使用var声明变量，该变量是全局的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">20</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">change</span>(<span class="hljs-params"></span>)&#123;<br>   a = <span class="hljs-number">30</span><br>&#125;<br><span class="hljs-title function_">change</span>()<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a) <span class="hljs-comment">// 30 </span><br></code></pre></td></tr></table></figure></li></ul><hr><h5 id="Let："><a href="#Let：" class="headerlink" title="Let："></a>Let：</h5><p>let是es6新增的语法，用来声明变量。</p><ul><li><p>只能在let代码块内有效。具有块级作用域。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&#123;<br>    <span class="hljs-keyword">let</span> a = <span class="hljs-number">20</span><br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a) <span class="hljs-comment">// ReferenceError: a is not defined.</span><br></code></pre></td></tr></table></figure></li><li><p>存在暂时性死区的问题，没有变量提升。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a)   <span class="hljs-comment">// Uncaught ReferenceError: Cannot access &#x27;a&#x27; before initialization</span><br><br><span class="hljs-keyword">let</span> a = <span class="hljs-number">30</span><br></code></pre></td></tr></table></figure></li><li><p>let 不能重复声明一个变量。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> a = <span class="hljs-number">20</span><br><span class="hljs-keyword">let</span> a = <span class="hljs-number">30</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a)   <span class="hljs-comment">//SyntaxError: Identifier &#x27;a&#x27; has already been declared</span><br></code></pre></td></tr></table></figure></li></ul><hr><h5 id="Const："><a href="#Const：" class="headerlink" title="Const："></a>Const：</h5><ul><li> <code>const</code>声明一个只读的常量，一旦声明，常量的值就不能改变 。</li></ul>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> a = <span class="hljs-number">1</span><br>a = <span class="hljs-number">3</span><br><span class="hljs-comment">// TypeError: Assignment to constant variable.</span><br></code></pre></td></tr></table></figure><ul><li> 之前用<code>var</code>或<code>let</code>声明过变量，再用<code>const</code>声明同样会报错 。</li></ul>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">20</span><br><span class="hljs-keyword">let</span> b = <span class="hljs-number">20</span><br><span class="hljs-keyword">const</span> a = <span class="hljs-number">30</span><br><span class="hljs-keyword">const</span> b = <span class="hljs-number">30</span><br><span class="hljs-comment">// 都会报错</span><br></code></pre></td></tr></table></figure><hr><h5 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h5><ul><li>var存在变量提升，let和const不存在变量提升。</li><li>var不存在暂时性死区，let和const存在暂时性死区，只有先正确声明好变量才能获取和使用该变量。</li><li>var不存在块级作用域，let和const存在块级作用域。</li><li>var可以重复声明变量，后者声明的值覆盖前者。let和const不能重复声明。</li><li>var和let可以修改值，const是一个常量，不能修改。</li></ul><hr><h5 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h5><hr><blockquote><ul><li><a href="https://es6.ruanyifeng.com/">https://es6.ruanyifeng.com/</a></li></ul></blockquote><blockquote><ul><li><a href="https://vue3js.cn/interview/es6/var_let_const.html#%E4%B8%80%E3%80%81var">https://vue3js.cn/interview/es6/var_let_const.html#%E4%B8%80%E3%80%81var</a></li></ul></blockquote>]]></content>
    
    
    <categories>
      
      <category>javascript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>区别</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>

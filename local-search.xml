<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>vue3和vue2 API的区别</title>
    <link href="/2021/06/09/vue3%E5%92%8Cvue2-API%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2021/06/09/vue3%E5%92%8Cvue2-API%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h4 id="Vue3-0-所采用的-Composition-Api-与-Vue2-x-使用的-Options-Api-有什么不同？"><a href="#Vue3-0-所采用的-Composition-Api-与-Vue2-x-使用的-Options-Api-有什么不同？" class="headerlink" title="Vue3.0 所采用的 Composition Api 与 Vue2.x 使用的 Options Api 有什么不同？"></a>Vue3.0 所采用的 Composition Api 与 Vue2.x 使用的 Options Api 有什么不同？</h4><ol><li><p>options API:</p><p>即选项式API，通过定义methods，data，computed，watch等属性与方法，共同处理页面逻辑。</p><p>一个功能的实现，需要不同的vue配置项，定义属相和方法比较分散。大项目可能包含多个方法，这可能会导致组件难以阅读和理解。</p><p>如图：</p><p><img src="/2021/06/09/vue3%E5%92%8Cvue2-API%E7%9A%84%E5%8C%BA%E5%88%AB/tt.png"></p></li><li><p>composition API:</p><p>一个功能的所有api都会放在一起，实现了高内聚，低耦合。方便找到功能所对应的方法及属性。</p><p>根据逻辑相关性组织代码，提高可读性和可维护性，基于函数组合的API。</p><p>如图：</p><p><img src="/2021/06/09/vue3%E5%92%8Cvue2-API%E7%9A%84%E5%8C%BA%E5%88%AB/cc.png"></p><h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h4><hr><blockquote><ul><li><a href="https://vue3js.cn/interview/vue3/composition.html#%E6%AD%A3%E6%96%87">https://vue3js.cn/interview/vue3/composition.html#%E6%AD%A3%E6%96%87</a></li></ul></blockquote></li></ol>]]></content>
    
    
    <categories>
      
      <category>vue3</category>
      
    </categories>
    
    
    <tags>
      
      <tag>optionsAPI</tag>
      
      <tag>compositionAPI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue3使用proxy代替defindproerty</title>
    <link href="/2021/06/08/vue3%E4%BD%BF%E7%94%A8proxy%E4%BB%A3%E6%9B%BFdefindproerty/"/>
    <url>/2021/06/08/vue3%E4%BD%BF%E7%94%A8proxy%E4%BB%A3%E6%9B%BFdefindproerty/</url>
    
    <content type="html"><![CDATA[<h4 id="Vue3-0里为什么要用-Proxy-API-替代-defineProperty-API-？"><a href="#Vue3-0里为什么要用-Proxy-API-替代-defineProperty-API-？" class="headerlink" title="Vue3.0里为什么要用 Proxy API 替代 defineProperty API ？"></a>Vue3.0里为什么要用 Proxy API 替代 defineProperty API ？</h4><hr>proxy的性能本来比defindproerty好，proxy可以拦截属性的访问，赋值，删除等操作，不需要初始化的时候遍历所有属性。另外如果是多层嵌套的对象，只有访问某个属性的时候，才会递归处理下一级的属性。<p>object.defineproperty():</p><ul><li>检测不到对象属性的添加和删除   在这里可以使用set，delete方法。</li><li>不能根据数组索引来修改值</li><li>需要遍历每个属性进行遍历监听，如果是嵌套对象的话，就需要深层监听，造成性能问题。</li></ul><p>proxy：</p><ul><li>可以直接监听整个对象</li><li>可以直接监听数组的变化（push，shift，splice）</li><li>有多达13种拦截方法，不限于apply，has等等，是defindproerty不具备的</li><li>返回一个新的对象，只操作新的对象就能达到目的。</li></ul><br><h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h4><hr><blockquote><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty</a></li></ul></blockquote><blockquote><ul><li><a href="https://vue3js.cn/interview/vue3/proxy.html#%E4%B8%80%E3%80%81object-defineproperty">https://vue3js.cn/interview/vue3/proxy.html#%E4%B8%80%E3%80%81object-defineproperty</a></li></ul></blockquote>]]></content>
    
    
    <categories>
      
      <category>vue3</category>
      
    </categories>
    
    
    <tags>
      
      <tag>proxy,defindproerty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue3.x设计目标及优化</title>
    <link href="/2021/06/06/vue3-0%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8F%8A%E4%BC%98%E5%8C%96/"/>
    <url>/2021/06/06/vue3-0%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8F%8A%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h4 id="vue3-0的设计目标是什么？做了那些优化？"><a href="#vue3-0的设计目标是什么？做了那些优化？" class="headerlink" title="vue3.0的设计目标是什么？做了那些优化？"></a>vue3.0的设计目标是什么？做了那些优化？</h4><hr>设计目标：<ul><li>打包体积更小： vue3移除一些不常用的API，将无用的模块“剪辑”掉，仅打包需要的，使打包体积更小了。</li><li>速度更快：   diff算法优化，静态提升。</li><li>更灵活的代码组织能力：    推出composition  API，大大增加了代码的逻辑组织能力和代码复用能力。</li></ul><p>优化方案：</p><ul><li>源码<ul><li>使用ts语法，源码的优化。</li></ul></li><li>性能<ul><li>体积，编译，数据劫持优化。</li></ul></li><li>语法 API<ul><li><p>组合式API，根据相关逻辑组织代码。</p><p><img src="/2021/06/06/vue3-0%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8F%8A%E4%BC%98%E5%8C%96/tt.png"></p></li></ul></li></ul><br><h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献:"></a>参考文献:</h4><hr><blockquote><ul><li><a href="https://juejin.cn/post/6850418112878575629#heading-5">https://juejin.cn/post/6850418112878575629#heading-5</a></li></ul></blockquote><blockquote><ul><li><a href="https://vue3js.cn/docs/zh">https://vue3js.cn/docs/zh</a></li></ul></blockquote>]]></content>
    
    
    <categories>
      
      <category>vue3</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue3性能提升</title>
    <link href="/2021/04/27/vue3%E6%80%A7%E8%83%BD%E6%8F%90%E5%8D%87/"/>
    <url>/2021/04/27/vue3%E6%80%A7%E8%83%BD%E6%8F%90%E5%8D%87/</url>
    
    <content type="html"><![CDATA[<h4 id="Vue3-0性能提升主要是通过哪几方面体现的？"><a href="#Vue3-0性能提升主要是通过哪几方面体现的？" class="headerlink" title="Vue3.0性能提升主要是通过哪几方面体现的？"></a>Vue3.0性能提升主要是通过哪几方面体现的？</h4><p><img src="/2021/04/27/vue3%E6%80%A7%E8%83%BD%E6%8F%90%E5%8D%87/tt.png"></p><h5 id="编译阶段"><a href="#编译阶段" class="headerlink" title="编译阶段"></a>编译阶段</h5><ul><li><p>diff算法优化</p><ul><li><p>vue3在diff算法中相比vue2增加了静态标记。作用：为了会发生变化的地方添加一个flag标记，下次发生变化的时候直接找该地方进行比较即可。</p><p>下图这里，已经标记静态节点的p标签在diff过程中则不会比较，把性能进一步提高。</p><p><img src="/2021/04/27/vue3%E6%80%A7%E8%83%BD%E6%8F%90%E5%8D%87/cc.png"></p></li></ul></li><li><p>静态提升</p><ul><li>vue3中对不参与更新的元素，会做静态提升，只会被创建一次，在渲染时直接复用。</li></ul></li><li><p>事件监听缓存</p></li><li><p>SSR优化</p><ul><li>当静态内容达到一定量度时，会使用服务端渲染。</li></ul></li></ul><h5 id="源码体积"><a href="#源码体积" class="headerlink" title="源码体积"></a>源码体积</h5><ul><li><p>相比vue2，vue3整体体积变小了，除了移除一些不常用的API，在重要的是<code>Tree shanking</code>(树摇)。比如任何一个函数（ref，reactived，computed）等，仅用到的时候才打包，没用到的模块都被摇掉，打包的整体体积变小。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; computed, defineComponent, ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineComponent</span>(&#123;<br>    <span class="hljs-title function_">setup</span>(<span class="hljs-params">props, context</span>) &#123;<br>        <span class="hljs-keyword">const</span> age = <span class="hljs-title function_">ref</span>(<span class="hljs-number">18</span>)<br><br>        <span class="hljs-keyword">let</span> state = <span class="hljs-title function_">reactive</span>(&#123;<br>            <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;test&#x27;</span><br>        &#125;)<br><br>        <span class="hljs-keyword">const</span> readOnlyAge = <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> age.<span class="hljs-property">value</span>++) <span class="hljs-comment">// 19</span><br><br>        <span class="hljs-keyword">return</span> &#123;<br>            age,<br>            state,<br>            readOnlyAge<br>        &#125;<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure></li></ul><h5 id="响应式系统"><a href="#响应式系统" class="headerlink" title="响应式系统"></a>响应式系统</h5><ul><li>vue2中采用defineProerty来劫持整个对象，然后进行深度遍历所有属性，给每个属性添加getter和setter，实现响应式。</li><li>vue3采用proxy代理对象，因为proxy可以对整个对象进行监听，所以不需要深度遍历。<ul><li>可以监听整个对象的修改和添加</li><li>可以监听数组的索引和数组length属性。</li></ul></li></ul><br> <h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h4><hr><blockquote><ul><li><a href="https://juejin.cn/post/6903171037211557895">https://juejin.cn/post/6903171037211557895</a></li></ul></blockquote><blockquote><ul><li><a href="https://vue3js.cn/interview/vue3/performance.html#%E4%B8%80%E3%80%81%E7%BC%96%E8%AF%91%E9%98%B6%E6%AE%B5">https://vue3js.cn/interview/vue3/performance.html#%E4%B8%80%E3%80%81%E7%BC%96%E8%AF%91%E9%98%B6%E6%AE%B5</a></li></ul></blockquote>]]></content>
    
    
    <categories>
      
      <category>vue3</category>
      
    </categories>
    
    
    <tags>
      
      <tag>性能提升</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Pandas统计分析</title>
    <link href="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/"/>
    <url>/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="第二章-Pandas统计分析"><a href="#第二章-Pandas统计分析" class="headerlink" title="第二章 Pandas统计分析"></a>第二章 Pandas统计分析</h1><p>Pandas是Python的核心数据分析支持库，它提供了大量能使我们快速便捷地处理数据的函数和方法。<br>由于Pandas相关知识非常多，本书将Pandas分为上、下两章进行讲解。本章开始Pandas入门内容，从安装开始，逐步介绍Pandas相关的入门知识，包括两个主要的数据结构，即Series对象和DataFrame对象，也包括如何导入外部数据、数据抽取，以及数据的增加、修改和删除，还包括数据清洗、索引设置、数据排序与排名等相关基础知识，这些都是在为后期数据处理和数据分析打下良好的基础。</p><h2 id="一-Pandas概述"><a href="#一-Pandas概述" class="headerlink" title="一. Pandas概述"></a>一. Pandas概述</h2><p>Pandas是数据分析三大剑客之一，是Python的核心数据分析库，它提供了快速、灵活、明确的数据结构，能够简单、直观、快速地处理各种类型的数据，具体介绍如下所示。</p><p>Pandas能够处理以下类型的数据。　</p><p>1.与SQL或Excel表类似的数据。　</p><p>2.有序和无序（非固定频率）的时间序列数据。　</p><p>3.带行、列标签的矩阵数据。</p><p>4.任意其他形式的观测、统计数据集。</p><p>Pandas提供的两个主要数据结构Series（一维数组结构）与DataFrame（二维数组结构），可以处理金融、统计、社会科学、工程等领域里的大多数典型案例，并且Pandas是基于NumPy开发的，可以与其他第三方科学计算库完美集成。<br>Pandas的功能很多，它的优势如下。　</p><p>list1=[0,1,2,3,4,5]</p><p>list2=[[0,1,2,3,4,5],[0,1,2,3,4,5]]</p><p>1.处理浮点与非浮点数据里的缺失数据，表示为<strong>NaN</strong>。　</p><p>2.大小可变，例如插入或删除DataFrame等多维对象的列。</p><p>3.自动、显式数据对齐，显式地将对象与一组标签对齐，也可以忽略标签，在Series、DataFrame计算时自动与数据对齐。　</p><p>4.强大、灵活的分组统计（groupby）功能，即数据聚合、数据转换。　</p><p>5.把Python和NumPy数据结构里不规则、不同索引的数据轻松地转换为DataFrame对象。　</p><p>6.智能标签，对大型数据集进行切片、花式索引、子集分解等操作。　</p><p>7.直观地合并（merge）、连接（join）数据集。　灵活地重塑（reshape）、透视（pivot）数据集。</p><p>8.成熟的导入、导出工具，导入文本文件（CSV等支持分隔符的文件）、Excel文件、数据库等来源的数据，导出Excel文件、文本文件等，利用超快的HDF5格式保存或加载数据。　</p><p>9.时间序列：支持日期范围生成、频率转换、移动窗口统计、移动窗口线性回归、日期位移等时间序列功能。</p><p>例1.读取excel数据</p><p>01 import pandas as pd               #导入pandas 模块<br>02 df=pd.read_excel(‘data.xlsx’)      #读取Excel 文件<br>03 df1=df.head()                      #显示前5 条数据</p><h2 id="二-seires-对象"><a href="#二-seires-对象" class="headerlink" title="二. seires 对象"></a>二. seires 对象</h2><p>Pandas是Python数据分析重要的库，而Series和DataFrame是Pandas库中两个重要的对象，也是Pandas中两个重要的数据结构，如图所示。</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018035610974.png" alt="image-20211018035610974"><br>本节将主要介绍Series对象。</p><h3 id="2-1-图解Series对象"><a href="#2-1-图解Series对象" class="headerlink" title="2.1　图解Series对象"></a>2.1　图解Series对象</h3><p>Series是Python的Pandas库中的一种数据结构，它类似一维数组，由一组数据以及与这组数据相关的标签（即索引)组成，或者仅有一组数据没有索引也可以创建一个简单的Series。Series可以存储整数、浮点数、字符串、Python对象等多种类型的数据。<br>例如，在成绩表（见图3)中包含了Series对象和DataFrame对象，其中“语文”“数学”“英语”3列中的每一列均是一个Series对象，而“语文”“数学”“英语”3列组成了一个DataFrame对象，如图4所示。</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018035821898.png" alt="image-20211018035821898"></p><p>​                                                                                           图3</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018035900680.png" alt="image-20211018035900680"></p><p>​                                                                                         图4</p><h3 id="2-2-创建一个series对象"><a href="#2-2-创建一个series对象" class="headerlink" title="2.2 创建一个series对象"></a>2.2 创建一个series对象</h3><p>创建Series对象主要使用Pandas的Series()方法，语法如下：</p><p>s=pd.Series(data,index=index)</p><p>参数说明：　</p><p>data：表示数据，支持Python字典、多维数组、标量值（即只有大小，没有方向的量。也就是说，只是一个数值，如s=pd.Series(5)）。　index：表示行标签（索引）。　</p><p>返回值：Series对象。</p><p>说明<br>当data参数是多维数组时，index长度必须与data长度一致。如果没有指定index参数，则自动创建数值型索引（从0～data数据长度-1）。</p><p>【示例02】　在成绩表添加一列“物理”成绩。（示例位置：资源包\MR\Code\03\02）创建一个Series对象，在成绩表中添加一列“物理”成绩。程序代码如下：</p><p>01 import pandas as pd<br>02 s1=pd.Series([88,60,75])<br>03 print(s1)</p><p>上述举例，如果通过Pandas模块引入Series对象，那么就可以直接在程序中使用Series对象了。主要代码如下：</p><p>01 from pandas import Series<br>02 s1=Series([88,60,75])</p><h3 id="2-3-手动设置series索引"><a href="#2-3-手动设置series索引" class="headerlink" title="2.3 手动设置series索引"></a>2.3 手动设置series索引</h3><p>创建Series对象时会自动生成整数索引，默认值从0开始至数据长度减1。例如，3.2.1节举例中使用的就是默认索引，如0、1、2。除了使用默认索引，还可以通过index参数手动设置索引。</p><p>【示例03】　手动设置索引。（示例位置：资源包\MR\Code\03\03）<br>下面手动设置索引，将3.2.1节添加的“物理”成绩的索引设置为1、2、3，也可以是“明日同学”“高同学”“七月流火”。</p><p>程序代码如下：</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018040816095.png" alt="image-20211018040816095"></p><p>运行程序，控制台输出结果如下：</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018040836315.png" alt="image-20211018040836315"></p><p>说明<br>上述结果中输出的dtype是DataFrame数据的数据类型，int为整型，后面的数字表示位数。</p><h3 id="2-4-series-位置索引"><a href="#2-4-series-位置索引" class="headerlink" title="2.4 series 位置索引"></a>2.4 series 位置索引</h3><h4 id="2-4-1-series位置索引"><a href="#2-4-1-series位置索引" class="headerlink" title="2.4.1 series位置索引"></a>2.4.1 series位置索引</h4><p>位置索引是从0开始数，[0]是Series第一个数，[1]是Series第二个数，以此类推。</p><p>【示例04】　通过位置索引获取学生物理成绩。（示例位置：资源包\MR\Code\03\04）获取第一个学生的物理成绩。程序代码如下：</p><p>01 import pandas as pd<br>02 s1=pd.Series([88,60,75])<br>03 print(s1[0])<br>运行程序，控制台输出结果如下：</p><p>88</p><p><strong>注意</strong><br><strong>Series不能使用[-1]定位索引。</strong></p><h4 id="2-4-2-series-标签索引"><a href="#2-4-2-series-标签索引" class="headerlink" title="2.4.2 series 标签索引"></a>2.4.2 series 标签索引</h4><p>Series标签索引与位置索引方法类似，用[ ]表示，里面是索引名称，注意index的数据类型是字符串，如果需要获取多个标签索引值，用[[ ]]表示（相当于[ ]中包含一个列表）。</p><p>【示例05】　通过标签索引获取学生物理成绩。（示例位置：资源包\MR\Code\03\05）通过标签索引“明日同学”和“七月流火”获取物理成绩，程序代码如下：</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018041305145.png" alt="image-20211018041305145"></p><h4 id="2-4-3-series-切片索引"><a href="#2-4-3-series-切片索引" class="headerlink" title="2.4.3 series 切片索引"></a>2.4.3 series 切片索引</h4><p>用标签索引做切片，包头包尾（即包含索引开始位置的数据，也包含索引结束位置的数据）。</p><p>【示例06】　通过切片获取数据。（示例位置：资源包\MR\Code\03\06）通过标签切片索引“明日同学”至“七月流火”获取数据。程序代码如下：</p><p>print(s1[‘明日同学’:’七月流火’])     #通过切片获取索引值</p><p>用位置索引做切片，和list列表用法一样，包头不包尾（即包含索引开始位置的数据，不包含索引结束位置的数据）。</p><p>【示例07】　通过位置切片获取数据。（示例位置：资源包\MR\Code\03\07）通过位置切片1～4获取数据，程序代码如下：</p><p>01  s2=pd.Series([88,60,75,34,68])<br>02  print(s2[1:4])<br>运行程序，控制台输出结果如下：</p><p>1  60<br>2  75<br>3  34</p><h4 id="2-4-5-获取series索引和值"><a href="#2-4-5-获取series索引和值" class="headerlink" title="2.4.5 获取series索引和值"></a>2.4.5 获取series索引和值</h4><p>获取Series索引和值主要使用Series的index和values方法。</p><p>【示例08】　获取物理成绩的索引和值。（示例位置：资源包\MR\Code\03\08）下面使用Series的index和values方法获取物理成绩的索引和值，程序代码如下：</p><p>01 import pandas as pd<br>02 s1=pd.Series([88,60,75])<br>03 print(s1.index)<br>04 print(s1.values)<br>运行程序，控制台输出结果如下：</p><p>RangeIndex(start=0, stop=3, step=1)<br>[88 60 75]</p><h2 id="三-DataFrame对象"><a href="#三-DataFrame对象" class="headerlink" title="三. DataFrame对象"></a>三. DataFrame对象</h2><p>DataFrame是Pandas库中的一种数据结构，它是由多种类型的列组成的二维表数据结构，类似于Excel、SQL或Series对象构成的字典。DataFrame是最常用的Pandas对象，它与Series对象一样支持多种类型的数据。</p><h3 id="3-1-图解DataFrame对象"><a href="#3-1-图解DataFrame对象" class="headerlink" title="3.1　图解DataFrame对象"></a>3.1　图解DataFrame对象</h3><p>DataFrame是一个二维表数据结构，由行、列数据组成的表格。DataFrame既有行索引也有列索引，它可以看作是由Series对象组成的字典，不过这些Series对象共用一个索引，如图3.11所示。</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018042136168.png" alt="image-20211018042136168"></p><p>图3.11　DataFrame结构<br>处理DataFrame表格数据时，用index表示行或用columns表示列更直观。用这种方式迭代DataFrame的列，代码更易读懂。</p><p>【示例09】　遍历DataFrame数据。（示例位置：资源包\MR\Code\03\09）遍历DataFrame数据，输出成绩表的每一列数据，程序代码如下：</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018042332305.png" alt="image-20211018042332305"></p><p>运行程序，控制台输出结果如下：</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018042319399.png" alt="image-20211018042319399"></p><p>从运行结果得知，上述代码返回的其实是Series，如图3.12所示。Pandas之所以提供多种数据结构，其目的就是为了代码易读、操作更加方便。</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018042510540.png" alt="image-20211018042510540"></p><h3 id="3-2-创建一个DataFrame对象"><a href="#3-2-创建一个DataFrame对象" class="headerlink" title="3.2 创建一个DataFrame对象"></a>3.2 创建一个DataFrame对象</h3><p>创建DataFrame主要使用Pandas的DataFrame()方法，语法如下：</p><p>pandas.DataFrame(data,index,columns,dtype,copy)<br>参数说明：　</p><p>data：表示数据，可以是ndarray数组、Series对象、列表、字典等。　</p><p>index：表示行标签（索引）。</p><p>columns：列标签（索引）。　</p><p>dtype：每一列数据的数据类型，其与Python数据类型有所不同，如object数据类型对应的是Python的字符型。</p><p>表3.1为Pandas数据类型与Python数据类型的对应表。</p><p>category作业，查询datetime64,timedela[ns],category</p><p>Timedelta在pandas中是一个表示两个datetime值之间的差(如日,秒和微妙)的类型,2个Datetime数据运算相减得出的结果就是一个Timedelta数据类型</p><p>​                                                                                          表3.1　数据类型对应表　</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018042916094.png" alt="image-20211018042916094"></p><p>copy：用于复制数据。　</p><p>返回值：DataFrame。<br>下面通过两种方法来创建DataFrame，即通过二维数组创建和通过字典创建。</p><p>1．通过二维数组创建DataFrame【示例10】　通过二维数组创建成绩表。（示例位置：资源包\MR\Code\03\10）<br>通过二维数组创建成绩表，包括语文、数学和英语，程序代码如下：</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018043105059.png" alt="image-20211018043105059"></p><p>运行程序，控制台输出结果如下：</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018043117683.png" alt="image-20211018043117683"></p><p>2．通过字典创建DataFrame<br>通过字典创建DataFrame，需要注意：字典中的value值只能是一维数组或单个的简单数据类型，如果是数组，要求所有数组长度一致；如果是单个数据，则每行都添加相同数据。</p><p>【示例11】　通过字典创建成绩表。（示例位置：资源包\MR\Code\03\11）通过字典创建成绩表，包括语文、数学、英语和班级，程序代码如下：</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018043238790.png" alt="image-20211018043238790"></p><p>运行程序，控制台输出结果如下：</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018043309599.png" alt="image-20211018043309599"></p><p>上述代码中，“班级”的value值是一个单个数据，所以每一行都添加了相同的数据“高一7班”。</p><h3 id="3-3-DataFrame重要属性和函数"><a href="#3-3-DataFrame重要属性和函数" class="headerlink" title="3.3 DataFrame重要属性和函数"></a>3.3 DataFrame重要属性和函数</h3><p>DataFrame是Pandas一个重要的对象，它的属性和函数很多，下面先简单了解DataFrame的几个重要属性和函数。重要属性介绍如表3.2所示，重要函数介绍如表3.3所示。</p><p>​                                                                                               表3.2　重要属性</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018043520943.png" alt="image-20211018043520943"></p><p>​                                                                                                  表3.3　重要函数</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018043534263.png" alt="image-20211018043534263"></p><h3 id="3-4-导入外部数据"><a href="#3-4-导入外部数据" class="headerlink" title="3.4 导入外部数据"></a>3.4 导入外部数据</h3><p>数据分析首先就要有数据。那么，数据类型有多种，本节介绍如何导入不同类型的外部数据。</p><h4 id="3-4-1-导入-xls或-xlsx文件"><a href="#3-4-1-导入-xls或-xlsx文件" class="headerlink" title="3.4.1　导入.xls或.xlsx文件"></a>3.4.1　导入.xls或.xlsx文件</h4><p>导入.xls或.xlsx文件主要使用Pandas的read_excel()方法，语法如下：</p><p>pandas.read_excel(io,sheet_name=0,header=0,names=None,index_col=None,usecols=None,squeeze=False,<br>dtype=None,engine=None,converters=None,true_values=None,false_values=None,skiprows=None,nrow=None,<br>na_values=None,keep_default_na=True,verbose=False,parse_dates=False,date_parser=None,thousands=None,<br>comment=None,skipfooter=0,conver_float=True,mangle_dupe_cols=True,**kwds)<br>常用参数说明：　</p><p>io：字符串，.xls或.xlsx文件路径或类文件对象。　</p><p>sheet_name：None、字符串、整数、字符串列表或整数列表，默认值为0。字符串用于工作表名称，整数为索引表示工作表位置，字符串列表或整数列表用于请求多个工作表，为None时获取所有工作表。参数值如表3.4所示。</p><p>​                                                                                     表3.4　sheet_name参数值　</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018043941426.png" alt="image-20211018043941426"></p><p>header：指定作为列名的行，默认值为0，即取第一行的值为列名。数据为除列名以外的数据；若数据不包含列名，则设置header=None。　</p><p>names：默认值为None，要使用的列名列表。　</p><p>index_col：指定列为索引列，默认值为None，索引0是DataFrame的行标签。</p><p>usecols：int、list列表或字符串，默认值为None。　如果为None，则解析所有列。　如果为int，则解析最后一列。　如果为list列表，则解析列号列表的列。　如果为字符串，则表示以逗号分隔的Excel列字母和列范围列表（例如“A:E”或“A,C,E:F”）。范围包括双方。　</p><p>squeeze：布尔值，默认值为False，如果解析的数据只包含一列，则返回一个Series。　</p><p>dtype：列的数据类型名称或字典，默认值为None。例如{‘a’:np.float64,’b’:np.int32}。　</p><p>skiprows：省略指定行数的数据，从第一行开始。　</p><p>skipfooter：省略指定行数的数据，从尾部数的行开始。</p><p>下面通过示例，详细介绍如何导入.xlsx文件。</p><h5 id="1．常规导入导入Excel文件。"><a href="#1．常规导入导入Excel文件。" class="headerlink" title="1．常规导入导入Excel文件。"></a>1．常规导入导入Excel文件。</h5><p>【示例12】　（示例位置：资源包\MR\Code\03\12）导入“1月.xlsx”Excel文件，程序代码如下：</p><p>01 import pandas as pd<br>02 df=pd.read_excel(‘1 月.xlsx’)<br>03 df1=df.head()          #输出前5 条数据<br>运行程序，输出前5条数据，结果如图3.13所示。<br>图3.13　1月淘宝销售数据（前5条数据）</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018044223025.png" alt="image-20211018044223025"></p><p>知识胶囊<br>导入外部数据，必然要涉及路径问题，下面来了解一下相对路径和绝对路径。　</p><p><strong>相对路径</strong>：相对路径就是以当前文件为基准进行一级级目录指向被引用的资源文件。以下是常用的表示当前目录和当前目录的父级目录的标识符。　../：表示当前文件所在目录的上一级目录。　./：表示当前文件所在的目录（可以省略）。　/：表示当前文件的根目录（域名映射或硬盘目录）。　如果使用系统默认文件路径\，那么，在Python中则需要在路径最前面加一个r，以避免路径里面的\被转义。　</p><p><strong>绝对路径</strong>：绝对路径是文件真正存在的路径，是指从硬盘的根目录（盘符）开始，进行一级级目录指向文件。</p><h5 id="2．导入指定的Sheet页"><a href="#2．导入指定的Sheet页" class="headerlink" title="2．导入指定的Sheet页"></a>2．导入指定的Sheet页</h5><p>一个Excel文件包含多个Sheet页，通过设置sheet_name参数就可以导入指定Sheet页的数据。</p><p>【示例13】　导入指定Sheet页的数据。（示例位置：资源包\MR\Code\03\13）一个Excel文件包含多家店铺的销售数据，导入其中一家店铺（莫寒）的销售数据，如图3.14所示。<br>图3.14　原始数据</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018044701218.png" alt="image-20211018044701218"></p><p>程序代码如下：</p><p>01 import pandas as pd<br>02 df=pd.read_excel(‘1 月.xlsx’,sheet_name=’莫寒’)<br>03 df1=df.head()          #输出前5条数据<br>运行程序，输出前5条数据，结果如图3.15所示。<br>除了指定Sheet页的名字，还可以指定Sheet页的顺序，从0开始。例如，sheet_name=0表示导入第一个Sheet页的数据，sheet_name=1表示导入第二个Sheet页的数据，以此类推。<br>如果不指定sheet_name参数，则默认导入第一个Sheet页的数据。</p><h5 id="3．通过行、列索引导入指定行、列数据"><a href="#3．通过行、列索引导入指定行、列数据" class="headerlink" title="3．通过行、列索引导入指定行、列数据"></a>3．通过行、列索引导入指定行、列数据</h5><p>DataFrame是二维数据结构，因此它既有行索引又有列索引。当导入Excel数据时，行索引会自动生成，如0、1、2；而列索引则默认将第0行作为列索引（如A,B,…,J）。DataFrame行、列索引的示意图如图3.16所示。</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018044837800.png" alt="image-20211018044837800"></p><p>​                                                  </p><p>​                                                                            图3.15　导入指定的Sheet页（前5条数据） </p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018044932996.png" alt="image-20211018044932996"></p><p>​                                                                                图3.16　DataFrame行、列索引示意图</p><p>【示例14】　指定行索引导入Excel数据。（示例位置：资源包\MR\Code\03\14）<br>如果通过指定行索引导入Excel数据，则需要设置index_col参数。下面将“买家会员名”作为行索引（位于第0列），导入Excel数据，程序代码如下：</p><p>01 import pandas as pd<br>02 df1=pd.read_excel(‘1 月.xlsx’,index_col=0)     #“买家会员名”为行索引<br>03 df1=df1.head()                                 #输出前5条数据<br>运行程序，输出结果如图3.17所示。</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018045103681.png" alt="image-20211018045103681"></p><p>图3.17　通过指定行索引导入Excel数据<br>如果通过指定列索引导入Excel数据，则需要设置header参数，主要代码如下：</p><p>df2=pd.read_excel(‘1月.xlsx’,header=1)        #设置第1行为列索引</p><p>运行程序，输出结果如图3.18所示。<br>如果将数字作为列索引，可以设置header参数为None，主要代码如下：</p><p>df3=pd.read_excel(‘1月.xlsx’,header=None)    #列索引为数字</p><p>运行程序，输出结果如图3.19所示。</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018045218250.png" alt="image-20211018045218250"></p><p>图3.18　通过指定列索引导入Excel数据</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018045231796.png" alt="image-20211018045231796"></p><p>图3.19　指定列索引<br>那么，为什么要指定索引呢？因为通过索引可以快速地检索数据，例如df3[0]，就可以快速检索到“买家会员名”这一列数据。</p><h5 id="4-导入指定列数据"><a href="#4-导入指定列数据" class="headerlink" title="4.导入指定列数据"></a>4.导入指定列数据</h5><p>一个Excel往往包含多列数据，如果只需要其中的几列，可以通过usecols参数指定需要的列，从0开始（表示第1列，以此类推）。</p><p>【示例15】　导入第1列数据。（示例位置：资源包\MR\Code\03\15）下面导入第1列数据（索引为0），程序代码如下：</p><p>01 import pandas as pd<br>02 df1=pd.read_excel(‘1 月.xlsx’,usecols=[0])       #导入第1列<br>03 df1.head()<br>运行程序，输出结果如图3.20所示。<br>如果导入多列，可以在列表中指定多个值。例如，导入第1列和第4列，主要代码如下：</p><p>df2=pd.read_excel(‘1月.xlsx’,usecols=[0,3])<br>也可以指定列名称，主要代码如下：</p><p>df3=pd.read_excel(‘1月.xlsx’,usecols=[‘买家会员名’,’宝贝标题’])<br>运行程序，输出结果如图3.21所示。</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018045614397.png" alt="image-20211018045614397"></p><p>​                                                                                               图3.20　导入第1列</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018045541729.png" alt="image-20211018045541729"></p><p>​                                                                                     图3.21　导入第1列和第4列数据</p><h4 id="3-4-2-导入-csv文件"><a href="#3-4-2-导入-csv文件" class="headerlink" title="3.4.2　导入.csv文件"></a>3.4.2　导入.csv文件</h4><p>导入.csv文件主要使用Pandas的read_csv()方法，语法如下：</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018045855117.png" alt="image-20211018045855117">常用参数说明：　</p><p>filepath_or_buffer：字符串，文件路径，也可以是URL链接。　</p><p>sep、delimiter：字符串，分隔符。</p><p>header：指定作为列名的行，默认值为0，即取第1行的值为列名。数据为除列名以外的数据；若数据不包含列名，则设置header=None。　</p><p>names：默认值为None，要使用的列名列表。　</p><p>index_col：指定列为索引列，默认值为None，索引0是DataFrame的行标签。　</p><p>usecols：int、list列表或字符串，默认值为None。　如果为None，则解析所有列。　如果为int，则解析最后一列。　如果为list列表，则解析列号列表的列。　如果为字符串，则表示以逗号分隔的Excel列字母和列范围列表（例如“A:E”或“A,C,E:F”）。范围包括双方。　dtype：列的数据类型名称或字典，默认值为None。例如{‘a’:np.float64,’b’:np.int32}。　</p><p>parse_dates：布尔类型值、int类型值的列表、列表或字典，默认值为False。可以通过parse_dates参数直接将某列转换成datetime64日期类型。例如，df1=pd.read_csv(‘1月.csv’, parse_dates=[‘订单付款时间’])。　</p><p>​        parse_dates为True时，尝试解析索引。　</p><p>​        parse_dates为int类型值组成的列表时，如[1,2,3]，则解析1、2、3列的值作为独立的日期列。　</p><p>​        parse_date为列表组成的列表，如[[1,3]]，则将1、3列合并，作为一个日期列使用。　</p><p>​        parse_date为字典时，如{‘总计’：[1, 3]}，则将1、3列合并，合并后的列名为“总计”。　</p><p>encoding：字符串，默认值为None，文件的编码格式。Python常用的编码格式是UTF-8。　返回值：返回一个DataFrame。</p><p>【示例16】　导入.csv文件。（示例位置：资源包\MR\Code\03\16）导入.csv文件，程序代码如下：</p><p>01 import pandas as pd<br>02 df1=pd.read_csv(‘1月.csv’<strong>,encoding=</strong>‘gbk’)        #导入.csv文件，并指定编码格式<br>03 df1=df1.head()                                   #输出前5条数据<br>运行程序，输出结果如图3.22所示。</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018050346464.png" alt="image-20211018050346464">                                                  </p><p>​                                                                                            图3.22　导入.csv文件</p><p>注意<br>上述代码中指定了编码格式，即encoding=’gbk’。Python常用的编码格式是UTF-8和gbk，默认编码格式为UTF-8。导入.csv文件时，需要通过encoding参数指定编码格式。当将Excel文件另存为.csv文件时，默认编码格式为gbk，此时当编写代码导入.csv文件时，就需要设置编码格式为gbk，与源文件编码格式保持一致；否则会提示错误。</p><h4 id="3-4-3-导入-txt文本文件"><a href="#3-4-3-导入-txt文本文件" class="headerlink" title="3.4.3　导入.txt文本文件"></a>3.4.3　导入.txt文本文件</h4><p>导入.txt文件同样使用Pandas的read_csv()方法，不同的是需要指定sep参数（如制表符\t）。read_csv()方法读取.txt文件返回一个DataFrame，像表格一样的二维数据结构，如图3.23所示。</p><p>【示例17】　导入.txt文件。（示例位置：资源包\MR\Code\03\17）<br>下面使用read_csv()方法导入1月.txt文件，主要代码如下：</p><p>01 import pandas as pd<br>02 df1=pd.read_csv(‘1月.txt’,sep=’\t’,encoding=’gbk’)<br>03 print(df1.head())<br>运行程序，输出结果如图3.24所示。</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018050613488-16345047782181.png" alt="image-20211018050613488"></p><p>​                                                                                                        图3.23　.txt文件形式</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018050642828.png" alt="image-20211018050642828"></p><p>​                                                                                                         图3.24　导入.txt文本</p><h4 id="3-4-4-导入HTML网页"><a href="#3-4-4-导入HTML网页" class="headerlink" title="3.4.4　导入HTML网页"></a>3.4.4　导入HTML网页</h4><p>导入HTML网页数据主要使用Pandas的read_html()方法，该方法用于导入带有table标签的网页表格数据，语法如下：</p><p>pandas.read_html(io,match=’.+’,flavor=None,header=None,index_col=None,skiprows=None,attrs=None,parse_<br>dates=False,thousands=’,’,encoding=None,decimal=’.’,converters=None,na_values=None,keep_default_na=True,<br>displayed_only=True)<br>常用参数说明：　</p><p>io：字符串，文件路径，也可以是URL链接。网址不接受https，可以尝试去掉https中的s后爬取，如<a href="http://www.mingribook.com./">http://www.mingribook.com。</a></p><p>match：正则表达式，返回与正则表达式匹配的表格。　</p><p>flavor：解析器默认为lxml。　</p><p>header：指定列标题所在的行，列表list为多重索引。　</p><p>index_col：指定行标题对应的列，列表list为多重索引。　</p><p>encoding：字符串，默认为None，文件的编码格式。　</p><p>返回值：返回一个DataFrame。<br>使用read_html()方法前，首先要确定网页表格是否为table类型。例如，NBA球员薪资网页（<a href="http://www.espn.com/nba/salaries%EF%BC%89%EF%BC%8C%E5%8F%B3%E5%87%BB%E8%AF%A5%E7%BD%91%E9%A1%B5%E4%B8%AD%E7%9A%84%E8%A1%A8%E6%A0%BC%EF%BC%8C%E5%9C%A8%E5%BC%B9%E5%87%BA%E7%9A%84%E5%BF%AB%E6%8D%B7%E8%8F%9C%E5%8D%95%E4%B8%AD%E9%80%89%E6%8B%A9%E2%80%9C%E6%A3%80%E6%9F%A5%E5%85%83%E7%B4%A0%E2%80%9D%E5%91%BD%E4%BB%A4%EF%BC%8C%E6%9F%A5%E7%9C%8B%E4%BB%A3%E7%A0%81%E4%B8%AD%E6%98%AF%E5%90%A6%E5%90%AB%E6%9C%89%E8%A1%A8%E6%A0%BC%E6%A0%87%E7%AD%BE">http://www.espn.com/nba/salaries），右击该网页中的表格，在弹出的快捷菜单中选择“检查元素”命令，查看代码中是否含有表格标签</a><table>…</table>的字样，如图3.25所示。确定后才可以使用read_html()方法。</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018051003748.png" alt="image-20211018051003748"></p><p>​                                                                            图3.25　<table>…</table>表格标签</p><p>【示例18】　导入NBA球员薪资数据。（示例位置：资源包\MR\Code\03\18）<br>下面使用read_html()方法导入NBA球员薪资数据，程序代码如下：</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018051015470.png" alt="image-20211018051015470"></p><p>运行程序，输出结果如图3.26所示。</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018051117577.png" alt="image-20211018051117577"></p><p>​                                                                                              图3.26　导入网页数据注意<br>运行程序，如果出现ImportError: lxml not found, please install it错误提示信息，则需要安装lxml模块。</p><h3 id="3-5-数据抽取"><a href="#3-5-数据抽取" class="headerlink" title="3.5　数据抽取"></a>3.5　数据抽取</h3><p>数据分析过程中，并不是所有的数据都是我们想要的，此时可以抽取部分数据，主要使用DataFrame对<strong>象的loc属性和iloc属性</strong>，示意图如图3.27所示。</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018051225461.png" alt="image-20211018051225461">          </p><pre><code class="hljs">                                                                                     图3.27　loc属性和iloc属性示意图</code></pre><p>对象的loc属性和iloc属性都可以抽取数据，区别如下。　</p><p>loc属性：以列名（columns）和行名（index）作为参数，当只有一个参数时，默认是行名，即抽取整行数据，包括所有列，如df.loc[‘A’]。　</p><p>iloc属性：以行和列位置索引（即0，1，2，…)作为参数，0表示第1行，1表示第2行，以此类推。当只有一个参数时，默认是行索引，即抽取整行数据，包括所有列。如抽取第1行数据，df.iloc[0]。</p><h4 id="3-5-1-抽取一行数据"><a href="#3-5-1-抽取一行数据" class="headerlink" title="3.5.1　抽取一行数据"></a>3.5.1　抽取一行数据</h4><p>抽取一行数据主要使用loc属性。【</p><p>示例19】　抽取一行考试成绩数据。（示例位置：资源包\MR\Code\03\19）抽取一行名为“明日”的考试成绩数据（包括所有列），程序代码如下：</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018051358694.png" alt="image-20211018051358694">运行程序，输出结果如图3.28所示。<br>使用iloc属性抽取第1行数据，指定行索引即可，如df.iloc[0]，输出结果同图3.28一样。</p><p>[1,2,2,3]</p><p>[[1,2,3,4]]</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018051441548.png" alt="image-20211018051441548"></p><p>​                                                                                                                图3.28　抽取一行数据</p><h4 id="3-5-2-抽取多行数据"><a href="#3-5-2-抽取多行数据" class="headerlink" title="3.5.2　抽取多行数据"></a>3.5.2　抽取多行数据</h4><p>1．抽取任意多行数据<br><strong>通过loc属性和iloc属性指定行名和行索引即可实现抽取任意多行数据。</strong></p><p>【示例20】　抽取多行考试成绩数据。（示例位置：资源包\MR\Code\03\20）抽取行名为“明日”和“高袁圆”（即第1行和第3行数据）的考试成绩数据，可以使用loc属性，也可以使用iloc属性，其输出结果都是一样的，主要代码如下：</p><p>01 df1=df.loc[[‘明日’,’高袁圆’]]<br>02 df1=df.iloc[[0,2]]<br>运行程序，输出结果如图3.29所示。</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018051606515.png" alt="image-20211018051606515"></p><p>​                                                                                                图3.29　抽取多行数据<br>2．抽取连续任意多行数据<br>在loc属性和iloc属性中合理地使用冒号（:），即可抽取连续任意多行数据。</p><p>【示例21】　抽取连续几个学生的考试成绩。（示例位置：资源包\MR\Code\03\21）抽取连续几个学生的考试成绩，主要代码如下：</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018051735968.png" alt="image-20211018051735968"></p><p>运行程序，控制台输出结果如图3.30所示。</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018051746750.png" alt="image-20211018051746750"></p><p>​                                                                                 图3.30　抽取连续任意多行数据</p><h4 id="3-5-3-抽取指定列数据"><a href="#3-5-3-抽取指定列数据" class="headerlink" title="3.5.3　抽取指定列数据"></a>3.5.3　抽取指定列数据</h4><p>抽取指定列数据，可以直接使用列名，也可以使用loc属性和iloc属性。<br>1．直接使用列名【示例22】　抽取“语文”和“数学”的考试成绩。（示例位置：资源包\MR\Code\03\22）<br>抽取列名为“语文”和“数学”的考试成绩数据，程序代码如下：</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018051846594.png" alt="image-20211018051846594"></p><p>运行程序，输出结果如图3.31所示。</p><p>2．使用loc属性和iloc属性<br>前面介绍loc属性和iloc属性均有两个参数：第一个参数代表行；第二个参数代表列。那么这里抽取指定列数据时，行参数不能省略。</p><p>【示例23】　抽取指定学科的考试成绩。（示例位置：资源包\MR\Code\03\23）<br>下面使用loc属性和iloc属性抽取指定列数据，主要代码如下：</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018052009426.png" alt="image-20211018052009426"></p><p>运行程序，控制台输出结果如图3.32所示。</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018052021825.png" alt="image-20211018052021825"></p><p>​                                                                                      图3.31　直接使用列名</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018052041459.png" alt="image-20211018052041459"></p><p>​                                                                                          图3.32　loc属性和iloc属性</p><h4 id="3-5-4-抽取指定行、列数据"><a href="#3-5-4-抽取指定行、列数据" class="headerlink" title="3.5.4　抽取指定行、列数据"></a>3.5.4　抽取指定行、列数据</h4><p>抽取指定行、列数据主要使用loc属性和iloc属性，这两个方法的两个参数都指定就可以实现指定行、列数据的抽取。</p><p>【示例24】　抽取指定学科和指定学生的考试成绩。（示例位置：资源包\MR\Code\03\24）使用loc属性和iloc属性抽取指定行、列数据，程序代码如下：</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018052200474.png" alt="image-20211018052200474"></p><p>运行程序，控制台输出结果如图3.33所示。</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018052214525.png" alt="image-20211018052214525"></p><pre><code class="hljs">                                                                               图3.33　抽取指定行、列数据</code></pre><p>在上述结果中，第一个输出结果是一个数，不是数据，是由于“df.loc[‘七月流火’,’英语’]”没有使用方括号[]，导致输出的数据不是DataFrame类型。</p><h4 id="3-5-5-按指定条件抽取数据"><a href="#3-5-5-按指定条件抽取数据" class="headerlink" title="3.5.5　按指定条件抽取数据"></a>3.5.5　按指定条件抽取数据</h4><p>DataFrame对象实现数据查询有以下3种方式。　取其中的一个元素.iat[x,x]。　基于位置的查询，如.iloc[]、iloc[2,1]。　基于行、列名称的查询，如.loc[x]。</p><p>【示例25】　抽取指定学科和指定分数的数据。（示例位置：资源包\MR\Code\03\25）抽取语文成绩大于105，数学成绩大于88的数据，程序代码如下：</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018052322850.png" alt="image-20211018052322850"></p><p>运行程序，输出结果如图3.34所示。</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018052523463.png" alt="image-20211018052523463">   </p><p>​                                                                                             图3.34　按指定条件抽取数据</p><h3 id="3-6-数据的增加、修改和删除"><a href="#3-6-数据的增加、修改和删除" class="headerlink" title="3.6　数据的增加、修改和删除"></a>3.6　数据的增加、修改和删除</h3><p>本节主要介绍如何操纵DataFrame对象中的各种数据。例如，数据的增加、修改和删除。</p><h4 id="3-6-1-增加数据"><a href="#3-6-1-增加数据" class="headerlink" title="3.6.1　增加数据"></a>3.6.1　增加数据</h4><p>DataFrame对象增加数据主要包括列数据增加和行数据增加。首先看一下原始数据，如图3.35所示。</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018052637063.png" alt="image-20211018052637063"></p><p>图3.35　原始数据</p><h5 id="1．按列增加数据"><a href="#1．按列增加数据" class="headerlink" title="1．按列增加数据"></a>1．按列增加数据</h5><p>按列增加数据，可以通过以下3种方式实现。<br>（1）直接为DataFrame对象赋值</p><p>【示例26】　增加一列“物理”成绩。（示例位置：资源包\MR\Code\03\26）<br>增加一列“物理”成绩，程序代码如下：</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018052702267.png" alt="image-20211018052702267"></p><p>运行程序，输出结果如图3.36所示。</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018052756371.png" alt="image-20211018052756371"></p><p>​                                                                                   图3.36　按列增加数据<br>（2）使用loc属性在DataFrame对象的最后增加一列</p><p>【示例27】　使用loc属性增加一列“物理”成绩。（示例位置：资源包\MR\Code\03\27）使用loc属性在DataFrame对象的最后增加一列。例如，增加“物理”一列，主要代码如下：</p><p>df.loc[:,’物理’] = [88,79,60,50]<br>在DataFrame对象最后增加一列“物理”，其值为等号右边数据。</p><p>（3）在指定位置插入一列<br>在指定位置插入一列，主要使用insert()方法。</p><p>【示例28】　在第1列后面插入“物理”成绩。（示例位置：资源包\MR\Code\03\28）<br>例如，在第1列后面插入“物理”，其值为wl的数值，主要代码如下：</p><p>01 wl =[88,79,60,50]<br>02 df.insert(1,’物理’,wl)<br>运行程序，输出结果如图3.37所示。</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018052920670.png" alt="image-20211018052920670"></p><p>​                                                                                                图3.37　使用insert()方法增加一列</p><h5 id="2．按行增加数据"><a href="#2．按行增加数据" class="headerlink" title="2．按行增加数据"></a>2．按行增加数据</h5><p>按行增加数据，可以通过以下两种方式实现。<br>（1）增加一行数据<br>增加一行数据主要使用loc属性实现。</p><p>【示例29】　在成绩表中增加一行数据。（示例位置：资源包\MR\Code\03\29）在成绩表中增加一行数据，即“钱多多”同学的成绩，主要代码如下：</p><p>df.loc[‘钱多多’] = [100,120,99]<br>（2）增加多行数据</p><p>增加多行数据主要使用<strong>字典</strong>结合**append()**方法实现。</p><p>【示例30】　在原有数据中增加几名同学的考试成绩。（示例位置：资源包\MR\Code\03\30）在原有数据中增加“钱多多”“童年”“无名”同学的考试成绩，主要代码如下：</p><p>01 df_insert=pd.DataFrame({‘语文’:[100,123,138],’数学’:[99,142,60],’英语’:[98,139,99]},index = [‘钱多多’,’童年’,’无名’])<br>02 df1 = df.append(df_insert)<br>运行程序，输出结果分别如图3.38和图3.39所示。</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018053145141.png" alt="image-20211018053145141"></p><p>​                                                                                       图3.38　增加一行数据</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018053204251.png" alt="image-20211018053204251"></p><p>​                                                                                        图3.39　增加多行数据</p><h4 id="3-6-2-修改数据"><a href="#3-6-2-修改数据" class="headerlink" title="3.6.2　修改数据"></a>3.6.2　修改数据</h4><p>修改数据包括行、列标题和数据的修改，首先看一下原始数据，如图3.40所示。</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018053230905.png" alt="image-20211018053230905"></p><p>​                                                                                               图3.40　原始数据</p><h5 id="1．修改列标题"><a href="#1．修改列标题" class="headerlink" title="1．修改列标题"></a>1．修改列标题</h5><p>修改列标题主要使用DataFrame对象的cloumns属性，直接赋值即可。</p><p>【示例31】　修改“数学”的列名。（示例位置：资源包\MR\Code\03\31）将“数学”修改为“数学（上）”，主要代码如下：</p><p>df.columns=[‘语文’,’数学（上）’,’英语’]</p><p>上述代码中，即使只修改“数学”为“数学（上）”，但是也<strong>要将所有列的标题全部写上；</strong>否则将报错。<br>下面再介绍一种方法，使用DataFrame对象的rename()方法修改列标题。</p><p>【示例32】　修改多个学科的列名。（示例位置：资源包\MR\Code\03\32）将“语文”修改为“语文（上）”、“数学”修改为“数学（上）”、“英语”修改为“英语（上）”，主要代码如下：</p><p>df.rename(columns = {‘语文’:’语文（上）’,’数学’:’数学（上）’,’英语’:’英语（上）’},inplace = True)</p><p>上述代码中，参数inplace为True，表示直接修改df；否则，不修改df，只返回修改后的数据。<br>运行程序，输出结果分别如图3.41和图3.42所示。</p><h5 id="2．修改行标题"><a href="#2．修改行标题" class="headerlink" title="2．修改行标题"></a>2．修改行标题</h5><p>修改行标题主要使用DataFrame对象的index属性，直接赋值即可。</p><p>【示例33】　将行标题统一修改为数字编号。（示例位置：资源包\MR\Code\03\33）<br>将行标题统一修改为数字编号，主要代码如下：</p><p>df.index=list(‘1234’)</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018053500036.png" alt="image-20211018053500036"></p><p>​                                                                                         图3.41　修改列标题1</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018053517247.png" alt="image-20211018053517247"></p><p>​                                                                                                 图3.42　修改列标题2</p><p>使用DataFrame对象的rename()方法也可以修改行标题。例如，将行标题统一修改为数字编号，主要代码如下：</p><p>df.rename({‘明日’:1,’七月流火’:2,’高袁圆’:3,’二月二’:4},axis=0,inplace = True)</p><h5 id="3．修改数据"><a href="#3．修改数据" class="headerlink" title="3．修改数据"></a>3．修改数据</h5><p>修改数据主要使用DataFrame对象的loc属性和iloc属性。</p><p>【示例34】　修改学生成绩数据。（示例位置：资源包\MR\Code\03\34）<br>（1）修改整行数据<br>例如，修改“明日”同学的各科成绩，主要代码如下：</p><p>df.loc[‘明日’]=[120,115,109]<br>如果各科成绩均加10分，可以直接在原有值上加10，主要代码如下：</p><p>df.loc[‘明日’]=df.loc[‘明日’]+10<br>（2）修改整列数据<br>例如，修改所有同学的“语文”成绩，主要代码如下：</p><p>df.loc[:,’语文’]=[115,108,112,118]<br>（3）修改某一数据</p><p>例如，修改“明日”同学的“语文”成绩，主要代码如下：</p><p>df.loc[‘明日’,’语文’]=115<br>（4）使用iloc属性修改数据<br>通过iloc属性指定行、列位置实现修改数据，主要代码如下：</p><p>01 df.iloc[0,0]=115                        #修改某一数据<br>02 df.iloc[:,0]=[115,108,112,118]          #修改整列数据<br>03 df.iloc[0,:]=[120,115,109]              #修改整行数据</p><h4 id="3-6-3-删除数据"><a href="#3-6-3-删除数据" class="headerlink" title="3.6.3　删除数据"></a>3.6.3　删除数据</h4><p>删除数据主要使用DataFrame对象的drop()方法。语法如下：</p><p>DataFrame.drop(labels=None, axis=0, index=None, columns=None, level=None, inplace=False, errors=’raise’)<br>参数说明：　</p><p>labels：表示行标签或列标签。　</p><p>axis：axis = 0，表示按行删除；</p><p>​            axis = 1，表示按列删除。默认值为0，即按行删除。　</p><p>index：删除行，默认值为None。　</p><p>columns：删除列，默认值为None。</p><p>level：针对有两级索引的数据。level = 0，表示按第1级索引删除整行；level = 1表示按第2级索引删除整行，默认值为None。　inplace：可选参数，对原数组做出修改并返回一个新数组。默认值为False，如果值为True，那么原数组直接就被替换。　</p><p>errors：参数值为ignore或raise，默认值为raise，如果值为ignore（忽略），则取消错误。</p><h5 id="1．删除行、列数据"><a href="#1．删除行、列数据" class="headerlink" title="1．删除行、列数据"></a>1．删除行、列数据</h5><p>【示例35】　删除学生成绩数据。（示例位置：资源包\MR\Code\03\35）<br>删除指定的学生成绩数据，主要代码如下：</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018054027938.png" alt="image-20211018054027938"></p><h5 id="2．删除特定条件的行"><a href="#2．删除特定条件的行" class="headerlink" title="2．删除特定条件的行"></a>2．删除特定条件的行</h5><p>删除满足特定条件的行，首先找到满足该条件的行索引，然后再使用drop()方法将其删除。</p><p>【示例36】　删除符合条件的学生成绩数据。（示例位置：资源包\MR\Code\03\36）<br>删除“数学”成绩中包含88的行、“语文”成绩中小于110的行，主要代码如下：</p><p>01 df.drop(index=df[df[‘数学’].<strong>isin</strong>([88])].index[0],inplace=True)      #删除“数学”成绩中包含88的行<br>02 df.drop(index=df[df[‘语文’]&lt;110].index[0],inplace=True)             #删除“语文”成绩中小于110的行说明<br>以上代码中的方法都可以实现删除指定的行、列数据，读者选择一种即可。</p><h3 id="3-7-数据清洗"><a href="#3-7-数据清洗" class="headerlink" title="3.7　数据清洗"></a>3.7　数据清洗</h3><h4 id="3-7-1-缺失值查看与处理"><a href="#3-7-1-缺失值查看与处理" class="headerlink" title="3.7.1　缺失值查看与处理"></a>3.7.1　缺失值查看与处理</h4><p>缺失值是指由于某种原因导致数据为空，这种情况一般有不处理、删除、填充／替换、插值（以均值／中位数／众数等填补）这4种处理方式。</p><h5 id="1．缺失值查看"><a href="#1．缺失值查看" class="headerlink" title="1．缺失值查看"></a>1．缺失值查看</h5><p>首先需要找到缺失值，主要使用DataFrame对象的info()方法。</p><p>【示例37】　查看数据概况。（示例位置：资源包\MR\Code\03\37）以淘宝销售数据为例，首先输出数据，然后使用info()方法查看数据，程序代码如下：</p><p>01 import pandas as pd<br>02 df=pd.read_excel(‘TB2018.xls’)<br>03 print(df)<br>04 print(df.info())</p><p>运行程序，控制台输出结果如图3.43所示。</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018054304916.png" alt="image-20211018054304916"></p><p>图3.43　缺失值查看<br>在Python中，缺失值一般用NaN表示，如图3.43所示。通过info()方法可看到“买家会员名”“买家实际支付金额”“宝贝标题”“订单付款时间”的非空数量是10，而“宝贝总数量”和“类别”的非空数量是8，那么说明这两项存在空值。</p><p>【示例38】　判断数据是否存在缺失值。（示例位置：资源包\MR\Code\03\38）<br>接下来，判断数据是否存在缺失值还可以使用isnull()方法和notnull()方法，主要代码如下：</p><p>01  print(df.isnull())<br>02  print(df.notnull())<br>运行程序，控制台输出结果如图3.44所示。</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018054406384.png" alt="image-20211018054406384"></p><p>​                                                                                              图3.44　判断缺失值<br>使用isnull()方法缺失值返回True，非缺失值返回False；而notnull()方法与isnull()方法正好相反，缺失值返回False，非缺失值返回True。<br>如果使用df[df.isnull() == False]，</p><p>则会将所有非缺失值的数据找出来，只针对Series对象。</p><h5 id="2．缺失值删除处理"><a href="#2．缺失值删除处理" class="headerlink" title="2．缺失值删除处理"></a>2．缺失值删除处理</h5><p>通过前面的判断得知数据缺失情况，下面将缺失值删除，主要使用dropna()方法，该方法用于删除含有缺失值的行，主要代码如下：</p><p>df1=df.dropna()<br>运行程序，输出结果如图3.45所示。说明<br>有些时候数据可能存在整行为空的情况，此时可以在dropna()方法中指定参数how=’all’，删除所有空行。</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018054531853.png" alt="image-20211018054531853"></p><p>​                                                                                   图3.45　缺失值删除处理1<br>从运行结果得知：dropna()方法将所有包含缺失值的数据全部删除了。那么，此时如果我们认为有些数据虽然存在缺失值，但是不影响数据分析，那么可以使用以下方法处理。例如，上述数据中只保留“宝贝总数量”不存在缺失值的数据，而类别是否缺失不关注，则可以使用notnull()方法判断，主要代码如下：</p><p>df2=df[df[‘宝贝总数量’].notnull()]<br>运行程序，输出结果如图3.46所示。</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018054627170.png" alt="image-20211018054627170"></p><p>图3.46　缺失值删除处理2</p><h5 id="3．缺失值填充处理"><a href="#3．缺失值填充处理" class="headerlink" title="3．缺失值填充处理"></a>3．缺失值填充处理</h5><p>对于缺失数据，如果比例高于30%可以选择放弃这个指标，做删除处理；低于30%尽量不要删除，而是选择将这部分数据填充，一般以0、均值、众数（大多数）填充。DataFrame对象中的fillna()函数可以实现填充缺失数据，pad/ffill表示用前一个非缺失值去填充该缺失值；backfill/bfill表示用下一个非缺失值填充该缺失值；None用于指定一个值去替换缺失值。</p><p>【示例39】　将NaN填充为0。（示例位置：资源包\MR\Code\03\39）对于用于计算的数值型数据如果为空，可以选择用0填充。例如，将“宝贝总数量”为空的数据填充为0，主要代码如下：</p><p>df[‘宝贝总数量’] = df[‘宝贝总数量’].fillna(0)<br>运行程序，输出结果如图3.47所示。</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018054749852.png" alt="image-20211018054749852"></p><p>​                                                                                                图3.47　缺失值填充处理</p><h4 id="3-7-2-重复值处理"><a href="#3-7-2-重复值处理" class="headerlink" title="3.7.2　重复值处理"></a>3.7.2　重复值处理</h4><p>对于数据中存在的重复数据，包括重复的行或者几行中某几列的值重复一般做删除处理，主要使用DataFrame对象的drop_duplicates()方法。</p><p>【示例40】　处理淘宝电商销售数据中的重复数据。（示例位置：资源包\MR\Code\03\40）下面以“1月.xlsx”淘宝销售数据为例，对其中的重复数据进行处理。<br>（1）判断每一行数据是否重复（完全相同），主要代码如下：</p><p>df1.duplicated()<br>如果返回值为False表示不重复，返回值为True表示重复。<br>（2）去除全部的重复数据，主要代码如下：</p><p>df1.drop_duplicates()<br>（3）去除指定列的重复数据，主要代码如下：</p><p>df1.drop_duplicates([‘买家会员名’])<br>（4）保留重复行中的最后一行，主要代码如下：</p><p>df1.drop_duplicates([‘买家会员名’],keep=’last’)</p><p>说明<br>以上代码中参数keep的值有3个。当keep=’first’表示保留第一次出现的重复行，是默认值；当keep为另外两个取值，即last和False时，分别表示保留最后一次出现的重复行和去除所有重复行。<br>（5）直接删除，保留一个副本，主要代码如下：</p><p>df1.drop_duplicates([‘买家会员名’,’买家支付宝账号’],inplace=Fasle)<br>inplace=True表示直接在原来的DataFrame上删除重复项，而默认值False表示删除重复项后生成一个副本。</p><h4 id="3-7-3-异常值的检测与处理"><a href="#3-7-3-异常值的检测与处理" class="headerlink" title="3.7.3　异常值的检测与处理"></a>3.7.3　异常值的检测与处理</h4><p>首先了解一下什么是异常值。在数据分析中异常值是指超出或低于正常范围的值，如年龄大于200、身高大于3米、宝贝总数量为负数等类似数据。那么这些数据如何检测呢？主要有以下几种方法。<br>（1）根据给定的数据范围进行判断，不在范围内的数据视为异常值。<br>（2）均方差。<br>在统计学中，如果一个数据分布近似正态分布（数据分布的一种形式，正态分布的概率密度函数曲线呈钟形，两头低、中间高、左右对称，因此人们又经常称之为钟形曲线），那么大约68%的数据值会在均值的一个标准差范围内，大约95%会在两个标准差范围内，大约99.7%会在3个标准差范围内。<br>（3）箱形图。<br>箱形图是显示一组数据分散情况资料的统计图。它可以将数据通过四分位数的形式进行图形化描述。箱形图通过上限和下限作为数据分布的边界。任何高于上限或低于下限的数据都可以认为是异常值，如图3.48所示。</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018055103761.png" alt="image-20211018055103761"></p><p>​                                                                                            图3.48　箱形图说明<br>有关箱形图的介绍以及如何通过箱形图识别异常值可参见第6章。<br>了解了异常值的检测，接下来介绍如何处理异常值，主要包括以下几种处理方式。<br>（1）最常用的方式是删除。<br>（2）将异常值当缺失值处理，以某个值填充。<br>（3）将异常值当特殊情况进行分析，研究异常值出现的原因。</p><h3 id="3-8-索引设置"><a href="#3-8-索引设置" class="headerlink" title="3.8 索引设置"></a>3.8 索引设置</h3><p>索引能够快速查询数据，本节主要介绍索引的作用以及索引的应用。</p><h4 id="3-8-1-索引的作用"><a href="#3-8-1-索引的作用" class="headerlink" title="3.8.1　索引的作用"></a>3.8.1　索引的作用</h4><p>索引的作用相当于图书的目录，可以根据目录中的页码快速找到所需的内容。Pandas索引的作用如下。　更方便查询数据。　使用索引可以提升查询性能。　如果索引是唯一的，Pandas会使用哈希表优化，查找数据的时间复杂度为O(1)。　如果索引不是唯一的，但是有序，Pandas会使用二分查找算法，查找数据的时间复杂度为O(logN)。　如果索引是完全随机的，那么每次查询都要扫描数据表，查找数据的时间复杂度为O(N)。　自动的数据对齐功能，示意图如图3.49所示。</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018113947441.png" alt="image-20211018113947441"></p><p>​                                                                                    图3.49　自动数据对齐示意图<br>实现上述效果，程序代码如下：</p><p>01 import pandas as pd<br>02 s1 = pd.Series([10,20,30],index= list(“abc”))<br>03 s2 = pd.Series([2,3,4],index=list(“bcd”))<br>04 print(s1 + s2)　强大的数据结构。　基于分类数的索引，提升性能。　多维索引，用于groupby多维聚合结果等。　时间类型索引，强大的日期和时间的方法支持。</p><h4 id="3-8-2-重新设置索引"><a href="#3-8-2-重新设置索引" class="headerlink" title="3.8.2　重新设置索引"></a>3.8.2　重新设置索引</h4><p>Pandas有一个很重要的方法是reindex()，它的作用是创建一个适应新索引的新对象。语法如下：</p><p>DataFrame.reindex(labels = None,index = None,columns = None,axis = None,method = None,copy = True,level =<br>None,fill_value = nan,limit = None,tolerance = None)<br>常用参数说明：　</p><p>labels：标签，可以是数组，默认值为None（无）。　</p><p>index：行索引，默认值为None。　</p><p>columns：列索引，默认值为None。</p><p>axis：轴，axis=0表示行，axis=1表示列。默认值为None。　</p><p>method：默认值为None，重新设置索引时，选择插值（一种填充缺失数据的方法）方法，其值可以是None、bfill/backfill（向后填充）、ffill/pad（向前填充）等。　</p><p>fill_value：缺失值要填充的数据。如缺失值不用NaN填充，而用0填充，则设置fill_value=0即可。</p><h5 id="1．对Series对象重新设置索引"><a href="#1．对Series对象重新设置索引" class="headerlink" title="1．对Series对象重新设置索引"></a>1．对Series对象重新设置索引</h5><p>【示例41】　重新设置物理成绩的索引。（示例位置：资源包\MR\Code\03\41）<br>在3.2.3节已经建立了一组学生的物理成绩，下面重新设置索引，程序代码如下：</p><p>01 import pandas as pd<br>02 s1=pd.Series([88,60,75],index=[1,2,3])<br>03 print(s1)<br>04 print(s1.reindex([1,2,3,4,5]))<br>运行程序，控制台输出结果对比如图3.50和图3.51所示。</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018124142285.png" alt="image-20211018124142285"></p><p>​                                                                                                              图3.50　原数据</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018124200693.png" alt="image-20211018124200693"></p><p>​                                                                                                 图3.51　重新设置索引<br>从运行结果得知：reindex()方法根据新索引进行了重新排序，并且对缺失值自动填充NaN。如果不想用NaN填充，则可以为fill_value参数指定值，如0，主要代码如下：</p><p>s1.reindex([1,2,3,4,5],fill_value=0)<br>而对于一些有一定顺序的数据，我们可能需要插值（插值是一种填充缺失数据的方法）来填充缺失的数据，可以使用method参数。</p><p>【示例42】　向前和向后填充数据。（示例位置：资源包\MR\Code\03\42）向前填充（和前面数据一样）、向后填充（和后面数据一样），主要代码如下：</p><p>01 print(s1.reindex([1,2,3,4,5],method=’ffill’))   #向前填充<br>02 print(s1.reindex([1,2,3,4,5],method=’bfill’))   #向后填充</p><h5 id="2．对DataFrame对象重新设置索引"><a href="#2．对DataFrame对象重新设置索引" class="headerlink" title="2．对DataFrame对象重新设置索引"></a>2．对DataFrame对象重新设置索引</h5><p>对于DataFrame对象，reindex()方法用于修改行索引和列索引。</p><p>【示例43】　创建成绩表并重新设置索引。（示例位置：资源包\MR\Code\03\43）通过二维数组创建成绩表，程序代码如下：</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018124525086.png" alt="image-20211018124525086">通过reindex()方法重新设置行索引，主要代码如下：</p><p>df.reindex([‘mr001’,’mr002’,’mr003’,’mr004’,’mr005’])<br>通过reindex()方法重新设置列索引，主要代码如下：</p><p>df.reindex(columns=[‘语文’,’物理’,’数学’,’英语’])<br>通过reindex()方法重新设置行索引和列索引，主要代码如下：</p><p>df.reindex(index=[‘mr001’,’mr002’,’mr003’,’mr004’,’mr005’],columns=[‘语文’,’物理’,’数学’,’英语’])<br>运行程序，控制台输出结果分别为原始数据（见图3.52）、重新设置行索引（见图3.53）、重新设置列索引（见图3.54）、重新设置行、列索引（见图3.55）。</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018124708302.png" alt="image-20211018124708302"></p><p>​                                                                                                  图3.52　原始数据</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018124737241.png" alt="image-20211018124737241"></p><p>​                                                                                                 图3.53　重新设置行索引</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018124821931.png" alt="image-20211018124821931"></p><p>​                                                                                                   图3.54　重新设置列索引</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018124905647.png" alt="image-20211018124905647"></p><h4 id="3-8-3-设置某列为行索引"><a href="#3-8-3-设置某列为行索引" class="headerlink" title="3.8.3　设置某列为行索引"></a>3.8.3　设置某列为行索引</h4><p>设置某列为行索引主要使用set_index()方法。</p><p>【示例44】　设置“买家会员名”为行索引。（示例位置：资源包\MR\Code\03\44）<br>首先，导入“1月.xlsx”Excel文件，程序代码如下：</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018125022369.png" alt="image-20211018125022369"></p><p>运行程序，输出结果如图3.56所示。<br>此时默认行索引为0、1、2、3、4，下面将“买家会员名”作为行索引，主要代码如下：</p><p>df2=df.set_index([‘买家会员名’])<br>运行程序，输出结果如图3.57所示。</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018125215478.png" alt="image-20211018125215478"></p><p>​                                                                                                图3.56　1月淘宝销售数据（部分数据）</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018125235811.png" alt="image-20211018125235811"></p><p>​                                                                                                       图3.57　设置“买家会员名”为索引<br>如果在set_index()方法中传入参数drop=True，则会删除“买家会员名”；如果传入drop=False，则会保留“买家会员名”。默认为False。</p><h4 id="3-8-4-数据清洗后重新设置连续的行索引"><a href="#3-8-4-数据清洗后重新设置连续的行索引" class="headerlink" title="3.8.4　数据清洗后重新设置连续的行索引"></a>3.8.4　数据清洗后重新设置连续的行索引</h4><p>在对Dataframe对象进行数据清洗后，例如去掉含NaN的行之后，发现行索引还是原来的行索引，对比效果如图3.58和图3.59所示。</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018125500556.png" alt="image-20211018125500556"></p><p>​                                                                                            图3.58　原数据</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018125521969.png" alt="image-20211018125521969"></p><p>​                                                                           图3.59　数据清洗后还是原来的索引</p><p>【示例45】　删除数据后重新设置索引。（示例位置：资源包\MR\Code\03\45）</p><p>如果要重新设置索引可以使用reset_index()方法，在删除缺失数据后重新设置索引，主要代码如下：</p><p>df2=df.dropna().reset_index(drop=True)<br>运行程序，输出结果如图3.60所示。</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018125620746.png" alt="image-20211018125620746"></p><p>​                                                                           图3.60　数据清洗后重新设置连续的行索引<br>另外，对于分组统计后的数据，有时也需要重新设置连续的行索引，方法同上。</p><h3 id="3-9-数据排序与排名"><a href="#3-9-数据排序与排名" class="headerlink" title="3.9　数据排序与排名"></a>3.9　数据排序与排名</h3><p>本节主要介绍数据的各种排序和排名方法。</p><h4 id="3-9-1-数据排序"><a href="#3-9-1-数据排序" class="headerlink" title="3.9.1　数据排序"></a>3.9.1　数据排序</h4><p>DataFrame数据排序主要使用sort_values()方法，该方法类似于SQL中的ORDER BY。sort_values()方法可以根据指定行／列进行排序，语法如下：</p><p>DataFrame.sort_values(by,axis=0,ascending=True,inplace=False,kind=’quicksort’,na_position=’last’,ignore_<br>index=False)<br>参数说明：　</p><p>by：要排序的名称列表。</p><p>axis：轴，axis=0表示行，axis=1表示列。默认值为0，即按行排序。　</p><p>ascending：升序或降序排序，布尔值，指定多个排序可以使用布尔值列表。默认值为True。　</p><p>inplace：布尔值，默认值为False，如果值为True，则就地排序。　</p><p>kind：指定排序算法，值为quicksort（快速排序）、mergesort（混合排序）或heapsort（堆排），默认值为quicksort。　na_position：空值（NaN）的位置，值为first空值在数据开头，值为last空值在数据最后，默认值为last。　</p><p>ignore_index：布尔值，是否忽略索引，值为True标记索引（从0开始按顺序的整数值），值为False则忽略索引。</p><h5 id="1．按一列数据排序"><a href="#1．按一列数据排序" class="headerlink" title="1．按一列数据排序"></a>1．按一列数据排序</h5><p>【示例46】　按“销量”降序排序。（示例位置：资源包\MR\Code\03\46）<br>按“销量”降序排序，排序对比效果如图3.61和图3.62所示。</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018125836428.png" alt="image-20211018125836428"></p><p>​                                                                                                     图3.61　原始数据</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018130000864.png" alt="image-20211018130000864"></p><p>​                                                                                图3.62　按“销量”降序排序实用技巧<br>Spyder变量浏览窗口本身也支持数据排序，单击需要排序的列即可实现升序或降序排序。<br>程序代码如下：</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018130020866.png" alt="image-20211018130020866"></p><h5 id="2．按多列数据排序"><a href="#2．按多列数据排序" class="headerlink" title="2．按多列数据排序"></a>2．按多列数据排序</h5><p>多列排序是按照给定列的先后顺序进行排序的。</p><p>【示例47】　按照“图书名称”和“销量”降序排序。（示例位置：资源包\MR\Code\03\47）<br>按照“图书名称”和“销量”降序排序，首先按“图书名称”降序排序，然后再按“销量”降序排序，排序后的效果如图3.63所示。</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018130140068.png" alt="image-20211018130140068"></p><p>​                                                                图3.63　按照“图书名称”和“销量”降序排序<br>主要代码如下：</p><p>df1=df.sort_values(by=[‘图书名称’,’销量’])</p><h5 id="3．对统计结果排序"><a href="#3．对统计结果排序" class="headerlink" title="3．对统计结果排序"></a>3．对统计结果排序</h5><p>【示例48】　对分组统计数据进行排序。（示例位置：资源包\MR\Code\03\48）</p><p>按“类别”分组统计销量并进行降序排序，统计排序后的效果如图3.64所示。</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018130240441.png" alt="image-20211018130240441"></p><p>​                                                                                 图3.64　按“类别”分组统计销量并降序排序<br>主要代码如下：</p><p>01 df1=df.groupby([“类别”])[“销量”].sum().reset_index()</p><p>2 df2=df1.sort_values(by=’销量’,ascending=False)</p><h5 id="4．按行数据排序"><a href="#4．按行数据排序" class="headerlink" title="4．按行数据排序"></a>4．按行数据排序</h5><p>【示例49】　按行数据排序。（示例位置：资源包\MR\Code\03\49）<br>按行排序，主要代码如下：</p><p>df=dfrow.sort_values(by=0,ascending=True,axis=1)注意<br>按行排序的数据类型要一致，否则会出现错误提示。</p><h4 id="3-9-2-数据排名"><a href="#3-9-2-数据排名" class="headerlink" title="3.9.2　数据排名"></a>3.9.2　数据排名</h4><p>排名是根据Series对象或DataFrame的某几列的值进行排名的，主要使用rank()方法，语法如下：</p><p>DataFrame.rank(axis=0,method=’average’,numeric_only=None,na_option=’keep’,ascending=True,pct=False)<br>参数说明：　</p><p>axis：轴，axis=0表示行，axis=1表示列。默认值为0，即按行排序。　</p><p>method：表示在具有相同值的情况下所使用的排序方法。设置值如下。　</p><p>average：默认值，平均排名。</p><p>min：最小值排名。　</p><p>max：最大值排名。　</p><p>first：按值在原始数据中的出现顺序分配排名。　</p><p>dense：密集排名，类似最小值排名，但是排名每次只增加1，即排名相同的数据只占一个名次。　</p><p>numeric_only：对于DataFrame对象，如果设置值为True，则只对数字列进行排序。　</p><p>na_option：空值的排序方式，设置值如下。　</p><p>keep：保留，将空值等级赋值给NaN值。　</p><p>top：如果按升序排序，则将最小排名赋值给NaN值。　</p><p>bottom：如果按升序排序，则将最大排名赋值给NaN值。　</p><p>ascending：升序或降序排序，布尔值，指定多个排序可以使用布尔值列表。默认值为True。　</p><p>pct：布尔值，是否以百分比形式返回排名。默认值为False。</p><p>1．顺序排名</p><p>【示例50】　对产品销量按顺序进行排名。（示例位置：资源包\MRCode\03\50）<br>下面对销量相同的产品，按照出现的顺序排名，程序代码如下：</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018130818619.png" alt="image-20211018130818619"></p><p>程序运行结果如图3.65所示。<br>2．平均排名</p><p>【示例51】　对产品销量进行平均排名。（示例位置：资源包\MR\Code\03\51）<br>现在对销量相同的产品，按照顺序排名的平均值作为平均排名，主要代码如下：</p><p>01 df[‘平均排名’]=df[‘销量’].rank(ascending=False)</p><p>02 df1=df[[‘图书名称’,’销量’,’平均排名’]]<br>程序运行结果如图3.66所示。<br>3．最小值排名<br>排名相同的，按顺序排名取最小值作为排名，主要代码如下：</p><p>df[‘最小值排名’]=df[‘销量’].rank(method=”min”,ascending=False)<br>4．最大值排名<br>排名相同的，按顺序排名取最大值作为排名，主要代码如下：</p><p>df[‘最大值排名’]=df[‘销量’]rank(method=”max”,ascending=False)</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018131022583.png" alt="image-20211018131022583"></p><p>​                                                                  图3.65　销量相同按出现的先后顺序排名</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211018131037838.png" alt="image-20211018131037838"></p><p>​                                                                   图3.66　销量相同按顺序排名的平均值排名</p><h3 id="3-10-小结"><a href="#3-10-小结" class="headerlink" title="3.10　小结"></a>3.10　小结</h3><p>本章介绍了Pandas数据处理的基本知识，从最初的数据来源开始（创建DataFrame数据或导入外部数据）到数据抽取、数据增删改操作、数据清洗、索引，再到数据排序，常用的数据处理操作基本都涉及了，通过本章的学习基本能够独立完成一些简单的数据处理工作。</p><h1 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h1><h2 id="4-1-数据计算"><a href="#4-1-数据计算" class="headerlink" title="4.1 数据计算"></a>4.1 数据计算</h2><p>Pandas提供了大量的数据计算函数，可以实现求和、求均值、求最大值、求最小值、求中位数、求众数、求方差、标准差等，从而使得数据统计变得简单高效。</p><h3 id="4-1-1求和函数（sum"><a href="#4-1-1求和函数（sum" class="headerlink" title="4.1.1求和函数（sum())"></a>4.1.1求和函数（sum())</h3><p>DataFrame.sum(axis=None, skipna=None, level=None, numeric_only=None, min_count=0, **kwargs)<br>参数说明：　</p><p>axis：axis=1表示行，axis=0表示列，默认值为None（无）。　skipna：布尔型，表示计算结果是否排除NaN/Null值，默认值为None。</p><p>level：表示索引层级，默认值为None。　</p><p>numeric_only：仅数字，布尔型，默认值为None。　</p><p>min_count：表示执行操作所需的数目，整型，默认值为0。　**kwargs：要传递给函数的附加关键字参数。　</p><p>返回值：返回Series对象或DataFrame对象。行或列求和数据。</p><p>【示例01】　计算语文、数学和英语三科的总成绩。（示例位置：资源包\MR\Code\04\01）<br>首先，创建一组DataFrame类型的数据，包括语文、数学和英语三科的成绩，如图4.1所示。<br>程序代码如下：</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/学习记录/专高三/讲义Pandas统计分析/image-20211020032035450.png" alt="image-20211020032035450">下面使用sum()函数计算三科的总成绩，代码如下：</p><p>df[‘总成绩’]=df.sum(axis=1)</p><p>运行程序，输出结果如图4.2所示。</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/学习记录/专高三/讲义Pandas统计分析/image-20211020032210845.png" alt="image-20211020032210845"></p><p>​                                        图4.1　DataFrame数据</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/学习记录/专高三/讲义Pandas统计分析/image-20211020032230748.png" alt="image-20211020032230748"></p><p>​                                  图4.2　sum()函数计算三科的总成绩</p><h3 id="4-1-2-求均值（mean-函数）"><a href="#4-1-2-求均值（mean-函数）" class="headerlink" title="4.1.2　求均值（mean()函数）"></a>4.1.2　求均值（mean()函数）</h3><p>DataFrame.mean(axis=None, skipna=None, level=None, numeric_only=None, kwargs)<br>参数说明：　</p><p>axis：axis=1表示行，axis=0表示列，默认值为None（无）。　</p><p>skipna：布尔型，表示计算结果是否排除NaN/Null值，默认值为None。　</p><p>level：表示索引层级，默认值为None。　</p><p>numeric_only：仅数字，布尔型，默认值为None。　</p><p>kwargs：要传递给函数的附加关键字参数。　</p><p>返回值：返回Series对象或DataFrame对象。行或列平均值数据。</p><p>【示例02】　计算语文、数学和英语各科的平均分。（示例位置：资源包\MR\Code\04\02）<br>计算语文、数学和英语各科成绩的平均值，程序代码如下：</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/学习记录/专高三/讲义Pandas统计分析/image-20211020032641368.png" alt="image-20211020032641368"></p><p>运行程序，输出结果如图4.3所示。</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020032714762.png" alt="image-20211020032714762"></p><p>​                             图4.3　mean()函数计算三科成绩的平均值<br>从运行结果得知：语文平均分109，数学平均分107，英语平均分114.667。</p><h3 id="4-1-3-求最大值（max-函数）"><a href="#4-1-3-求最大值（max-函数）" class="headerlink" title="4.1.3　求最大值（max()函数）"></a>4.1.3　求最大值（max()函数）</h3><p>在Python中通过调用DataFrame对象的max()函数实现行／列数据最大值运算，语法如下：</p><p>DataFrame.max(axis=None, skipna=None, level=None, numeric_only=None, **kwargs)<br>参数说明：　**</p><p>**axis：axis=1表示行，axis=0表示列，默认值为None（无）。　skipna：布尔型，表示计算结果是否排除NaN/Null值，默认值为None。　</p><p>**level：表示索引层级，默认值为None。　</p><p>**numeric_only：仅数字，布尔型，默认值为None。　</p><p>kwargs：要传递给函数的附加关键字参数。　</p><p>返回值：返回Series对象或DataFrame对象。行或列最大值数据。</p><p>【示例03】　计算语文、数学和英语各科的最高分。（示例位置：资源包\MR\Code\04\03）<br>计算语文、数学和英语各科成绩的最大值，程序代码如下：</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/学习记录/专高三/讲义Pandas统计分析/image-20211020032850843.png" alt="image-20211020032850843"></p><p>运行程序，输出结果如图4.4所示。</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/学习记录/专高三/讲义Pandas统计分析/image-20211020033031795.png" alt="image-20211020033031795"></p><p>​                       图4.4　max()函数计算三科成绩的最大值</p><p>4.1.4　求最小值（min()函数）<br>在Python中通过调用DataFrame对象的min()函数实现行／列数据最小值运算，语法如下：</p><p>DataFrame.min(axis=None, skipna=None, level=None, numeric_only=None, **kwargs)<br>参数说明：　**</p><p>**axis：axis=1表示行，axis=0表示列，默认值为None（无）。　skipna：布尔型，表示计算结果是否排除NaN/Null值，默认值为None。　</p><p>**level：表示索引层级，默认值为None。　</p><p>**numeric_only：仅数字，布尔型，默认值为None。　</p><p>kwargs：要传递给函数的附加关键字参数。　</p><p>返回值：返回Series对象或DataFrame对象。行或列最小值数据。</p><p>【示例04】　计算语文、数学和英语各科的最低分。（示例位置：资源包\MR\Code\04\04）<br>计算语文、数学和英语各科成绩的最小值，程序代码如下：</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/学习记录/专高三/讲义Pandas统计分析/image-20211020033254349.png" alt="image-20211020033254349"></p><p>运行程序，输出结果如图4.5所示。</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/学习记录/专高三/讲义Pandas统计分析/image-20211020033314763.png" alt="image-20211020033314763"></p><h3 id="4-1-5-求中位数（median-函数）"><a href="#4-1-5-求中位数（median-函数）" class="headerlink" title="4.1.5　求中位数（median()函数）"></a>4.1.5　求中位数（median()函数）</h3><p>中位数又称中值，是统计学专有名词，是指按顺序排列的一组数据中位于中间位置的数，其不受异常值的影响。例如，年龄23、45、35、25、22、34、28这7个数，中位数就是排序后位于中间的数字，即28；而年龄23、45、35、25、22、34、28、27这8个数，中位数则是排序后位于中间两个数的平均值，即27.5。在Python中直接调用DataFrame对象的median()函数就可以轻松实现中位数的运算，语法如下：</p><p>DataFrame.median(axis=None,skipna=None,level=None,numeric_only=None,**kwargs)<br>参数说明：　**</p><p>**axis：axis=1表示行，axis=0表示列，默认值为None（无）。　skipna：布尔型，表示计算结果是否排除NaN/Null值，默认值为None。　</p><p>**level：表示索引层级，默认值为None。　</p><p>**numeric_only：仅数字，布尔型，默认值为None。　</p><p>kwargs：要传递给函数的附加关键字参数。　</p><p>返回值：返回Series对象或DataFrame对象。</p><p>【示例05】　计算学生各科成绩的中位数1。（示例位置：资源包\MR\Code\04\05）<br>下面给出一组数据（3条记录），然后使用median()函数计算语文、数学和英语各科成绩的中位数，程序代码如下：</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/学习记录/专高三/讲义Pandas统计分析/image-20211020033458773.png" alt="image-20211020033458773"></p><p>运行程序，控制台输出结果如下：</p><p>语文    130.0数学    120.0英语    130.0</p><p>【示例06】　计算学生各科成绩的中位数2。（示例位置：资源包\MR\Code\04\06）<br>下面再给出一组数据（4条记录），同样使用median()函数计算语文、数学和英语各科成绩的中位数，程序代码如下：</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/学习记录/专高三/讲义Pandas统计分析/image-20211020033625031.png" alt="image-20211020033625031"></p><p>运行程序，控制台输出结果如下：</p><p>语文    121.5数学    121.5英语    120.0</p><h3 id="4-1-6-求众数（mode-函数）"><a href="#4-1-6-求众数（mode-函数）" class="headerlink" title="4.1.6　求众数（mode()函数）"></a>4.1.6　求众数（mode()函数）</h3><p>什么是众数？众数的众字有多的意思，顾名思义，众数就是一组数据中出现最多的数称为众数，它代表了数据的一般水平。<br>在Python中通过调用DataFrame对象的mode()函数可以实现众数运算，语法如下：</p><p>DataFrame.mode(axis=0,numeric_only=False,dropna=True)<br>参数说明：　</p><p>axis：axis=1表示行，axis=0表示列，默认值为0。　</p><p>numeric_only：仅数字，布尔型，默认值为False。如果值为True，则仅适用于数字列。　</p><p>dropna：是否删除缺失值，布尔型，默认值为True。　</p><p>返回值：返回Series对象或DataFrame对象。<br>首先看一组原始数据，如图4.6所示。</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020033849240.png" alt="image-20211020033849240"></p><p>【示例07】　计算学生各科成绩的众数。（示例位置：资源包\MR\Code\04\07）<br>计算语文、数学和英语三科成绩的众数、每一行的众数和“数学”成绩的众数，程序代码如下：</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020034005721.png" alt="image-20211020034005721"></p><p>三科成绩的众数：<br>每一行的众数：</p><p>0  110<br>1  130<br>2  130<br>数学成绩的众数：</p><p>0  120</p><h3 id="4-1-7-求方差（var-函数）"><a href="#4-1-7-求方差（var-函数）" class="headerlink" title="4.1.7　求方差（var()函数）"></a>4.1.7　求方差（var()函数）</h3><p>方差用于衡量一组数据的离散程度，即各组数据与它们的平均数的差的平方，那么我们用这个结果来衡量这组数据的波动大小，并把它叫作这组数据的方差，方差越小越稳定。通过方差可以了解一个问题的波动性。下面简单介绍下方差的意义，相信通过一个简单的举例您就会了解。<br>例如，某校两名同学的物理成绩都很优秀，而参加物理竞赛的名额只有一个，那么选谁去获得名次的机率更大呢？于是根据历史数据计算出了两名同学的平均成绩，但结果是实力相当，平均成绩都是107.6，怎么办呢？这时让方差帮决定，看看谁的成绩更稳定。首先汇总物理成绩，如图4.7所示。</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020034219502.png" alt="image-20211020034219502"></p><p>​                                            图4.7　物理成绩<br>通过方差对比两名同学物理成绩的波动，如图4.8所示。</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020034235082.png" alt="image-20211020034235082"></p><p>​                                                   图4.8　方差<br>接着来看一下总体波动（方差和），“小黑”的数据是73.2，“小白”的数据是949.2，很明显“小黑”的物理成绩波动较小，发挥更稳定，所以应该选“小黑”参加物理竞赛。<br>以上举例就是方差的意义。大数据时代，它能够帮助我们解决很多身边的问题、协助我们做出合理的决策。<br>在Python中通过调用DataFrame对象的var()函数可以实现方差运算，语法如下：</p><p><strong>DataFrame.var(axis=None,skipna=None,level=None,ddof=1,numeric_only=None,kwargs)</strong><br>参数说明：　</p><p>axis：axis=1表示行，axis=0表示列，默认值为None（无）。　skipna：布尔型，表示计算结果是否排除NaN/Null值，默认值为None。　</p><p>level：表示索引层级，默认值为None。　</p><p>ddof：整型，默认值为1。自由度，计算中使用的除数是N-ddof，其中N表示元素的数量。　</p><p>numeric_only：仅数字，布尔型，默认值为None。　</p><p>kwargs：要传递给函数的附加关键字参数。　</p><p>返回值：返回Series对象或DataFrame对象。</p><p>【示例08】　通过方差判断谁的物理成绩更稳定。（示例位置：资源包\MR\Code\04\08）<br>计算“小黑”和“小白”物理成绩的方差，程序代码如下：</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020034435272.png" alt="image-20211020034435272"></p><p>运行程序，控制台输出结果如下：</p><p>小黑     18.3小白    237.3<br>从运行结果得知：“小黑”的物理成绩波动较小，发挥更稳定。这里需要注意的是，Pandas中计算的方差为无偏样本方差（即方差和／样本数-1），NumPy中计算的方差就是样本方差本身（即方差和／样本数）。</p><h3 id="4-1-8-标准差（数据标准化std-函数）"><a href="#4-1-8-标准差（数据标准化std-函数）" class="headerlink" title="4.1.8　标准差（数据标准化std()函数）"></a>4.1.8　标准差（数据标准化std()函数）</h3><p>标准差又称均方差，是方差的平方根，用来表示数据的离散程度。<br>在Python中通过调用DataFrame对象的std()函数求标准差，语法如下：</p><p>DataFrame.std(axis=None,skipna=None,level=None,ddof=1,numeric_only=None,**kwargs)<br>std()函数的参数与var()函数一样，这里不再赘述。</p><p>【示例09】　计算各科成绩的标准差。（示例位置：资源包\MR\Code\04\09）<br>使用std()函数计算标准差，程序代码如下：</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020034453875.png" alt="image-20211020034453875"></p><p>运行程序，控制台输出结果如下：</p><p>语文    11.547005数学     5.773503英语    11.5547005</p><h3 id="4-1-9-求分位数（quantile-函数）"><a href="#4-1-9-求分位数（quantile-函数）" class="headerlink" title="4.1.9　求分位数（quantile()函数）"></a>4.1.9　求分位数（quantile()函数）</h3><p>分位数也称分位点，它以概率依据将数据分割为几个等份，常用的有中位数（即二分位数）、四分位数、百分位数等。分位数是数据分析中常用的一个统计量，经过抽样得到一个样本值。例如，经常会听老师说：“这次考试竟然有20%的同学不及格！”，那么这句话就体现了分位数的应用。在Python中通过调用DataFrame对象的quantile()函数求分位数，语法如下：</p><p><strong>DataFrame.quantile(q=0.5,axis=0,numeric_only=True, interpolation=’linear’)</strong><br>参数说明：　</p><p>q：浮点型或数组，默认为0.5（50%分位数），其值为0～1。　</p><p>axis：axis=1表示行，axis=0表示列。默认值为0。　</p><p>numeric_only：仅数字，布尔型，默认值为True。　</p><p>interpolation：内插值，可选参数[{‘linear’,‘lower’,‘higher’,‘midpoint’,‘nearest’}]用于指定要使用的插值方法，当期望的分位数为数据点i～j时。　</p><p>​    linear’：i+(j-i)×分数，其中分数是指数被i和j包围的小数部分。　</p><p>​    lower：i。　</p><p>​    higher：j。　</p><p>​    nearest：i或j二者以最近者为准。　</p><p>​    midpoint：(i+j)/2。　</p><p>返回值：返回Series或DataFrame对象。</p><p>【示例10】　通过分位数确定被淘汰的35%的学生。（示例位置：资源包\MR\Code\04\10）<br>以学生成绩为例，数学成绩分别为120、89、98、78、65、102、112、56、79、45的10名同学，现根据分数淘汰35%的学生，该如何处理？首先使用quantile()函数计算35%的分位数，然后将学生成绩与分位数比较，筛选小于等于分位数的学生，程序代码如下：</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020035437337.png" alt="image-20211020035437337"></p><p>运行程序，控制台输出结果如下：</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020035513992.png" alt="image-20211020035513992"></p><p>从运行结果得知：即将被淘汰的学生有4名，分数分别为78、65、56和45。</p><p>【示例11】　计算日期、时间和时间增量数据的分位数。（示例位置：资源包\MR\Code\04\11）<br>如果参数numeric_only=False，将计算日期、时间和时间增量数据的分位数，程序代码如下：<br>运行程序，控制台输出结果如下：</p><p>A                  1.5<br>B 2019-07-02 12:00:00<br>C          1 days 12:00:00<br>Name: 0.5, dtype: object</p><h2 id="4-2-数据格式化"><a href="#4-2-数据格式化" class="headerlink" title="4.2　数据格式化"></a>4.2　数据格式化</h2><p>在进行数据处理时，尤其是在数据计算中应用求均值（mean()函数）后，发现结果中的小数位数增加了许多。此时就需要对数据进行格式化，以增加数据的可读性。例如，保留小数点位数、百分号、千位分隔符等。首先来看一组数据，如图4.9所示。</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020035851798.png" alt="image-20211020035851798"></p><p>​                                         图4.9　原始数据</p><h3 id="4-2-1-设置小数位数"><a href="#4-2-1-设置小数位数" class="headerlink" title="4.2.1　设置小数位数"></a>4.2.1　设置小数位数</h3><p>设置小数位数主要使用DataFrame对象的round()函数，该函数可以实现四舍五入，而它的decimals参数则用于设置保留小数的位数，设置后数据类型不会发生变化，依然是浮点型。语法如下：</p><p>DataFrame.round(decimals=0, *args, **kwargs)　**</p><p>decimals：每一列四舍五入的小数位数，整型、字典或Series对象。如果是整数，则将每一列四舍五入到相同的位置。否则，将字典和Series舍入到可变数目的位置；如果小数是类似于字典的，那么列名应该在键中；如果小数是级数，列名应该在索引中。没有包含在小数中的任何列都将保持原样。非输入列的小数元素将被忽略。　</p><p>args：附加的关键字参数。　</p><p>kwargs：附加的关键字参数。　</p><p>返回值：返回DataFrame对象。</p><p>【示例12】　四舍五入保留指定的小数位数。（示例位置：资源包\MR\Code\04\12）<br>使用round()函数四舍五入保留小数位数，程序代码如下：</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020040002742.png" alt="image-20211020040002742"></p><p>运行程序，控制台输出结果如下：</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020040023289.png" alt="image-20211020040023289"></p><p>当然，保留小数位数也可以用自定义函数，例如，为DataFrame对象中的各个浮点值保留两位小数，主要代码如下：</p><p>df.applymap(lambda x: ‘%.2f’%x)</p><p>注意<br>经过自定义函数处理过的数据将不再是浮点型而是对象型，如果后续计算需要数据，则应先进行数据类型转换。</p><h3 id="4-2-2-设置百分比"><a href="#4-2-2-设置百分比" class="headerlink" title="4.2.2　设置百分比"></a>4.2.2　设置百分比</h3><p>在数据分析过程中，有时需要百分比数据。那么，利用自定义函数将数据进行格式化处理，处理后的数据就可以从浮点型转换成带指定小数位数的百分比数据，主要使用apply()函数与format()函数。</p><p>【示例13】　将指定数据格式化为百分比数据。（示例位置：资源包\MR\Code\04\13）<br>将A1列的数据格式化为百分比数据，程序代码如下：</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020040234891.png" alt="image-20211020040234891"></p><p>运行程序，控制台输出结果如下：</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020040335780.png" alt="image-20211020040335780"></p><h3 id="4-2-3-设置千位分隔符"><a href="#4-2-3-设置千位分隔符" class="headerlink" title="4.2.3　设置千位分隔符"></a>4.2.3　设置千位分隔符</h3><p>由于业务需要，有时需要将数据格式化为带千位分隔符的数据。那么，处理后的数据将不再是浮点型而是对象型。</p><p>【示例14】　将金额格式化为带千位分隔符的数据。（示例位置：资源包\MR\Code\04\14）<br>将图书销售码洋格式化为带千位分隔符的数据，程序代码如下：</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020040604750.png" alt="image-20211020040604750"></p><p>运行程序，控制台输出结果如下：</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020040623599.png" alt="image-20211020040623599"></p><p>注意<br>设置千位分隔符后，对于程序来说，这些数据将不再是数值型，而是数字和逗号组成的字符串，如果由于程序需要再变成数值型就会很麻烦，因此设置千位分隔符要慎重。</p><h2 id="4-3-数据分组统计"><a href="#4-3-数据分组统计" class="headerlink" title="4.3　数据分组统计"></a>4.3　数据分组统计</h2><p>本节主要介绍分组统计函数groupby()的各种应用。</p><h3 id="4-3-1-分组统计groupby-函数"><a href="#4-3-1-分组统计groupby-函数" class="headerlink" title="4.3.1　分组统计groupby()函数"></a>4.3.1　分组统计groupby()函数</h3><p>对数据进行分组统计，主要使用DataFrame对象的groupby()函数，其功能如下。<br>（1）根据给定的条件将数据拆分成组。</p><p>（2）每个组都可以独立应用函数（如求和函数sum()、求平均值函数mean()等）。<br>（3）将结果合并到一个数据结构中。<br>groupby()函数用于将数据按照一列或多列进行分组，一般与计算函数结合使用，实现数据的分组统计，语法如下：</p><p><strong>DataFrame.groupby(by=None,axis=0,level=None,as_index=True,sort=True,group_keys=True,squeeze=False,observed=False)</strong></p><p>参数说明：　</p><p>by：映射、字典或Series对象、数组、标签或标签列表。如果by是一个函数，则对象索引的每个值都调用它；如果传递了一个字典或Series对象，则使用该字典或Series对象值来确定组；如果传递了数组ndarray，则按原样使用这些值来确定组。　</p><p>axis：axis=1表示行，axis=0表示列。默认值为0。　</p><p>level：表示索引层级，默认值为None（无）。　</p><p>as_index：布尔型，默认值为True，返回以组标签为索引的对象。　sort：对组进行排序，布尔型，默认值为True。　</p><p>group_keys：布尔型，默认值为True，调用apply()函数时，将分组的键添加到索引以标识片段。　</p><p>squeeze：布尔型，默认值为False。如果可能，减少返回类型的维度；否则返回一致类型。　</p><p>observed： <em>bool, default False</em> 布尔型, 观察者, 默认为False。当以石斑鱼为分类时，才会使用该参数。如果参数值为True，则仅显示分类石斑鱼的观测值；如果参数值为False，则显示分类石斑鱼的所有值。</p><p>返回值：返回DataFrameGroupBy，返回包含有关组的信息的groupby对象。</p><h4 id="1．按照一列分组统计"><a href="#1．按照一列分组统计" class="headerlink" title="1．按照一列分组统计"></a>1．按照一列分组统计</h4><p>【示例15】　根据“一级分类”统计订单数据。（示例位置：资源包\MR\Code\04\15）<br>按照图书“一级分类”对订单数据进行分组统计求和，程序代码如下：</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020042705196.png" alt="image-20211020042705196"></p><p>运行程序，输出结果如图4.10所示。</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020042744863.png" alt="image-20211020042744863"></p><p>​                                 图4.10　按照一列分组统计</p><h4 id="2．按照多列分组统计"><a href="#2．按照多列分组统计" class="headerlink" title="2．按照多列分组统计"></a>2．按照多列分组统计</h4><p>多列分组统计，以列表形式指定列。</p><p>【示例16】　根据两级分类统计订单数据。（示例位置：资源包\MR\Code\04\16）<br>按照图书“一级分类”和“二级分类”对订单数据进行分组统计求和，主要代码如下：</p><p>01 #抽取数据<br>02 df1=df[[‘一级分类’,’二级分类’,’7天点击量’,’订单预定’]]<br>03 df1=df1.groupby([‘一级分类’,’二级分类’]).sum()    #分组统计求和</p><p>运行程序，输出结果如图4.11所示。</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020042906442.png" alt="image-20211020042906442"></p><p>​                                    图4.11　按照多列分组统计</p><h4 id="3．分组并按指定列进行数据计算"><a href="#3．分组并按指定列进行数据计算" class="headerlink" title="3．分组并按指定列进行数据计算"></a>3．分组并按指定列进行数据计算</h4><p>前面介绍的分组统计是按照所有列进行汇总计算的，那么如何按照指定列汇总计算呢？</p><p>【示例17】　统计各编程语言的7天点击量。（示例位置：资源包\MR\Code\04\17）<br>统计各编程语言的7天点击量，首先按“二级分类”分组，然后抽取“7天点击量”列并对该列进行求和运算，主要代码如下：</p><p>df1=df1.groupby(‘二级分类’)[‘7天点击量’].sum()<br>运行程序，输出结果如图4.12所示。</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020043023795.png" alt="image-20211020043023795"></p><p>图4.12　分组并按指定列进行数据计算</p><h3 id="4-3-2-对分组数据进行迭代"><a href="#4-3-2-对分组数据进行迭代" class="headerlink" title="4.3.2　对分组数据进行迭代"></a>4.3.2　对分组数据进行迭代</h3><p>通过for循环对分组统计数据进行迭代（遍历分组数据）。</p><p>【示例18】　迭代一级分类的订单数据。（示例位置：资源包\MR\Code\04\18）<br>按照“一级分类”分组，并输出每一分类中的订单数据，主要代码如下：</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020043149194.png" alt="image-20211020043149194"></p><p>运行程序，控制台输出结果如图4.13所示。<br>上述代码中，name是groupby()函数中“一级分类”的值，group是分组后的数据。如果groupby()函数对多列进行分组，那么需要在for循环中指定多列。</p><p>【示例19】　迭代两级分类的订单数据。（示例位置：资源包\MR\Code\04\19）<br>迭代“一级分类”和“二级分类”的订单数据，主要代码如下：</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020043219251.png" alt="image-20211020043219251"></p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020043328145.png" alt="image-20211020043328145"></p><p>​                          图4.13　对分组数据进行迭代</p><h3 id="4-3-3-对分组的某列或多列使用聚合函数（agg-函数）"><a href="#4-3-3-对分组的某列或多列使用聚合函数（agg-函数）" class="headerlink" title="4.3.3　对分组的某列或多列使用聚合函数（agg()函数）"></a>4.3.3　对分组的某列或多列使用聚合函数（agg()函数）</h3><p>Python也可以实现像SQL中的分组聚合运算操作，主要通过groupby()函数与agg()函数实现。【示例20】　对分组统计结果使用聚合函数。（示例位置：资源包\MR\Code\04\20）<br>按“一级分类”分组统计“7天点击量”“订单预定”的平均值和总和，主要代码如下：</p><p>print(df1.groupby(‘一级分类’).agg([‘mean’,’sum’]))<br>运行程序，控制台输出结果如图4.14所示。</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020043531227.png" alt="image-20211020043531227"></p><p>​                 图4.14　分组统计“7天点击量”“订单预定”的平均值和总和</p><p>【示例21】　针对不同的列使用不同的聚合函数。（示例位置：资源包\MR\Code\04\21）<br>在上述示例中，还可以针对不同的列使用不同的聚合函数。例如，按“一级分类”分组统计“7天点击量”的平均值和总和、“订单预定”的总和，主要代码如下：</p><p>print(df1.groupby(‘一级分类’).agg({‘7天点击量’:[‘mean’,’sum’], ‘订单预定’:[‘sum’]}))<br>运行程序，控制台输出结果如图4.15所示。</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020043554534.png" alt="image-20211020043554534"></p><p>​           图4.15　分组统计“7天点击量”的平均值和总和、“订单预定”的总和</p><p>【示例22】　通过自定义函数实现分组统计。（示例位置：资源包\MR\Code\04\22）<br>通过自定义函数也可以实现数据分组统计。例如，统计1月份销售数据中，购买次数最多的产品，主要代码如下：</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020043631773.png" alt="image-20211020043631773"></p><p>运行程序，控制台输出结果如图4.16所示。</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020043647886.png" alt="image-20211020043647886"></p><p>​                             图4.16　统计购买次数最多的产品</p><p>从运行结果得知：“零基础学Python”是用户购买次数最多的产品。实用技巧<br>在图4.16显示的输出结果中可以看到，lambda()函数名称<lambda>被输出出来，看上去不是很美观，那么如何去掉它？方法是使用__name__方法修改函数名称，主要代码如下：</lambda></p><p>max.<strong>name</strong> = “购买次数最多”<br>运行程序，控制台输出结果如图4.17所示。</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020043747160.png" alt="image-20211020043747160"></p><p>​                         图4.17　使用__name__方法修改函数名称</p><h3 id="4-3-4-通过字典和Series对象进行分组统计"><a href="#4-3-4-通过字典和Series对象进行分组统计" class="headerlink" title="4.3.4　通过字典和Series对象进行分组统计"></a>4.3.4　通过字典和Series对象进行分组统计</h3><h4 id="1．通过字典进行分组统计"><a href="#1．通过字典进行分组统计" class="headerlink" title="1．通过字典进行分组统计"></a>1．通过字典进行分组统计</h4><p>首先创建字典建立对应关系，然后将字典传递给groupby()函数从而实现数据分组统计。</p><p>【示例23】　通过字典分组统计“北上广”销量。（示例位置：资源包\MR\Code\04\23）<br>统计各地区销量，业务要求将“北京”“上海”“广州”3个一线城市放在一起统计。那么首先创建一个字典将“北京出库销量”“上海出库销量”“广州出库销量”都对应“北上广”；然后使用groupby()函数进行分组统计。主要代码如下：</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020043824543.png" alt="image-20211020043824543"></p><p>运行程序，控制台输出结果如图4.18所示。</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020043847244.png" alt="image-20211020043847244"></p><p>​                                 图4.18　通过字典进行分组统计</p><h4 id="2．通过Series对象进行分组统计"><a href="#2．通过Series对象进行分组统计" class="headerlink" title="2．通过Series对象进行分组统计"></a>2．通过Series对象进行分组统计</h4><p>通过Series对象进行分组统计与字典的方法类似。</p><p>【示例24】　通过Series对象分组统计“北上广”销量。（示例位置：资源包\MR\Code\04\24）<br>首先，创建一个Series对象，主要代码如下：</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020043933019.png" alt="image-20211020043933019"></p><p>运行程序，输出结果如图4.19所示。<br>然后，将Series对象传递给groupby()函数实现数据分组统计，主要代码如下：</p><p>01  df1=df.groupby(s1,axis=1).sum()<br>02  print(df1)<br>运行程序，控制台输出结果如图4.20所示。</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020043959963.png" alt="image-20211020043959963"></p><p>​                             图4.19　通过Series对象进行分组统计</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020044040014.png" alt="image-20211020044040014"></p><p>​                             图4.20　分组统计结果</p><h2 id="4-4-数据移位"><a href="#4-4-数据移位" class="headerlink" title="4.4　数据移位"></a>4.4　数据移位</h2><p>什么是数据移位？例如，分析数据时需要上一条数据怎么办？当然是移动至上一条，从而得到该条数据，这就是数据移位。在Pandas中，使用shift()方法可以获得上一条数据，该方法返回向下移位后的结果，从而得到上一条数据。例如，获取某学生上一次英语成绩，如图4.21所示。</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020044117875.png" alt="image-20211020044117875"></p><p>​                              图4.21　获取学生上一次英语成绩<br>shift()方法是一个非常有用的方法，用于数据位移与其他方法结合，能实现很多难以想象的功能，语法格式如下：</p><p>DataFrame.shift(periods=1, freq=None, axis=0)<br>参数说明：　</p><p>periods：表示移动的幅度，可以是正数，也可以是负数，默认值是1，1表示移动一次。注意这里移动的都是数据，而索引是不移动的，移动之后是没有对应值的，赋值为NaN。　</p><p>freq：可选参数，默认值为None，只适用于时间序列，如果这个参数存在，那么会按照参数值移动时间索引，而数据值没有发生变化。　</p><p>axis：axis=1表示行，axis=0表示列。默认值为0。</p><p>【示例25】　统计学生英语周测成绩的升降情况。（示例位置：资源包\MR\Code\04\25）<br>使用shift()方法统计学生每周英语测试成绩的升降情况，程序代码如下：</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020044313140.png" alt="image-20211020044313140"></p><p>运行程序，控制台输出结果如图4.22所示。<br>从运行结果得知：第2次比第1次下降5分，第3次比第2次下降6分，第4次比第3次提升21分，第5次比第4次下降5分。<br>这里再扩展下，通过10次周测来一看下学生整体英语成绩的升降情况，如图4.23和图4.24所示。</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020044330897.png" alt="image-20211020044330897"></p><p>​                                     图4.22　英语升降情况</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020044547566.png" alt="image-20211020044547566"></p><p>​                               图4.23　10次周测英语成绩升降情况</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020044603814.png" alt="image-20211020044603814"></p><p>​                     图4.24　图表展示英语成绩升降情况</p><p>说明</p><p>有关图表的知识将在第6章介绍，这里先简单了解。</p><p>shift()方法还有很多方面的应用。例如这样一个场景：分析股票数据，获取的股票数据中有股票的实时价格，也有每日的收盘价“close”，此时需要将实时价格和上一个工作日的收盘价进行对比，那么通过shift()方法就可以轻松解决。shift()方法还可以应用于时间序列，感兴趣的读者可以在学习完成后续章节进行尝试和探索。</p><h2 id="4-5-数据转换"><a href="#4-5-数据转换" class="headerlink" title="4.5　数据转换"></a>4.5　数据转换</h2><p>数据转换一般包括一列数据转换为多列数据、行列转换、DataFrame转换为字典、DataFrame转换为列表和DataFrame转换为元组等。</p><h3 id="4-5-1-一列数据转换为多列数据"><a href="#4-5-1-一列数据转换为多列数据" class="headerlink" title="4.5.1　一列数据转换为多列数据"></a>4.5.1　一列数据转换为多列数据</h3><p>一列数据转换为多列数据的情况在日常工作中经常会用到，从各种系统中导出的订单号、名称、地址很多都是复合组成的（即由多项内容组成），那么，这些列在查找、统计、合并时就没办法使用，需要将它们拆分开。例如，地址信息由省市区街道门牌号等信息组成，如果按省、市或区统计数据，就需要将地址信息中的“省”“市”“区”拆分开，此时就应用到了一列数据转多列数据，通常使用以下方法。</p><h4 id="1．split-方法"><a href="#1．split-方法" class="headerlink" title="1．split()方法"></a>1．split()方法</h4><p>Pandas的DataFrame对象中的str.split()内置方法可以实现分割字符串，语法如下：</p><p>Series.str.split(pat=None, n=-1, expand=False)<br>参数说明：　</p><p>pat：字符串、符号或正则表达式，字符串分割的依据，默认以空格分割字符串。　</p><p>n：整型，分割次数，默认值是-1，0或-1都将返回所有拆分。　</p><p>expand：布尔型，分割后的结果是否转换为DataFrame，默认值是False。　</p><p>返回值：系列、索引、DataFrame或多重索引。<br>首先，我们来看一组淘宝销售订单数据（部分数据），如图4.25所示。</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020044753477.png" alt="image-20211020044753477"></p><p>图4.25　淘宝销售订单数据（部分数据）<br>从图4-25中数据得知：不仅“收货地址”是复合的，“宝贝标题”也是复合的，即由多种产品组成。</p><p>【示例26】　分割“收货地址”数据中的“省、市、区”。（示例位置：资源包\MR\Code\04\26）<br>使用split()方法先对“收货地址”进行分割，程序代码如下：</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020044817707.png" alt="image-20211020044817707"></p><p>运行程序，输出结果如图4.26所示。</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020044931041.png" alt="image-20211020044931041"></p><p>​                                  图4.26　分割后的收货地址</p><h4 id="2．join-方法与split-方法结合"><a href="#2．join-方法与split-方法结合" class="headerlink" title="2．join()方法与split()方法结合"></a>2．join()方法与split()方法结合</h4><p>【示例27】　以逗号分隔多种产品数据。（示例位置：资源包\MR\Code\04\27）<br>通过join()方法与split()方法结合，以逗号“,”分隔“宝贝标题”，主要代码如下：</p><p>df = df.join(df[‘宝贝标题’].str.split(‘, ‘, expand=True))</p><p>运行程序，输出结果如图4.27所示。</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020044959881.png" alt="image-20211020044959881"></p><p>​                                   图4.27　分隔后的“宝贝标题”<br>从运行结果得知：“宝贝标题”中含有多种产品的数据被拆分开，这样操作便于日后对每种产品的销量进行统计。<br>将DataFrame中的tuple（元组）类型数据分隔成多列</p><p>【示例28】　对元组数据进行分隔。（示例位置：资源包\MR\Code\04\28）<br>首先，创建一组包含元组的数据，程序代码如下：</p><p>01  import pandas as pd<br>02  df = pd.DataFrame({‘a’:[1,2,3,4,5], ‘b’:[(1,2), (3,4),(5,6),(7,8),(9,10)]})<br>03  print(df)</p><p>然后，使用apply()函数对元组进行分隔，主要代码如下：</p><p>df[[‘b1’, ‘b2’]] = df[‘b’].apply(pd.Series)<br>或者使用join()方法结合apply()函数，主要代码如下：</p><p>df= df.join(df[‘b’].apply(pd.Series))<br>运行程序，控制台输出原始数据如图4.28所示，结果如图4.29和图4.30所示。</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020045110497.png" alt="image-20211020045110497"></p><p>​                                            图4.28　原始数据</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020045122797.png" alt="image-20211020045122797"></p><p>​                             图4.29　apply()函数分隔元组</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020045146968.png" alt="image-20211020045146968"></p><p>​                       图4.30　join()方法结合apply()函数分隔元组</p><h3 id="4-5-2-行列转换"><a href="#4-5-2-行列转换" class="headerlink" title="4.5.2　行列转换"></a>4.5.2　行列转换</h3><p>在Pandas处理数据过程中，有时需要对数据进行行列转换或重排，主要使用stack()方法、unstack()方法和pivot()方法，下面介绍这3种方法的应用。</p><h4 id="1．stack-方法"><a href="#1．stack-方法" class="headerlink" title="1．stack()方法"></a>1．stack()方法</h4><p>stack()方法用于将原来的列索引转换成最内层的行索引，转换效果对比示意图如图4.31所示。</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020045215351.png" alt="image-20211020045215351"></p><p>​                               图4.31　转换效果对比示意图<br>stack()方法的语法如下：</p><p>DataFrame.stack(level=-1, dropna=True)<br>参数说明：　</p><p>level：索引层级，定义为一个索引或标签，或索引或标签列表，默认值是-1。　</p><p>dropna：布尔型，默认值是True，　</p><p>返回值：DataFrame对象或Series对象。</p><p>【示例29】　对英语成绩表进行行列转换。（示例位置：资源包\MR\Code\04\29）<br>将学生英语成绩表进行行列转换，程序代码如下：</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020045321517.png" alt="image-20211020045321517"></p><h4 id="2．unstack-方法"><a href="#2．unstack-方法" class="headerlink" title="2．unstack()方法"></a>2．unstack()方法</h4><p>unstack()方法与stack()方法相反，它是stack()方法的逆操作，即将最内层的行索引转换成列索引，转换效果对比如图4.32所示。</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020045341690.png" alt="image-20211020045341690"></p><p>​                   图4.32　unstack()方法转换数据示意图<br>unstack()方法的语法如下：</p><p>DataFrame.unstack(level=-1, fill_value=None)<br>参数说明：　</p><p>level：索引层级，定义为一个索引或标签，或索引或标签列表，默认值是-1。　</p><p>fill_value：整型、字符串或字典，如果unstack()方法产生丢失值，则用这个值替换NaN。　返回值：DataFrame对象或Series对象。</p><p>【示例30】　使用unstack()方法转换学生成绩表。（示例位置：资源包\MR\Code\04\30）<br>同样转换学生成绩表，主要代码如下：</p><p>01 df=pd.read_excel(‘grade.xls’,sheet_name=’英语2’)      #导入Excel文件<br>02 df = df.set_index([‘班级’,’序号’,’Unnamed: 2’])       #设置多级索引<br>03 print(df.unstack())<br>unstack()方法中有一个参数可以指定转换第几层索引，例如，unstack(0)就是把第一层行索引转换为列索引，默认是将最内层索引转换为列索引。</p><h4 id="3．pivot-方法"><a href="#3．pivot-方法" class="headerlink" title="3．pivot()方法"></a>3．pivot()方法</h4><p>pivot()方法针对列的值，即指定某列的值作为行索引，指定某列的值作为列索引，然后再指定哪些列作为索引对应的值。unstack()方法针对索引进行操作，pivot()方法针对值进行操作。但实际上，二者的功能往往可以互相实现。<br>pivot()方法的语法如下：</p><p>DataFrame.pivot(index=None, columns=None, values=None)<br>参数说明：　</p><p>index：字符串或对象，可选参数。列用于创建新DataFrame数据的索引。如果没有，则使用现有索引。　</p><p>columns：字符串或对象，列用于创建新DataFrame的列。　</p><p>values：列用于填充新DataFrame的值，如果未指定，则将使用所有剩余的列，结果将具有分层索引列。　</p><p>返回值：DataFrame对象或Series对象。</p><p>【示例31】　使用pivot()方法转换学生成绩表。（示例位置：资源包\MR\Code\04\31）<br>使用pivot()方法转换学生成绩表，主要代码如下：</p><p>01 df=pd.read_excel(‘grade.xls’,sheet_name=’英语3’)         #导入Excel文件<br>02 df1=df.pivot(index=’序号’,columns=’班级’,values=’得分’)<br>运行程序，输出结果如图4.33所示。</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020045550818.png" alt="image-20211020045550818"></p><p>图4.33　使用pivot()方法转换学生成绩表</p><h3 id="4-5-3-DataFrame转换为字典"><a href="#4-5-3-DataFrame转换为字典" class="headerlink" title="4.5.3　DataFrame转换为字典"></a>4.5.3　DataFrame转换为字典</h3><p>DataFrame转换为字典主要使用DataFrame对象的to_dict()方法，以索引作为字典的键（key），以列作为字典的值（value）。例如，有一个DataFrame对象（索引为“类别”、列为“数量”），通过to_dict()方法就会生成一个字典，示意图如图4.34所示。如果DataFrame对象包含两列，那么to_dict()方法就会生成一个两层的字典（dict），第一层是列名作为字典的键（key），第二层以索引列的值作为字典的键（key），以列值作为字典的值（value）。</p><p>【示例32】　将Excel销售数据转换为字典。（示例位置：资源包\MR\Code\04\32）<br>使用to_dict()方法将按“宝贝标题”分组统计后的部分数据转换为字典，程序代码如下：</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020045613721.png" alt="image-20211020045613721"></p><p>运行程序，控制台输出结果如图4.35所示。</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020045643137.png" alt="image-20211020045643137"></p><p>​                       图4.34　DataFrame转换为字典示意图</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020045702961.png" alt="image-20211020045702961"></p><p>​                           图4.35　DataFrame转换为字典</p><h3 id="4-5-4-DataFrame转换为列表"><a href="#4-5-4-DataFrame转换为列表" class="headerlink" title="4.5.4　DataFrame转换为列表"></a>4.5.4　DataFrame转换为列表</h3><p>DataFrame转换为列表主要使用DataFrame对象的tolist()方法。</p><p>【示例33】　将电商数据转换为列表。（示例位置：资源包\MR\Code\04\33）<br>将淘宝销售数据中的“买家会员名”转换为列表，程序代码如下：</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020045737401.png" alt="image-20211020045737401"></p><p>运行程序，控制台输出结果如图4.36所示。</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020045806297.png" alt="image-20211020045806297"></p><p>图4.36　DataFrame转换为列表</p><h3 id="4-5-5-DataFrame转换为元组"><a href="#4-5-5-DataFrame转换为元组" class="headerlink" title="4.5.5　DataFrame转换为元组"></a>4.5.5　DataFrame转换为元组</h3><p>DataFrame转换为元组，首先通过循环语句按行读取DataFrame数据，然后使用元组函数tuple()将其转换为元组。</p><p>【示例34】　将Excel数据转换为元组。（示例位置：资源包\MR\Code\04\34）<br>将Excel表中的人物关系部分数据转换成元组，程序代码如下：</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020045832962.png" alt="image-20211020045832962"></p><p>运行程序，控制台输出结果如图4.37所示。</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020045913740.png" alt="image-20211020045913740"></p><p>​                            图4.37　DataFrame转换为元组</p><h3 id="4-5-6-Excel转换为HTML网页格式"><a href="#4-5-6-Excel转换为HTML网页格式" class="headerlink" title="4.5.6　Excel转换为HTML网页格式"></a>4.5.6　Excel转换为HTML网页格式</h3><p>日常工作中，有时会涉及财务数据的处理，而Excel应用最为广泛，但是对于展示数据来说，Excel并不友好，如果你想用其他格式的文件来向用户展示，那么，HTML网页格式是不错的选择。首先使用read_excel()方法导入Excel文件，然后使用to_html()方法将DataFrame数据导出为HTML格式，这样便实现了Excel转换为HTML格式。</p><p>【示例35】　将Excel订单数据转换为HTML网页格式。（示例位置：资源包\MR\Code\04\35）<br>将淘宝部分订单数据转换为HTML网页格式，效果如图4.38所示。</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020045939834.png" alt="image-20211020045939834"></p><p>​                              图4.38　Excel转换为HTML网页格式<br>程序代码如下：</p><p>01 import pandas as pd<br>02 df=pd.read_excel(‘mrbooks.xls’)<br>03 df.to_html(‘mrbook.html’,header = True,index = False)</p><h2 id="4-6-数据合并"><a href="#4-6-数据合并" class="headerlink" title="4.6　数据合并"></a>4.6　数据合并</h2><p>DataFrame数据合并主要使用merge()方法和concat()方法。</p><h3 id="4-6-1-数据合并（merge-方法）"><a href="#4-6-1-数据合并（merge-方法）" class="headerlink" title="4.6.1　数据合并（merge()方法）"></a>4.6.1　数据合并（merge()方法）</h3><p>Pandas模块的merge()方法是按照两个DataFrame对象列名相同的列进行连接合并，两个DataFrame对象必须具有同名的列。merge()方法的语法如下：</p><p>pandas.merge(right,how=’inner’,on=None,left_on=None,right_on=None,left_index=False,right_index=False,sort=False,suffixes=(‘_x’,’_y’),copy=True,indicator=False,validate=None)<br>参数说明：　</p><p>right：合并对象，DataFrame对象或Series对象。　</p><p>how：合并类型，参数值可以是left（左合并）、right（右合并）、outer（外部合并）或inner（内部合并），默认值为inner。各个值的说明如下。　</p><p>​        left：只使用来自左数据集的键，类似于SQL左外部联接，保留键的顺序。　</p><p>​        right：只使用来自右数据集的键，类似于SQL右外部联接，保留键的顺序。　</p><p>​        outer：使用来自两个数据集的键，类似于SQL外部联接，按字典顺序对键进行排序。　</p><p>​        inner：使用来自两个数据集的键的交集，类似于SQL内部连接，保持左键的顺序。</p><p>on：标签、列表或数组，默认值为None。DataFrame对象连接的列或索引级别名称。也可以是DataFrame对象长度的数组或数组列表。</p><p>left_on：标签、列表或数组，默认值为None。要连接的左数据集的列或索引级名称，也可以是左数据集长度的数组或数组列表。　</p><p>right_on：标签、列表或数组，默认值为None。要连接的右数据集的列或索引级名称，也可以是右数据集长度的数组或数组列表。　</p><p>left_index：布尔型，默认值为False。使用左数据集的索引作为连接键。如果是多重索引，则其他数据中的键数（索引或列数）必须匹配索引级别数。</p><p>right_index：布尔型，默认值为False，使用右数据集的索引作为连接键。　</p><p>sort：布尔型，默认值为False，在合并结果中按字典顺序对连接键进行排序。如果值为False，则连接键的顺序取决于连接类型how参数。　suffixes：元组类型，默认值为(‘_x’,’_y’)。当左侧数据集和右侧数据集的列名相同时，数据合并后列名将带上“_x”和“_y”后缀。　</p><p>copy：是否复制数据，默认值为True。如果值为False，则不复制数据。　</p><p>indicator：布尔型或字符串，默认值为False。如果值为True，则添加一个列以输出名为_Merge的DataFrame对象，其中包含每一行的信息。如果是字符串，将向输出的DataFrame对象中添加包含每一行信息的列，并将列命名为字符型的值。　</p><p>validate：字符串，检查合并数据是否为指定类型。可选参数，其值说明如下。　one_to_one或“1:1”：检查合并键在左、右数据集中是否都是唯一的。　one_to_many或“1:m”：检查合并键在左数据集中是否唯一。　many_to_one或“m:1”：检查合并键在右数据集中是否唯一。　many_to_many或“m:m”：允许，但不检查。　</p><p>返回值：DataFrame对象，两个合并对象的数据集。</p><h4 id="1．常规合并"><a href="#1．常规合并" class="headerlink" title="1．常规合并"></a>1．常规合并</h4><p>【示例36】　合并学生成绩表。（示例位置：资源包\MR\Code\04\36）<br>假设一个DataFrame对象包含了学生的“语文”“数学”“英语”成绩，而另一个DataFrame对象则包含了学生的“体育”成绩，现在将它们合并，示意图如图4.39所示。</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020050304612.png" alt="image-20211020050304612"></p><p>​                 图4.39　数据合并效果对比示意图<br>程序代码如下：</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020050326358.png" alt="image-20211020050326358"></p><p>运行程序，控制台输出结果如图4.40所示。</p><p>【示例37】　通过索引合并数据。（示例位置：资源包\MR\Code\04\37）<br>如果通过索引列合并，则需要设置right_index参数和left_index参数值为True。例如，上述举例，通过列索引合并，主要代码如下：</p><p>01 df_merge=pd.merge(df1,df2,right_index=True,left_index=True)<br>02 print(df_merge)<br>运行程序，控制台输出结果如图4.41所示。</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020050352118.png" alt="image-20211020050352118"></p><p>​                           图4.40　合并结果</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020050412167.png" alt="image-20211020050412167"></p><p>​                            图4.41　通过索引列合并</p><p>【示例38】　对合并数据去重。（示例位置：资源包\MR\Code\04\38）<br>从图4.41中的运行结果得知：数据中存在重复列（如编号），如果不想要重复列，可以设置按指定列和列索引合并数据，主要代码如下：</p><p>df_merge=pd.merge(df1,df2,on=’编号’,left_index=True,right_index=True)</p><p>还可以通过how参数解决这一问题。例如，设置该参数值为left，就是让df1保留所有的行列数据，df2则根据df1的行列进行补全，主要代码如下：</p><p>df_merge=pd.merge(df1,df2,on=’编号’,how=’left’)<br>运行程序，控制台输出结果如图4.42所示。</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020050506047.png" alt="image-20211020050506047"></p><p>图4.42　合并结果</p><h4 id="2．多对一的数据合并"><a href="#2．多对一的数据合并" class="headerlink" title="2．多对一的数据合并"></a>2．多对一的数据合并</h4><p>多对一是指两个数据集（df1、df2）的共有列中的数据不是一对一的关系，例如，df1中的“编号”是唯一的，而df2中的“编号”有重复的编号，类似这种就是多对一的关系，示意图如图4.43所示。【示例39】　根据共有列进行合并数据。（示例位置：资源包\MR\Code\04\39）<br>根据共有列中的数据进行合并，df2根据df1的行列进行补全，程序代码如下：</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020050528714.png" alt="image-20211020050528714"></p><p>运行程序，控制台输出结果如图4.44所示。</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020050545631.png" alt="image-20211020050545631"></p><p>​                                     图4.43　多对一合并示意图</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020050604101.png" alt="image-20211020050604101"></p><p>​                                  图4.44　合并结果</p><h4 id="3．多对多的数据合并"><a href="#3．多对多的数据合并" class="headerlink" title="3．多对多的数据合并"></a>3．多对多的数据合并</h4><p>多对多是指两个数据集（df1、df2）的共有列中的数据不全是一对一的关系，都有重复数据，例如“编号”，示图如图4.45所示。</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020050702131.png" alt="image-20211020050702131"></p><p>​                                    图4.45　多对多示意图</p><p>【示例40】　合并数据并相互补全。（示例位置：资源包\MR\Code\04\40）<br>根据共有列中的数据进行合并，df2、df1相互补全，程序代码如下：</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020050733884.png" alt="image-20211020050733884"></p><p>运行程序，控制台输出结果如图4.46所示。</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020050749641.png" alt="image-20211020050749641"></p><p>​                                               图4.46　合并结果</p><h3 id="4-6-2-数据合并（concat-方法）"><a href="#4-6-2-数据合并（concat-方法）" class="headerlink" title="4.6.2　数据合并（concat()方法）"></a>4.6.2　数据合并（concat()方法）</h3><p>concat()方法可以根据不同的方式将数据合并，语法如下：</p><p>pandas.concat(objs,axis=0,join=’outer’,ignore_index: bool = False, keys=None, levels=None, names=None,<br>verify_integrity: bool = False, sort: bool = False, copy: bool = True)<br>参数说明：　</p><p>objs：Series、DataFrame或Panel对象的序列或映射。如果传递一个字典，则排序的键将用作键参数。　</p><p>axis：axis=1表示行，axis=0表示列。默认值为0。　</p><p>join：值为inner（内连接）或outer（外连连接），处理其他轴上的索引方式。默认值为outer。　</p><p>ignore_index：布尔值，默认值为False，保留索引，索引值为0，…，n-1。如果值为True，则忽略索引。　</p><p>keys：序列，默认值为None。使用传递的键作为最外层构建层次索引。如果为多索引，应该使用元组。　</p><p>levels：序列列表，默认值为None。用于构建MultiIndex的特定级别（唯一值）；否则，它们将从键推断。　</p><p>names：list列表，默认值为None。结果层次索引中的级别的名称。　verify_integrity：布尔值，默认值为False。检查新连接的轴是否包含重复项。　</p><p>sort：布尔值，默认值为True（1.0.0以后版本默认值为False，即不排序）。如果连接为外连接（join=’outer’），则对未对齐的非连接轴进行排序；如果连接为内连接（join=’inner’），则该参数不起作用。</p><p>copy：是否复制数据，默认值为True，如果值为False，则不复制数据。</p><p>下面介绍concat()方法不同的合并方式，其中dfs代表合并后的DataFrame对象，df1、df2等代表单个DataFrame对象，result代表合并后的结果（DataFrame对象）。</p><h4 id="1．相同字段的表首尾相接"><a href="#1．相同字段的表首尾相接" class="headerlink" title="1．相同字段的表首尾相接"></a>1．相同字段的表首尾相接</h4><p>表结构相同的数据将直接合并，表首尾相接，主要代码如下：</p><p>01  dfs= [df1, df2, df3]<br>02  result = pd.concat(dfs)<br>例如，表df1、df2和df3结构相同，如图4.47所示。合并后的效果如图4.48所示。如果想要在合并数据时标记源数据来自哪张表，则需要在代码中加入参数keys，例如表名分别为“1月”“2月”“3月”，合并后的效果如图4.49所示。</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020051001176.png" alt="image-20211020051001176"></p><p>​                          图4.47　3张相同字段的表</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020051019220.png" alt="image-20211020051019220"></p><p>​                                     图4.48　首尾相接合并后的效果</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020051035379.png" alt="image-20211020051035379"></p><p>​                        图4.49　合并后带标记（月份）的效果<br>主要代码如下：</p><p>result = pd.concat(dfs, keys=[‘1月’, ‘2月’, ‘3月’])</p><h4 id="2．横向表合并（行对齐）"><a href="#2．横向表合并（行对齐）" class="headerlink" title="2．横向表合并（行对齐）"></a>2．横向表合并（行对齐）</h4><p>当合并的数据列名称不一致时，可以设置参数axis=1，concat()方法将按行对齐，然后将不同列名的两组数据进行合并，缺失的数据用NaN填充，df1和df4合并前后效果如图4.50和图4.51所示。</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020051057217.png" alt="image-20211020051057217"></p><p>​                        图4.50　横向表合并前</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020051113896.png" alt="image-20211020051113896"></p><p>​                            图4.51　横向表合并后<br>主要代码如下：</p><p>result = pd.concat([df1, df4], axis=1)</p><h4 id="3．交叉合并"><a href="#3．交叉合并" class="headerlink" title="3．交叉合并"></a>3．交叉合并</h4><p>交叉合并，需要在代码中加上join参数，如果值为inner，结果是两张表的交集；如果值为outer，结果是两张表的并集。例如两张表交集，表df1和df4合并前后的效果如图4.52和图4.53所示。</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020051227829.png" alt="image-20211020051227829"></p><p>​                                   图4.52　交叉合并前</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020051243654.png" alt="image-20211020051243654"></p><p>​                                       图4.53　交叉合并后<br>主要代码如下：</p><p>result = pd.concat([df1, df4], axis=1, join=’inner’)</p><h4 id="4．指定表对齐数据（行对齐）"><a href="#4．指定表对齐数据（行对齐）" class="headerlink" title="4．指定表对齐数据（行对齐）"></a>4．指定表对齐数据（行对齐）</h4><p>如果指定参数join_axes，就可以指定根据哪张表来对齐数据。例如，根据df4对齐数据，就会保留表df4的数据，然后将表df1的数据与之合并，行数不变，合并前后的效果与如图4.54和图4.55所示。</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020051305083.png" alt="image-20211020051305083"></p><p>​                          图4.54　指定表对齐数据合并前</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020051320918.png" alt="image-20211020051320918"></p><p>​                           图4.55　指定表对齐数据合并后<br>主要代码如下：</p><p>result = pd.concat([df1, df4], axis=1, join_axes=[df4.index])</p><h2 id="4-7-数据导出"><a href="#4-7-数据导出" class="headerlink" title="4.7　数据导出"></a>4.7　数据导出</h2><h3 id="4-7-1-导出为-xlsx文件"><a href="#4-7-1-导出为-xlsx文件" class="headerlink" title="4.7.1　导出为.xlsx文件"></a>4.7.1　导出为.xlsx文件</h3><p>导出数据为Excel，主要使用DataFrame对象的to_excel()方法，语法如下：</p><p>DataFrame.to_excel(excel_writer,sheet_name=’Sheet1’,na_rep=’’,float_format=None,columns=None,header=True,<br>index=True,index_label=None,startrow=0,startcol=0,engine=None,merge_cells=True, encoding=None, inf_rep=’inf’,<br>verbose=True, freeze_panes=None)<br>参数说明：　</p><p>excel_writer：字符串或ExcelWriter对象。　</p><p>sheet_name：字符串，默认值为Sheet1，包含DataFrame的表的名称。　</p><p>na_rep：字符串，默认值为’ ‘。缺失数据的表示方式。　</p><p>float_format：字符串，默认值为None，格式化浮点数的字符串。　columns：序列，可选参数，要编辑的列。　</p><p>header：布尔型或字符串列表，默认值为True。列名称，如果给定字符串列表，则表示它是列名称的别名。　</p><p>index：布尔型，默认值为True，行名（索引）。　</p><p>index_label：字符串或序列，默认值为None。如果需要，可以使用索引列的列标签；如果没有给出，标题和索引为True，则使用索引名称；如果数据文件使用多索引，则需使用序列。</p><p>startrow：指定从哪一行开始写入数据。　</p><p>startcol：指定从哪一列开始写入数据。　</p><p>engine：字符串，默认值为None，指定要使用的写引擎，如openpyxl或xlsxwriter。也可以通过io.excel.xlsx.writer、io.excel.xls.writer和io.excel.xlsm.writer进行设置。　</p><p>merge_cells：布尔型，默认值为True。　</p><p>encoding：指定Excel文件的编码方式，默认值为None。　</p><p>inf_rep：字符串，默认值为“正”，表示无穷大。　</p><p>verbose：布尔型，默认值为True。在错误日志中显示更多信息。　freeze_panes：整数的元组，长度2，默认值为None。指定要冻结的行列。</p><p>【示例41】　将处理后的数据导出为Excel文件。（示例位置：资源包\MR\Code\04\41）<br>将数据合并后的结果导出为Excel文件，主要代码如下：</p><p>df_merge.to_excel(‘merge.xlsx’)<br>运行程序，数据将导出为Excel文件，如图4.56所示。</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020051510137.png" alt="image-20211020051510137"></p><p>​                         图4.56　导出为Excel文件</p><p>上述举例，如果需要指定Sheet页名称，可以通过sheet_name参数指定，主要代码如下：</p><p>df1.to_excel(‘df1.xlsx’,sheet_name=’df1’)</p><h3 id="4-7-2-导出为-csv文件"><a href="#4-7-2-导出为-csv文件" class="headerlink" title="4.7.2　导出为.csv文件"></a>4.7.2　导出为.csv文件</h3><p>导出数据为.csv文件，主要使用DataFrame对象的to_csv()方法，语法如下：</p><p>DataFrame.to_csv(path_or_buf=None,sep=’,’,na_rep=’’,float_format=None,columns=None,header=True,index=<br>True,index_label=None,mode=’w’,encoding=None,compression=’infer’,quoting=None,quotechar=’”‘,line_terminator=<br>None,chunksize=None,date_format=None,doublequote=True, escapechar=None, decimal=’.’,errors=’strict’)<br>参数说明：　</p><p>path_or_buf：要保存的路径及文件名。　</p><p>sep：分隔符，默认值为”,”。　</p><p>na_rep：指定空值的输出方式，默认值为空字符串。　</p><p>float_format：浮点数的输出格式，要用双引号括起来。　</p><p>columns：指定要导出的列，用列名列表表示，默认值为None。　</p><p>header：是否输出列名，默认值为True。　</p><p>index：是否输出索引，默认值为True。　</p><p>index_label：索引列的列名，默认值为None。　</p><p>mode：Python写入模式，默认值为w。　</p><p>encoding：编码方式，默认值为utf-8。　</p><p>compression：压缩模式，默认值为infer。　</p><p>quoting：导出.csv文件是否用引号，默认值为0，表示不加双引号；如果值为1，则每个字段都会加上引号，数值也会被当作字符串看待。</p><p>quotechar：引用字符，当quoting=1时可以指定引号字符为双引号（” “）或单引号（’ ‘）。　</p><p>line_terminator：换行符，默认值为\n。</p><p>chunksize：一次写入.csv文件的行数，当DataFrame对象数据特别大时需要分批写入。　</p><p>date_format：日期输出格式。　</p><p>doublequote：是否添加双引用符，默认值为True。　</p><p>escapechar：设置转义字符。　</p><p>decimal：可识别十进制分隔符的字符。　</p><p>errors：指定如何处理编码和解码错误，默认值为strict（严格的）。</p><p>【示例42】　将处理后的数据导出为.csv文件。（示例位置：资源包\MR\Code\04\42）<br>下面介绍to_csv()方法常用功能，举例如下，df为DataFrame对象。<br>（1）相对位置，保存在程序所在路径下，代码如下：</p><p>df.to_csv(‘Result.csv’)<br>（2）绝对位置，代码如下：</p><p>df.to_csv(‘d:\Result.csv’)<br>（3）分隔符。使用问号（？）分隔符分隔需要保存的数据，代码如下：</p><p>df.to_csv(‘Result.csv’,sep=’?’)<br>（4）替换空值，缺失值保存为NA，代码如下：</p><p>df.to_csv(‘Result1.csv’,na_rep=’NA’)<br>（5）格式化数据，保留两位小数，代码如下：</p><p>df.to_csv(‘Result1.csv’,float_format=’%.2f’)<br>（6）保留某列数据，保存索引列和name列，代码如下：</p><p>df.to_csv(‘Result.csv’,columns=[‘name’])<br>（7）是否保留列名，不保留列名，代码如下：</p><p>df.to_csv(‘Result.csv’,header=False)<br>（8）是否保留行索引，不保留行索引，代码如下：</p><p>df.to_csv(‘Result.csv’,index=False)</p><h3 id="4-7-3-导出多个Sheet"><a href="#4-7-3-导出多个Sheet" class="headerlink" title="4.7.3　导出多个Sheet"></a>4.7.3　导出多个Sheet</h3><p>导出多个Sheet，应首先使用pd.ExcelWriter()方法打开一个Excel文件，然后再使用to_excel()方法导出指定的Sheet。</p><p>【示例43】　导出Excel中多个Sheet页的数据。（示例位置：资源包\MR\Code\04\43）<br>导出指定Sheet页中的数据，主要代码如下：</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020051720411.png" alt="image-20211020051720411"></p><h2 id="4-8-日期数据处理"><a href="#4-8-日期数据处理" class="headerlink" title="4.8　日期数据处理"></a>4.8　日期数据处理</h2><h3 id="4-8-1-DataFrame的日期数据转换"><a href="#4-8-1-DataFrame的日期数据转换" class="headerlink" title="4.8.1　DataFrame的日期数据转换"></a>4.8.1　DataFrame的日期数据转换</h3><p>日常工作中，有一个非常麻烦的事情就是日期的格式可以有很多种表达，我们看到同样是2020年2月14日，可以有很多种格式，如图4.57所示。那么，我们需要先将这些格式统一后才能进行后续的工作。Pandas提供了to_datetime()方法可以帮助我们解决这一问题。<br>to_datetime()方法可以用来批量处理日期数据转换，对于处理大数据非常实用和方便，它可以将日期数据转换成你需要的各种格式。例如，将2/14/20和14-2-2020转换为日期格式2020-02-14。to_datetime()方法的语法如下：</p><p>pandas.to_datetime(arg,errors=’ignore’,dayfirst=False,yearfirst=False,utc=None,box=True,format=None,exact=<br>True,unit=None,infer_datetime_format=False,origin=’unix’,cache=False)<br>参数说明：　</p><p>arg：字符串、日期时间、字符串数组。　</p><p>errors：值为ignore、raise或coerce，具体说明如下，默认值为ignore，即忽略错误。　</p><p>ignore：无效的解析将返回原值。　</p><p>raise：无效的解析将引发异常。　</p><p>coerce：无效的解析将被设置为NaT，即无法转换为日期的数据将被转换为NaT。　</p><p>dayfirst：第一个为天，布尔型，默认值为False。例如02/09/2020，如果值为True，则解析日期的第一个为天，即2020-09-02；如果值为False，则解析日期与原日期一致，即2020-02-09。　</p><p>yearfirst：第一个为年，布尔型，默认值为False。例如14-Feb-20，如果值为True，则解析日期的第一个为年，即2014-02-20；如果值为False，则解析日期与原日期一致，即2020-02-14。　</p><p>utc：默认值为None。返回utc即协调世界时间。　</p><p>box：布尔值，默认值为True，如果值为True，则返回DatetimeIndex；如果值为False，则返回ndarray。　</p><p>format：格式化显示时间的格式。字符串，默认值为None。　</p><p>exact：布尔值，默认值为True。如果为True，则要求格式完全匹配；如果为False，则允许格式与目标字符串中的任何位置匹配。　</p><p>unit：默认值为None，参数的单位（D、s、、ms、μs、ns）表示时间的单位。　</p><p>infer_datetime_format：默认值为False。如果没有格式，则尝试根据第一个日期时间字符串推断格式。　</p><p>origin：默认值为unix。定义参考日期。数值将被解析为单位数。　</p><p>cache：默认值为False。如果值为True，则使用唯一、转换日期的缓存应用日期时间转换。在解析重复日期字符串，特别是带有时区偏移的字符串时，可能会产生明显的加速。只有在至少有50个值时才使用缓存。越界值的存在将使缓存不可用，并可能减慢解析速度。　</p><p>返回值：日期时间。</p><p>【示例44】　将各种日期字符串转换为指定的日期格式。（示例位置：资源包\MR\Code\04\44）<br>将2020年2月14日的各种格式转换为日期格式，程序代码如下：</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020051913944.png" alt="image-20211020051913944"></p><p>运行程序，控制台输出结果如图4.58所示。</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020051928130.png" alt="image-20211020051928130"></p><p>​                   图4.57　日期的多种格式转换</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020051944812.png" alt="image-20211020051944812"></p><p>​                 图4.58　2020年2月14日的各种格式转换为日期格式<br>还可以实现从DataFrame对象中的多列，如年、月、日各列组合成一列日期。键值是常用的日期缩略语。</p><p>组合要求：　</p><p>必选：year、month、day。　</p><p>可选：hour、minute、second、millisecond（毫秒）、microsecond（微秒）、nanosecond（纳秒）。</p><p>【示例45】　将一组数据组合为日期数据。（示例位置：资源包\MR\Code\04\45）<br>将一组数据组合为日期数据，主要代码如下：<br>运行程序，控制台输出结果如图4.59所示。</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020052022697.png" alt="image-20211020052022697"></p><p>​                                        图4.59　日期组合</p><h3 id="4-8-2-dt对象的使用"><a href="#4-8-2-dt对象的使用" class="headerlink" title="4.8.2　dt对象的使用"></a>4.8.2　dt对象的使用</h3><p>dt对象是Series对象中用于获取日期属性的一个访问器对象，通过它可以获取日期中的年、月、日、星期数、季节等，还可以判断日期是否处在年底。语法如下：</p><p>  Series.dt()<br>参数说明：　</p><p>返回值：返回与原始系列相同的索引系列。如果Series不包含类日期值，则引发错误。　</p><p>dt对象提供了year、month、day、dayofweek、dayofyear、is_leap_year、quarter、weekday_name等属性和方法。</p><p>例如，year可以获取“年”、month可以获取“月”、quarter可以直接得到每个日期分别是第几个季度，weekday_name可以直接得到每个日期对应的是周几。</p><p>【示例46】　获取日期中的年、月、日、星期数等。（示例位置：资源包\MR\Code\04\46）<br>使用dt对象获取日期中的年、月、日、星期数、季节等。<br>（1）获取年、月、日，代码如下：</p><p>df[‘年’],df[‘月’],df[‘日’]=df[‘日期’].dt.year,df[‘日期’].dt.month,df[‘日期’].dt.day<br>（2）从日期判断出所处星期数，代码如下：</p><p>df[‘星期几’]=df[‘日期’].dt.day_name()<br>（3）从日期判断所处季度，代码如下：</p><p>df[‘季度’]=df[‘日期’].dt.quarter<br>（4）从日期判断是否为年底最后一天，代码如下：</p><p>df[‘是否年底’]=df[‘日期’].dt.is_year_end<br>运行程序，控制台输出结果如图4.60所示。</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020052128703.png" alt="image-20211020052128703"></p><p>​                               图4.60　dt对象日期转换</p><h3 id="4-8-3-获取日期区间的数据"><a href="#4-8-3-获取日期区间的数据" class="headerlink" title="4.8.3　获取日期区间的数据"></a>4.8.3　获取日期区间的数据</h3><p>获取日期区间的数据的方法是直接在DataFrame对象中输入日期或日期区间，但前提必须设置日期为索引，举例如下。　</p><p>获取2018年的数据。</p><p>df1[‘2018’]　</p><p>获取2017—2018年的数据。</p><p>df1[‘2017’:’2018’]　</p><p>获取某月（2018年7月）的数据。</p><p>df1[‘2018-07’]　</p><p>获取具体某天（2018年5月6日）的数据。</p><p>df1[‘2018-05-06’:’2018-05-06’]</p><p>【示例47】　获取指定日期区间的订单数据。（示例位置：资源包\MR\Code\04\47）<br>获取2018年5月11日至6月10日的订单，结果如图4.61所示。<br>程序代码如下：</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020052236563.png" alt="image-20211020052236563"></p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020052256160.png" alt="image-20211020052256160"></p><p>​            图4.61　2018年5月11日至6月10日的订单（省略部分数据）</p><h3 id="4-8-4-按不同时期统计并显示数据"><a href="#4-8-4-按不同时期统计并显示数据" class="headerlink" title="4.8.4　按不同时期统计并显示数据"></a>4.8.4　按不同时期统计并显示数据</h3><h4 id="1．按时期统计数据"><a href="#1．按时期统计数据" class="headerlink" title="1．按时期统计数据"></a>1．按时期统计数据</h4><p>按时期统计数据主要通过DataFrame对象的resample()方法结合数据计算函数实现。resample()方法主要应用于时间序列频率转换和重采样，它可以从日期中获取年、月、日、星期、季节等，结合数据计算函数就可以实现按年、月、日、星期或季度等不同时期统计数据。举例如下所示。<br>（1）按年统计数据，代码如下：</p><p>df1=df1.resample(‘AS’).sum()<br>（2）按季度统计数据，代码如下：</p><p>df2.resample(‘Q’).sum()<br>（3）按月度统计数据，代码如下：</p><p>df1.resample(‘M’).sum()<br>（4）按星期统计数据，代码如下：</p><p>df1.resample(‘W’).sum()<br>（5）按天统计数据，代码如下：</p><p>df1.resample(‘D’).sum()</p><p>实用技巧<br>按日期统计数据过程中，可能会出现如图4.62所示的错误提示。</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020052356675.png" alt="image-20211020052356675"></p><p>图4.62　错误提示</p><p>完整错误描述：<br>TypeError: Only valid with DatetimeIndex, TimedeltaIndex or PeriodIndex, but got an instance of’Index’<br>出现上述错误，是由于resample()函数要求索引必须为日期型。<br>解决方法：将数据的索引转换为datetime类型，主要代码如下：</p><p>df1.index = pd.to_datetime(df1.index)</p><h4 id="2．按时期显示数据"><a href="#2．按时期显示数据" class="headerlink" title="2．按时期显示数据"></a>2．按时期显示数据</h4><p>DataFrame对象的to_period()方法可以将时间戳转换为时期，从而实现按时期显示数据，前提是日期必须设置为索引。语法如下：</p><p>DataFrame.to_period(freq=None, axis=0, copy=True)<br>参数说明：　</p><p>freq：字符串，周期索引的频率，默认值为None。　</p><p>axis：行列索引，axis=0表示行索引，axis=1表示列索引。默认值为0，即表示行索引。　</p><p>copy：是否复制数据，默认值为True，如果值为False，则不复制数据。　返回值：带周期索引的时间序列。</p><p>【示例48】　从日期中获取不同的时期。（示例位置：资源包\MR\Code\04\48）<br>从日期中获取不同的时期，主要代码如下：</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020052452293.png" alt="image-20211020052452293"></p><h4 id="3．按时期统计并显示数据"><a href="#3．按时期统计并显示数据" class="headerlink" title="3．按时期统计并显示数据"></a>3．按时期统计并显示数据</h4><p>（1）按年统计并显示数据，代码如下：</p><p>df2.resample(‘AS’).sum().to_period(‘A’)<br>控制台输出结果如图4.63所示。<br>（2）按季度统计并显示数据，代码如下：</p><p>Q_df=df2.resample(‘Q’).sum().to_period(‘Q’)</p><p>控制台输出结果如图4.64所示。</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020052536700.png" alt="image-20211020052536700"></p><p>​                            图4.63　按年统计并显示数据</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020052550813.png" alt="image-20211020052550813"></p><p>​                      图4.64　按季度统计并显示数据<br>（3）按月统计并显示数据，代码如下：</p><p>df2.resample(‘M’).sum().to_period(‘M’)<br>控制台输出结果如图4.65所示。<br>（4）按星期统计并显示数据（前5条数据），代码如下：</p><p>df2.resample(‘W’).sum().to_period(‘W’).head()<br>控制台输出结果如图4.66所示。</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020052622774.png" alt="image-20211020052622774"></p><p>​                          图4.65　按月统计并显示数据</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020052640893.png" alt="image-20211020052640893"></p><p>​                      图4.66　按星期统计并显示数据</p><h2 id="4-9-时间序列"><a href="#4-9-时间序列" class="headerlink" title="4.9　时间序列"></a>4.9　时间序列</h2><h3 id="4-9-1-重采样（Resample-方法）"><a href="#4-9-1-重采样（Resample-方法）" class="headerlink" title="4.9.1　重采样（Resample()方法）"></a>4.9.1　重采样（Resample()方法）</h3><p>通过前面的学习，我们学会了如何生成不同频率的时间索引，按小时、按天、按周、按月等，如果想对数据做不同频率的转换，该怎么办？在Pandas中对时间序列的频率的调整称为重新采样，即将时间序列从一个频率转换到另一个频率的处理过程。例如，每天一个频率转换为每5天一个频率，如图4.67所示。</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020052720517.png" alt="image-20211020052720517"></p><p>​                                       图4.67　时间频率<br>重采样主要使用resample()方法，该方法用于对常规时间序列重新采样和频率转换，包括降采样和升采样两种。首先了解下resample()方法，语法如下：</p><p>DataFrame.resample(rule,how=None,axis=0,fill_method=None,closed=None,label=None,convention=’start’,kind=<br>None,loffset=None,limit=None,base=0,on=None,level=None)<br>参数说明：　</p><p>rule：字符串，偏移量表示目标字符串或对象转换。　</p><p>how：用于产生聚合值的函数名或数组函数。例如mean、ohlc和np.max等，默认值为mean，其他常用的值为first、last、median、max和min。　</p><p>axis：整型，表示行列，axis=0表示列，axis=1表示行。默认值为0，即表示列。　fill_method：升采样时所使用的填充方法，ffill()方法（用前值填充）或bfill()方法（用后值填充），默认值为None。　</p><p>closed：降采样时，时间区间的开和闭，与数学里区间的概念一样，其值为right或left，right表示左开右闭（即左边值不包括在内），left表示左闭右开（即右边值不包括在内），默认值为right左开右闭。　</p><p>label：降采样时，如何设置聚合值的标签。例如，10:30—10:35会被标记成10:30还是10:35，默认值为None。　</p><p>convention：当重采样时，将低频率转换到高频率所采用的约定，其值为start或end，默认值为start。　</p><p>kind：聚合到时期（period）或时间戳（timestamp），默认聚合到时间序列的索引类型，默认值为None。　</p><p>loffset：聚合标签的时间校正值，默认值为None。例如，-1s或Second(-1)用于将聚合标签调早1秒。　</p><p>limit：向前或向后填充时，允许填充的最大时期数，默认值为None。</p><p>　base：整型，默认值为0。对于均匀细分1天的频率，聚合间隔的“原点”。例如，对于5min频率，base的范围可以是0～4。　on：字符串，可选参数，默认值为None。对DataFrame对象使用列代替索引进行重新采样。列必须与日期时间类似。　</p><p>level：字符串或整型，可选参数，默认值为None。用于多索引，重新采样的级别名称或级别编号，级别必须与日期时间类似。　</p><p>返回值：重新采样对象。</p><p>【示例49】　一分钟的时间序列转换为3分钟的时间序列。（示例位置：资源包\MR\Code\04\49）<br>首先创建一个包含9个一分钟的时间序列，然后使用resample()方法转换为3分钟的时间序列，并对索引列进行求和计算，如图4.68所示。</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020052840027.png" alt="image-20211020052840027"></p><p>​                          图4.68　时间序列转换<br>程序代码如下：</p><p>01  import pandas as pd<br>02  index = pd.date_range(‘02/02/2020’, periods=9, freq=’T’)</p><p>03  series = pd.Series(range(9), index=index)<br>04  print(series)<br>05  print(series.resample(‘3T’).sum())</p><h3 id="4-9-2-降采样处理"><a href="#4-9-2-降采样处理" class="headerlink" title="4.9.2　降采样处理"></a>4.9.2　降采样处理</h3><p>降采样是周期由高频率转向低频率。例如，将5min股票交易数据转换为日交易，按天统计的销售数据转换为按周统计。<br>数据降采样会涉及数据的聚合。例如，天数据变成周数据，那么就要对1周7天的数据进行聚合，聚合的方式主要包括求和、求均值等。例如，淘宝店铺每天销售数据（部分数据），如图4.69所示。</p><p>【示例50】　按周统计销售数据。（示例位置：资源包\MR\Code\04\50）<br>使用resample()方法来做降采样处理，频率为“周”，也就是将上述销售数据处理为每周（每7天）求和一次数据，程序代码如下：</p><p>01 import pandas as pd<br>02 df=pd.read_excel(‘time.xls’)<br>03 df1 = df.set_index(‘订单付款时间’)  #设置“订单付款时间”为索引<br>04 print(df1.resample(‘W’).sum().head())<br>运行程序，控制台输出结果如图4.70所示。<br>在参数说明中，我们列出了closed参数的解释，如果把closed参数值设置为left，结果如图4.71所示。</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020052938423.png" alt="image-20211020052938423"></p><p>​              图4.69　淘宝店铺每天销售数据（部分数据）</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020053019859.png" alt="image-20211020053019859"></p><p>​                                       图4.70　周数据统计1</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020053036196.png" alt="image-20211020053036196"></p><p>​                              图4.71　周数据统计2</p><h3 id="4-9-3-升采样处理"><a href="#4-9-3-升采样处理" class="headerlink" title="4.9.3　升采样处理"></a>4.9.3　升采样处理</h3><p>升采样是周期由低频率转向高频率。将数据从低频率转换到高频率时，就不需要聚合了，将其重采样到日频率，默认会引入缺失值。<br>例如，原来是按周统计的数据，现在变成按天统计。升采样会涉及数据的填充，根据填充的方法不同，填充的数据也不同。下面介绍3种填充方法。　不填充。空值用NaN代替，使用asfreq()方法。　用前值填充。用前面的值填充空值，使用ffill()方法或者pad()方法。为了方便记忆，ffill()方法可以使用它的第一个字母“f”代替，代表forward，向前的意思。　用后值填充，使用bfill()方法，可以使用字母“b”代替，代表back，向后的意思。</p><p>【示例51】　每6小时统计一次数据。（示例位置：资源包\MR\Code\04\51）<br>下面创建一个时间序列，起始日期是2020-02-02，一共两天，每天对应的数值分别是1和2，通过升采样处理为每6小时统计一次数据，空值以不同的方式填充，程序代码如下：</p><p>01  import pandas as pd<br>02  import numpy as np<br>03  rng = pd.date_range(‘20200202’, periods=2)<br>04  s1 = pd.Series(np.arange(1,3), index=rng)</p><p>05  s1_6h_asfreq = s1.resample(‘6H’).asfreq()</p><p>06  print(s1_6h_asfreq)</p><p>07  s1_6h_pad = s1.resample(‘6H’).pad()<br>08  print(s1_6h_pad)</p><p>09  s1_6h_ffill = s1.resample(‘6H’).ffill()<br>10  print(s1_6h_ffill)</p><p>11  s1_6h_bfill = s1.resample(‘6H’).bfill()<br>12  print(s1_6h_bfill)<br>运行程序，控制台输出结果如图4.72所示。</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020053124798.png" alt="image-20211020053124798"></p><p>​                          图4.72　6小时数据统计</p><h3 id="4-9-4-时间序列数据汇总（ohlc-函数）"><a href="#4-9-4-时间序列数据汇总（ohlc-函数）" class="headerlink" title="4.9.4　时间序列数据汇总（ohlc()函数）"></a>4.9.4　时间序列数据汇总（ohlc()函数）</h3><p>在金融领域，经常会看到开盘（open）、收盘（close）、最高价（high）和最低价（low）数据，而在Pandas中经过重新采样的数据也可以实现这样的结果，通过调用ohlc()函数得到数据汇总结果，即开始值（open）、结束值（close）、最高值（high）和最低值（low）。ohlc()函数的语法如下：</p><p>resample.ohlc()<br>ohlc()函数返回DataFrame对象，每组数据的open（开）、high（高）、low（低）和close（关）值。</p><p>【示例52】　统计数据的open、high、low和close值。（示例位置：资源包\MR\Code\04\52）<br>下面是一组5分钟的时间序列，通过ohlc()函数获取该时间序列中每组时间的开始值、最高值、最低值和结束值，程序代码如下：</p><p>01  import pandas as pd<br>02  import numpy as np<br>03  rng = pd.date_range(‘2/2/2020’,periods=12,freq=’T’)<br>04  s1 = pd.Series(np.arange(12),index=rng)<br>05  print(s1.resample(‘5min’).ohlc())<br>运行程序，控制台输出结果如图4.73所示。</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020053212045.png" alt="image-20211020053212045"></p><p>​                          图4.73　时间序列数据汇总</p><h3 id="4-9-5-移动窗口数据计算（rolling-函数）"><a href="#4-9-5-移动窗口数据计算（rolling-函数）" class="headerlink" title="4.9.5　移动窗口数据计算（rolling()函数）"></a>4.9.5　移动窗口数据计算（rolling()函数）</h3><p>通过重采样可以得到想要的任何频率的数据，但是这些数据也是一个时点的数据，那么就存在这样一个问题：时点的数据波动较大，某一点的数据就不能很好地表现它本身的特性，于是就有了“移动窗口”的概念，简单地说，为了提升数据的可靠性，将某个点的取值扩大到包含这个点的一段区间，用区间来进行判断，这个区间就是窗口。<br>下面举例说明，图4.74显示了移动窗口数据示意图，其中时间序列代表1号到15号每天的销量数据，接下来以3天为一个窗口，将该窗口从左至右依次移动，统计出3天的平均值作为这个点的值，如3号的销量是1号、2号和3号的平均值。</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020053234231.png" alt="image-20211020053234231"></p><p>​                      图4.74　移动窗口数据示意图<br>通过上述示意图相信您已经理解了移动窗口，在Pandas中可以通过rolling()函数实现移动窗口数据的计算，语法如下：</p><p>DataFrame.rolling(window, min_periods=None, center=False, win_type=None, on=None, axis=0, closed=None)</p><p>参数说明：　</p><p>window：时间窗口的大小，有两种形式，即int或offset。如果使用int，则数值表示计算统计量的观测值的数量，即向前几个数据；如果使用offset，则表示时间窗口的大小。　</p><p>min_periods：每个窗口最少包含的观测值数量，小于这个值的窗口结果为NA。值可以是int，默认值为None。offset情况下，默认值为1。</p><p>center：把窗口的标签设置为居中。布尔型，默认值为False，居右。</p><p>win_type：窗口的类型。截取窗的各种函数。字符串类型，默认值为None。　</p><p>on：可选参数。对于DataFrame对象，是指定要计算移动窗口的列，值为列名。　</p><p>axis：整型，axis=0表示列，axis=1表示行。默认值为0，即对列进行计算。　</p><p>closed：定义区间的开闭，支持int类型的窗口。对于offset类型默认是左开右闭（默认值为right）。可以根据情况指定left。　</p><p>返回值：为特定操作而生成的窗口或移动窗口子类。</p><p>【示例53】　创建淘宝每日销量数据。（示例位置：资源包\MR\Code\04\53）<br>首先创建一组淘宝每日销量数据，程序代码如下：</p><p>01  import pandas as pd<br>02  index=pd.date_range(‘20200201’,’20200215’)<br>03  data=[3,6,7,4,2,1,3,8,9,10,12,15,13,22,14]<br>04  s1_data=pd.Series(data,index=index)<br>05  print(s1_data)<br>运行程序，控制台输出结果如图4.75所示。</p><p>【示例54】　使用rolling()函数计算3天的均值。（示例位置：资源包\MR\Code\04\54）</p><p>下面使用rolling()函数计算2020-02-01至2020-02-15中每3天的均值，窗口个数为3，代码如下：</p><p>s1_data.rolling(3).mean()<br>运行程序，看下rolling()函数是如何计算的？在图4.76中，当窗口开始移动时，第一个时间点2020-02-01和第二个时间点2020-02-02的数值为空，这是因为窗口个数为3，它们前面有空数据，所以均值为空；而到第三个时间点2020-02-03时，它前面的数据是2020-02-01至2020-02-03，所以3天的均值是5.333333；以此类推。</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020053403924.png" alt="image-20211020053403924"></p><p>​                                     图4.75　原始数据</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020053419587.png" alt="image-20211020053419587"></p><p>​                       图4.76　2020-02-01至2020-02-15移动窗口均值1</p><p>【示例55】　用当天的数据代表窗口数据。（示例位置：资源包\MR\Code\04\55）<br>在计算第一个时间点2020-02-01的窗口数据时，虽然数据不够窗口长度3，但是至少有当天的数据，那么能否用当天的数据代表窗口数据呢？答案是肯定的，通过设置min_periods参数即可，它表示窗口最少包含的观测值，小于这个值的窗口长度显示为空，等于或大于时都有值，主要代码如下：</p><p>s1_data.rolling(3,min_periods=1).mean()</p><p>运行程序，对比效果如图4.77所示。<br>上述举例，我们再扩展下，通过图表观察原始数据与移动窗口数据的平稳性，如图4.78所示。其中实线代表移动窗口数据，其走向更平稳，这也是学习移动窗口rolling()函数的原因。</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020053518298.png" alt="image-20211020053518298"></p><p>​                 图4.77　2020-02-01至2020-02-15移动窗口均值2</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020053531782.png" alt="image-20211020053531782"></p><p>​                     图4.78　移动窗口数据的平稳性说明<br>虚线代表原始数据，实线代表移动窗口数据。</p><h2 id="4-10-综合应用"><a href="#4-10-综合应用" class="headerlink" title="4.10　综合应用"></a>4.10　综合应用</h2><h3 id="4-10-1-案例1：Excel多表合并"><a href="#4-10-1-案例1：Excel多表合并" class="headerlink" title="4.10.1　案例1：Excel多表合并"></a>4.10.1　案例1：Excel多表合并</h3><p>案例位置：资源包\MR\Code\04\example\01<br>在日常工作中，几乎我们每天都有大量的数据需要处理，桌面上总是布满密密麻麻的Excel表，这样看上去非常凌乱，其实我们完全可以将其中类别相同的Excel表合并到一起，这样不但不会丢失数据，而且还可以有效地分析数据。下面使用concat()方法将指定文件夹内的所有Excel表合并，程序代码如下：</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020053607260.png" alt="image-20211020053607260"></p><h3 id="4-10-2-案例2：股票行情数据分析"><a href="#4-10-2-案例2：股票行情数据分析" class="headerlink" title="4.10.2　案例2：股票行情数据分析"></a>4.10.2　案例2：股票行情数据分析</h3><p>案例位置：资源包\MR\Code\04\example\02<br>股票数据包括开盘价、收盘价、最高价、最低价、成交量等多个指标。其中，收盘价是当日行情的标准，也是下一个交易日开盘价的依据，可以预测未来证券市场行情，因此当投资者对行情分析时，一般采用收盘价作为计算依据。<br>下面使用rolling()函数计算某股票20天、50天和200天的收盘价均值并生成走势图（也称K线图），如图4.79所示。</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020053723586.png" alt="image-20211020053723586"></p><p>​                                       图4.79　股票行情分析</p><p>程序代码如下：</p><p><img src="/2020/02/19/Pandas%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/image-20211020053800663.png" alt="image-20211020053800663"></p><p>实用技巧<br>默认情况下，图表嵌入控制台（IPython console）中并以静态方式显示，无法进行移动、放大、缩小等操作。此时需要在工具中的首选项窗口进行设置，方法为选择Tools→Preferences命令，打开Preferences（首选项）窗口，在左侧列表中选择IPython console（IPython控制台），在右侧窗口选择Graphics（图形）选项卡，然后在Backend（后端）下拉列表框中选择Automatic（自动）或者Qt5，单击Apply（应用）按钮。设置完成后重新启动Spyder才生效。</p><h2 id="4-11-小结"><a href="#4-11-小结" class="headerlink" title="4.11　小结"></a>4.11　小结</h2><p>本章是Pandas的进阶学习，有一定难度，但同时也更能够体现Pandas的强大之处，不仅可以完成数据处理工作，而且还能够实现数据的统计分析。Pandas提供的大量函数使统计分析工作变得简单高效。别具特色的“数据位移”是一个非常有用的方法，与其他方法结合，能够实现很多难以想象的功能，数据转换将DataFrame与Python数据类型之间进行灵活转换。不仅如此，对于日期数据的处理、时间序列也都提供了专门的函数和方法，使得量化数据得心应手。</p>]]></content>
    
    
    <categories>
      
      <category>数据分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>介绍babel原理</title>
    <link href="/2019/04/10/%E4%BB%8B%E7%BB%8Dbabel%E5%8E%9F%E7%90%86/"/>
    <url>/2019/04/10/%E4%BB%8B%E7%BB%8Dbabel%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h4 id="介绍一下-webpack-scope-hosting"><a href="#介绍一下-webpack-scope-hosting" class="headerlink" title="介绍一下 webpack scope hosting"></a>介绍一下 webpack scope hosting</h4><p> 作用域提升，将分散的模块划分到同一个作用域中，避免了代码的重复引入，有效减少打包后的代码体积和运行时的内存损耗； </p><br><h4 id="介绍一下-babel原理"><a href="#介绍一下-babel原理" class="headerlink" title="介绍一下 babel原理"></a>介绍一下 babel原理</h4><blockquote><p><code>babel</code> 的编译过程分为三个阶段：<strong>parsing</strong>、<strong>transforming</strong>、<strong>generating</strong>，以 ES6 编译为 ES5 作为例子： </p></blockquote><ol><li><code>ES6</code> 代码输入；</li><li><code>babylon</code> 进行解析得到 AST；</li><li><code>plugin</code> 用 <code>babel-traverse</code> 对 <code>AST</code>树进行遍历编译，得到新的 <code>AST</code>树；</li><li>用 <code>babel-generator</code> 通过 <code>AST</code>树生成 <code>ES5</code> 代码。</li></ol>]]></content>
    
    
    <categories>
      
      <category>webpack</category>
      
    </categories>
    
    
    <tags>
      
      <tag>babel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>介绍Rollup</title>
    <link href="/2019/04/10/%E4%BB%8B%E7%BB%8DRollup/"/>
    <url>/2019/04/10/%E4%BB%8B%E7%BB%8DRollup/</url>
    
    <content type="html"><![CDATA[<h4 id="介绍一下Rollup"><a href="#介绍一下Rollup" class="headerlink" title="介绍一下Rollup"></a>介绍一下Rollup</h4><p>Rollup 是一款 ES Modules 打包器。它也可以将项目中散落的细小模块打包为整块代码，从而使得这些划分的模块可以更好地运行在浏览器环境或者 Node.js 环境。</p><blockquote><p>Rollup 是一款 ES Modules 打包器。它也可以将项目中散落的细小模块打包为整块代码，从而使得这些划分的模块可以更好地运行在浏览器环境或者 Node.js 环境。 </p></blockquote><h5 id="Rollup优势："><a href="#Rollup优势：" class="headerlink" title="Rollup优势："></a><strong>Rollup优势：</strong></h5><ul><li>输出结果更加扁平，执行效率更高；</li><li>自动移除未引用代码；</li><li>打包结果依然完全可读</li></ul><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a><strong>缺点</strong></h5><ul><li><p>加载非 ESM 的第三方模块比较复杂；</p></li><li><p>因为模块最终都被打包到全局中，所以无法实现 <code>HMR</code>；</p></li><li><p>浏览器环境中，代码拆分功能必须使用 <code>Require.js</code> 这样的 <code>AMD</code> 库</p></li></ul><blockquote><ul><li>我们发现如果我们开发的是一个应用程序，需要大量引用第三方模块，同时还需要 HMR 提升开发体验，而且应用过大就必须要分包。那这些需求 Rollup 都无法满足。</li><li>如果我们是开发一个 JavaScript 框架或者库，那这些优点就特别有必要，而缺点呢几乎也都可以忽略，所以在很多像 React 或者 Vue 之类的框架中都是使用的 Rollup 作为模块打包器，而并非 Webpack</li></ul></blockquote><p> <strong>总结一下</strong>：<code>Webpack 大而全，Rollup 小而美</code>。 </p><p>在对它们的选择上，我的基本原则是：<code>应用开发使用 Webpack，类库或者框架开发使用 Rollup</code>。</p><p>不过这并不是绝对的标准，只是经验法则。因为 Rollup 也可用于构建绝大多数应用程序，而 Webpack 同样也可以构建类库或者框架。</p><p><img src="/2019/04/10/%E4%BB%8B%E7%BB%8DRollup/tt.png"></p>]]></content>
    
    
    <categories>
      
      <category>webpack</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Roollup</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>介绍TreeShaking</title>
    <link href="/2019/04/08/%E4%BB%8B%E7%BB%8DTreeShaking/"/>
    <url>/2019/04/08/%E4%BB%8B%E7%BB%8DTreeShaking/</url>
    
    <content type="html"><![CDATA[<h4 id="介绍一下tree-shaking"><a href="#介绍一下tree-shaking" class="headerlink" title="介绍一下tree-shaking"></a>介绍一下tree-shaking</h4><h5 id="作用："><a href="#作用：" class="headerlink" title="作用："></a><strong>作用：</strong></h5><p> 它表示在打包的时候会去除一些无用的代码 </p><h5 id="原理："><a href="#原理：" class="headerlink" title="原理："></a><strong>原理</strong>：</h5><ul><li><code>ES6</code>的模块引入是静态分析的，所以在编译时能正确判断到底加载了哪些模块</li><li>分析程序流，判断哪些变量未被使用、引用，进而删除此代码</li></ul><h5 id="特点："><a href="#特点：" class="headerlink" title="特点："></a><strong>特点：</strong></h5><ul><li>在生产模式下它是默认开启的，但是由于经过<code>babel</code>编译全部模块被封装成<code>IIFE</code>，它存在副作用无法被<code>tree-shaking</code>掉</li><li>可以在<code>package.json</code>中配置<code>sideEffects</code>来指定哪些文件是有副作用的。它有两种值，一个是布尔类型，如果是<code>false</code>则表示所有文件都没有副作用；如果是一个数组的话，数组里的文件路径表示改文件有副作用</li><li><code>rollup</code>和<code>webpack</code>中对<code>tree-shaking</code>的层度不同，例如对<code>babel</code>转译后的<code>class</code>，如果<code>babel</code>的转译是宽松模式下的话(也就是<code>loose</code>为<code>true</code>)，<code>webpack</code>依旧会认为它有副作用不会<code>tree-shaking</code>掉，而<code>rollup</code>会。这是因为<code>rollup</code>有程序流分析的功能，可以更好的判断代码是否真正会产生副作用。</li></ul><h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a><strong>原理</strong></h5><ul><li><code>ES6 Module</code> 引入进行静态分析，故而编译的时候正确判断到底加载了那些模块</li><li>静态分析程序流，判断那些模块和变量未被使用或者引用，进而删除对应代码</li></ul><blockquote><p>依赖于<code>import/export</code> </p></blockquote><p> 通过导入所有的包后再进行条件获取。如下： </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> foo <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;foo&quot;</span>;<br><span class="hljs-keyword">import</span> bar <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;bar&quot;</span>;<br><br><span class="hljs-keyword">if</span>(condition) &#123;<br>    <span class="hljs-comment">// foo.xxxx</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// bar.xxx</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>ES6的import语法完美可以使用tree shaking，因为可以在代码不运行的情况下就能分析出不需要的代码 </p></blockquote><p> <strong>CommonJS的动态特性模块意味着tree shaking不适用</strong>。因为它是不可能确定哪些模块实际运行之前是需要的或者是不需要的。在ES6中，进入了完全静态的导入语法：import。这也意味着下面的导入是不可行的： </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 不可行，ES6 的import是完全静态的</span><br><span class="hljs-keyword">if</span>(condition) &#123;<br>    myDynamicModule = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;foo&quot;</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    myDynamicModule = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;bar&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>webpack</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Three_Shaking</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>webpack层面如何做优化</title>
    <link href="/2019/04/06/webpack%E5%B1%82%E9%9D%A2%E5%A6%82%E4%BD%95%E5%81%9A%E4%BC%98%E5%8C%96/"/>
    <url>/2019/04/06/webpack%E5%B1%82%E9%9D%A2%E5%A6%82%E4%BD%95%E5%81%9A%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h4 id="webpack-层面如何做性能优化"><a href="#webpack-层面如何做性能优化" class="headerlink" title="webpack 层面如何做性能优化"></a>webpack 层面如何做性能优化</h4><h5 id="优化前的准备工作"><a href="#优化前的准备工作" class="headerlink" title="优化前的准备工作"></a>优化前的准备工作</h5><p>准备基于时间的分析工具：我们需要一类插件，来帮助我们统计项目构建过程中在编译阶段的耗时情况。speed-measure-webpack-plugin 分析插件加载的时间<br>使用 webpack-bundle-analyzer 分析产物内容<br>代码优化:</p><blockquote><p>无用代码消除，是许多编程语言都具有的优化手段，这个过程称为 DCE (dead code elimination)，即 删除不可能执行的代码；</p></blockquote><p>例如我们的 UglifyJs，它就会帮我们在生产环境中删除不可能被执行的代码，例如:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> fn = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><span class="hljs-comment">// 下面代码便属于 不可能执行的代码；</span><br><span class="hljs-comment">// 通过 UglifyJs (Webpack4+ 已内置) 便会进行 DCE；</span><br><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">return</span> a;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>摇树优化 (Tree-shaking)，这是一种形象比喻。我们把打包后的代码比喻成一棵树，这里其实表示的就是，通过工具 “摇” 我们打包后的 js 代码，将没有使用到的无用代码 “摇” 下来 (删除)。即 消除那些被 引用了但未被使用 的模块代码。</p></blockquote><ul><li>原理: 由于是在编译时优化，因此最基本的前提就是语法的静态分析，ES6的模块机制 提供了这种可能性。不需要运行时，便可进行代码字面上的静态分析，确定相应的依赖关系。</li><li>问题: 具有 副作用 的函数无法被tree-shaking<ul><li>在引用一些第三方库，需要去观察其引入的代码量是不是符合预期；</li><li>尽量写纯函数，减少函数的副作用；</li><li>可使用 <code>webpack-deep-scope-plugin</code>，可以进行作用域分析，减少此类情况的发生，但仍需要注意；</li></ul></li></ul><p><strong>code-spliting: 代码分割技术</strong>，将代码分割成多份进行 懒加载 或 异步加载，避免打包成一份后导致体积过大，影响页面的首屏加载；</p><ul><li><code>Webpack</code> 中使用 <code>SplitChunksPlugin</code> 进行拆分；</li><li>按 页面 拆分: 不同页面打包成不同的文件；</li><li>按 功能 拆分:<ul><li>将类似于播放器，计算库等大模块进行拆分后再懒加载引入；</li><li>提取复用的业务代码，减少冗余代码；</li></ul></li><li>按 文件修改频率 拆分: 将第三方库等不常修改的代码单独打包，而且不改变其文件 hash 值，能最大化运用浏览器的缓存；</li></ul><p><strong>scope hoisting</strong>: 作用域提升，将分散的模块划分到同一个作用域中，避免了代码的重复引入，有效减少打包后的代码体积和运行时的内存损耗；</p><h5 id="编译性能优化"><a href="#编译性能优化" class="headerlink" title="编译性能优化:"></a>编译性能优化:</h5><ul><li>升级至 最新 版本的 <code>webpack</code>，能有效提升编译性能；</li><li> 使用 <code>dev-server</code> / 模块热替换 (<code>HMR</code>) 提升开发体验； </li><li>监听文件变动 忽略 node_modules 目录能有效提高监听时的编译效率；</li><li>缩小编译范围<ul><li><code>modules</code>: 指定模块路径，减少递归搜索；</li><li><code>mainFields</code>: 指定入口文件描述字段，减少搜索；</li><li><code>noParse</code>: 避免对非模块化文件的加载；</li><li><code>includes/exclude</code>: 指定搜索范围/排除不必要的搜索范围；</li><li><code>alias</code>: 缓存目录，避免重复寻址；</li></ul></li><li>babel-loader<ul><li>忽略<code>node_moudles</code>，避免编译第三方库中已经被编译过的代码</li><li>使用<code>cacheDirectory</code>，可以缓存编译结果，避免多次重复编译</li></ul></li><li>多进程并发<ul><li><code>webpack-parallel-uglify-plugin</code>: 可多进程并发压缩 js 文件，提高压缩速度；</li><li><code>HappyPack</code>: 多进程并发文件的 <code>Loader</code> 解析；</li></ul></li><li>第三方库模块缓存:<ul><li><code>DLLPlugin</code> 和 <code>DLLReferencePlugin</code> 可以提前进行打包并缓存，避免每次都重新编译；</li></ul></li><li>使用分析<ul><li><code>Webpack Analyse / webpack-bundle-analyzer</code> 对打包后的文件进行分析，寻找可优化的地方</li><li>配置profile：true，对各个编译阶段耗时进行监控，寻找耗时最多的地方</li></ul></li><li>source-map:<ul><li>开发: <code>cheap-module-eval-source-map</code></li><li>生产: <code>hidden-source-map</code>；</li></ul></li></ul><h5 id="优化webpack打包速度"><a href="#优化webpack打包速度" class="headerlink" title="优化webpack打包速度"></a>优化webpack打包速度</h5><ul><li>减少文件搜索范围<ul><li>比如通过别名</li><li><code>loader</code> 的 <code>test</code>，<code>include &amp; exclude</code></li></ul></li><li><code>Webpack4</code> 默认压缩并行</li><li><code>Happypack</code> 并发调用</li><li><code>babel</code> 也可以缓存编译</li><li><code>Resolve</code> 在构建时指定查找模块文件的规则</li><li>使用<code>DllPlugin</code>，不用每次都重新构建</li><li> <code>externals</code> 和 <code>DllPlugin</code> 解决的是同一类问题：将依赖的框架等模块从构建过程中移除。它们的区别在于 </li><li>在 Webpack 的配置方面，<code>externals</code> 更简单，而 <code>DllPlugin</code> 需要独立的配置文件。</li><li><code>DllPlugin</code> 包含了依赖包的独立构建流程，而 <code>externals</code> 配置中不包含依赖框架的生成方式，通常使用已传入 CDN 的依赖包</li><li><code>externals</code> 配置的依赖包需要单独指定依赖模块的加载方式：全局对象、CommonJS、AMD 等</li><li>在引用依赖包的子模块时，<code>DllPlugin</code> 无须更改，而 <code>externals</code> 则会将子模块打入项目包中</li></ul><h5 id="优化打包体积"><a href="#优化打包体积" class="headerlink" title="优化打包体积"></a>优化打包体积</h5><ul><li>提取第三方库或通过引用外部文件的方式引入第三方库</li><li>代码压缩插件<code>UglifyJsPlugin</code></li><li>服务器启用<code>gzip</code>压缩</li><li>按需加载资源文件 <code>require.ensure</code></li><li>优化<code>devtool</code>中的<code>source-map</code></li><li>剥离<code>css</code>文件，单独打包</li><li>去除不必要插件，通常就是开发环境与生产环境用同一套配置文件导致</li><li><code>Tree Shaking</code> 在构建打包过程中，移除那些引入但未被使用的无效代码</li><li>开启scope hosting<ul><li>体积更小</li><li>创建函数作用域更小</li><li>代码可读性更好</li></ul></li></ul><p><img src="/2019/04/06/webpack%E5%B1%82%E9%9D%A2%E5%A6%82%E4%BD%95%E5%81%9A%E4%BC%98%E5%8C%96/tt.png"></p><br><p><img src="/2019/04/06/webpack%E5%B1%82%E9%9D%A2%E5%A6%82%E4%BD%95%E5%81%9A%E4%BC%98%E5%8C%96/oo.png"></p>]]></content>
    
    
    <categories>
      
      <category>webpack</category>
      
    </categories>
    
    
    <tags>
      
      <tag>优化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>webpack热更新原理</title>
    <link href="/2019/04/04/webpack%E7%83%AD%E6%9B%B4%E6%96%B0%E5%8E%9F%E7%90%86/"/>
    <url>/2019/04/04/webpack%E7%83%AD%E6%9B%B4%E6%96%B0%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p><img src="/2019/04/04/webpack%E7%83%AD%E6%9B%B4%E6%96%B0%E5%8E%9F%E7%90%86/rr.png"></p><h5 id="HMR-的基本流程图"><a href="#HMR-的基本流程图" class="headerlink" title="HMR 的基本流程图"></a><strong>HMR 的基本流程图</strong></h5><p><img src="/2019/04/04/webpack%E7%83%AD%E6%9B%B4%E6%96%B0%E5%8E%9F%E7%90%86/tt.png"></p><ul><li>当修改了一个或多个文件；</li><li>文件系统接收更改并通知 <code>webpack</code>；</li><li><code>webpack</code> 重新编译构建一个或多个模块，并通知 HMR 服务器进行更新；</li><li><code>HMR Server</code> 使用 <code>webSocket</code> 通知 <code>HMR runtime</code> 需要更新，<code>HMR</code> 运行时通过 <code>HTTP</code> 请求更新 <code>jsonp</code></li><li><code>HMR</code> 运行时替换更新中的模块，如果确定这些模块无法更新，则触发整个页面刷新</li></ul><h5 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h5><hr><blockquote><ul><li><a href="https://interview2.poetries.top/docs/simply.html#_4-webpack-%E7%83%AD%E6%9B%B4%E6%96%B0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86">https://interview2.poetries.top/docs/simply.html#_4-webpack-%E7%83%AD%E6%9B%B4%E6%96%B0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86</a></li></ul></blockquote>]]></content>
    
    
    <categories>
      
      <category>webpack</category>
      
    </categories>
    
    
    <tags>
      
      <tag>热更新</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>介绍webpack_Plugin</title>
    <link href="/2019/04/03/%E4%BB%8B%E7%BB%8Dwebpack-Plugin/"/>
    <url>/2019/04/03/%E4%BB%8B%E7%BB%8Dwebpack-Plugin/</url>
    
    <content type="html"><![CDATA[<h4 id="介绍webpack中的plugin？"><a href="#介绍webpack中的plugin？" class="headerlink" title="介绍webpack中的plugin？"></a>介绍webpack中的plugin？</h4><p>plugin是插件，对于webpack本身的扩展，是一个扩展器。</p><p>配置方式：写在plugins属性中传入new实例对象，他是个数组，可以写多个插件。</p><ul><li>UglifyJsPlugin: 压缩、混淆代码；</li><li>CommonsChunkPlugin: 代码分割；</li><li>ProvidePlugin: 自动加载模块；</li><li>html-webpack-plugin: 加载 html 文件，并引入 css / js 文件；</li><li>extract-text-webpack-plugin / mini-css-extract-plugin: 抽离样式，生成 css 文件； DefinePlugin: 定义全局变量；</li><li>optimize-css-assets-webpack-plugin: CSS 代码去重；</li><li>webpack-bundle-analyzer: 代码分析；</li><li>compression-webpack-plugin: 使用 gzip 压缩 js 和 css；</li><li>happypack: 使用多进程，加速代码构建；</li><li>EnvironmentPlugin: 定义环境变量；</li></ul><h5 id="下面介绍几个常用的插件用法："><a href="#下面介绍几个常用的插件用法：" class="headerlink" title="下面介绍几个常用的插件用法："></a>下面介绍几个常用的插件用法：</h5><ul><li>HtmlWebpackPlugin<ul><li> ⾃动生成⼀个 <code>html</code> ⽂文件，并把打包生成的<code>js</code> 模块引⼊到该 <code>html</code> 中 </li></ul></li><li>clean-webpack-plugin<ul><li> 删除（清理）构建目录 </li></ul></li><li>mini-css-extract-plugin<ul><li>提取css到一个单独文件中</li></ul></li><li>copy-webpack-plugin<ul><li>复制文件或目录到执行区域。</li></ul></li></ul><h5 id="loader和plugin的区别？"><a href="#loader和plugin的区别？" class="headerlink" title="loader和plugin的区别？"></a>loader和plugin的区别？</h5><ul><li>对于loader，它是一个转换器，将A文件进行编译形成B文件，这里操作的是文件，比如将A.scss转换为A.css，单纯的文件转换过程。</li><li>plugin是一个插件，在webpack中相当于一个扩展器。是对现有webpack功能的一个扩展。针对于loader结束后，在webpack打包过程中并不是直接进行操作的，而是遵循事件机制工作的。会监听webpack打包过程中的某些节点，执行广泛的任务。</li></ul><h5 id="一个最简单的-plugin-是这样的"><a href="#一个最简单的-plugin-是这样的" class="headerlink" title="一个最简单的 plugin 是这样的:"></a><strong>一个最简单的 plugin 是这样的:</strong></h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Plugin</span>&#123;<br>  <span class="hljs-comment">// 注册插件时，会调用 apply 方法</span><br>  <span class="hljs-comment">// apply 方法接收 compiler 对象</span><br>  <span class="hljs-comment">// 通过 compiler 上提供的 Api，可以对事件进行监听，执行相应的操作</span><br>  <span class="hljs-title function_">apply</span>(<span class="hljs-params">compiler</span>)&#123;<br>  <span class="hljs-comment">// compilation 是监听每次编译循环</span><br>  <span class="hljs-comment">// 每次文件变化，都会生成新的 compilation 对象并触发该事件</span><br>    compiler.<span class="hljs-title function_">plugin</span>(<span class="hljs-string">&#x27;compilation&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">compilation</span>) &#123;&#125;)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p> <strong>注册插件:</strong> </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// webpack.config.js</span><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">export</span> = &#123;<br><span class="hljs-attr">plugins</span>:[<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Plugin</span>(options),<br>]<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h5><hr><blockquote><ul><li><a href="https://interview2.poetries.top/docs/simply.html#_3-%E4%BB%8B%E7%BB%8D-plugin">https://interview2.poetries.top/docs/simply.html#_3-%E4%BB%8B%E7%BB%8D-plugin</a></li></ul></blockquote>]]></content>
    
    
    <categories>
      
      <category>webpack</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Plugin</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>介绍webpack_Loader</title>
    <link href="/2019/03/29/%E4%BB%8B%E7%BB%8Dwebpack-Loader/"/>
    <url>/2019/03/29/%E4%BB%8B%E7%BB%8Dwebpack-Loader/</url>
    
    <content type="html"><![CDATA[<h4 id="介绍webpack中的loader？"><a href="#介绍webpack中的loader？" class="headerlink" title="介绍webpack中的loader？"></a>介绍webpack中的loader？</h4><p>webpack默认情况下，只支持对js，json文件打包。像css，less，png图片啊这些类型文件，webpack需要采用相对应的loader（模块加载器）进行解析转换。</p><h5 id="loader配置（module-rules）："><a href="#loader配置（module-rules）：" class="headerlink" title="loader配置（module.rules）："></a>loader配置（module.rules）：</h5><ul><li>rules是一个数组的形式，因此我们可以配置多个loader。</li><li>每一个loader对应一个对象形式，属性test为匹配的规则，一般情况下为正则表达式。</li><li>属性use针对匹配到文件类型，调用对应的loader进行处理。</li></ul><br><h5 id="常见的loader："><a href="#常见的loader：" class="headerlink" title="常见的loader："></a>常见的loader：</h5><ul><li><p>style-loader：将css添加到dom的内联样式标签style中。</p></li><li><p>css-loader： 允许css文件通过import和url,引用css文件对应的资源。</p></li><li><p>sass-loader / less-loader：css预处理器，提高了开发效率。</p></li><li><p>babel-loader： 用babel将es6/es7 代码转换成es5。</p></li><li><p>file-loader： 加载文件资源，如 字体/图片 等。</p></li><li><p>url-loader：对于图片格式的模块，可以选择性的把图片转成base64格式的字符串，并打包到js中，对小体积的图片比较合适，大图片不合适。</p></li></ul><h5 id="编写原则"><a href="#编写原则" class="headerlink" title="编写原则:"></a><strong>编写原则:</strong></h5><ul><li>单一原则: 每个 Loader 只做一件事；</li><li>链式调用: Webpack 会按顺序链式调用每个 Loader；</li><li>统一原则: 遵循 Webpack制定的设计规则和结构，输入与输出均为字符串，各个 Loader 完全独立，即插即用；</li></ul><h5 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h5><hr><blockquote><ul><li><a href="https://interview2.poetries.top/docs/simply.html#_2-%E4%BB%8B%E7%BB%8D-loader">https://interview2.poetries.top/docs/simply.html#_2-%E4%BB%8B%E7%BB%8D-loader</a></li></ul></blockquote>]]></content>
    
    
    <categories>
      
      <category>webpack</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Loader</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>webpack构建流程</title>
    <link href="/2019/03/28/webpack%E6%9E%84%E5%BB%BA%E6%B5%81%E7%A8%8B/"/>
    <url>/2019/03/28/webpack%E6%9E%84%E5%BB%BA%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h4 id="介绍一下-webpack-的构建流程"><a href="#介绍一下-webpack-的构建流程" class="headerlink" title="介绍一下 webpack 的构建流程"></a>介绍一下 webpack 的构建流程</h4><h5 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a><strong>核心概念</strong></h5><ul><li><code>entry</code>：入口配置。webpack从入口开始根据模块间依赖关系递归解析和处理所有资源文件。</li><li><code>output</code>：出口配置。经打包后的文件写入的位置。</li><li><code>loader</code>：模块转换器。纯文件转换。因为webpack默认只认识js，json文件。</li><li><code>plugin</code>：扩展插件。插件可以扩展 Webpack 的功能。</li><li><code>module</code>：模块。除了js范畴内的<code>es module、commonJs、AMD</code>等，<code>css @import、url(...)</code>、图片、字体等在webpack中都被视为模块。</li></ul><h5 id="打包流程"><a href="#打包流程" class="headerlink" title="打包流程"></a>打包流程</h5><ul><li>初始化参数：从配置文件和 Shell 语句中读取并合并参数，得出最终的配置参数。</li><li>开始编译：从上一步得到的参数初始化 <code>Compiler</code> 对象，加载所有配置的插件，执行对象的 <code>run</code> 方法开始执行编译。</li><li>确定入口：根scope据配置中的 <code>entry</code> 找出所有的入口文件。</li><li>编译模块：从入口文件出发，调用所有配置的 <code>loader</code> 对模块进行翻译，再找出该模块依赖的模块，这个步骤是递归执行的，直至所有入口依赖的模块文件都经过本步骤的处理。</li><li>完成模块编译：经过第 4 步使用 loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系。</li><li>输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 <code>chunk</code>，再把每个 <code>chunk</code> 转换成一个单独的文件加入到输出列表，这一步是可以修改输出内容的最后机会。</li><li>输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。</li></ul><p><img src="/2019/03/28/webpack%E6%9E%84%E5%BB%BA%E6%B5%81%E7%A8%8B/tt.png"></p><br><p>从配置文件中读取所需要的参数，初始化compiler对象，并且加载所有的插件，执行run方法开始编译。找到entry入口文件。调用loader对模板进行递归解析翻译。等确定每个模块的依赖关系后，将他们组装成一个个包含多个模块的chunk。确定好内容后，根据出口配置将打包后的文件写入到具体位置。</p><h5 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h5><hr><blockquote><ul><li><a href="https://interview2.poetries.top/docs/simply.html#_10-%E7%A7%BB%E5%8A%A8%E7%AB%AF%E4%BC%98%E5%8C%96">https://interview2.poetries.top/docs/simply.html#_10-%E7%A7%BB%E5%8A%A8%E7%AB%AF%E4%BC%98%E5%8C%96</a></li></ul></blockquote>]]></content>
    
    
    <categories>
      
      <category>webpack</category>
      
    </categories>
    
    
    <tags>
      
      <tag>webpack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>var,let,const的区别</title>
    <link href="/2016/03/28/var-let-const%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2016/03/28/var-let-const%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h4 id="说说var、let、const之间的区别？"><a href="#说说var、let、const之间的区别？" class="headerlink" title="说说var、let、const之间的区别？"></a>说说var、let、const之间的区别？</h4><hr><h5 id="Var："><a href="#Var：" class="headerlink" title="Var："></a>Var：</h5><p>用var声明的变量既是全局变量，也是顶层变量。</p><p>注意：顶层变量，在浏览器环境里指的是window对象，在node指的是global对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-property">a</span>) <span class="hljs-comment">// 10</span><br></code></pre></td></tr></table></figure><ul><li><p>使用var存在变量提升的情况</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a)  <span class="hljs-comment">//undefind</span><br><span class="hljs-keyword">var</span> a = <span class="hljs-number">20</span><br></code></pre></td></tr></table></figure></li><li><p> 使用<code>var</code>，我们能够对一个变量进行多次声明，后面声明的变量会覆盖前面的变量声明 。</p></li></ul>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">20</span><br><span class="hljs-keyword">var</span> a = <span class="hljs-number">30</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a)   <span class="hljs-comment">//30</span><br></code></pre></td></tr></table></figure><ul><li><p>在函数中使用var声明变量，该变量是局部的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">20</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">change</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">var</span> a = <span class="hljs-number">30</span><br>&#125;<br><span class="hljs-title function_">change</span>()<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a)  <span class="hljs-comment">// 20 </span><br></code></pre></td></tr></table></figure></li><li><p>在函数中不使用var声明变量，该变量是全局的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">20</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">change</span>(<span class="hljs-params"></span>)&#123;<br>   a = <span class="hljs-number">30</span><br>&#125;<br><span class="hljs-title function_">change</span>()<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a) <span class="hljs-comment">// 30 </span><br></code></pre></td></tr></table></figure></li></ul><hr><h5 id="Let："><a href="#Let：" class="headerlink" title="Let："></a>Let：</h5><p>let是es6新增的语法，用来声明变量。</p><ul><li><p>只能在let代码块内有效。具有块级作用域。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&#123;<br>    <span class="hljs-keyword">let</span> a = <span class="hljs-number">20</span><br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a) <span class="hljs-comment">// ReferenceError: a is not defined.</span><br></code></pre></td></tr></table></figure></li><li><p>存在暂时性死区的问题，没有变量提升。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a)   <span class="hljs-comment">// Uncaught ReferenceError: Cannot access &#x27;a&#x27; before initialization</span><br><br><span class="hljs-keyword">let</span> a = <span class="hljs-number">30</span><br></code></pre></td></tr></table></figure></li><li><p>let 不能重复声明一个变量。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> a = <span class="hljs-number">20</span><br><span class="hljs-keyword">let</span> a = <span class="hljs-number">30</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a)   <span class="hljs-comment">//SyntaxError: Identifier &#x27;a&#x27; has already been declared</span><br></code></pre></td></tr></table></figure></li></ul><hr><h5 id="Const："><a href="#Const：" class="headerlink" title="Const："></a>Const：</h5><ul><li> <code>const</code>声明一个只读的常量，一旦声明，常量的值就不能改变 。</li></ul>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> a = <span class="hljs-number">1</span><br>a = <span class="hljs-number">3</span><br><span class="hljs-comment">// TypeError: Assignment to constant variable.</span><br></code></pre></td></tr></table></figure><ul><li> 之前用<code>var</code>或<code>let</code>声明过变量，再用<code>const</code>声明同样会报错 。</li></ul>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">20</span><br><span class="hljs-keyword">let</span> b = <span class="hljs-number">20</span><br><span class="hljs-keyword">const</span> a = <span class="hljs-number">30</span><br><span class="hljs-keyword">const</span> b = <span class="hljs-number">30</span><br><span class="hljs-comment">// 都会报错</span><br></code></pre></td></tr></table></figure><hr><h5 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h5><ul><li>var存在变量提升，let和const不存在变量提升。</li><li>var不存在暂时性死区，let和const存在暂时性死区，只有先正确声明好变量才能获取和使用该变量。</li><li>var不存在块级作用域，let和const存在块级作用域。</li><li>var可以重复声明变量，后者声明的值覆盖前者。let和const不能重复声明。</li><li>var和let可以修改值，const是一个常量，不能修改。</li></ul><hr><h5 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h5><hr><blockquote><ul><li><a href="https://es6.ruanyifeng.com/">https://es6.ruanyifeng.com/</a></li></ul></blockquote><blockquote><ul><li><a href="https://vue3js.cn/interview/es6/var_let_const.html#%E4%B8%80%E3%80%81var">https://vue3js.cn/interview/es6/var_let_const.html#%E4%B8%80%E3%80%81var</a></li></ul></blockquote>]]></content>
    
    
    <categories>
      
      <category>javascript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>区别</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue3中Treeaking特性</title>
    <link href="/2014/07/27/vue3%E4%B8%ADTreeshaking%E7%89%B9%E6%80%A7/"/>
    <url>/2014/07/27/vue3%E4%B8%ADTreeshaking%E7%89%B9%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h4 id="说说Vue-3-0中Treeshaking特性？举例说明一下？"><a href="#说说Vue-3-0中Treeshaking特性？举例说明一下？" class="headerlink" title="说说Vue 3.0中Treeshaking特性？举例说明一下？"></a>说说Vue 3.0中Treeshaking特性？举例说明一下？</h4><p><img src="/2014/07/27/vue3%E4%B8%ADTreeshaking%E7%89%B9%E6%80%A7/tt.png"></p><h5 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h5><p>Tree shaking是一种术语，在打包时将不打包没有用到的代码清除掉，这些代码会成为dead code（死代码）。也就是说，treeshaking在打包时所留下的，是我们用到的代码。</p><ul><li>在vue2中，无论我们使用什么功能，它们最终都会出现在打包后的文件中。因为vue2在项目中是单例的，无法检测到哪些代码在项目中是被用到的。</li><li>vue3引入了treeshaking特性，将全局api进行分块。如果没有使用到某个功能，他们将不会包含在你打包后的文件中。</li></ul><h5 id="如何做？"><a href="#如何做？" class="headerlink" title="如何做？"></a>如何做？</h5><p>Tree shaking是基于es6的模板语法import，exports静态编辑思想确定模块依赖关系的。</p><ul><li>treeshaking在编译阶段会判断模块的加载状态。</li><li>判断未使用的相关变量，进行移除。</li></ul><p>举个例子：<br> 如果，新创建的项目中，data中的变量1，和变量2被使用了，但是变量3，并没有被使用，那么变量3，会在打包的时候被移除<br> 在比如，可以对比一下项目在使用treeShaking打包之后和未使用的情况下进行打包后的大小，<br> data中的数据都被正常使用，methods的方法也被正常使用，component方法和watch方法未使用，然后进行打包<br> 答案显而易见，在使用treeShaking后进行打包只会将data和methods这种使用的方法进行打包，而不是打包所有</p><h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><ul><li>减少程序体积（更小）</li><li>减少程序执行时间（更快）</li><li>便于维护优化项目框架</li></ul><br><h5 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h5><hr><blockquote><ul><li><a href="https://segmentfault.com/a/1190000038962700">https://segmentfault.com/a/1190000038962700</a></li></ul></blockquote><blockquote><ul><li><a href="https://vue3js.cn/interview/vue3/treeshaking.html#%E4%B8%80%E3%80%81%E6%98%AF%E4%BB%80%E4%B9%88">https://vue3js.cn/interview/vue3/treeshaking.html#%E4%B8%80%E3%80%81%E6%98%AF%E4%BB%80%E4%B9%88</a></li></ul></blockquote>]]></content>
    
    
    <categories>
      
      <category>vue2</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue3Tree_shaking</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>防抖与节流</title>
    <link href="/2014/06/05/%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/"/>
    <url>/2014/06/05/%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<br><h4 id="什么是防抖和节流？"><a href="#什么是防抖和节流？" class="headerlink" title="什么是防抖和节流？"></a>什么是防抖和节流？</h4><ul><li>防抖：在一定时间内执行某个事件被触发或者是函数，如果在这个时间内再次触发该事件，则重新计时。只执行最后一次。</li><li>节流：持续触发一个事件，每隔一段时间，只执行一次事件。控制事件执行的次数以及事件触发的频率。从而提高性能。</li></ul><p>简单来说：</p><p>节流: n 秒内只运行一次，若在 n 秒内重复触发，只有一次生效。</p><p>防抖: n 秒后在执行该事件，若在 n 秒内被重复触发，则重新计时，执行最后一次事件。</p><br><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><p>相同点：</p><ul><li>都可以通过使用 <code>setTimeout</code> ，结合闭包实现。</li><li>目的都是为了，降低执行的频率，节省资源。</li></ul><p>不同点：</p><ul><li>防抖，在一段连续操作结束后，处理回调，利用<code>clearTimeout</code>和<code>setTimeout</code>来实现。        节流，在一段连续的操作后，每隔一段时间只执行一次，触发频率高的事件中使用来提高性能。</li><li>防抖关注一定时间连续触发的事件，只在最后执行一次。  节流，每隔多少时间，执行一次。</li></ul><br><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>防抖：</p><ul><li>搜索框搜索输入。   只需用户输入完毕之后，发送请求。</li><li>手机号，邮箱验证输入检测。</li><li>窗口大小resize。     只需窗口调整完成后，计算窗口大小。防止重新渲染。</li></ul><p>节流：</p><ul><li>滚动条滚动，加载更多数据等。</li><li>盒子拖动触发事件。</li><li>搜索框，搜索联想功能。</li></ul>]]></content>
    
    
    <categories>
      
      <category>javascript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>防抖-节流</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue响应式原理</title>
    <link href="/2014/05/27/vue%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/"/>
    <url>/2014/05/27/vue%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p> <img src="/2014/05/27/vue%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/15.png" alt="img"> </p><p>Vue2.x响应式原理：</p><p>vue创建一个实例时，首先会遍历data属性。采用数据劫持结合发布者订阅者的方式。使用es5的object.defindeproperty 方法将他们转化成getter，setter，并在内部追踪相关依赖。在属性被访问和修改时通知变化。也就是observer使用object.defindproerty来监听数据的读写。读取数据时，调用get方法通知dep去收集订阅者（watcher）。添加到道dep的一个属性subs数理。 dep有很多属性，其中就有一个subsadd添加订阅者的方法。修改1数据时，调用set方法，通知dep数据发生了改变。使用dep.notify方法遍历subs数组里面的每个watcher。调用watcher的update（）方法。创建出一个新的dom树，与原来旧的dom树作对比，根据差异性，从而更新视图。</p><p> <img src="/2014/05/27/vue%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/vue.jpeg" alt="img"> </p><p> **Object.defineProperty()**，那么它的用法是什么，以及优缺点是什么呢？ </p><ul><li>可以检测对象中数据发生的修改</li><li>对于复杂的对象，层级很深的话，是不友好的，需要经行深度监听，这样子就需要递归到底，这也是它的缺点。</li><li>对于一个对象中，如果你新增加属性，删除属性，**Object.defineProperty()**是不能观测到的，那么应该如何解决呢？可以通过<code>Vue.set()</code>和<code>Vue.delete()</code>来实现。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 模拟 Vue 中的 data 选项 </span><br><span class="hljs-keyword">let</span> data = &#123;<br>    <span class="hljs-attr">msg</span>: <span class="hljs-string">&#x27;hello&#x27;</span><br>&#125;<br><span class="hljs-comment">// 模拟 Vue 的实例 </span><br><span class="hljs-keyword">let</span> vm = &#123;&#125;<br><span class="hljs-comment">// 数据劫持:当访问或者设置 vm 中的成员的时候，做一些干预操作</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(vm, <span class="hljs-string">&#x27;msg&#x27;</span>, &#123;<br>  <span class="hljs-comment">// 可枚举(可遍历)</span><br>  <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-comment">// 可配置(可以使用 delete 删除，可以通过 defineProperty 重新定义) </span><br>  <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-comment">// 当获取值的时候执行 </span><br>  get () &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;get: &#x27;</span>, data.<span class="hljs-property">msg</span>)<br>    <span class="hljs-keyword">return</span> data.<span class="hljs-property">msg</span> <br>  &#125;,<br>  <span class="hljs-comment">// 当设置值的时候执行 </span><br>  set (newValue) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;set: &#x27;</span>, newValue) <br>    <span class="hljs-keyword">if</span> (newValue === data.<span class="hljs-property">msg</span>) &#123;<br>      <span class="hljs-keyword">return</span><br>    &#125;<br>    data.<span class="hljs-property">msg</span> = newValue<br>    <span class="hljs-comment">// 数据更改，更新 DOM 的值 </span><br>    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#app&#x27;</span>).<span class="hljs-property">textContent</span> = data.<span class="hljs-property">msg</span><br>  &#125; <br>&#125;)<br><br><span class="hljs-comment">// 测试</span><br>vm.<span class="hljs-property">msg</span> = <span class="hljs-string">&#x27;Hello World&#x27;</span> <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(vm.<span class="hljs-property">msg</span>)<br></code></pre></td></tr></table></figure><p>Vue3.响应式原理：</p><p> <code>Vue3.x</code>改用<code>Proxy</code>替代<code>Object.defineProperty</code>。因为<code>Proxy</code>可以直接监听<code>对象和数组</code>的变化，并且有多达13种拦截方法。</p><p>代理，顾名思义，就是在要访问的对象之前增加⼀个中间层，这样就不直接访问对象，⽽是通过中间层做⼀个中转，通过操作代理对象，来实现修改目标对象。</p><p> <strong>监测数组的时候可能触发多次get/set，那么如何防止触发多次呢？</strong> </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 模拟 Vue 中的 data 选项 </span><br><span class="hljs-keyword">let</span> data = &#123;<br>  <span class="hljs-attr">msg</span>: <span class="hljs-string">&#x27;hello&#x27;</span>,<br>  <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> <br>&#125;<br><span class="hljs-comment">// 模拟 Vue 实例</span><br><span class="hljs-keyword">let</span> vm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(data, &#123;<br>  <span class="hljs-comment">// 当访问 vm 的成员会执行</span><br>  get (target, key) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;get, key: &#x27;</span>, key, target[key])<br>    <span class="hljs-keyword">return</span> target[key]<br>  &#125;,<br>  <span class="hljs-comment">// 当设置 vm 的成员会执行</span><br>  set (target, key, newValue) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;set, key: &#x27;</span>, key, newValue)<br>    <span class="hljs-keyword">if</span> (target[key] === newValue) &#123;<br>      <span class="hljs-keyword">return</span><br>    &#125;<br>    target[key] = newValue<br>    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#app&#x27;</span>).<span class="hljs-property">textContent</span> = target[key]<br>  &#125;<br>&#125;)<br><br><span class="hljs-comment">// 测试</span><br>vm.<span class="hljs-property">msg</span> = <span class="hljs-string">&#x27;Hello World&#x27;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(vm.<span class="hljs-property">msg</span>)<br></code></pre></td></tr></table></figure><p>总结：</p><ul><li>Vue<ul><li>记录传入的选项，设置 <code>$data/$el</code></li><li>把 <code>data</code> 的成员注入到 <code>Vue</code> 实例</li><li>负责调用 <code>Observer</code> 实现数据响应式处理(数据劫持)</li><li>负责调用 <code>Compiler</code> 编译指令/插值表达式等</li></ul></li><li>Observer<ul><li>数据劫持<ul><li>负责把 <code>data</code> 中的成员转换成 <code>getter/setter</code></li><li>负责把多层属性转换成 <code>getter/setter</code></li><li>如果给属性赋值为新对象，把新对象的成员设置为 <code>getter/setter</code></li></ul></li><li>添加 <code>Dep</code> 和 <code>Watcher</code> 的依赖关系</li><li>数据变化发送通知</li></ul></li><li>Compiler<ul><li>负责编译模板，解析指令/插值表达式</li><li>负责页面的首次渲染过程</li><li>当数据变化后重新渲染</li></ul></li><li>Dep<ul><li>收集依赖，添加订阅者(<code>watcher</code>)</li><li>通知所有订阅者</li></ul></li><li>Watcher<ul><li>自身实例化的时候往<code>dep</code>对象中添加自己</li><li>当数据变化<code>dep</code>通知所有的 <code>Watcher</code> 实例更新视图</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>vue2</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>jsonp原理及实现</title>
    <link href="/2014/05/25/jsonp%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/"/>
    <url>/2014/05/25/jsonp%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h3><p> jsonp是一种跨域通信的手段，它的原理其实很简单： </p><ul><li>首先是利用script标签的src属性来实现跨域。</li><li>通过将前端方法作为参数传递到服务器端，然后由服务器端注入参数之后再返回，实现服务器端向客户端通信。</li><li>由于使用script标签的src属性，因此只支持get方法</li></ul><h3 id="2、实现流程"><a href="#2、实现流程" class="headerlink" title="2、实现流程"></a>2、实现流程</h3><ol><li> 设定一个script标签 。</li></ol>   <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;script src=<span class="hljs-string">&quot;http://jsonp.js?callback=xxx&quot;</span>&gt;&lt;/script&gt;<br></code></pre></td></tr></table></figure><ol start="2"><li> callback定义了一个函数名，而远程服务端通过调用指定的函数并传入参数来实现传递参数，将fn(response)传递回客户端 。</li></ol>   <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">$callback = !<span class="hljs-title function_">empty</span>($_GET[<span class="hljs-string">&#x27;callback&#x27;</span>]) ? $_GET[<span class="hljs-string">&#x27;callback&#x27;</span>] : <span class="hljs-string">&#x27;callback&#x27;</span>;<br>echo $callback.<span class="hljs-string">&#x27;(.json_encode($data).)&#x27;</span>;<br></code></pre></td></tr></table></figure><ol start="3"><li> 客户端接收到返回的js脚本，开始解析和执行fn(response) 。</li></ol><h3 id="3、jsonp简单实现"><a href="#3、jsonp简单实现" class="headerlink" title="3、jsonp简单实现"></a>3、jsonp简单实现</h3><p> 一个简单的jsonp实现，其实就是拼接url，然后将动态添加一个script元素到头部。 </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">jsonp</span>(<span class="hljs-params">req</span>)&#123;<br>    <span class="hljs-keyword">var</span> script = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;script&#x27;</span>);<br>    <span class="hljs-keyword">var</span> url = req.<span class="hljs-property">url</span> + <span class="hljs-string">&#x27;?callback=&#x27;</span> + req.<span class="hljs-property">callback</span>.<span class="hljs-property">name</span>;<br>    script.<span class="hljs-property">src</span> = url;<br>    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementsByTagName</span>(<span class="hljs-string">&#x27;head&#x27;</span>)[<span class="hljs-number">0</span>].<span class="hljs-title function_">appendChild</span>(script); <br>&#125;<br></code></pre></td></tr></table></figure><p> <strong>前端js示例</strong> </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">hello</span>(<span class="hljs-params">res</span>)&#123;<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;hello &#x27;</span> + res.<span class="hljs-property">data</span>);<br>&#125;<br><span class="hljs-title function_">jsonp</span>(&#123;<br>    url : <span class="hljs-string">&#x27;&#x27;</span>,<br>    callback : hello <br>&#125;);<br></code></pre></td></tr></table></figure><p> <strong>服务器端代码</strong> </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>);<br><span class="hljs-keyword">var</span> urllib = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;url&#x27;</span>);<br><br><span class="hljs-keyword">var</span> port = <span class="hljs-number">8080</span>;<br><span class="hljs-keyword">var</span> data = &#123;<span class="hljs-string">&#x27;data&#x27;</span>:<span class="hljs-string">&#x27;world&#x27;</span>&#125;;<br><br>http.<span class="hljs-title function_">createServer</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">req,res</span>)&#123;<br>    <span class="hljs-keyword">var</span> params = urllib.<span class="hljs-title function_">parse</span>(req.<span class="hljs-property">url</span>,<span class="hljs-literal">true</span>);<br>    <span class="hljs-keyword">if</span>(params.<span class="hljs-property">query</span>.<span class="hljs-property">callback</span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(params.<span class="hljs-property">query</span>.<span class="hljs-property">callback</span>);<br>        <span class="hljs-comment">//jsonp</span><br>        <span class="hljs-keyword">var</span> str = params.<span class="hljs-property">query</span>.<span class="hljs-property">callback</span> + <span class="hljs-string">&#x27;(&#x27;</span> + <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(data) + <span class="hljs-string">&#x27;)&#x27;</span>;<br>        res.<span class="hljs-title function_">end</span>(str);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        res.<span class="hljs-title function_">end</span>();<br>    &#125;<br>    <br>&#125;).<span class="hljs-title function_">listen</span>(port,<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;jsonp server is on&#x27;</span>);<br>&#125;);<br><br></code></pre></td></tr></table></figure><p> 然而，这个实现虽然简单，但有一些不足的地方：</p><ol><li>我们传递的回调必须是一个全局方法，我们都知道要尽量减少全局的方法。</li><li>需要加入一些参数校验，确保接口可以正常执行。 </li></ol><h3 id="4、-可靠的jsonp实现"><a href="#4、-可靠的jsonp实现" class="headerlink" title="4、 可靠的jsonp实现"></a>4、 可靠的jsonp实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs javascript">(<span class="hljs-keyword">function</span> (<span class="hljs-params"><span class="hljs-variable language_">global</span></span>) &#123;<br>    <span class="hljs-keyword">var</span> id = <span class="hljs-number">0</span>,<br>        container = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementsByTagName</span>(<span class="hljs-string">&quot;head&quot;</span>)[<span class="hljs-number">0</span>];<br><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">jsonp</span>(<span class="hljs-params">options</span>) &#123;<br>        <span class="hljs-keyword">if</span>(!options || !options.<span class="hljs-property">url</span>) <span class="hljs-keyword">return</span>;<br><br>        <span class="hljs-keyword">var</span> scriptNode = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&quot;script&quot;</span>),<br>            data = options.<span class="hljs-property">data</span> || &#123;&#125;,<br>            url = options.<span class="hljs-property">url</span>,<br>            callback = options.<span class="hljs-property">callback</span>,<br>            fnName = <span class="hljs-string">&quot;jsonp&quot;</span> + id++;<br><br>        <span class="hljs-comment">// 添加回调函数</span><br>        data[<span class="hljs-string">&quot;callback&quot;</span>] = fnName;<br><br>        <span class="hljs-comment">// 拼接url</span><br>        <span class="hljs-keyword">var</span> params = [];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> data) &#123;<br>            params.<span class="hljs-title function_">push</span>(<span class="hljs-built_in">encodeURIComponent</span>(key) + <span class="hljs-string">&quot;=&quot;</span> + <span class="hljs-built_in">encodeURIComponent</span>(data[key]));<br>        &#125;<br>        url = url.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&quot;?&quot;</span>) &gt; <span class="hljs-number">0</span> ? (url + <span class="hljs-string">&quot;&amp;&quot;</span>) : (url + <span class="hljs-string">&quot;?&quot;</span>);<br>        url += params.<span class="hljs-title function_">join</span>(<span class="hljs-string">&quot;&amp;&quot;</span>);<br>        scriptNode.<span class="hljs-property">src</span> = url;<br><br>        <span class="hljs-comment">// 传递的是一个匿名的回调函数，要执行的话，暴露为一个全局方法</span><br>        <span class="hljs-variable language_">global</span>[fnName] = <span class="hljs-keyword">function</span> (<span class="hljs-params">ret</span>) &#123;<br>            callback &amp;&amp; <span class="hljs-title function_">callback</span>(ret);<br>            container.<span class="hljs-title function_">removeChild</span>(scriptNode);<br>            <span class="hljs-keyword">delete</span> <span class="hljs-variable language_">global</span>[fnName];<br>        &#125;<br><br>        <span class="hljs-comment">// 出错处理</span><br>        scriptNode.<span class="hljs-property">onerror</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>            callback &amp;&amp; <span class="hljs-title function_">callback</span>(&#123;<span class="hljs-attr">error</span>:<span class="hljs-string">&quot;error&quot;</span>&#125;);<br>            container.<span class="hljs-title function_">removeChild</span>(scriptNode);<br>            <span class="hljs-variable language_">global</span>[fnName] &amp;&amp; <span class="hljs-keyword">delete</span> <span class="hljs-variable language_">global</span>[fnName];<br>        &#125;<br><br>        scriptNode.<span class="hljs-property">type</span> = <span class="hljs-string">&quot;text/javascript&quot;</span>;<br>        container.<span class="hljs-title function_">appendChild</span>(scriptNode)<br>    &#125;<br><br>    <span class="hljs-variable language_">global</span>.<span class="hljs-property">jsonp</span> = jsonp;<br><br>&#125;)(<span class="hljs-variable language_">this</span>);<br><br></code></pre></td></tr></table></figure><p> <strong>使用示例</strong> </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">jsonp</span>(&#123;    url : <span class="hljs-string">&quot;www.example.com&quot;</span>,   <br> data : &#123;id : <span class="hljs-number">1</span>&#125;,    callback : <span class="hljs-keyword">function</span> (<span class="hljs-params">ret</span>)<br>&#123;    <br>     <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(ret);    &#125;&#125;);<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>javascript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jsonp原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试题总结</title>
    <link href="/2014/05/17/lin-first-blog/"/>
    <url>/2014/05/17/lin-first-blog/</url>
    
    <content type="html"><![CDATA[<!-- --- title  标题  标题会显示在最上方居中位置     date  建立日期    如果不指定则为默认值-文件创建日期，可以自定义。 updated  更新日期  如果不指定则为默认值-文件修改后重新生成静态文件的日期。 comments  是否开启文章的评论功能 默认值为true tags  标签（不适用于页面page布局） categories  分类（不适用于页面page布局） permalink  覆盖文章网址 keywords  仅用于 meta 标签和 Open Graph 的关键词（不推荐使用） --- --><h4 id="1-说说你对盒子模型的理解"><a href="#1-说说你对盒子模型的理解" class="headerlink" title="1.    说说你对盒子模型的理解"></a>1.    说说你对盒子模型的理解</h4><p>标准盒子模型： </p><ul><li>content（内容）</li><li>margin（外边距） ：盒子与盒子之间的距离。</li><li>padding（内边距）：内容与边框的距离。</li><li>border（边框） </li></ul><p>IE盒子模型（怪异盒模型）</p><ul><li>content </li><li>margin </li></ul><p> 开发中往往使用IE盒模型，只需要设置box-sizing：border-box </p><p>盒⼦模型的实际宽度:width+左右padding+左右border</p><p>盒⼦模型的实际高度:height+左右padding+左右border</p><h4 id="2-css选择器有哪些？优先级？哪些属性可以继承？"><a href="#2-css选择器有哪些？优先级？哪些属性可以继承？" class="headerlink" title="2.    css选择器有哪些？优先级？哪些属性可以继承？"></a>2.    css选择器有哪些？优先级？哪些属性可以继承？</h4><ul><li><p>id选择器（#box），选择id为box的元素</p></li><li><p>类选择器（.one），选择类名为one的所有元素</p></li><li><p>标签选择器（div），选择标签为div的所有元素</p></li><li><p>后代选择器（#box  div），选择id为box元素内部所有的div元素</p></li><li><p>通配符选择器(*) </p></li><li><p>伪类选择器(a:hover, li:nth-child) </p></li></ul><p><strong>优先级</strong></p><p> 内联 &gt; ID选择器 &gt; 类选择器 &gt; 标签选择器 &gt;子代选择器&gt;后代选择器&gt;通配符选择器&gt;伪类选择器</p><p>可继承的属性：font-size, font-family, color， line-height：行高 </p><p>不可继承的属性：border, padding, margin, width, height</p><h4 id="3-元素水平垂直居中的方法有哪些？如果元素不定宽高呢？"><a href="#3-元素水平垂直居中的方法有哪些？如果元素不定宽高呢？" class="headerlink" title="3.    元素水平垂直居中的方法有哪些？如果元素不定宽高呢？"></a>3.    元素水平垂直居中的方法有哪些？如果元素不定宽高呢？</h4><ul><li><p>使用绝对定位：position:absolute;    left:0,    top:0,    bottom:0,    right:0,    margin:auto。</p></li><li><p>使用flex布局：display：flex，aligin-item：center，justify-content：center。</p></li><li><p>使用表格中属性：display：table-cell，text-align：center</p></li><li><p>使用text-align：center水平居中，使用line-height：父元素的高度</p></li></ul><h4 id="4-怎么理解回流跟重绘？什么场景下会触发？"><a href="#4-怎么理解回流跟重绘？什么场景下会触发？" class="headerlink" title="4.    怎么理解回流跟重绘？什么场景下会触发？"></a>4.    怎么理解回流跟重绘？什么场景下会触发？</h4><p>回流一定会触发重绘，重绘不能触发回流。</p><p>回流的代价高，只要元素结构发生变化就有可能全部重新渲染。</p><p>回流：当渲染树中的一些元素结构，窗口大小，位置发生变化，浏览器就会重新渲染文档这个过程叫做回流。（连锁反应）</p><p>重绘：当页面样式发生改变而不影响它在文档流中的位置，布局不会发生改变这个过程叫做重绘。</p><p>导致回流的操作：</p><ul><li>页面重新渲染</li><li>页面内容改变</li><li>添加和删除节点</li><li>浏览器窗口大小发生改变</li></ul><p>导致重绘的操作：</p><ul><li>背景颜色   透明度   阴影  发生改变。</li></ul><p>如何避免减少回流？</p><ul><li>css<ul><li>避免设置多层内联样式。</li><li>避免使用table布局</li><li>避免使用CSS表达式</li></ul></li><li>JavaScript<ul><li>避免频繁操作样式。</li><li>避免频繁操作DOM。创建一个documentFragment，在它上面应用所有DOM操作，最后再把它添加到文档中。</li><li>可以先为元素设置为不可见：display: none，操作结束后再把它显示出来。</li></ul></li></ul><h4 id="5-什么是响应式设计？响应式设计的基本原理是什么？如何做？"><a href="#5-什么是响应式设计？响应式设计的基本原理是什么？如何做？" class="headerlink" title="5.    什么是响应式设计？响应式设计的基本原理是什么？如何做？"></a>5.    什么是响应式设计？响应式设计的基本原理是什么？如何做？</h4><p>响应式设计就是：页面布局可以响应不同尺寸的屏幕，同一个页面，随着屏幕尺寸的改变，自适应的改变页面布局。</p><p>原理：利用CSS3媒体查询，为不同尺寸的设备适配不同样式。</p><p> 实现响应式布局的方式有如下 ：</p><ul><li> 媒体查询：    通过给不同分辨率的设备编写不同的样式。</li><li> 百分比：          当浏览器高度，宽度发生变化时，样式也会随着变化。</li><li> vw/vh：          vw表示视图窗口的宽度，vh表示视图窗口高度。 </li><li> rem ：             根据根元素html的font-size属性。 </li></ul><h4 id="6-如果要做优化，CSS提高性能的方法有哪些？"><a href="#6-如果要做优化，CSS提高性能的方法有哪些？" class="headerlink" title="6.    如果要做优化，CSS提高性能的方法有哪些？"></a>6.    如果要做优化，CSS提高性能的方法有哪些？</h4><p> 加载性能： </p><ul><li> css压缩：使用webpack将写好的css进行打包压缩，可以减少很多的体积 。</li><li> 减少使用@import,而建议使用link，因为后者在页面加载时一起加载，前者是等待页面加载完成之后再进行加载。  </li></ul><p> 选择器性能： </p><ul><li> 避免使用通配规则。 *{}计算次数惊人！只对需要用到的元素进行选择 。</li><li> 尽量少的去对标签进行选择，而是用class。  </li></ul><p> 渲染性能： </p><ul><li> 尽量减少页面重排、重绘 。</li><li> 属性值为0时，不加单位。 </li></ul><h4 id="7-对前端工程师这个职位是怎么样理解的？它的前景会怎么样"><a href="#7-对前端工程师这个职位是怎么样理解的？它的前景会怎么样" class="headerlink" title="7.    对前端工程师这个职位是怎么样理解的？它的前景会怎么样"></a>7.    对前端工程师这个职位是怎么样理解的？它的前景会怎么样</h4><p>理解：</p><p>前端工程师是跟用户最贴合的一个职位。一个产品的好坏并不是企业说了算，是用户喜欢的才是好的产品。而用户所能评价的就是他可以看到的，可以触摸到的。前端工程师要做的就是呈现给用户这些信息。</p><p>前景：</p><p>web前端人才需求量是比较大的。</p><p>同时他的就业方向多：包括网站，h5页面，小程序，APP等等，就需要前端开发工程师岗位。具体就业方向还可以按公司所需技术来区分，前端已经变得越来越广泛。</p><span id="more"></span><h4 id="8-说说JavaScript中的数据类型？存储上的差别？"><a href="#8-说说JavaScript中的数据类型？存储上的差别？" class="headerlink" title="8.    说说JavaScript中的数据类型？存储上的差别？"></a>8.    说说JavaScript中的数据类型？存储上的差别？</h4><p>基本数据类型：string，number，boolean，undefind，null，symbol，bigint</p><p>复杂数据类型：object，function，array，data，math</p><p>存储差别：</p><ul><li>基本数据类型存储在栈当中，固定大小，占空间小，适于频繁调用。</li><li>复杂数据类型存放在堆中，大小不固定，占空间大。并且在栈中存储了指向堆实体的指针，使用时会检索栈中的地址，再去堆中拿到实体。</li></ul><h4 id="9-typeof-与-instanceof-区别"><a href="#9-typeof-与-instanceof-区别" class="headerlink" title="9.    typeof 与 instanceof 区别"></a>9.    typeof 与 instanceof 区别</h4><p>typeof：可以正确判断基本数据类型，除了null外（object）。他不能正确判断复杂数据类型，除function外都是object。</p><p>instanceof：可以正确判断复杂数据类型，其内部机制是根据判断对象的原型链上是否含有该类型，是返回true，不是返回false。不能直接判断基本数据类型。</p><p>可使用原型判断的方式：</p><p>object.prototype.toString().call()：判断object类型的，直接调用toString()就可以返回正确类型，其他对象必须使用.call（）方法，才能返回正确的类型信息 。</p><h4 id="10-说说你对闭包的理解？闭包使用场景"><a href="#10-说说你对闭包的理解？闭包使用场景" class="headerlink" title="10.   说说你对闭包的理解？闭包使用场景"></a>10.   说说你对闭包的理解？闭包使用场景</h4><p>闭包就是一个有权访问其他函数里的变量及参数。最常见创建闭包的形式就是一个函数内嵌套一个函数。内部函数可以访问外部函数的变量和参数。突破了作用域。</p><p>两个用处：封装私有属性及私有方法。     可以读取函数内部的变量，并且不会被回收。</p><p> 闭包的使用场景： </p><ol><li>返回一个函数</li><li>函数赋值，将内部函数赋值给外部变量</li><li>返回一个函数，作为函数参数传递 </li></ol><h4 id="11-bind、call、apply-区别？如何实现一个bind"><a href="#11-bind、call、apply-区别？如何实现一个bind" class="headerlink" title="11.   bind、call、apply 区别？如何实现一个bind?"></a>11.   bind、call、apply 区别？如何实现一个bind?</h4><p>三者都可以改变函数的<code>this</code>对象指向</p><p>三者第一个参数都是<code>this</code>要指向的对象，如果没有这个参数或参数为<code>undefined</code>或<code>null</code>，则默认指向全局<code>window</code>。</p><p>call()传递参数是以参数列表的形式，apply是以数组的形式。这两者都是调用之后立即执行。</p><p>bind()返回一个绑定this之后的函数。bind第一个参数就作为运行时的this。</p><p>实现<code>bind</code>的步骤，我们可以分解成为三部分：</p><ul><li><p>修改<code>this</code>指向</p></li><li><p>动态传递参数</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 方式一：只在bind中传递函数参数</span><br>fn.<span class="hljs-title function_">bind</span>(obj,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)()<br> <br><span class="hljs-comment">// 方式二：在bind中传递函数参数，也在返回函数中传递参数</span><br>fn.<span class="hljs-title function_">bind</span>(obj,<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><ul><li>兼容<code>new</code>关键字</li></ul><h4 id="12-说说你对事件循环的理解"><a href="#12-说说你对事件循环的理解" class="headerlink" title="12.   说说你对事件循环的理解"></a>12.   说说你对事件循环的理解</h4><p>event loop过程1：</p><ul><li>同步代码，一行一行在call stack（执行栈）执行</li><li>遇到异步，会先“记录”下，等待时机（定时，网络请求等）</li><li>时机到了，就移动到 Callback  Queue （回调队列）</li></ul><p>event loop过程2：</p><ul><li>如Call Stack为空（及代码执行完）Event loop 开始工作</li><li>轮询查找Callback  Queue，如有则移动到 Call Stack执行</li><li>然后继续轮询查找（永动机一样）</li></ul><p>宏任务：</p><ul><li>js代码</li><li>setTimeout</li><li>Ajax</li><li>Dom事件</li></ul><p>微任务：</p><ul><li>Promise async/</li><li>nextTick（Node.js）</li><li>MutaionObserver</li></ul><h4 id="13-DOM常见的操作有哪些"><a href="#13-DOM常见的操作有哪些" class="headerlink" title="13.   DOM常见的操作有哪些"></a>13.   DOM常见的操作有哪些</h4><ul><li><p>创建dom节点</p><ul><li>document.createElement(‘元素名’);            创建新的元素节点</li><li>document.createAttribute(‘属性名’);           创建新的属性节点</li><li>document.createTextNode(‘⽂本内容’);      创建新的⽂本节点</li><li>document.createComment(‘注释节点’);      创建新的注释节点</li><li>document.createDocumentFragment();     创建文档片段节点</li></ul></li><li><p>访问/获取节点</p><ul><li>getElementById(‘id属性值’);                            返回拥有指定id的第⼀个对象的引⽤</li><li>getElementsByClassName(‘class属性值’);返回拥有指定class的对象集合</li><li>getElementsByTagName(‘标签名’);              返回拥有指定标签名的对象集合</li><li>getElementsByName(‘name属性值’);          返回拥有指定名称的对象结合</li><li>querySelector(‘CSS选择器’);                             仅返回第⼀个匹配的元素</li><li>querySelectorAll(‘CSS选择器’);                        返回所有匹配的元素</li><li>document.documentElement;                         获取页⾯中的HTML标签</li><li>document.body ；                                                  获取页面body标签</li></ul></li><li><p>添加节点</p><ul><li>appendChild 添加节点</li></ul></li><li><p>删除节点</p><ul><li>parentNode.removeChild( existingChild );   删除已有的⼦节点，返回值为删除节点</li><li>element.removeAttribute(‘属性名’);                 删除具有指定属性名称的属性，⽆返回值</li><li>element.removeAttributeNode( attrNode ); 删除指定属性，返回值为删除的属性</li></ul><p>修改节点内容</p><ul><li>style   设置css样式</li><li>innerHTML  修改节点内容</li><li>innerText   修改内容，也可添加一个节点</li></ul></li></ul><h4 id="14-说说你对BOM的理解，常见的BOM对象你了解哪些？"><a href="#14-说说你对BOM的理解，常见的BOM对象你了解哪些？" class="headerlink" title="14.   说说你对BOM的理解，常见的BOM对象你了解哪些？"></a>14.   说说你对BOM的理解，常见的BOM对象你了解哪些？</h4><p> <code>BOM</code> (Browser Object <a href="https://so.csdn.net/so/search?q=Model&spm=1001.2101.3001.7020">Model</a>)，浏览器对象模型，提供了内容与浏览器窗口进行交互的对象。</p><p>Bom作用：跟浏览器做一些交互效果。比如：页面的前进，后退，刷新，滚动条的滚动，鼠标的坐标 。</p><p>五个对象：</p><ul><li>window <ul><li><code>Bom</code>的核心对象是<code>window</code> ， 在全局作用域中声明的变量、函数都会变成<code>window</code>对象的属性和方法 </li></ul></li><li>location<ul><li> <code>location.reload()</code>，此方法可以重新刷新当前页面 。修改location，会重载页面。</li></ul></li><li>navigator    <ul><li>主要用来获取浏览器的属性，区分浏览器类型。</li></ul></li><li>history  <ul><li>主要用来操作浏览器<code>URL</code>的历史记录，可以通过参数向前，向后，或者向指定<code>URL</code>跳转 </li><li><code>history.go()</code></li><li><code>history.forward()</code>：向前跳转一个页面</li><li><code>history.back()</code>：向后跳转一个页面</li><li><code>history.length</code>：获取历史记录数</li></ul></li><li>screen  <ul><li>保存的是客户端的信息。比如像素的宽和高。</li></ul></li></ul><h4 id="15-Javascript本地存储的方式有哪些？区别及应用场景？"><a href="#15-Javascript本地存储的方式有哪些？区别及应用场景？" class="headerlink" title="15.   Javascript本地存储的方式有哪些？区别及应用场景？"></a>15.   Javascript本地存储的方式有哪些？区别及应用场景？</h4><ul><li>cookie</li><li>sessionStorage</li><li>locaStorage</li></ul><p>区别：</p><ul><li>cookie存储大小不能超过4k，http始终携带cookie，即使不使用。是为了解决 <code>HTTP</code> 无状态导致的问题。适合保存很小的数据。sessionStorage和localStorage比cookis大得多，可以达到5m或者更多。</li><li>cookie具有时效，时间过后清除数据。  sessionStorage是在关闭当前对话也就是当前页面清除缓存。locaStorage只有手动清除，否侧一直存在。适合做持久化。</li><li>sessionStorage只在当前浏览器窗口共享，locaStorage，cookie在所有同源浏览器窗口共享。</li></ul><h4 id="16-什么是防抖和节流？有什么区别？如何实现？"><a href="#16-什么是防抖和节流？有什么区别？如何实现？" class="headerlink" title="16.   什么是防抖和节流？有什么区别？如何实现？"></a>16.   什么是防抖和节流？有什么区别？如何实现？</h4><ul><li>防抖：在一定的时间后调用函数，如果在这段时间内重新调用该函数，则重新计算执行时间。只执行最后一次。</li><li>节流：持续触发一个事件，每隔一段时间，只执行一次事件。控制执行的次数以及事件触发的频率。从而提高性能。</li></ul><p>相同点：</p><ul><li>都可以通过使用 setTimeout 实现目的都是，降低回调执行频率。节省计算资源</li></ul><p>不同点：</p><ul><li>函数防抖，利用clearTimeout和 setTimeout实现。</li><li>防抖关注一定时间连续触发的事件，只在最后执行一次，而函数节流一段时间内只执行一次。</li></ul><p>应用场景： </p><p>​        1.scroll事件滚动触发</p><p>​        2.搜索框输入查询</p><p>​        3.表单验证</p><p>​        4.按钮提交事件</p><p>​        5.浏览器窗口缩放，resize事件</p><h4 id="17-如何通过JS判断一个数组"><a href="#17-如何通过JS判断一个数组" class="headerlink" title="17.   如何通过JS判断一个数组"></a>17.   如何通过JS判断一个数组</h4><ul><li> isArray()数组自带的判断方法 </li><li> instanceof  判断类型</li><li> constructor.toString()方法 </li><li> Object.prototype.toString.call(a) 原型方法</li></ul><h4 id="18-说说你对作用域链的理解"><a href="#18-说说你对作用域链的理解" class="headerlink" title="18.   说说你对作用域链的理解"></a>18.   说说你对作用域链的理解</h4><p>作用域的作用就是保证有权被访问的变量及函数的有序性，作用域链的变量只能向上访问，不能向下访问。当访问到window对象时终止。作用链就是变量和函数的可访问范围，控制变量和函数的可见性及生命周期。</p><h4 id="19-JavaScript原型，原型链-有什么特点？"><a href="#19-JavaScript原型，原型链-有什么特点？" class="headerlink" title="19.   JavaScript原型，原型链 ? 有什么特点？"></a>19.   JavaScript原型，原型链 ? 有什么特点？</h4><ul><li>原型： 每个对象都会在其内部初始化一个属性，就是<code>__proto__</code> （原型）。还预置了prototype属性。构造函数创建实例时，该prototype属性值就会被作为实例对象的原型proto。</li><li>原型链：当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，那么它就会去它的原型对象里找这个属性，这个原型对象又会有自己的原型，于是就这样一直找下去， 直到找到属性/方法或 <code>undefined</code> 为止 ，也就是原型链的概念 。</li><li>特点： javascript对象是通过引用来传递的，当修改原型时，与之相关的对象也会继承这一改变 。</li></ul><h4 id="20-请解释什么是事件代理"><a href="#20-请解释什么是事件代理" class="headerlink" title="20.   请解释什么是事件代理"></a>20.   请解释什么是事件代理</h4><p>事件代理也就是事件委托，将原本需要绑定的事件委托给父元素。让父元素去监听。其原理就是：dom元素的事件冒泡。好处：节省大量内存，减少事件注册，提高性能。当新增子对象时无需再次绑定。</p><h4 id="21-谈谈This对象的理解"><a href="#21-谈谈This对象的理解" class="headerlink" title="21.   谈谈This对象的理解"></a>21.   谈谈This对象的理解</h4><ul><li>this总是指向函数的直接调用者</li><li>如果有new关键字，this指向new出来的这个实例对象</li><li>在事件中，this指向触发这个事件的对象。</li><li>IE中，this总是指向全局对象window。</li><li>箭头函数没有this，箭头函数的this指向上一级的函数。</li><li>可通过apply，call，bind来改变this指向。</li></ul><h4 id="22-new操作符具体干了什么"><a href="#22-new操作符具体干了什么" class="headerlink" title="22.   new操作符具体干了什么"></a>22.   new操作符具体干了什么</h4><ul><li>创建一个空对象，并且this引用该对象，也继承了该对象的原型。</li><li>将所有的属性，方法都添加到了this引用的这个对象。</li><li>新创建的对象由this引用，最后隐式的返回this。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">mynew</span>(<span class="hljs-params">Func, ...args</span>) &#123;<br>    <span class="hljs-comment">// 1.创建一个新对象</span><br>    <span class="hljs-keyword">const</span> obj = &#123;&#125;<br>    <span class="hljs-comment">// 2.新对象原型指向构造函数原型对象</span><br>    obj.<span class="hljs-property">__proto__</span> = <span class="hljs-title class_">Func</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span><br>    <span class="hljs-comment">// 3.将构建函数的this指向新对象</span><br>    <span class="hljs-keyword">let</span> result = <span class="hljs-title class_">Func</span>.<span class="hljs-title function_">apply</span>(obj, args)<br>    <span class="hljs-comment">// 4.根据返回值判断</span><br>    <span class="hljs-keyword">return</span> result <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Object</span> ? result : obj<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="23-null，undefined-的区别"><a href="#23-null，undefined-的区别" class="headerlink" title="23.   null，undefined 的区别"></a>23.   null，undefined 的区别</h4><ul><li>undefinded：表示没有不存在的值，一个缺少值。此处应有值，但没定义。读取时，返回undefined。</li><li>null：表示一个空对象，没有任何属性及方法。对比验证时使用===。</li></ul><h4 id="24-javascript-代码中的”use-strict”-是什么意思"><a href="#24-javascript-代码中的”use-strict”-是什么意思" class="headerlink" title="24.   javascript 代码中的”use strict”;是什么意思"></a>24.   javascript 代码中的”use strict”;是什么意思</h4><p>use strict是 es5添加的一种严格运行模式，这种模式使JavaScript能够在更严格的条件下运行。使js编码更加规范，消除了一些不严谨，不合理之处。</p><h4 id="25-同步和异步的区别"><a href="#25-同步和异步的区别" class="headerlink" title="25.   同步和异步的区别"></a>25.   同步和异步的区别</h4><p>同步是阻塞模式，异步是非阻塞模式。</p><ul><li>同步<ul><li>同步是指一个进程在执行某个请求时，该请求需要一定时间返回消息。那么这个进程就会一直等待下去，直到返回消息后，才执行下面的操作。</li></ul></li><li>异步<ul><li>异步是指不需要一直等待下去，而是继续执行下面的操作。不管其他进程的状态，当返回消息时，系统会通知该进程进行处理。提高了执行效率。</li></ul></li></ul><h4 id="26-谈一谈箭头函数与普通函数的区别"><a href="#26-谈一谈箭头函数与普通函数的区别" class="headerlink" title="26.   谈一谈箭头函数与普通函数的区别"></a>26.   谈一谈箭头函数与普通函数的区别</h4><ul><li>语法形式不同，箭头函数更简短</li><li>没有单独的<code>this</code></li><li>不绑定<code>arguments</code></li><li>不能使用<code>new</code>操作</li><li>没有<code>prototype</code>属性</li><li>通过<code>call</code>或<code>apply</code>调用会忽略第一个参数，只能传递参数，不能绑定<code>this</code></li><li>不能使用<code>yield</code>关键字</li></ul><h4 id="27-JS-数组和对象的遍历方式，以及几种方式的比较"><a href="#27-JS-数组和对象的遍历方式，以及几种方式的比较" class="headerlink" title="27.   JS 数组和对象的遍历方式，以及几种方式的比较"></a>27.   JS 数组和对象的遍历方式，以及几种方式的比较</h4><ul><li>for in 循环 </li><li>for  of循环 </li><li>forEach循环</li><li>map循环</li></ul><p>区别：</p><ul><li>for in循环 和 for循环 性能低。</li><li>for in适合遍历对象，for of适合遍历数组。for in遍历的是数组的索引，对象的key值，以及原型链上的属性 。</li><li>forEach ⽆法遍历对象  forEach ⽆法使⽤ break ， continue 跳出循环，且使⽤ return 是跳过本次循环 。</li><li>map可以return出一个新数组，原数组不会改变 。⽆法遍历对象 。</li></ul><h4 id="28-如何解决跨域问题"><a href="#28-如何解决跨域问题" class="headerlink" title="28.   如何解决跨域问题"></a>28.   如何解决跨域问题</h4><p>产生跨域的是因为浏览器的同源策略，同源策略是一种约定，它是浏览器最核心也最基本的安全功能。所谓同源是指 协议 域名 端口 三者一致。若其中一项不一致就会产生跨域。</p><ul><li>jsonp跨域<ul><li>只可以使用get方式提交。设置请求url –》 参数拼接  –》创建script节点  –》  返回数据，清除script。</li></ul></li><li>nginx代理跨域</li><li>node中间件跨域</li><li>cors后端头部设置安全域名<ul><li>需要浏览器和服务器的支持，自动完成跨域。添加一些头部信息。</li></ul></li></ul><h4 id="29-XML和JSON的区别"><a href="#29-XML和JSON的区别" class="headerlink" title="29.   XML和JSON的区别"></a>29.   XML和JSON的区别</h4><p>json是一个轻量的数据交换格式。是javascript的一个子集。</p><p>xml是纯文本的格式的，可扩展标记语言。</p><ul><li>JSON 比 XML 体积小，传递速度快。</li><li>JSON对jacascript交互更方便，更容易解析。</li><li>JSON 比 XML 传输速度快很多。</li><li>JSON对数据的描述性差。</li></ul><h4 id="30-谈谈你对webpack的看法"><a href="#30-谈谈你对webpack的看法" class="headerlink" title="30.   谈谈你对webpack的看法"></a>30.   谈谈你对webpack的看法</h4><p>webpack是一个模块打包工具，可以使用webpack管理模块依赖，并编译除模块所需的静态文件。打包web开发中所用到的html，css，js等静态文件。提高开发效率。对于不同的类型的资源，webpack由相对应的模块加载器。webpack会分析模块间的相关依赖，最后生成优化后的静态资源。</p><h4 id="31-webpack的打包原理"><a href="#31-webpack的打包原理" class="headerlink" title="31.   webpack的打包原理"></a>31.   webpack的打包原理</h4><p> <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/71b263000fa94db792cf1e98d67a578a~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="img"> </p><ul><li>初始化参数：从配置文件和 Shell 语句中读取并合并参数，得出最终的配置参数。</li><li>开始编译：从上一步得到的参数初始化 <code>Compiler</code> 对象，加载所有配置的插件，执行对象的 <code>run</code> 方法开始执行编译。</li><li>确定入口：根scope据配置中的 <code>entry</code> 找出所有的入口文件。</li><li>编译模块：从入口文件出发，调用所有配置的 <code>loader</code> 对模块进行翻译，再找出该模块依赖的模块，这个步骤是递归执行的，直至所有入口依赖的模块文件都经过本步骤的处理。</li><li>完成模块编译：经过第 4 步使用 loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系。</li><li>输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 <code>chunk</code>，再把每个 <code>chunk</code> 转换成一个单独的文件加入到输出列表，这一步是可以修改输出内容的最后机会。</li><li>输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。</li></ul><p> webpack打包原理是将根据文件间的依赖关系对其进行静态分析，然后将这些模块按指定规则生成静态资源，当 webpack处理程序时，会递归地构建一个依赖关系图，其中包含应用程序需要的每个模块，然后将所所有这些模块打包成bundle。 </p><p>从配置文件中读取所需要的参数，并且加载所有的插件，开始执行编译。找到entry入口文件。调用loader对模板进行递归解析翻译。等确定每个模块的依赖关系后，将他们组装成一个个包含多个模块的chunk。确定好内容后，根据出口配置将打包后的文件写入到具体位置。</p><h4 id="32-如何优化webpack打包速度"><a href="#32-如何优化webpack打包速度" class="headerlink" title="32.   如何优化webpack打包速度"></a>32.   如何优化webpack打包速度</h4><ul><li><p>优化 loader 配置：           减少文件的搜索范围，使用test，include，exclude。</p></li><li><p>使用image-webpack-loader进行图片压缩</p></li><li><p>terser启用多线程 ：        使用多进程并行运行来提高构建速度</p></li><li><p>使用 cache-loader：      将开销较大的loader结果缓存到磁盘</p></li><li><p>优化 resolve.modules:    指明存放第三方模块的绝对路径，以减少寻找 。</p></li><li><p>优化 resolve.alias</p></li><li><p>使用 DLLPlugin 插件</p></li><li><p>合理使用 sourceMap</p></li></ul><h4 id="33-说说webpack中常见的Loader？解决了什么问题？"><a href="#33-说说webpack中常见的Loader？解决了什么问题？" class="headerlink" title="33.   说说webpack中常见的Loader？解决了什么问题？"></a>33.   说说webpack中常见的Loader？解决了什么问题？</h4><p>webpack默认情况下，只支持对js，json文件打包。像css，less，png等这些类型文件，webpack需要采用相对应的loader（模块加载器）进行解析。</p><p>关于<code>loader</code>的配置，我们是写在<code>module.rules</code>属性中，属性介绍如下：</p><ul><li><code>rules</code>是一个数组的形式，因此我们可以配置很多个<code>loader</code></li><li>每一个<code>loader</code>对应一个对象的形式，对象属性<code>test</code> 为匹配的规则，一般情况为正则表达式</li><li>属性<code>use</code>针对匹配到文件类型，调用对应的 <code>loader</code> 进行处理</li></ul><p>常见的<code>loader</code>如下：</p><ul><li>style-loader: 将css添加到DOM的内联样式标签style里</li><li>css-loader :允许将css文件通过require的方式引入，并返回css代码</li><li>less-loader: 处理less</li><li>sass-loader: 处理sass</li><li>babel-loader :用babel来转换ES6文件到ES5</li><li>file-loader: 分发文件到output目录并返回相对路径</li><li>url-loader: 和file-loader类似，但是当文件小于设定的limit时可以返回一个Data Url</li></ul><p>css-loader:        分析 <code>css</code> 模块之间的关系，并合成⼀个 <code>css</code></p><p>staly-loader:    把 <code>css-loader</code> 生成的内容，用 <code>style</code> 标签挂载到页面的 <code>head</code> 中</p><p>less-loader:      开发中，我们也常常会使用<code>less</code>、<code>sass</code>、<code>stylus</code>预处理器编写<code>css</code>样式，使开发效率提高，这里需要使用<code>less-loader</code> </p><p>url-loader:        可以处理 <code>file-loader</code> 所有的事情，遇到图片格式的模块，可以选择性的把图片转成 <code>base64</code> 格式的字符串，并打包到 <code>js</code> 中，对小体积的图片比较合适，大图片不合适。 </p><h4 id="34-说说webpack中常见的Plugin？解决了什么问题？"><a href="#34-说说webpack中常见的Plugin？解决了什么问题？" class="headerlink" title="34.   说说webpack中常见的Plugin？解决了什么问题？"></a>34.   说说webpack中常见的Plugin？解决了什么问题？</h4><p>plugin是插件，对于webpack本身的扩展，是一个扩展器。</p><p>配置方式：写在plugins属性中传入new实例对象，他是个数组，可以写多个插件。</p><p>下面介绍几个常用的插件用法：</p><ul><li>HtmlWebpackPlugin<ul><li> ⾃动生成⼀个 <code>html</code> ⽂文件，并把打包生成的<code>js</code> 模块引⼊到该 <code>html</code> 中 </li></ul></li><li>clean-webpack-plugin<ul><li> 删除（清理）构建目录 </li></ul></li><li>mini-css-extract-plugin<ul><li>提取css到一个单独文件中</li></ul></li><li>copy-webpack-plugin<ul><li>复制文件或目录到执行区域。</li></ul></li></ul><h4 id="35-说说你对promise的了解"><a href="#35-说说你对promise的了解" class="headerlink" title="35.    说说你对promise的了解"></a>35.    说说你对promise的了解</h4><p>promise是es6新增的语法，解决了回调地狱的问题。（ 多个异步任务顺序执行，形成的多层回调函数的嵌套结构，就称为回调地狱现象 ）。</p><p>promise有三个状态：pending等待初始化状态，resolved成功的状态，rejected成功的状态。变化不可逆。</p><p>promise构造函数内代码是同步的，而之后then和catch执行的是异步的。构造函数接收两个参数resolve和reject。他们的执行是传递给then，catch，表示成功的回调及失败的回调。</p><h4 id="36-async函数是什么，有什么作用"><a href="#36-async函数是什么，有什么作用" class="headerlink" title="36.    async函数是什么，有什么作用"></a>36.    async函数是什么，有什么作用</h4><p>async/await 是为了简化使用基于promiseAPI的一种语法（语法糖）。async和await简化了promise的异步行为，不用链式的调用promise。</p><p>async表示是异步操作，await表示跟在表达式后面等待结果。await只能在async函数中有效，不然会报错。async返回一个promise对象，可以使用then方法添加回调函数。不管是不是promise对象，都会被包装成promise对象。async函数内部会被await阻塞并按顺序执行代码。也可使用try..catch进行异常处理。</p><h4 id="37-有使用过vue吗？说说你对vue的理解"><a href="#37-有使用过vue吗？说说你对vue的理解" class="headerlink" title="37.    有使用过vue吗？说说你对vue的理解"></a>37.    有使用过vue吗？说说你对vue的理解</h4><p>vue是一个构建用户界面的渐进式框架。vue所关注的核心是视图层。有一套精简的mvvm框架。</p><p>vue是一款轻量级别的框架，适合开发小型项目。</p><p>vue核心特性：</p><ul><li>数据驱动（MVVM<code>表示的是 </code>Model-View-ViewModel）<ul><li>Model：模型层，负责处理业务逻辑以及和服务器端进行交互</li><li>View：视图层：负责将数据渲染出来展示页面，可以简单的理解为HTML页面</li><li>ViewModel：视图模型层，用来连接Model和View，是Model和View之间的通信桥梁。</li></ul></li><li>组件化开发<ul><li>组件可以重复使用。提高开发效率。高内聚低耦合。</li><li>提高可维护性，每个组件的职责单一 。</li></ul></li><li>有着一套丰富的vue指令<ul><li>条件渲染指令 <code>v-if</code></li><li>列表渲染指令<code>v-for</code></li><li>属性绑定指令<code>v-bind</code></li><li>事件绑定指令<code>v-on</code></li><li>双向数据绑定指令<code>v-model</code></li></ul></li></ul><h4 id="38-你对SPA单页面的理解，它的优缺点分别是什么？如何实现SPA应用呢"><a href="#38-你对SPA单页面的理解，它的优缺点分别是什么？如何实现SPA应用呢" class="headerlink" title="38.    你对SPA单页面的理解，它的优缺点分别是什么？如何实现SPA应用呢"></a>38.    你对SPA单页面的理解，它的优缺点分别是什么？如何实现SPA应用呢</h4><p> SPA仅在Web页面初始化时加载相应的HTML、JavaScript和CSS。一旦页面加载完成,SPA不会因为用户操作而进行页面的重新加载或跳转;取而代之的是利用JavaScript实现HTML内容变换,UI与用户的交互,避免页面的重新加载。 </p><p>优点：</p><ul><li>用户体验好、快，内容的改变不需要重新加载整个页面</li><li>SPA相对于服务器压力小; </li><li>良好的前后端分离，分工更明确。</li></ul><p>缺点：</p><ul><li>不利于搜索引擎的抓取</li><li>首次加载页面速度比较慢</li></ul><p>实现：</p><ul><li>hash模式<ul><li>通过onhashchange监听路由的改变，从而跳转路由更新页面。</li></ul></li><li>history模式<ul><li>history采用HTML5的新特性；pushState()添加历史记录，replaceState()修改浏览器历史记录。</li><li>通过popState()监听路由的改变，从而触发路由跳转和页面更新。</li></ul></li></ul><h4 id="39-SPA首屏加载速度慢的怎么解决？"><a href="#39-SPA首屏加载速度慢的怎么解决？" class="headerlink" title="39.    SPA首屏加载速度慢的怎么解决？"></a>39.    SPA首屏加载速度慢的怎么解决？</h4><ul><li>减小入口文件积<ul><li>路由懒加载，不同组件的分割。</li></ul></li><li>静态资源本地缓存</li><li>UI框架按需加载</li><li>开启GZip压缩</li><li>使用服务器端渲染SSR（nuxt.js）</li><li>图片资源的压缩</li></ul><h4 id="40-VUE路由的原理"><a href="#40-VUE路由的原理" class="headerlink" title="40.    VUE路由的原理"></a>40.    VUE路由的原理</h4><p>hash：</p><ul><li>其中对象中的location.hash储存的是路由的地址、可以赋值改变其URL的地址。而这会触发hashchange事件，而通过window.addEventListener监听hash值然后去匹配对应的路由、从而渲染页面的组件 。</li></ul><p>history：</p><ul><li>history采用HTML5的新特性，通过 pushState 和 replaceState 两个方法来实现 URL 的变化</li><li>可以通过 popstate 事件来监听 URL 的变化，从而对页面进行跳转（渲染）</li></ul><h4 id="41-Vue中组件和插件有什么区别？"><a href="#41-Vue中组件和插件有什么区别？" class="headerlink" title="41.    Vue中组件和插件有什么区别？"></a>41.    Vue中组件和插件有什么区别？</h4><p> 组件 <code>(Component)</code> 是用来构成 <code>App</code> 的业务模块，它的目标是 <code>App.vue</code>。  在<code>Vue</code>中每一个<code>.vue</code>文件都可以视为一个组件 </p><p>插件就是指对<code>Vue</code>的功能的增强或补充。</p><p>编写形式区别：</p><ul><li>组件是以.vue后缀结尾的组件，包含三部分。template，script，style。</li><li>插件需要暴露一个install方法，第一个参数是vue构造器，第二个参数是可选对象。</li></ul><p>注册形式区别：</p><ul><li>组件是在main.js中全局注册vue.component(),局部注册就是在组件内。</li><li>插件在main.js中使用vue实例vue.use（插件名）</li></ul><h4 id="42-Vue组件之间的通信方式都有哪些"><a href="#42-Vue组件之间的通信方式都有哪些" class="headerlink" title="42.    Vue组件之间的通信方式都有哪些"></a>42.    Vue组件之间的通信方式都有哪些</h4><ul><li>父子组件之间的通信<ul><li>使用props进行传递</li></ul></li><li>兄弟组件之间的通信<ul><li>使用eventbus  vue实例进行传递</li></ul></li><li>provide 和  inject<ul><li>在祖先组件定义<code>provide</code>属性，返回传递的值</li><li>在后代组件通过<code>inject</code>接收组件传递过来的值</li></ul></li><li>vuex</li></ul><h1 id="43-你了解vue的diff算法吗？说说看"><a href="#43-你了解vue的diff算法吗？说说看" class="headerlink" title="43.    你了解vue的diff算法吗？说说看"></a>43.    你了解vue的diff算法吗？说说看</h1><p> diff的过程就是调用名为patch的函数，比较新旧节点，一边比较一边给真实的DOM打补丁 。</p><p>原理：当数据发生改变时，<code>set</code>方法会调用<code>Dep.notify</code>通知所有订阅者<code>Watcher</code>，调用<code>patch</code>给真实的<code>DOM</code>打补丁，更新相应的视图 。</p><p>其有两个特点：</p><ul><li>比较只会在同层级进行, 不会跨层级比较</li><li>在diff比较的过程中，循环从两边向中间比较</li><li>同一个节点，进行最小量的更新。</li></ul><p> diff 算法的在很多场景下都有应用，在 vue 中，作用于虚拟 dom 渲染成真实 dom 的新旧 VNode 节点比较 </p><p>Diff算法的步骤：</p><ul><li>用 JavaScript 对象结构表示 DOM 树的结构；然后用这个树构建一个真正的 DOM 树，插到文 档当中。</li><li>当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较(diff)，记录两棵树差异。</li><li>把第二棵树所记录的差异应用到第一棵树所构建的真正的DOM树上(patch)，视图就更新了。</li></ul><h4 id="44-为什么需要-Virtual-Dom"><a href="#44-为什么需要-Virtual-Dom" class="headerlink" title="44.   为什么需要 Virtual Dom"></a>44.   为什么需要 Virtual Dom</h4><ul><li><p>DOM的操作本身是性能会出现问题，操作比较复杂的</p></li><li><p>MVVM框架解决视图和状态同步问题</p></li><li><p>模板引擎可以简化视图操作，没办法跟踪状态（无法得知当前页面变化之前的状态）</p></li><li><p>虚拟DOM能够跟踪状态变化</p></li><li><p>虚拟DOM可以维护程序的状态，跟踪上一次的状态，通过比较前后两次状态差异更新真实DOM</p></li></ul><p><strong>虚拟 DOM 的作用</strong></p><ul><li>维护视图和状态的关系</li><li>复杂视图情况下提升渲染性能</li><li>除了渲染 <code>DOM</code> 以外，还可以实现 <code>SSR(Nuxt.js/Next.js)</code>、原生应用(<code>Weex/React Native</code>)、小程序(<code>mpvue/uni-app</code>)等</li></ul><h4 id="45-Vue3-0的设计目标是什么？做了哪些优化"><a href="#45-Vue3-0的设计目标是什么？做了哪些优化" class="headerlink" title="45.   Vue3.0的设计目标是什么？做了哪些优化"></a>45.   Vue3.0的设计目标是什么？做了哪些优化</h4><p>设计目标：</p><ul><li>打包体积更小： <code>Vue3</code>移除一些不常用的 <code>API</code> ， 将无用模块“剪辑”，仅打包需要的，使打包的整体体积变小了 </li><li>速度更快： diff算法优化，静态提升。</li><li>更灵活的代码组织能力：推出Composition API，大大增加了代码的逻辑组织能力和代码复用能力。</li></ul><p>优化方案：</p><ul><li>源码<ul><li>使用ts语法，源码的优化。</li></ul></li><li>性能<ul><li>体积，编译，数据劫持优化。</li></ul></li><li>语法 API<ul><li>组合式API，根据相关逻辑组织代码。</li></ul></li></ul><h4 id="46-Vue3-0-所采用的-Composition-Api-与-Vue2-x-使用的-Options-Api-有什么不同？"><a href="#46-Vue3-0-所采用的-Composition-Api-与-Vue2-x-使用的-Options-Api-有什么不同？" class="headerlink" title="46.   Vue3.0 所采用的 Composition Api 与 Vue2.x 使用的 Options Api 有什么不同？"></a>46.   Vue3.0 所采用的 Composition Api 与 Vue2.x 使用的 Options Api 有什么不同？</h4><ul><li>Options：</li></ul><p>​                         在一个vue文件中的data，methods，computed…定义属性和方法，共同处理页面逻辑。</p><p>​                         缺点：一个功能的实现    需要不同的vue配置项，定义属性方法比较分散。大项目methods可能                                    包含多个方法，这可能会导致组件难以阅读和理解。</p><p>​                         优点：新手入门会比较简单。</p><ul><li><p>Compositions API:</p><p>​                一个功能的所有api会放在一起（高内聚，低耦合），方便找到功能所对应的方法及属性。</p><p>​                缺点：学习思维方式改变。</p><p>​                优点：根据逻辑相关性组织代码，提高可读性和可维护性，基于函数组合的API。</p></li></ul><h4 id="47-说一下Vue数据响应式的原理"><a href="#47-说一下Vue数据响应式的原理" class="headerlink" title="47.   说一下Vue数据响应式的原理"></a>47.   说一下Vue数据响应式的原理</h4><p>当一个vue实例被创建时，vue会遍历data选项的属性。采用数据劫持结合发布/订阅者模式，用es5的object.defindproerty将他们转化为getter/setter，并在内部追踪相关依赖。在属性被访问和修改时通知变化。也就是observer使用object.defindproerty来监听数据的读写。读取数据时，调用get方法通知dep收集订阅者（watcher）。添加到dep的一个属性subs数组里。   修改数据时，调用set方法，通知dep数据改变了。 使用notify方法遍历subs里面的watcher，调用watcher的update（）方法。创建出一个新的dom树与原本旧的dom树做对比，从而更新视图。</p><h4 id="48-说说对-React-的理解？有哪些特性？"><a href="#48-说说对-React-的理解？有哪些特性？" class="headerlink" title="48.   说说对 React 的理解？有哪些特性？"></a>48.   说说对 React 的理解？有哪些特性？</h4><p> 由FaceBook在2011年开发的。React用于构建用户界面的 JavaScript 库 ，声明式编程，组件化开发。</p><ol><li><p>它使用**虚拟DOM **而不是真正的DOM。</p></li><li><p>它可以用<strong>服务器端渲染</strong>。</p></li><li><p>它遵循<strong>单向数据流</strong>或数据绑定。</p></li><li><p>使用jsx语法，将html和css代码写入到一个js文件。</p></li></ol><h4 id="49-说说-Real-DOM-和-Virtual-DOM-的区别？优缺点？"><a href="#49-说说-Real-DOM-和-Virtual-DOM-的区别？优缺点？" class="headerlink" title="49.   说说 Real DOM 和 Virtual DOM 的区别？优缺点？"></a>49.   说说 Real DOM 和 Virtual DOM 的区别？优缺点？</h4><p> Real DOM（真实的dom），在页面渲染出的每个节点都是一个真实的DOM结构 。</p><p> Virtual DOM （虚拟dom），是一个轻量级的js对象，它最初只是real DOM的副本，也是一个节点树。将属性和内容作为该对象的属性。 </p><p>区别：</p><ul><li><p>虚拟dom会减少重绘和回流，而真实dom会频繁进行重绘和回流。</p></li><li><p>虚拟dom的总损耗是”虚拟dom的增删改+真实dom的<strong>差异</strong>增删改+重排“；真实dom的消耗是”真实dom全部增删改+重排“</p></li></ul><p>真实dom：  优点：直接操作html，易用。    缺点：解析速度慢，效率低，内存占用高。， 频繁操作真实                                              DOM，导致重绘、 回流</p><p>虚拟dom：  优点：减少真实dom的频繁更新，减少重绘，回流，占内存少。  跨平台：一套react代码可以多                        端运行 </p><p>​                        缺点：初次渲染时，多了一层虚拟dom计算，速度慢些。</p><h4 id="50-说说-React-生命周期有哪些不同阶段？每个阶段对应的方法是？"><a href="#50-说说-React-生命周期有哪些不同阶段？每个阶段对应的方法是？" class="headerlink" title="50.   说说 React 生命周期有哪些不同阶段？每个阶段对应的方法是？"></a>50.   说说 React 生命周期有哪些不同阶段？每个阶段对应的方法是？</h4><p> <code>React</code>生命周期就是从创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、卸载等这一过程 。</p><ul><li>创建阶段<ul><li>render     用于渲染<code>DOM</code>结构，可以访问组件<code>state</code>与<code>prop</code>属性 </li><li>componentDidMount     组件挂载到真实<code>DOM</code>节点后执行，其在<code>render</code>方法之后执行 </li><li>constructor      初始化<code>state</code>状态 </li></ul></li><li>更新阶段<ul><li>componentDidUpdate        组件更新结束后触发 </li><li>shouldComponentUpdate    告诉组件本身是否需要重新渲染，默认false。</li><li>render      用于渲染<code>DOM</code>结构</li></ul></li><li>卸载阶段<ul><li><em><strong>componentWillUnmount</strong></em><strong>()</strong> – 从 DOM 卸载组件前调用。   </li></ul></li></ul><h4 id="51-说说-React中的setState执行机制"><a href="#51-说说-React中的setState执行机制" class="headerlink" title="51.   说说 React中的setState执行机制"></a>51.   说说 React中的setState执行机制</h4><p> 当需要修改状态时通过调用<code>setState</code>来改变，从而达到更新组件内部数据的作用 。</p><p>当使用setState（）更新状态后，然后会执行render函数，从而导致页面的视图更新。</p><p>更新类型：</p><ul><li>异步更新<ul><li>在组件生命周期或React合成事件中，setState是异步</li></ul></li><li>同步更新<ul><li>在setTimeout或者原生dom事件中，setState是同步</li></ul></li></ul><h4 id="52-说说对React中类组件和函数组件的理解？有什么区别？"><a href="#52-说说对React中类组件和函数组件的理解？有什么区别？" class="headerlink" title="52.   说说对React中类组件和函数组件的理解？有什么区别？"></a>52.   说说对React中类组件和函数组件的理解？有什么区别？</h4><p>类组件：通过使用es6类的编写形式来定义，继承React.Component。如果想要访问父组件传递过来的参数，可通过this.props来拿到。使用render方法，返回一个react对象。</p><p>函数组件：通过函数来编写一个react组件，函数第一个参数用于接收父组件传过来的参数。</p><p>在hooks出来之前，函数式组件时没有生命周期的，以及无法定义状态。现在可以使用useState定义状态。</p><p>useEffect定义生命周期。类式组件是不能使用hooks的。</p><h4 id="53-说说对React-Hooks的理解？解决了什么问题？"><a href="#53-说说对React-Hooks的理解？解决了什么问题？" class="headerlink" title="53.   说说对React Hooks的理解？解决了什么问题？"></a>53.   说说对React Hooks的理解？解决了什么问题？</h4><p>hooks是react 16版本以后新增的特性，可以在不写class组件的情况下使用state及其他属性。</p><p>useState（）定义组件状态       useEffect（）定义组件生命周期，第一个参数相当于 componentDidMount 和 componentDidUpdate 。第二个参数是个列表。可以返回一个函数，相当于 componentwillUnmount 销毁生命周期。     useReducer，useRef。</p><p>解决：</p><ul><li>每调用useHook一次都会生成一份独立的状态</li><li>通过自定义hook能够更好的封装我们的功能</li></ul><p>hook的出现，使函数式组件拥有了类式组件的相似功能。还可以进行代码复用。</p><h4 id="54-说说你对Redux的理解？其工作原理？"><a href="#54-说说你对Redux的理解？其工作原理？" class="headerlink" title="54.   说说你对Redux的理解？其工作原理？"></a>54.   说说你对Redux的理解？其工作原理？</h4><p>redux与vux相似，也是将组件状态进行集中管理。相当于管理组件状态的一个工具。</p><p> <strong>Redux三大原则</strong> ：</p><ul><li>单一数据源</li><li>state是只读的</li><li>使用纯函数修改状态</li></ul><p>redux三大核心：</p><ul><li>action：    动作对象，两个参数type，和data</li><li>reducer：   用于初始化状态，加工状态</li><li>store</li></ul><p>原理： 页面需要获取数据时，通过Action creates创建一个action动作对象，提交dispatch请求给store。store通知reducer进行匹配action的属性type。从而进行返回一个新的对象。</p><h4 id="55-说说-React-性能优化的手段有哪些"><a href="#55-说说-React-性能优化的手段有哪些" class="headerlink" title="55.   说说 React 性能优化的手段有哪些"></a>55.   说说 React 性能优化的手段有哪些</h4><ul><li>为避免不必要的render渲染，可以使用shouldComponentUpdate。</li><li>避免使用内联函数</li><li>懒加载组件</li><li>服务端渲染</li><li>事件绑定方式 </li><li>列表渲染的时候加key</li><li>避免使用内联样式属性</li></ul><h4 id="56-vue、react、angular-区别"><a href="#56-vue、react、angular-区别" class="headerlink" title="56.   vue、react、angular 区别"></a>56.   vue、react、angular 区别</h4><ul><li>angular是基于MVC架构，vue和react都是基于虚拟dom。</li><li><strong>Angular</strong>使用的是双向数据绑定，<strong>React</strong>用的是单数据流的，而<strong>Vue</strong>则支持两者。 </li><li>vue与angular自带的渲染指令不同。react没有渲染指令。</li><li>react使用jsx语法，angular使用ts语法。    </li></ul><h4 id="57-说说你对-TypeScript-的理解？与-JavaScript-的区别"><a href="#57-说说你对-TypeScript-的理解？与-JavaScript-的区别" class="headerlink" title="57.   说说你对 TypeScript 的理解？与 JavaScript 的区别"></a>57.   说说你对 TypeScript 的理解？与 JavaScript 的区别</h4><p> typescript是一个强类型的JavaScript超集， 支持面向对象编程的概念，如类、接口、继承、泛型等 ，可编译为纯JavaScript 。typescrit可以在任何浏览器运行。但是不能直接运行，需要一个编译器编译成javascript文件。</p><p>区别：</p><ul><li><p>ts支持es6语法，js不支持es6。</p></li><li><p>ts支持模块，js不支持模块。</p></li><li><p>js中没有静态类型的概念。</p></li><li><p>TypeScript 文件的后缀名 .ts （.ts，.tsx，.dts），JavaScript 文件是 .js</p></li></ul><h4 id="58-说说你对-TypeScript-中泛型的理解？应用场景？"><a href="#58-说说你对-TypeScript-中泛型的理解？应用场景？" class="headerlink" title="58.   说说你对 TypeScript 中泛型的理解？应用场景？"></a>58.   说说你对 TypeScript 中泛型的理解？应用场景？</h4><p>泛型是设计语言的一种风格或规范。</p><p> 泛型（Generics）是指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性 。</p><p> 泛型通过<code>&lt;&gt;</code>的形式进行表述，可以声明 ：函数，类，接口。</p><h4 id="59-说说你对微信小程序的理解？优缺点？"><a href="#59-说说你对微信小程序的理解？优缺点？" class="headerlink" title="59.   说说你对微信小程序的理解？优缺点？"></a>59.   说说你对微信小程序的理解？优缺点？</h4><p>小程序是一种不需要下载安装即可使用的应用，用户扫一扫或者搜一下即可打开应用。</p><p>也体现了“用完即走”的理念，用户不用关心是否安装太多应用的问题。应用将无处不在，随时可用，但又无需安装卸载。</p><p>注意的是，除了微信小程序，还有百度小程序、支付宝小程序、抖音小程序，都是每个平台自己开发的，都是有针对性平台的应用程序。</p><p>优点：</p><ul><li>随搜随用，用完即走：使得小程序可以代替许多APP，或是做APP的整体嫁接，或是作为阉割版功能的承载体</li><li>流量大，易接受：小程序借助自身平台更加容易引入更多的流量</li><li>安全</li><li>开发门槛低</li><li>降低兼容性限制</li></ul><p>缺点：</p><ul><li>用户留存：及相关数据显示，小程序的平均次日留存在13%左右，但是双周留存骤降到仅有1%</li><li>体积限制：微信小程序只有2M的大小，这样导致无法开发大型一些的小程序</li><li>受控微信：比起APP，尤其是安卓版的高自由度，小程序要面对很多来自微信的限制，从功能接口，甚至到类别内容，都要接受微信的管控</li></ul><h4 id="60-说说你对发布订阅、观察者模式的理解？区别？"><a href="#60-说说你对发布订阅、观察者模式的理解？区别？" class="headerlink" title="60.   说说你对发布订阅、观察者模式的理解？区别？"></a>60.   说说你对发布订阅、观察者模式的理解？区别？</h4><ul><li><p>发布订阅模式三个角色：订阅者，发布者。信号中心。</p><ul><li> 我们假定，存在一个”信号中心”，某个任务执行完成，就向信号中心”发布”(publish)一个信 号，其他任务可以向信号中心”订阅”(subscribe)这个信号，从而知道什么时候自己可以开始执 行。这就叫做”发布/订阅模式” </li><li> 例子： Vue 的自定义事件 ， 兄弟组件通信， 模拟 Vue 自定义事件的实现 </li></ul></li><li><p>观察者模式三个角色：</p><ul><li>观察者(订阅者)–Watcher        <ul><li><code>update()</code>:当事件发生时，具体要做的事情</li></ul></li><li>目标(发布者) –Dep<ul><li><code>subs</code> 数组:存储所有的观察者</li><li><code>addSub()</code>:添加观察者</li><li><code>notify()</code>:当事件发生，调用所有观察者的 <code>update()</code> 方法</li></ul></li><li>没有事件中心</li></ul></li></ul><p><strong>发布/订阅模式</strong>由统一信号中心调用，因此发布者和订阅者不需要知道对方的存在</p><p><strong>观察者模式</strong>是由具体目标调动，比如当事件触发，<code>Dep</code> 就会去调用观察者的方法，所以观察者模 式的订阅者与发布者之间是存在依赖的</p><h4 id="61-项目做过哪些性能优化"><a href="#61-项目做过哪些性能优化" class="headerlink" title="61.   项目做过哪些性能优化"></a>61.   项目做过哪些性能优化</h4><ul><li><p>减少 <code>HTTP</code> 请求数</p></li><li><p>减少<code>DOM</code> 操作</p></li><li><p>压缩css，js，图片等</p></li><li><p>在外部使用js和css</p></li><li><p>路由懒加载，图片懒加载</p></li><li><p>减少重绘，和回流。</p></li><li><p>ui框架按需加载</p></li><li><p>减少 <code>DNS</code> 查询</p></li><li><p>使用 <code>CDN</code></p></li><li><p>避免重定向</p></li><li><p>减少 <code>DOM</code> 元素数量</p></li><li><p>优化 <code>CSS Sprite</code></p></li><li><p>使用 <code>iconfont</code></p></li><li><p>字体裁剪</p></li><li><p>多域名分发划分内容到不同域名</p></li><li><p>尽量减少 <code>iframe</code> 使用</p></li><li><p>避免图片 <code>src</code> 为空</p></li><li><p>把样式表放在<code>link</code> 中</p></li><li><p>把<code>JavaScript</code>放在页面底部</p></li></ul><h4 id="62-描述浏览器的渲染过程，DOM树和渲染树的区别"><a href="#62-描述浏览器的渲染过程，DOM树和渲染树的区别" class="headerlink" title="62.   描述浏览器的渲染过程，DOM树和渲染树的区别"></a>62.   描述浏览器的渲染过程，DOM树和渲染树的区别</h4><ul><li>浏览器的渲染过程：<ul><li>解析<code>HTML</code>构建 <code>DOM</code>(DOM树)，并请求 <code>css/image/js</code></li><li><code>CSS</code> 文件下载完成，开始构建 <code>CSSDOM</code>(<code>CSS</code>树)</li><li>css树构建结束后，和 <code>DOM</code> 一起生成 <code>Render Tree</code>(渲染树)</li><li>布局：计算出每个节点在屏幕中的位置</li><li>显示：通过显卡把页面画到屏幕上</li></ul></li><li><code>DOM</code>树 和 渲染树 的区别：<ul><li><code>DOM</code>树与<code>HTML</code>标签一一对应，包括<code>head</code>和隐藏元素</li><li>渲染树不包括<code>head</code>和隐藏元素，大段文本每一行都是独立节点，每一个节点都有对应的<code>css</code>属性。</li></ul></li></ul><h4 id="63-你认为什么样的前端代码是好的"><a href="#63-你认为什么样的前端代码是好的" class="headerlink" title="63.   你认为什么样的前端代码是好的"></a>63.   你认为什么样的前端代码是好的</h4><p>完成一个项目操作尽量是低代码，代码是高内聚，低耦合的。</p><p>代码维护性比较高，而且容易扩展的。遵循代码的规范。</p><h4 id="64-从浏览器地址栏输入url到显示页面的步骤"><a href="#64-从浏览器地址栏输入url到显示页面的步骤" class="headerlink" title="64.   从浏览器地址栏输入url到显示页面的步骤"></a>64.   从浏览器地址栏输入url到显示页面的步骤</h4><p>1，URL解析 ：判断url格式是否正确</p><p>2，DNS域名查询 ：获取域名对应的服务器IP地址</p><p>3，建立TCP连接： 三次握手建立TCP连接</p><p>4，发起http请求: 浏览器发送请求到目标服务器，进行逻辑操作</p><p>5，响应请求和页面渲染：服务器返回一个响应请求，响应完，当页面关闭，tcp经过四次挥手断开连接</p><p>6 ，页面渲染：浏览器拿到服务器响应返回的资源，解析 先对资源进行解析，比如重定向 储存cookie、解压gzip等</p><p>7，解析html，构建dom树。</p><p>8，解析css 生成css规则树。</p><p>9，合并dom树，生成rander树</p><p>10，布局rander树，绘制rander树，绘制页面像素信息</p><p>11最后，浏览器把信息给gpu将各层信息合并，显示到屏幕上；</p><h4 id="65-http-请求报文和响应报文的格式"><a href="#65-http-请求报文和响应报文的格式" class="headerlink" title="65.   http 请求报文和响应报文的格式"></a>65.   http 请求报文和响应报文的格式</h4><ul><li><p>向后端服务器发出一个web资源请求，称之为客户端向服务器端发出了一个http请求。</p><p>HTTP请求报文主要由请求行、请求头、请求正文3部分组成 。</p></li><li><p>响应就是后端服务器对该请求做了个处理，返回一些数据等等。</p><p>HTTP响应报文主要由响应行、响应头、响应正文3部分组成。</p></li></ul><h4 id="66-Token-cookie-session-区别"><a href="#66-Token-cookie-session-区别" class="headerlink" title="66.   Token cookie session 区别"></a>66.   Token cookie session 区别</h4><p> <strong>Session</strong>会话：客户端A访问服务器，服务器存储A的数据value，把key返回给客户端A，客户端A下次带着key（<a href="https://so.csdn.net/so/search?q=session&spm=1001.2101.3001.7020">session</a> ID）来访问服务器，服务器就能给出客户端A的数据。 </p><p> <strong>Cookie</strong>：客户端A访问服务器，服务器返回cookie给客户端A，客户端A存储cookie，下次需要带着cookie访问服务器，服务器返回相应的数据。 </p><p> <strong>Token</strong>令牌：客户端A访问服务器，服务器给了客户端token，客户端A拿着token访问服务器，服务器验证token，返回数据。 </p><ul><li><code>cookie</code> 数据存放在浏览器上，session 数据存放在服务器上</li><li><code>cookie</code> 不是很安全，别人可以分析存放在本地的cookie 并进行 cookie 欺骗 考虑到安全应当使用 session</li><li><code>session</code> 会在一定时间内保存在服务器上。当访问增多，服务器性能会变差，这时应当使用cookie。</li><li>单个 <code>cookie</code> 保存的数据不能超过 <code>4K</code>，很多浏览器都限制一个站点最多保存 20 个 <code>cookie</code>。session是根据服务器大小来定。</li></ul><p>token：</p><p> token是服务器生成的一串字符串，作为客户端进行请求的一个令牌。 </p><p>token比较安全，cookie容易伪造，但是token不容易伪造，盗取。</p><h4 id="67-CORS跨域的原理"><a href="#67-CORS跨域的原理" class="headerlink" title="67.   CORS跨域的原理"></a>67.   CORS跨域的原理</h4><ul><li>当我们发起跨域请求时，如果是非简单请求，浏览器会帮我们自动触发预检请求，也就是 options请求，用于确认目标资源是否支持跨域。如果是简单请求，则不会触发预检，直接发出正常请求。</li><li>浏览器会根据服务端响应的 header 自动处理剩余的请求，如果响应支持跨域，则继续发出正常请求，如果不支持，则在控制台显示错误。</li></ul><h4 id="68-什么是MVVM"><a href="#68-什么是MVVM" class="headerlink" title="68.   什么是MVVM"></a>68.   什么是MVVM</h4><p>mvvm就是modle –view  –viewmodle。mvvm是一种设计思想 。</p><p>modle：模型层，用于处理逻辑和服务器的交互。</p><p>view：视图层，用于将数据渲染在页面上。UI视图。</p><p>view-modle：视图模型层，用来连接Model和View，是Model和View之间的通信桥梁。达到数据驱动视图的效果。</p><p> MVVM模式简化了界面与业务的依赖，解决了数据频繁更新。MVVM 在使用当中，利用双向绑定技术，使得 Model 变化时，ViewModel 会自动更新，而 ViewModel 变化时，View 也会自动变化。 </p><h4 id="69-说说你对版本管理的理解？常用的版本管理工具有哪些？"><a href="#69-说说你对版本管理的理解？常用的版本管理工具有哪些？" class="headerlink" title="69.   说说你对版本管理的理解？常用的版本管理工具有哪些？"></a>69.   说说你对版本管理的理解？常用的版本管理工具有哪些？</h4><p>简单来说： 你的修改只要提到到版本控制系统，基本都可以找回，版本控制系统就像一台时光机器，可以让你回到任何一个时间点 。</p><p>三个分类：</p><ul><li>本地版本控制系统</li><li>集中式版本控制系统    优点：适合多人团队协作开发，代码集中管理。  缺点：必须联网，无法单机工作。<ul><li>SVN</li><li>CVS</li></ul></li><li>分布式版本控制系统    优点：适合多人团队协作开发，代码集中管理。可离线工作。<ul><li>Git       一般公司都是使用git和gitlab自己搭建版本控制环境。比较安全。</li><li>HG</li></ul></li></ul><h4 id="70-说说你对Git的理解？"><a href="#70-说说你对Git的理解？" class="headerlink" title="70.   说说你对Git的理解？"></a>70.   说说你对Git的理解？</h4><p>git是目前世界上最先进的分布式版本控制系统，快速高效的处理小型到大型项目的事务。</p><p> 当我们通过<code>git init</code>创建或者<code>git clone</code>一个项目的时候，项目目录会隐藏一个<code>.git</code>子目录，其作用是用来跟踪管理版本库的 。</p><p>特性：易于学习，占用内存小，具有闪电般快速的性能。</p><p>使用<code>Git</code>和<code>Gitlab</code>搭建版本控制环境是现在互联网公司最流行的版本控制方式。</p><h4 id="71-说说Git常用的命令有哪些"><a href="#71-说说Git常用的命令有哪些" class="headerlink" title="71.   说说Git常用的命令有哪些"></a>71.   说说Git常用的命令有哪些</h4><ul><li>git add  .  ：提交暂存区</li><li>git status：  查看当前分支状态</li><li>git  commit -m  ‘’ ：提交本地库</li><li>git pull  更新或合并</li><li>git push -u origin master   提交到远程仓库</li></ul><h4 id="72-说说-git-发生冲突的场景？如何解决？"><a href="#72-说说-git-发生冲突的场景？如何解决？" class="headerlink" title="72.   说说 git 发生冲突的场景？如何解决？"></a>72.   说说 git 发生冲突的场景？如何解决？</h4><p>多个分支修改了同一个文件，比如在项目开发中，需要写组件了。要注册路由，然后你增加了几个路由。在你提交前，已经有人提交了并且已经修改了路由文件。这时你提交就会冲突。</p><p>首先将修改过的文件add 提到暂存区，commit 提交本地库，git pull 更新合并代码。然后根据提示手动去解决冲突。</p><h4 id="73-loader和plugin的区别"><a href="#73-loader和plugin的区别" class="headerlink" title="73.  loader和plugin的区别"></a>73.  loader和plugin的区别</h4><p>对于loader，它是一个转换器，将A文件进行编译形成B文件，这里操作的是文件，比如将A.scss转换为A.css，单纯的文件转换过程。<br>plugin是一个插件，在webpack中相当于一个扩展器。是对现有webpack功能的一个扩展。针对于loader结束后，在webpack打包过程中并不是直接进行操作的，而是遵循事件机制工作的。会监听webpack打包过程中的某些节点，执行广泛的任务。</p>]]></content>
    
    
    <categories>
      
      <category>面试题总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>72道面试题总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>

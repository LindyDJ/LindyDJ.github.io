

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.ico">
  <link rel="icon" href="/img/fluid.ico">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="赵硕林">
  <meta name="keywords" content="">
  
    <meta name="description" content="1.    说说你对盒子模型的理解标准盒子模型：   content（内容） margin（外边距） ：盒子与盒子之间的距离。 padding（内边距）：内容与边框的距离。 border（边框）   IE盒子模型（怪异盒模型）  content  margin    开发中往往使用IE盒模型，只需要设置box-sizing：border-box  盒⼦模型的实际宽度:width+左右pa">
<meta property="og:type" content="article">
<meta property="og:title" content="面试题总结">
<meta property="og:url" content="http://example.com/2019/05/17/lin-first-blog/index.html">
<meta property="og:site_name" content="zhaoShuoLin的博客">
<meta property="og:description" content="1.    说说你对盒子模型的理解标准盒子模型：   content（内容） margin（外边距） ：盒子与盒子之间的距离。 padding（内边距）：内容与边框的距离。 border（边框）   IE盒子模型（怪异盒模型）  content  margin    开发中往往使用IE盒模型，只需要设置box-sizing：border-box  盒⼦模型的实际宽度:width+左右pa">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/71b263000fa94db792cf1e98d67a578a~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp">
<meta property="article:published_time" content="2019-05-17T10:52:54.000Z">
<meta property="article:modified_time" content="2022-05-25T13:54:10.181Z">
<meta property="article:author" content="赵硕林">
<meta property="article:tag" content="72道面试题总结">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/71b263000fa94db792cf1e98d67a578a~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp">
  
  
  
  <title>面试题总结 - zhaoShuoLin的博客</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.0","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>

  
<meta name="generator" content="Hexo 5.4.2"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Lin&#39;s blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="面试题总结"></span>
          
        </div>

        
          
  <div class="mt-3">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-author" aria-hidden="true"></i>
        赵硕林
      </span>
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2019-05-17 18:52" pubdate>
          2019年5月17日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          19k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          158 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">面试题总结</h1>
            
            <div class="markdown-body">
              
              <!-- ---
 title  标题  标题会显示在最上方居中位置    
 date  建立日期    如果不指定则为默认值-文件创建日期，可以自定义。
 update  更新日期  如果不指定则为默认值-文件修改后重新生成静态文件的日期。
 comments  是否开启文章的评论功能 默认值为true
 tags  标签（不适用于页面page布局）
 categories  分类（不适用于页面page布局）
 permalink  覆盖文章网址
 keywords  仅用于 meta 标签和 Open Graph 的关键词（不推荐使用） 
--- -->




<h4 id="1-说说你对盒子模型的理解"><a href="#1-说说你对盒子模型的理解" class="headerlink" title="1.    说说你对盒子模型的理解"></a>1.    说说你对盒子模型的理解</h4><p>标准盒子模型： </p>
<ul>
<li>content（内容）</li>
<li>margin（外边距） ：盒子与盒子之间的距离。</li>
<li>padding（内边距）：内容与边框的距离。</li>
<li>border（边框） </li>
</ul>
<p>IE盒子模型（怪异盒模型）</p>
<ul>
<li>content </li>
<li>margin </li>
</ul>
<p> 开发中往往使用IE盒模型，只需要设置box-sizing：border-box </p>
<p>盒⼦模型的实际宽度:width+左右padding+左右border</p>
<p>盒⼦模型的实际高度:height+左右padding+左右border</p>
<h4 id="2-css选择器有哪些？优先级？哪些属性可以继承？"><a href="#2-css选择器有哪些？优先级？哪些属性可以继承？" class="headerlink" title="2.    css选择器有哪些？优先级？哪些属性可以继承？"></a>2.    css选择器有哪些？优先级？哪些属性可以继承？</h4><ul>
<li><p>id选择器（#box），选择id为box的元素</p>
</li>
<li><p>类选择器（.one），选择类名为one的所有元素</p>
</li>
<li><p>标签选择器（div），选择标签为div的所有元素</p>
</li>
<li><p>后代选择器（#box  div），选择id为box元素内部所有的div元素</p>
</li>
<li><p>通配符选择器(*) </p>
</li>
<li><p>伪类选择器(a:hover, li:nth-child) </p>
</li>
</ul>
<p><strong>优先级</strong></p>
<p> 内联 &gt; ID选择器 &gt; 类选择器 &gt; 标签选择器 &gt;子代选择器&gt;后代选择器&gt;通配符选择器&gt;伪类选择器</p>
<p>可继承的属性：font-size, font-family, color， line-height：行高 </p>
<p>不可继承的属性：border, padding, margin, width, height</p>
<h4 id="3-元素水平垂直居中的方法有哪些？如果元素不定宽高呢？"><a href="#3-元素水平垂直居中的方法有哪些？如果元素不定宽高呢？" class="headerlink" title="3.    元素水平垂直居中的方法有哪些？如果元素不定宽高呢？"></a>3.    元素水平垂直居中的方法有哪些？如果元素不定宽高呢？</h4><ul>
<li><p>使用绝对定位：position:absolute;    left:0,    top:0,    bottom:0,    right:0,    margin:auto。</p>
</li>
<li><p>使用flex布局：display：flex，aligin-item：center，justify-content：center。</p>
</li>
<li><p>使用表格中属性：display：table-cell，text-align：center</p>
</li>
<li><p>使用text-align：center水平居中，使用line-height：父元素的高度</p>
</li>
</ul>
<h4 id="4-怎么理解回流跟重绘？什么场景下会触发？"><a href="#4-怎么理解回流跟重绘？什么场景下会触发？" class="headerlink" title="4.    怎么理解回流跟重绘？什么场景下会触发？"></a>4.    怎么理解回流跟重绘？什么场景下会触发？</h4><p>回流一定会触发重绘，重绘不能触发回流。</p>
<p>回流的代价高，只要元素结构发生变化就有可能全部重新渲染。</p>
<p>回流：当渲染树中的一些元素结构，窗口大小，位置发生变化，浏览器就会重新渲染文档这个过程叫做回流。（连锁反应）</p>
<p>重绘：当页面样式发生改变而不影响它在文档流中的位置，布局不会发生改变这个过程叫做重绘。</p>
<p>导致回流的操作：</p>
<ul>
<li>页面重新渲染</li>
<li>页面内容改变</li>
<li>添加和删除节点</li>
<li>浏览器窗口大小发生改变</li>
</ul>
<p>导致重绘的操作：</p>
<ul>
<li>背景颜色   透明度   阴影  发生改变。</li>
</ul>
<p>如何避免减少回流？</p>
<ul>
<li>css<ul>
<li>避免设置多层内联样式。</li>
<li>避免使用table布局</li>
<li>避免使用CSS表达式</li>
</ul>
</li>
<li>JavaScript<ul>
<li>避免频繁操作样式。</li>
<li>避免频繁操作DOM。创建一个documentFragment，在它上面应用所有DOM操作，最后再把它添加到文档中。</li>
<li>可以先为元素设置为不可见：display: none，操作结束后再把它显示出来。</li>
</ul>
</li>
</ul>
<h4 id="5-什么是响应式设计？响应式设计的基本原理是什么？如何做？"><a href="#5-什么是响应式设计？响应式设计的基本原理是什么？如何做？" class="headerlink" title="5.    什么是响应式设计？响应式设计的基本原理是什么？如何做？"></a>5.    什么是响应式设计？响应式设计的基本原理是什么？如何做？</h4><p>响应式设计就是：页面布局可以响应不同尺寸的屏幕，同一个页面，随着屏幕尺寸的改变，自适应的改变页面布局。</p>
<p>原理：利用CSS3媒体查询，为不同尺寸的设备适配不同样式。</p>
<p> 实现响应式布局的方式有如下 ：</p>
<ul>
<li> 媒体查询：    通过给不同分辨率的设备编写不同的样式。</li>
<li> 百分比：          当浏览器高度，宽度发生变化时，样式也会随着变化。</li>
<li> vw/vh：          vw表示视图窗口的宽度，vh表示视图窗口高度。 </li>
<li> rem ：             根据根元素html的font-size属性。 </li>
</ul>
<h4 id="6-如果要做优化，CSS提高性能的方法有哪些？"><a href="#6-如果要做优化，CSS提高性能的方法有哪些？" class="headerlink" title="6.    如果要做优化，CSS提高性能的方法有哪些？"></a>6.    如果要做优化，CSS提高性能的方法有哪些？</h4><p> 加载性能： </p>
<ul>
<li> css压缩：使用webpack将写好的css进行打包压缩，可以减少很多的体积 。</li>
<li> 减少使用@import,而建议使用link，因为后者在页面加载时一起加载，前者是等待页面加载完成之后再进行加载。  </li>
</ul>
<p> 选择器性能： </p>
<ul>
<li> 避免使用通配规则。 *{}计算次数惊人！只对需要用到的元素进行选择 。</li>
<li> 尽量少的去对标签进行选择，而是用class。  </li>
</ul>
<p> 渲染性能： </p>
<ul>
<li> 尽量减少页面重排、重绘 。</li>
<li> 属性值为0时，不加单位。 </li>
</ul>
<h4 id="7-对前端工程师这个职位是怎么样理解的？它的前景会怎么样"><a href="#7-对前端工程师这个职位是怎么样理解的？它的前景会怎么样" class="headerlink" title="7.    对前端工程师这个职位是怎么样理解的？它的前景会怎么样"></a>7.    对前端工程师这个职位是怎么样理解的？它的前景会怎么样</h4><p>理解：</p>
<p>前端工程师是跟用户最贴合的一个职位。一个产品的好坏并不是企业说了算，是用户喜欢的才是好的产品。而用户所能评价的就是他可以看到的，可以触摸到的。前端工程师要做的就是呈现给用户这些信息。</p>
<p>前景：</p>
<p>web前端人才需求量是比较大的。</p>
<p>同时他的就业方向多：包括网站，h5页面，小程序，APP等等，就需要前端开发工程师岗位。具体就业方向还可以按公司所需技术来区分，前端已经变得越来越广泛。</p>
<span id="more"></span>


<h4 id="8-说说JavaScript中的数据类型？存储上的差别？"><a href="#8-说说JavaScript中的数据类型？存储上的差别？" class="headerlink" title="8.    说说JavaScript中的数据类型？存储上的差别？"></a>8.    说说JavaScript中的数据类型？存储上的差别？</h4><p>基本数据类型：string，number，boolean，undefind，null，symbol，bigint</p>
<p>复杂数据类型：object，function，array，data，math</p>
<p>存储差别：</p>
<ul>
<li>基本数据类型存储在栈当中，固定大小，占空间小，适于频繁调用。</li>
<li>复杂数据类型存放在堆中，大小不固定，占空间大。并且在栈中存储了指向堆实体的指针，使用时会检索栈中的地址，再去堆中拿到实体。</li>
</ul>
<h4 id="9-typeof-与-instanceof-区别"><a href="#9-typeof-与-instanceof-区别" class="headerlink" title="9.    typeof 与 instanceof 区别"></a>9.    typeof 与 instanceof 区别</h4><p>typeof：可以正确判断基本数据类型，除了null外（object）。他不能正确判断复杂数据类型，除function外都是object。</p>
<p>instanceof：可以正确判断复杂数据类型，其内部机制是根据判断对象的原型链上是否含有该类型，是返回true，不是返回false。不能直接判断基本数据类型。</p>
<p>可使用原型判断的方式：</p>
<p>object.prototype.toString().call()：判断object类型的，直接调用toString()就可以返回正确类型，其他对象必须使用.call（）方法，才能返回正确的类型信息 。</p>
<h4 id="10-说说你对闭包的理解？闭包使用场景"><a href="#10-说说你对闭包的理解？闭包使用场景" class="headerlink" title="10.   说说你对闭包的理解？闭包使用场景"></a>10.   说说你对闭包的理解？闭包使用场景</h4><p>闭包就是一个有权访问其他函数里的变量及参数。最常见创建闭包的形式就是一个函数内嵌套一个函数。内部函数可以访问外部函数的变量和参数。突破了作用域。</p>
<p>两个用处：封装私有属性及私有方法。     可以读取函数内部的变量，并且不会被回收。</p>
<p> 闭包的使用场景： </p>
<ol>
<li>返回一个函数</li>
<li>函数赋值，将内部函数赋值给外部变量</li>
<li>返回一个函数，作为函数参数传递 </li>
</ol>
<h4 id="11-bind、call、apply-区别？如何实现一个bind"><a href="#11-bind、call、apply-区别？如何实现一个bind" class="headerlink" title="11.   bind、call、apply 区别？如何实现一个bind?"></a>11.   bind、call、apply 区别？如何实现一个bind?</h4><p>三者都可以改变函数的<code>this</code>对象指向</p>
<p>三者第一个参数都是<code>this</code>要指向的对象，如果没有这个参数或参数为<code>undefined</code>或<code>null</code>，则默认指向全局<code>window</code>。</p>
<p>call()传递参数是以参数列表的形式，apply是以数组的形式。这两者都是调用之后立即执行。</p>
<p>bind()返回一个绑定this之后的函数。bind第一个参数就作为运行时的this。</p>
<p>实现<code>bind</code>的步骤，我们可以分解成为三部分：</p>
<ul>
<li><p>修改<code>this</code>指向</p>
</li>
<li><p>动态传递参数</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 方式一：只在bind中传递函数参数</span><br>fn.<span class="hljs-title function_">bind</span>(obj,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)()<br> <br><span class="hljs-comment">// 方式二：在bind中传递函数参数，也在返回函数中传递参数</span><br>fn.<span class="hljs-title function_">bind</span>(obj,<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure>

<ul>
<li>兼容<code>new</code>关键字</li>
</ul>
<h4 id="12-说说你对事件循环的理解"><a href="#12-说说你对事件循环的理解" class="headerlink" title="12.   说说你对事件循环的理解"></a>12.   说说你对事件循环的理解</h4><p>event loop过程1：</p>
<ul>
<li>同步代码，一行一行在call stack（执行栈）执行</li>
<li>遇到异步，会先“记录”下，等待时机（定时，网络请求等）</li>
<li>时机到了，就移动到 Callback  Queue （回调队列）</li>
</ul>
<p>event loop过程2：</p>
<ul>
<li>如Call Stack为空（及代码执行完）Event loop 开始工作</li>
<li>轮询查找Callback  Queue，如有则移动到 Call Stack执行</li>
<li>然后继续轮询查找（永动机一样）</li>
</ul>
<p>宏任务：</p>
<ul>
<li>js代码</li>
<li>setTimeout</li>
<li>Ajax</li>
<li>Dom事件</li>
</ul>
<p>微任务：</p>
<ul>
<li>Promise async/</li>
<li>nextTick（Node.js）</li>
<li>MutaionObserver</li>
</ul>
<h4 id="13-DOM常见的操作有哪些"><a href="#13-DOM常见的操作有哪些" class="headerlink" title="13.   DOM常见的操作有哪些"></a>13.   DOM常见的操作有哪些</h4><ul>
<li><p>创建dom节点</p>
<ul>
<li>document.createElement(‘元素名’);            创建新的元素节点</li>
<li>document.createAttribute(‘属性名’);           创建新的属性节点</li>
<li>document.createTextNode(‘⽂本内容’);      创建新的⽂本节点</li>
<li>document.createComment(‘注释节点’);      创建新的注释节点</li>
<li>document.createDocumentFragment();     创建文档片段节点</li>
</ul>
</li>
<li><p>访问/获取节点</p>
<ul>
<li>getElementById(‘id属性值’);                            返回拥有指定id的第⼀个对象的引⽤</li>
<li>getElementsByClassName(‘class属性值’);返回拥有指定class的对象集合</li>
<li>getElementsByTagName(‘标签名’);              返回拥有指定标签名的对象集合</li>
<li>getElementsByName(‘name属性值’);          返回拥有指定名称的对象结合</li>
<li>querySelector(‘CSS选择器’);                             仅返回第⼀个匹配的元素</li>
<li>querySelectorAll(‘CSS选择器’);                        返回所有匹配的元素</li>
<li>document.documentElement;                         获取页⾯中的HTML标签</li>
<li>document.body ；                                                  获取页面body标签</li>
</ul>
</li>
<li><p>添加节点</p>
<ul>
<li>appendChild 添加节点</li>
</ul>
</li>
<li><p>删除节点</p>
<ul>
<li>parentNode.removeChild( existingChild );   删除已有的⼦节点，返回值为删除节点</li>
<li>element.removeAttribute(‘属性名’);                 删除具有指定属性名称的属性，⽆返回值</li>
<li>element.removeAttributeNode( attrNode ); 删除指定属性，返回值为删除的属性</li>
</ul>
<p>修改节点内容</p>
<ul>
<li>style   设置css样式</li>
<li>innerHTML  修改节点内容</li>
<li>innerText   修改内容，也可添加一个节点</li>
</ul>
</li>
</ul>
<h4 id="14-说说你对BOM的理解，常见的BOM对象你了解哪些？"><a href="#14-说说你对BOM的理解，常见的BOM对象你了解哪些？" class="headerlink" title="14.   说说你对BOM的理解，常见的BOM对象你了解哪些？"></a>14.   说说你对BOM的理解，常见的BOM对象你了解哪些？</h4><p> <code>BOM</code> (Browser Object <a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=Model&spm=1001.2101.3001.7020">Model</a>)，浏览器对象模型，提供了内容与浏览器窗口进行交互的对象。</p>
<p>Bom作用：跟浏览器做一些交互效果。比如：页面的前进，后退，刷新，滚动条的滚动，鼠标的坐标 。</p>
<p>五个对象：</p>
<ul>
<li>window <ul>
<li><code>Bom</code>的核心对象是<code>window</code> ， 在全局作用域中声明的变量、函数都会变成<code>window</code>对象的属性和方法 </li>
</ul>
</li>
<li>location<ul>
<li> <code>location.reload()</code>，此方法可以重新刷新当前页面 。修改location，会重载页面。</li>
</ul>
</li>
<li>navigator    <ul>
<li>主要用来获取浏览器的属性，区分浏览器类型。</li>
</ul>
</li>
<li>history  <ul>
<li>主要用来操作浏览器<code>URL</code>的历史记录，可以通过参数向前，向后，或者向指定<code>URL</code>跳转 </li>
<li><code>history.go()</code></li>
<li><code>history.forward()</code>：向前跳转一个页面</li>
<li><code>history.back()</code>：向后跳转一个页面</li>
<li><code>history.length</code>：获取历史记录数</li>
</ul>
</li>
<li>screen  <ul>
<li>保存的是客户端的信息。比如像素的宽和高。</li>
</ul>
</li>
</ul>
<h4 id="15-Javascript本地存储的方式有哪些？区别及应用场景？"><a href="#15-Javascript本地存储的方式有哪些？区别及应用场景？" class="headerlink" title="15.   Javascript本地存储的方式有哪些？区别及应用场景？"></a>15.   Javascript本地存储的方式有哪些？区别及应用场景？</h4><ul>
<li>cookie</li>
<li>sessionStorage</li>
<li>locaStorage</li>
</ul>
<p>区别：</p>
<ul>
<li>cookie存储大小不能超过4k，http始终携带cookie，即使不使用。是为了解决 <code>HTTP</code> 无状态导致的问题。适合保存很小的数据。sessionStorage和localStorage比cookis大得多，可以达到5m或者更多。</li>
<li>cookie具有时效，时间过后清除数据。  sessionStorage是在关闭当前对话也就是当前页面清除缓存。locaStorage只有手动清除，否侧一直存在。适合做持久化。</li>
<li>sessionStorage只在当前浏览器窗口共享，locaStorage，cookie在所有同源浏览器窗口共享。</li>
</ul>
<h4 id="16-什么是防抖和节流？有什么区别？如何实现？"><a href="#16-什么是防抖和节流？有什么区别？如何实现？" class="headerlink" title="16.   什么是防抖和节流？有什么区别？如何实现？"></a>16.   什么是防抖和节流？有什么区别？如何实现？</h4><ul>
<li>防抖：在一定的时间后调用函数，如果在这段时间内重新调用该函数，则重新计算执行时间。只执行最后            一次。</li>
<li>节流：持续触发一个事件，每隔一段时间，只执行一次事件。控制执行的次数以及事件触发的频率。从而                         提高性能。</li>
</ul>
<p>相同点：</p>
<ul>
<li>都可以通过使用 setTimeout 实现目的都是，降低回调执行频率。节省计算资源</li>
</ul>
<p>不同点：</p>
<ul>
<li>函数防抖，利用clearTimeout和 setTimeout实现。</li>
<li>防抖关注一定时间连续触发的事件，只在最后执行一次，而函数节流一段时间内只执行一次。</li>
</ul>
<p>应用场景： </p>
<p>​        1.scroll事件滚动触发</p>
<p>​        2.搜索框输入查询</p>
<p>​        3.表单验证</p>
<p>​        4.按钮提交事件</p>
<p>​        5.浏览器窗口缩放，resize事件</p>
<h4 id="17-如何通过JS判断一个数组"><a href="#17-如何通过JS判断一个数组" class="headerlink" title="17.   如何通过JS判断一个数组"></a>17.   如何通过JS判断一个数组</h4><ul>
<li> isArray()数组自带的判断方法 </li>
<li> instanceof  判断类型</li>
<li> constructor.toString()方法 </li>
<li> Object.prototype.toString.call(a) 原型方法</li>
</ul>
<h4 id="18-说说你对作用域链的理解"><a href="#18-说说你对作用域链的理解" class="headerlink" title="18.   说说你对作用域链的理解"></a>18.   说说你对作用域链的理解</h4><p>作用域的作用就是保证有权被访问的变量及函数的有序性，作用域链的变量只能向上访问，不能向下访问。当访问到window对象时终止。作用链就是变量和函数的可访问范围，控制变量和函数的可见性及生命周期。</p>
<h4 id="19-JavaScript原型，原型链-有什么特点？"><a href="#19-JavaScript原型，原型链-有什么特点？" class="headerlink" title="19.   JavaScript原型，原型链 ? 有什么特点？"></a>19.   JavaScript原型，原型链 ? 有什么特点？</h4><ul>
<li>原型： 每个对象都会在其内部初始化一个属性，就是<code>__proto__</code> （原型）。还预置了prototype属性。构造函数创建实例时，该prototype属性值就会被作为实例对象的原型proto。</li>
<li>原型链：当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，那么它就会去它的原型对象里找这个属性，这个原型对象又会有自己的原型，于是就这样一直找下去， 直到找到属性/方法或 <code>undefined</code> 为止 ，也就是原型链的概念 。</li>
<li>特点： javascript对象是通过引用来传递的，当修改原型时，与之相关的对象也会继承这一改变 。</li>
</ul>
<h4 id="20-请解释什么是事件代理"><a href="#20-请解释什么是事件代理" class="headerlink" title="20.   请解释什么是事件代理"></a>20.   请解释什么是事件代理</h4><p>事件代理也就是事件委托，将原本需要绑定的事件委托给父元素。让父元素去监听。其原理就是：dom元素的事件冒泡。好处：节省大量内存，减少事件注册，提高性能。当新增子对象时无需再次绑定。</p>
<h4 id="21-谈谈This对象的理解"><a href="#21-谈谈This对象的理解" class="headerlink" title="21.   谈谈This对象的理解"></a>21.   谈谈This对象的理解</h4><ul>
<li>this总是指向函数的直接调用者</li>
<li>如果有new关键字，this指向new出来的这个实例对象</li>
<li>在事件中，this指向触发这个事件的对象。</li>
<li>IE中，this总是指向全局对象window。</li>
<li>箭头函数没有this，箭头函数的this指向上一级的函数。</li>
<li>可通过apply，call，bind来改变this指向。</li>
</ul>
<h4 id="22-new操作符具体干了什么"><a href="#22-new操作符具体干了什么" class="headerlink" title="22.   new操作符具体干了什么"></a>22.   new操作符具体干了什么</h4><ul>
<li>创建一个空对象，并且this引用该对象，也继承了该对象的原型。</li>
<li>将所有的属性，方法都添加到了this引用的这个对象。</li>
<li>新创建的对象由this引用，最后隐式的返回this。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">mynew</span>(<span class="hljs-params">Func, ...args</span>) &#123;<br>    <span class="hljs-comment">// 1.创建一个新对象</span><br>    <span class="hljs-keyword">const</span> obj = &#123;&#125;<br>    <span class="hljs-comment">// 2.新对象原型指向构造函数原型对象</span><br>    obj.<span class="hljs-property">__proto__</span> = <span class="hljs-title class_">Func</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span><br>    <span class="hljs-comment">// 3.将构建函数的this指向新对象</span><br>    <span class="hljs-keyword">let</span> result = <span class="hljs-title class_">Func</span>.<span class="hljs-title function_">apply</span>(obj, args)<br>    <span class="hljs-comment">// 4.根据返回值判断</span><br>    <span class="hljs-keyword">return</span> result <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Object</span> ? result : obj<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="23-null，undefined-的区别"><a href="#23-null，undefined-的区别" class="headerlink" title="23.   null，undefined 的区别"></a>23.   null，undefined 的区别</h4><ul>
<li>undefinded：表示没有不存在的值，一个缺少值。此处应有值，但没定义。读取时，返回undefined。</li>
<li>null：表示一个空对象，没有任何属性及方法。对比验证时使用===。</li>
</ul>
<h4 id="24-javascript-代码中的”use-strict”-是什么意思"><a href="#24-javascript-代码中的”use-strict”-是什么意思" class="headerlink" title="24.   javascript 代码中的”use strict”;是什么意思"></a>24.   javascript 代码中的”use strict”;是什么意思</h4><p>use strict是 es5添加的一种严格运行模式，这种模式使JavaScript能够在更严格的条件下运行。使js编码更加规范，消除了一些不严谨，不合理之处。</p>
<h4 id="25-同步和异步的区别"><a href="#25-同步和异步的区别" class="headerlink" title="25.   同步和异步的区别"></a>25.   同步和异步的区别</h4><p>同步是阻塞模式，异步是非阻塞模式。</p>
<ul>
<li>同步<ul>
<li>同步是指一个进程在执行某个请求时，该请求需要一定时间返回消息。那么这个进程就会一直等待下去，直到返回消息后，才执行下面的操作。</li>
</ul>
</li>
<li>异步<ul>
<li>异步是指不需要一直等待下去，而是继续执行下面的操作。不管其他进程的状态，当返回消息时，系统会通知该进程进行处理。提高了执行效率。</li>
</ul>
</li>
</ul>
<h4 id="26-谈一谈箭头函数与普通函数的区别"><a href="#26-谈一谈箭头函数与普通函数的区别" class="headerlink" title="26.   谈一谈箭头函数与普通函数的区别"></a>26.   谈一谈箭头函数与普通函数的区别</h4><ul>
<li>语法形式不同，箭头函数更简短</li>
<li>没有单独的<code>this</code></li>
<li>不绑定<code>arguments</code></li>
<li>不能使用<code>new</code>操作</li>
<li>没有<code>prototype</code>属性</li>
<li>通过<code>call</code>或<code>apply</code>调用会忽略第一个参数，只能传递参数，不能绑定<code>this</code></li>
<li>不能使用<code>yield</code>关键字</li>
</ul>
<h4 id="27-JS-数组和对象的遍历方式，以及几种方式的比较"><a href="#27-JS-数组和对象的遍历方式，以及几种方式的比较" class="headerlink" title="27.   JS 数组和对象的遍历方式，以及几种方式的比较"></a>27.   JS 数组和对象的遍历方式，以及几种方式的比较</h4><ul>
<li>for in 循环 </li>
<li>for  of循环 </li>
<li>forEach循环</li>
<li>map循环</li>
</ul>
<p>区别：</p>
<ul>
<li>for in循环 和 for循环 性能低。</li>
<li>for in适合遍历对象，for of适合遍历数组。for in遍历的是数组的索引，对象的key值，以及原型链上的属性 。</li>
<li>forEach ⽆法遍历对象  forEach ⽆法使⽤ break ， continue 跳出循环，且使⽤ return 是跳过本次循环 。</li>
<li>map可以return出一个新数组，原数组不会改变 。⽆法遍历对象 。</li>
</ul>
<h4 id="28-如何解决跨域问题"><a href="#28-如何解决跨域问题" class="headerlink" title="28.   如何解决跨域问题"></a>28.   如何解决跨域问题</h4><p>产生跨域的是因为浏览器的同源策略，同源策略是一种约定，它是浏览器最核心也最基本的安全功能。所谓同源是指 协议 域名 端口 三者一致。若其中一项不一致就会产生跨域。</p>
<ul>
<li>jsonp跨域<ul>
<li>只可以使用get方式提交。设置请求url –》 参数拼接  –》创建script节点  –》  返回数据，清除script。</li>
</ul>
</li>
<li>nginx代理跨域</li>
<li>node中间件跨域</li>
<li>cors后端头部设置安全域名<ul>
<li>需要浏览器和服务器的支持，自动完成跨域。添加一些头部信息。</li>
</ul>
</li>
</ul>
<h4 id="29-XML和JSON的区别"><a href="#29-XML和JSON的区别" class="headerlink" title="29.   XML和JSON的区别"></a>29.   XML和JSON的区别</h4><p>json是一个轻量的数据交换格式。是javascript的一个子集。</p>
<p>xml是纯文本的格式的，可扩展标记语言。</p>
<ul>
<li>JSON 比 XML 体积小，传递速度快。</li>
<li>JSON对jacascript交互更方便，更容易解析。</li>
<li>JSON 比 XML 传输速度快很多。</li>
<li>JSON对数据的描述性差。</li>
</ul>
<h4 id="30-谈谈你对webpack的看法"><a href="#30-谈谈你对webpack的看法" class="headerlink" title="30.   谈谈你对webpack的看法"></a>30.   谈谈你对webpack的看法</h4><p>webpack是一个模块打包工具，可以使用webpack管理模块依赖，并编译除模块所需的静态文件。打包web开发中所用到的html，css，js等静态文件。提高开发效率。对于不同的类型的资源，webpack由相对应的模块加载器。webpack会分析模块间的相关依赖，最后生成优化后的静态资源。</p>
<h4 id="31-webpack的打包原理"><a href="#31-webpack的打包原理" class="headerlink" title="31.   webpack的打包原理"></a>31.   webpack的打包原理</h4><p> <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/71b263000fa94db792cf1e98d67a578a~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" srcset="/img/loading.gif" lazyload alt="img"> </p>
<ul>
<li>初始化参数：从配置文件和 Shell 语句中读取并合并参数，得出最终的配置参数。</li>
<li>开始编译：从上一步得到的参数初始化 <code>Compiler</code> 对象，加载所有配置的插件，执行对象的 <code>run</code> 方法开始执行编译。</li>
<li>确定入口：根scope据配置中的 <code>entry</code> 找出所有的入口文件。</li>
<li>编译模块：从入口文件出发，调用所有配置的 <code>loader</code> 对模块进行翻译，再找出该模块依赖的模块，这个步骤是递归执行的，直至所有入口依赖的模块文件都经过本步骤的处理。</li>
<li>完成模块编译：经过第 4 步使用 loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系。</li>
<li>输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 <code>chunk</code>，再把每个 <code>chunk</code> 转换成一个单独的文件加入到输出列表，这一步是可以修改输出内容的最后机会。</li>
<li>输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。</li>
</ul>
<p> webpack打包原理是将根据文件间的依赖关系对其进行静态分析，然后将这些模块按指定规则生成静态资源，当 webpack处理程序时，会递归地构建一个依赖关系图，其中包含应用程序需要的每个模块，然后将所所有这些模块打包成bundle。 </p>
<p>从配置文件中读取所需要的参数，并且加载所有的插件，开始执行编译。找到entry入口文件。调用loader对模板进行递归解析翻译。等确定每个模块的依赖关系后，将他们组装成一个个包含多个模块的chunk。确定好内容后，根据出口配置将打包后的文件写入到具体位置。</p>
<h4 id="32-如何优化webpack打包速度"><a href="#32-如何优化webpack打包速度" class="headerlink" title="32.   如何优化webpack打包速度"></a>32.   如何优化webpack打包速度</h4><ul>
<li><p>优化 loader 配置：           减少文件的搜索范围，使用test，include，exclude。</p>
</li>
<li><p>使用image-webpack-loader进行图片压缩</p>
</li>
<li><p>terser启用多线程 ：        使用多进程并行运行来提高构建速度</p>
</li>
<li><p>使用 cache-loader：      将开销较大的loader结果缓存到磁盘</p>
</li>
<li><p>优化 resolve.modules:    指明存放第三方模块的绝对路径，以减少寻找 。</p>
</li>
<li><p>优化 resolve.alias</p>
</li>
<li><p>使用 DLLPlugin 插件</p>
</li>
<li><p>合理使用 sourceMap</p>
</li>
</ul>
<h4 id="33-说说webpack中常见的Loader？解决了什么问题？"><a href="#33-说说webpack中常见的Loader？解决了什么问题？" class="headerlink" title="33.   说说webpack中常见的Loader？解决了什么问题？"></a>33.   说说webpack中常见的Loader？解决了什么问题？</h4><p>webpack默认情况下，只支持对js，json文件打包。像css，less，png等这些类型文件，webpack需要采用相对应的loader（模块加载器）进行解析。</p>
<p>关于<code>loader</code>的配置，我们是写在<code>module.rules</code>属性中，属性介绍如下：</p>
<ul>
<li><code>rules</code>是一个数组的形式，因此我们可以配置很多个<code>loader</code></li>
<li>每一个<code>loader</code>对应一个对象的形式，对象属性<code>test</code> 为匹配的规则，一般情况为正则表达式</li>
<li>属性<code>use</code>针对匹配到文件类型，调用对应的 <code>loader</code> 进行处理</li>
</ul>
<p>常见的<code>loader</code>如下：</p>
<ul>
<li>style-loader: 将css添加到DOM的内联样式标签style里</li>
<li>css-loader :允许将css文件通过require的方式引入，并返回css代码</li>
<li>less-loader: 处理less</li>
<li>sass-loader: 处理sass</li>
<li>babel-loader :用babel来转换ES6文件到ES5</li>
<li>file-loader: 分发文件到output目录并返回相对路径</li>
<li>url-loader: 和file-loader类似，但是当文件小于设定的limit时可以返回一个Data Url</li>
</ul>
<p>css-loader:        分析 <code>css</code> 模块之间的关系，并合成⼀个 <code>css</code></p>
<p>staly-loader:    把 <code>css-loader</code> 生成的内容，用 <code>style</code> 标签挂载到页面的 <code>head</code> 中</p>
<p>less-loader:      开发中，我们也常常会使用<code>less</code>、<code>sass</code>、<code>stylus</code>预处理器编写<code>css</code>样式，使开发效率提高，这里需要使用<code>less-loader</code> </p>
<p>url-loader:        可以处理 <code>file-loader</code> 所有的事情，遇到图片格式的模块，可以选择性的把图片转成 <code>base64</code> 格式的字符串，并打包到 <code>js</code> 中，对小体积的图片比较合适，大图片不合适。 </p>
<h4 id="34-说说webpack中常见的Plugin？解决了什么问题？"><a href="#34-说说webpack中常见的Plugin？解决了什么问题？" class="headerlink" title="34.   说说webpack中常见的Plugin？解决了什么问题？"></a>34.   说说webpack中常见的Plugin？解决了什么问题？</h4><p>plugin是插件，对于webpack本身的扩展，是一个扩展器。</p>
<p>配置方式：写在plugins属性中传入new实例对象，他是个数组，可以写多个插件。</p>
<p>下面介绍几个常用的插件用法：</p>
<ul>
<li>HtmlWebpackPlugin<ul>
<li> ⾃动生成⼀个 <code>html</code> ⽂文件，并把打包生成的<code>js</code> 模块引⼊到该 <code>html</code> 中 </li>
</ul>
</li>
<li>clean-webpack-plugin<ul>
<li> 删除（清理）构建目录 </li>
</ul>
</li>
<li>mini-css-extract-plugin<ul>
<li>提取css到一个单独文件中</li>
</ul>
</li>
<li>copy-webpack-plugin<ul>
<li>复制文件或目录到执行区域。</li>
</ul>
</li>
</ul>
<h4 id="35-说说你对promise的了解"><a href="#35-说说你对promise的了解" class="headerlink" title="35.    说说你对promise的了解"></a>35.    说说你对promise的了解</h4><p>promise是es6新增的语法，解决了回调地狱的问题。（ 多个异步任务顺序执行，形成的多层回调函数的嵌套结构，就称为回调地狱现象 ）。</p>
<p>promise有三个状态：pending等待初始化状态，resolved成功的状态，rejected成功的状态。变化不可逆。</p>
<p>promise构造函数内代码是同步的，而之后then和catch执行的是异步的。构造函数接收两个参数resolve和reject。他们的执行是传递给then，catch，表示成功的回调及失败的回调。</p>
<h4 id="36-async函数是什么，有什么作用"><a href="#36-async函数是什么，有什么作用" class="headerlink" title="36.    async函数是什么，有什么作用"></a>36.    async函数是什么，有什么作用</h4><p>async/await 是为了简化使用基于promiseAPI的一种语法（语法糖）。async和await简化了promise的异步行为，不用链式的调用promise。</p>
<p>async表示是异步操作，await表示跟在表达式后面等待结果。await只能在async函数中有效，不然会报错。async返回一个promise对象，可以使用then方法添加回调函数。不管是不是promise对象，都会被包装成promise对象。async函数内部会被await阻塞并按顺序执行代码。也可使用try..catch进行异常处理。</p>
<h4 id="37-有使用过vue吗？说说你对vue的理解"><a href="#37-有使用过vue吗？说说你对vue的理解" class="headerlink" title="37.    有使用过vue吗？说说你对vue的理解"></a>37.    有使用过vue吗？说说你对vue的理解</h4><p>vue是一个构建用户界面的渐进式框架。vue所关注的核心是视图层。有一套精简的mvvm框架。</p>
<p>vue是一款轻量级别的框架，适合开发小型项目。</p>
<p>vue核心特性：</p>
<ul>
<li>数据驱动（MVVM<code>表示的是 </code>Model-View-ViewModel）<ul>
<li>Model：模型层，负责处理业务逻辑以及和服务器端进行交互</li>
<li>View：视图层：负责将数据渲染出来展示页面，可以简单的理解为HTML页面</li>
<li>ViewModel：视图模型层，用来连接Model和View，是Model和View之间的通信桥梁。</li>
</ul>
</li>
<li>组件化开发<ul>
<li>组件可以重复使用。提高开发效率。高内聚低耦合。</li>
<li>提高可维护性，每个组件的职责单一 。</li>
</ul>
</li>
<li>有着一套丰富的vue指令<ul>
<li>条件渲染指令 <code>v-if</code></li>
<li>列表渲染指令<code>v-for</code></li>
<li>属性绑定指令<code>v-bind</code></li>
<li>事件绑定指令<code>v-on</code></li>
<li>双向数据绑定指令<code>v-model</code></li>
</ul>
</li>
</ul>
<h4 id="38-你对SPA单页面的理解，它的优缺点分别是什么？如何实现SPA应用呢"><a href="#38-你对SPA单页面的理解，它的优缺点分别是什么？如何实现SPA应用呢" class="headerlink" title="38.    你对SPA单页面的理解，它的优缺点分别是什么？如何实现SPA应用呢"></a>38.    你对SPA单页面的理解，它的优缺点分别是什么？如何实现SPA应用呢</h4><p> SPA仅在Web页面初始化时加载相应的HTML、JavaScript和CSS。一旦页面加载完成,SPA不会因为用户操作而进行页面的重新加载或跳转;取而代之的是利用JavaScript实现HTML内容变换,UI与用户的交互,避免页面的重新加载。 </p>
<p>优点：</p>
<ul>
<li>用户体验好、快，内容的改变不需要重新加载整个页面</li>
<li>SPA相对于服务器压力小; </li>
<li>良好的前后端分离，分工更明确。</li>
</ul>
<p>缺点：</p>
<ul>
<li>不利于搜索引擎的抓取</li>
<li>首次加载页面速度比较慢</li>
</ul>
<p>实现：</p>
<ul>
<li>hash模式<ul>
<li>通过onhashchange监听路由的改变，从而跳转路由更新页面。</li>
</ul>
</li>
<li>history模式<ul>
<li>history采用HTML5的新特性；pushState()添加历史记录，replaceState()修改浏览器历史记录。</li>
<li>通过popState()监听路由的改变，从而触发路由跳转和页面更新。</li>
</ul>
</li>
</ul>
<h4 id="39-SPA首屏加载速度慢的怎么解决？"><a href="#39-SPA首屏加载速度慢的怎么解决？" class="headerlink" title="39.    SPA首屏加载速度慢的怎么解决？"></a>39.    SPA首屏加载速度慢的怎么解决？</h4><ul>
<li>减小入口文件积<ul>
<li>路由懒加载，不同组件的分割。</li>
</ul>
</li>
<li>静态资源本地缓存</li>
<li>UI框架按需加载</li>
<li>开启GZip压缩</li>
<li>使用服务器端渲染SSR（nuxt.js）</li>
<li>图片资源的压缩</li>
</ul>
<h4 id="40-VUE路由的原理"><a href="#40-VUE路由的原理" class="headerlink" title="40.    VUE路由的原理"></a>40.    VUE路由的原理</h4><p>hash：</p>
<ul>
<li>其中对象中的location.hash储存的是路由的地址、可以赋值改变其URL的地址。而这会触发hashchange事件，而通过window.addEventListener监听hash值然后去匹配对应的路由、从而渲染页面的组件 。</li>
</ul>
<p>history：</p>
<ul>
<li>history采用HTML5的新特性，通过 pushState 和 replaceState 两个方法来实现 URL 的变化</li>
<li>可以通过 popstate 事件来监听 URL 的变化，从而对页面进行跳转（渲染）</li>
</ul>
<h4 id="41-Vue中组件和插件有什么区别？"><a href="#41-Vue中组件和插件有什么区别？" class="headerlink" title="41.    Vue中组件和插件有什么区别？"></a>41.    Vue中组件和插件有什么区别？</h4><p> 组件 <code>(Component)</code> 是用来构成 <code>App</code> 的业务模块，它的目标是 <code>App.vue</code>。  在<code>Vue</code>中每一个<code>.vue</code>文件都可以视为一个组件 </p>
<p>插件就是指对<code>Vue</code>的功能的增强或补充。</p>
<p>编写形式区别：</p>
<ul>
<li>组件是以.vue后缀结尾的组件，包含三部分。template，script，style。</li>
<li>插件需要暴露一个install方法，第一个参数是vue构造器，第二个参数是可选对象。</li>
</ul>
<p>注册形式区别：</p>
<ul>
<li>组件是在main.js中全局注册vue.component(),局部注册就是在组件内。</li>
<li>插件在main.js中使用vue实例vue.use（插件名）</li>
</ul>
<h4 id="42-Vue组件之间的通信方式都有哪些"><a href="#42-Vue组件之间的通信方式都有哪些" class="headerlink" title="42.    Vue组件之间的通信方式都有哪些"></a>42.    Vue组件之间的通信方式都有哪些</h4><ul>
<li>父子组件之间的通信<ul>
<li>使用props进行传递</li>
</ul>
</li>
<li>兄弟组件之间的通信<ul>
<li>使用eventbus  vue实例进行传递</li>
</ul>
</li>
<li>provide 和  inject<ul>
<li>在祖先组件定义<code>provide</code>属性，返回传递的值</li>
<li>在后代组件通过<code>inject</code>接收组件传递过来的值</li>
</ul>
</li>
<li>vuex</li>
</ul>
<h1 id="43-你了解vue的diff算法吗？说说看"><a href="#43-你了解vue的diff算法吗？说说看" class="headerlink" title="43.    你了解vue的diff算法吗？说说看"></a>43.    你了解vue的diff算法吗？说说看</h1><p> diff的过程就是调用名为patch的函数，比较新旧节点，一边比较一边给真实的DOM打补丁 。</p>
<p>原理：当数据发生改变时，<code>set</code>方法会调用<code>Dep.notify</code>通知所有订阅者<code>Watcher</code>，调用<code>patch</code>给真实的<code>DOM</code>打补丁，更新相应的视图 。</p>
<p>其有两个特点：</p>
<ul>
<li>比较只会在同层级进行, 不会跨层级比较</li>
<li>在diff比较的过程中，循环从两边向中间比较</li>
<li>同一个节点，进行最小量的更新。</li>
</ul>
<p> diff 算法的在很多场景下都有应用，在 vue 中，作用于虚拟 dom 渲染成真实 dom 的新旧 VNode 节点比较 </p>
<p>Diff算法的步骤：</p>
<ul>
<li>用 JavaScript 对象结构表示 DOM 树的结构；然后用这个树构建一个真正的 DOM 树，插到文 档当中。</li>
<li>当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较(diff)，记录两棵树差异。</li>
<li>把第二棵树所记录的差异应用到第一棵树所构建的真正的DOM树上(patch)，视图就更新了。</li>
</ul>
<h4 id="44-为什么需要-Virtual-Dom"><a href="#44-为什么需要-Virtual-Dom" class="headerlink" title="44.   为什么需要 Virtual Dom"></a>44.   为什么需要 Virtual Dom</h4><ul>
<li><p>DOM的操作本身是性能会出现问题，操作比较复杂的</p>
</li>
<li><p>MVVM框架解决视图和状态同步问题</p>
</li>
<li><p>模板引擎可以简化视图操作，没办法跟踪状态（无法得知当前页面变化之前的状态）</p>
</li>
<li><p>虚拟DOM能够跟踪状态变化</p>
</li>
<li><p>虚拟DOM可以维护程序的状态，跟踪上一次的状态，通过比较前后两次状态差异更新真实DOM</p>
</li>
</ul>
<p><strong>虚拟 DOM 的作用</strong></p>
<ul>
<li>维护视图和状态的关系</li>
<li>复杂视图情况下提升渲染性能</li>
<li>除了渲染 <code>DOM</code> 以外，还可以实现 <code>SSR(Nuxt.js/Next.js)</code>、原生应用(<code>Weex/React Native</code>)、小程序(<code>mpvue/uni-app</code>)等</li>
</ul>
<h4 id="45-Vue3-0的设计目标是什么？做了哪些优化"><a href="#45-Vue3-0的设计目标是什么？做了哪些优化" class="headerlink" title="45.   Vue3.0的设计目标是什么？做了哪些优化"></a>45.   Vue3.0的设计目标是什么？做了哪些优化</h4><p>设计目标：</p>
<ul>
<li>打包体积更小： <code>Vue3</code>移除一些不常用的 <code>API</code> ， 将无用模块“剪辑”，仅打包需要的，使打包的整体体积变小了 </li>
<li>速度更快： diff算法优化，静态提升。</li>
<li>更灵活的代码组织能力：推出Composition API，大大增加了代码的逻辑组织能力和代码复用能力。</li>
</ul>
<p>优化方案：</p>
<ul>
<li>源码<ul>
<li>使用ts语法，源码的优化。</li>
</ul>
</li>
<li>性能<ul>
<li>体积，编译，数据劫持优化。</li>
</ul>
</li>
<li>语法 API<ul>
<li>组合式API，根据相关逻辑组织代码。</li>
</ul>
</li>
</ul>
<h4 id="46-Vue3-0-所采用的-Composition-Api-与-Vue2-x-使用的-Options-Api-有什么不同？"><a href="#46-Vue3-0-所采用的-Composition-Api-与-Vue2-x-使用的-Options-Api-有什么不同？" class="headerlink" title="46.   Vue3.0 所采用的 Composition Api 与 Vue2.x 使用的 Options Api 有什么不同？"></a>46.   Vue3.0 所采用的 Composition Api 与 Vue2.x 使用的 Options Api 有什么不同？</h4><ul>
<li>Options：</li>
</ul>
<p>​                         在一个vue文件中的data，methods，computed…定义属性和方法，共同处理页面逻辑。</p>
<p>​                         缺点：一个功能的实现    需要不同的vue配置项，定义属性方法比较分散。大项目methods可能                                    包含多个方法，这可能会导致组件难以阅读和理解。</p>
<p>​                         优点：新手入门会比较简单。</p>
<ul>
<li><p>Compositions API:</p>
<p>​                一个功能的所有api会放在一起（高内聚，低耦合），方便找到功能所对应的方法及属性。</p>
<p>​                缺点：学习思维方式改变。</p>
<p>​                优点：根据逻辑相关性组织代码，提高可读性和可维护性，基于函数组合的API。</p>
</li>
</ul>
<h4 id="47-说一下Vue数据响应式的原理"><a href="#47-说一下Vue数据响应式的原理" class="headerlink" title="47.   说一下Vue数据响应式的原理"></a>47.   说一下Vue数据响应式的原理</h4><p>当一个vue实例被创建时，vue会遍历data选项的属性。采用数据劫持结合发布/订阅者模式，用es5的object.defindproerty将他们转化为getter/setter，并在内部追踪相关依赖。在属性被访问和修改时通知变化。也就是observer使用object.defindproerty来监听数据的读写。读取数据时，调用get方法通知dep收集订阅者（watcher）。添加到dep的一个属性subs数组里。   修改数据时，调用set方法，通知dep数据改变了。 使用notify方法遍历subs里面的watcher，调用watcher的update（）方法。创建出一个新的dom树与原本旧的dom树做对比，从而更新视图。</p>
<h4 id="48-说说对-React-的理解？有哪些特性？"><a href="#48-说说对-React-的理解？有哪些特性？" class="headerlink" title="48.   说说对 React 的理解？有哪些特性？"></a>48.   说说对 React 的理解？有哪些特性？</h4><p> 由FaceBook在2011年开发的。React用于构建用户界面的 JavaScript 库 ，声明式编程，组件化开发。</p>
<ol>
<li><p>它使用**虚拟DOM **而不是真正的DOM。</p>
</li>
<li><p>它可以用<strong>服务器端渲染</strong>。</p>
</li>
<li><p>它遵循<strong>单向数据流</strong>或数据绑定。</p>
</li>
<li><p>使用jsx语法，将html和css代码写入到一个js文件。</p>
</li>
</ol>
<h4 id="49-说说-Real-DOM-和-Virtual-DOM-的区别？优缺点？"><a href="#49-说说-Real-DOM-和-Virtual-DOM-的区别？优缺点？" class="headerlink" title="49.   说说 Real DOM 和 Virtual DOM 的区别？优缺点？"></a>49.   说说 Real DOM 和 Virtual DOM 的区别？优缺点？</h4><p> Real DOM（真实的dom），在页面渲染出的每个节点都是一个真实的DOM结构 。</p>
<p> Virtual DOM （虚拟dom），是一个轻量级的js对象，它最初只是real DOM的副本，也是一个节点树。将属性和内容作为该对象的属性。 </p>
<p>区别：</p>
<ul>
<li><p>虚拟dom会减少重绘和回流，而真实dom会频繁进行重绘和回流。</p>
</li>
<li><p>虚拟dom的总损耗是”虚拟dom的增删改+真实dom的<strong>差异</strong>增删改+重排“；真实dom的消耗是”真实dom全部增删改+重排“</p>
</li>
</ul>
<p>真实dom：  优点：直接操作html，易用。    缺点：解析速度慢，效率低，内存占用高。， 频繁操作真实                                              DOM，导致重绘、 回流</p>
<p>虚拟dom：  优点：减少真实dom的频繁更新，减少重绘，回流，占内存少。  跨平台：一套react代码可以多                        端运行 </p>
<p>​                        缺点：初次渲染时，多了一层虚拟dom计算，速度慢些。</p>
<h4 id="50-说说-React-生命周期有哪些不同阶段？每个阶段对应的方法是？"><a href="#50-说说-React-生命周期有哪些不同阶段？每个阶段对应的方法是？" class="headerlink" title="50.   说说 React 生命周期有哪些不同阶段？每个阶段对应的方法是？"></a>50.   说说 React 生命周期有哪些不同阶段？每个阶段对应的方法是？</h4><p> <code>React</code>生命周期就是从创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、卸载等这一过程 。</p>
<ul>
<li>创建阶段<ul>
<li>render     用于渲染<code>DOM</code>结构，可以访问组件<code>state</code>与<code>prop</code>属性 </li>
<li>componentDidMount     组件挂载到真实<code>DOM</code>节点后执行，其在<code>render</code>方法之后执行 </li>
<li>constructor      初始化<code>state</code>状态 </li>
</ul>
</li>
<li>更新阶段<ul>
<li>componentDidUpdate        组件更新结束后触发 </li>
<li>shouldComponentUpdate    告诉组件本身是否需要重新渲染，默认false。</li>
<li>render      用于渲染<code>DOM</code>结构</li>
</ul>
</li>
<li>卸载阶段<ul>
<li><em><strong>componentWillUnmount</strong></em><strong>()</strong> – 从 DOM 卸载组件前调用。   </li>
</ul>
</li>
</ul>
<h4 id="51-说说-React中的setState执行机制"><a href="#51-说说-React中的setState执行机制" class="headerlink" title="51.   说说 React中的setState执行机制"></a>51.   说说 React中的setState执行机制</h4><p> 当需要修改状态时通过调用<code>setState</code>来改变，从而达到更新组件内部数据的作用 。</p>
<p>当使用setState（）更新状态后，然后会执行render函数，从而导致页面的视图更新。</p>
<p>更新类型：</p>
<ul>
<li>异步更新<ul>
<li>在组件生命周期或React合成事件中，setState是异步</li>
</ul>
</li>
<li>同步更新<ul>
<li>在setTimeout或者原生dom事件中，setState是同步</li>
</ul>
</li>
</ul>
<h4 id="52-说说对React中类组件和函数组件的理解？有什么区别？"><a href="#52-说说对React中类组件和函数组件的理解？有什么区别？" class="headerlink" title="52.   说说对React中类组件和函数组件的理解？有什么区别？"></a>52.   说说对React中类组件和函数组件的理解？有什么区别？</h4><p>类组件：通过使用es6类的编写形式来定义，继承React.Component。如果想要访问父组件传递过来的参数，可通过this.props来拿到。使用render方法，返回一个react对象。</p>
<p>函数组件：通过函数来编写一个react组件，函数第一个参数用于接收父组件传过来的参数。</p>
<p>在hooks出来之前，函数式组件时没有生命周期的，以及无法定义状态。现在可以使用useState定义状态。</p>
<p>useEffect定义生命周期。类式组件是不能使用hooks的。</p>
<h4 id="53-说说对React-Hooks的理解？解决了什么问题？"><a href="#53-说说对React-Hooks的理解？解决了什么问题？" class="headerlink" title="53.   说说对React Hooks的理解？解决了什么问题？"></a>53.   说说对React Hooks的理解？解决了什么问题？</h4><p>hooks是react 16版本以后新增的特性，可以在不写class组件的情况下使用state及其他属性。</p>
<p>useState（）定义组件状态       useEffect（）定义组件生命周期，第一个参数相当于 componentDidMount 和 componentDidUpdate 。第二个参数是个列表。可以返回一个函数，相当于 componentwillUnmount 销毁生命周期。     useReducer，useRef。</p>
<p>解决：</p>
<ul>
<li>每调用useHook一次都会生成一份独立的状态</li>
<li>通过自定义hook能够更好的封装我们的功能</li>
</ul>
<p>hook的出现，使函数式组件拥有了类式组件的相似功能。还可以进行代码复用。</p>
<h4 id="54-说说你对Redux的理解？其工作原理？"><a href="#54-说说你对Redux的理解？其工作原理？" class="headerlink" title="54.   说说你对Redux的理解？其工作原理？"></a>54.   说说你对Redux的理解？其工作原理？</h4><p>redux与vux相似，也是将组件状态进行集中管理。相当于管理组件状态的一个工具。</p>
<p> <strong>Redux三大原则</strong> ：</p>
<ul>
<li>单一数据源</li>
<li>state是只读的</li>
<li>使用纯函数修改状态</li>
</ul>
<p>redux三大核心：</p>
<ul>
<li>action：    动作对象，两个参数type，和data</li>
<li>reducer：   用于初始化状态，加工状态</li>
<li>store</li>
</ul>
<p>原理： 页面需要获取数据时，通过Action creates创建一个action动作对象，提交dispatch请求给store。store通知reducer进行匹配action的属性type。从而进行返回一个新的对象。</p>
<h4 id="55-说说-React-性能优化的手段有哪些"><a href="#55-说说-React-性能优化的手段有哪些" class="headerlink" title="55.   说说 React 性能优化的手段有哪些"></a>55.   说说 React 性能优化的手段有哪些</h4><ul>
<li>为避免不必要的render渲染，可以使用shouldComponentUpdate。</li>
<li>避免使用内联函数</li>
<li>懒加载组件</li>
<li>服务端渲染</li>
<li>事件绑定方式 </li>
<li>列表渲染的时候加key</li>
<li>避免使用内联样式属性</li>
</ul>
<h4 id="56-vue、react、angular-区别"><a href="#56-vue、react、angular-区别" class="headerlink" title="56.   vue、react、angular 区别"></a>56.   vue、react、angular 区别</h4><ul>
<li>angular是基于MVC架构，vue和react都是基于虚拟dom。</li>
<li><strong>Angular</strong>使用的是双向数据绑定，<strong>React</strong>用的是单数据流的，而<strong>Vue</strong>则支持两者。 </li>
<li>vue与angular自带的渲染指令不同。react没有渲染指令。</li>
<li>react使用jsx语法，angular使用ts语法。    </li>
</ul>
<h4 id="57-说说你对-TypeScript-的理解？与-JavaScript-的区别"><a href="#57-说说你对-TypeScript-的理解？与-JavaScript-的区别" class="headerlink" title="57.   说说你对 TypeScript 的理解？与 JavaScript 的区别"></a>57.   说说你对 TypeScript 的理解？与 JavaScript 的区别</h4><p> typescript是一个强类型的JavaScript超集， 支持面向对象编程的概念，如类、接口、继承、泛型等 ，可编译为纯JavaScript 。typescrit可以在任何浏览器运行。但是不能直接运行，需要一个编译器编译成javascript文件。</p>
<p>区别：</p>
<ul>
<li><p>ts支持es6语法，js不支持es6。</p>
</li>
<li><p>ts支持模块，js不支持模块。</p>
</li>
<li><p>js中没有静态类型的概念。</p>
</li>
<li><p>TypeScript 文件的后缀名 .ts （.ts，.tsx，.dts），JavaScript 文件是 .js</p>
</li>
</ul>
<h4 id="58-说说你对-TypeScript-中泛型的理解？应用场景？"><a href="#58-说说你对-TypeScript-中泛型的理解？应用场景？" class="headerlink" title="58.   说说你对 TypeScript 中泛型的理解？应用场景？"></a>58.   说说你对 TypeScript 中泛型的理解？应用场景？</h4><p>泛型是设计语言的一种风格或规范。</p>
<p> 泛型（Generics）是指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性 。</p>
<p> 泛型通过<code>&lt;&gt;</code>的形式进行表述，可以声明 ：函数，类，接口。</p>
<h4 id="59-说说你对微信小程序的理解？优缺点？"><a href="#59-说说你对微信小程序的理解？优缺点？" class="headerlink" title="59.   说说你对微信小程序的理解？优缺点？"></a>59.   说说你对微信小程序的理解？优缺点？</h4><p>小程序是一种不需要下载安装即可使用的应用，用户扫一扫或者搜一下即可打开应用。</p>
<p>也体现了“用完即走”的理念，用户不用关心是否安装太多应用的问题。应用将无处不在，随时可用，但又无需安装卸载。</p>
<p>注意的是，除了微信小程序，还有百度小程序、支付宝小程序、抖音小程序，都是每个平台自己开发的，都是有针对性平台的应用程序。</p>
<p>优点：</p>
<ul>
<li>随搜随用，用完即走：使得小程序可以代替许多APP，或是做APP的整体嫁接，或是作为阉割版功能的承载体</li>
<li>流量大，易接受：小程序借助自身平台更加容易引入更多的流量</li>
<li>安全</li>
<li>开发门槛低</li>
<li>降低兼容性限制</li>
</ul>
<p>缺点：</p>
<ul>
<li>用户留存：及相关数据显示，小程序的平均次日留存在13%左右，但是双周留存骤降到仅有1%</li>
<li>体积限制：微信小程序只有2M的大小，这样导致无法开发大型一些的小程序</li>
<li>受控微信：比起APP，尤其是安卓版的高自由度，小程序要面对很多来自微信的限制，从功能接口，甚至到类别内容，都要接受微信的管控</li>
</ul>
<h4 id="60-说说你对发布订阅、观察者模式的理解？区别？"><a href="#60-说说你对发布订阅、观察者模式的理解？区别？" class="headerlink" title="60.   说说你对发布订阅、观察者模式的理解？区别？"></a>60.   说说你对发布订阅、观察者模式的理解？区别？</h4><ul>
<li><p>发布订阅模式三个角色：订阅者，发布者。信号中心。</p>
<ul>
<li> 我们假定，存在一个”信号中心”，某个任务执行完成，就向信号中心”发布”(publish)一个信 号，其他任务可以向信号中心”订阅”(subscribe)这个信号，从而知道什么时候自己可以开始执 行。这就叫做”发布/订阅模式” </li>
<li> 例子： Vue 的自定义事件 ， 兄弟组件通信， 模拟 Vue 自定义事件的实现 </li>
</ul>
</li>
<li><p>观察者模式三个角色：</p>
<ul>
<li>观察者(订阅者)–Watcher        <ul>
<li><code>update()</code>:当事件发生时，具体要做的事情</li>
</ul>
</li>
<li>目标(发布者) –Dep<ul>
<li><code>subs</code> 数组:存储所有的观察者</li>
<li><code>addSub()</code>:添加观察者</li>
<li><code>notify()</code>:当事件发生，调用所有观察者的 <code>update()</code> 方法</li>
</ul>
</li>
<li>没有事件中心</li>
</ul>
</li>
</ul>
<p><strong>发布/订阅模式</strong>由统一信号中心调用，因此发布者和订阅者不需要知道对方的存在</p>
<p><strong>观察者模式</strong>是由具体目标调动，比如当事件触发，<code>Dep</code> 就会去调用观察者的方法，所以观察者模 式的订阅者与发布者之间是存在依赖的</p>
<h4 id="61-项目做过哪些性能优化"><a href="#61-项目做过哪些性能优化" class="headerlink" title="61.   项目做过哪些性能优化"></a>61.   项目做过哪些性能优化</h4><ul>
<li><p>减少 <code>HTTP</code> 请求数</p>
</li>
<li><p>减少<code>DOM</code> 操作</p>
</li>
<li><p>压缩css，js，图片等</p>
</li>
<li><p>在外部使用js和css</p>
</li>
<li><p>路由懒加载，图片懒加载</p>
</li>
<li><p>减少重绘，和回流。</p>
</li>
<li><p>ui框架按需加载</p>
</li>
<li><p>减少 <code>DNS</code> 查询</p>
</li>
<li><p>使用 <code>CDN</code></p>
</li>
<li><p>避免重定向</p>
</li>
<li><p>减少 <code>DOM</code> 元素数量</p>
</li>
<li><p>优化 <code>CSS Sprite</code></p>
</li>
<li><p>使用 <code>iconfont</code></p>
</li>
<li><p>字体裁剪</p>
</li>
<li><p>多域名分发划分内容到不同域名</p>
</li>
<li><p>尽量减少 <code>iframe</code> 使用</p>
</li>
<li><p>避免图片 <code>src</code> 为空</p>
</li>
<li><p>把样式表放在<code>link</code> 中</p>
</li>
<li><p>把<code>JavaScript</code>放在页面底部</p>
</li>
</ul>
<h4 id="62-描述浏览器的渲染过程，DOM树和渲染树的区别"><a href="#62-描述浏览器的渲染过程，DOM树和渲染树的区别" class="headerlink" title="62.   描述浏览器的渲染过程，DOM树和渲染树的区别"></a>62.   描述浏览器的渲染过程，DOM树和渲染树的区别</h4><ul>
<li>浏览器的渲染过程：<ul>
<li>解析<code>HTML</code>构建 <code>DOM</code>(DOM树)，并请求 <code>css/image/js</code></li>
<li><code>CSS</code> 文件下载完成，开始构建 <code>CSSDOM</code>(<code>CSS</code>树)</li>
<li>css树构建结束后，和 <code>DOM</code> 一起生成 <code>Render Tree</code>(渲染树)</li>
<li>布局：计算出每个节点在屏幕中的位置</li>
<li>显示：通过显卡把页面画到屏幕上</li>
</ul>
</li>
<li><code>DOM</code>树 和 渲染树 的区别：<ul>
<li><code>DOM</code>树与<code>HTML</code>标签一一对应，包括<code>head</code>和隐藏元素</li>
<li>渲染树不包括<code>head</code>和隐藏元素，大段文本每一行都是独立节点，每一个节点都有对应的<code>css</code>属性。</li>
</ul>
</li>
</ul>
<h4 id="63-你认为什么样的前端代码是好的"><a href="#63-你认为什么样的前端代码是好的" class="headerlink" title="63.   你认为什么样的前端代码是好的"></a>63.   你认为什么样的前端代码是好的</h4><p>完成一个项目操作尽量是低代码，代码是高内聚，低耦合的。</p>
<p>代码维护性比较高，而且容易扩展的。遵循代码的规范。</p>
<h4 id="64-从浏览器地址栏输入url到显示页面的步骤"><a href="#64-从浏览器地址栏输入url到显示页面的步骤" class="headerlink" title="64.   从浏览器地址栏输入url到显示页面的步骤"></a>64.   从浏览器地址栏输入url到显示页面的步骤</h4><p>1，URL解析 ：判断url格式是否正确</p>
<p>2，DNS域名查询 ：获取域名对应的服务器IP地址</p>
<p>3，建立TCP连接： 三次握手建立TCP连接</p>
<p>4，发起http请求: 浏览器发送请求到目标服务器，进行逻辑操作</p>
<p>5，响应请求和页面渲染：服务器返回一个响应请求，响应完，当页面关闭，tcp经过四次挥手断开连接</p>
<p>6 ，页面渲染：浏览器拿到服务器响应返回的资源，解析 先对资源进行解析，比如重定向 储存cookie、解压gzip等</p>
<p>7，解析html，构建dom树。</p>
<p>8，解析css 生成css规则树。</p>
<p>9，合并dom树，生成rander树</p>
<p>10，布局rander树，绘制rander树，绘制页面像素信息</p>
<p>11最后，浏览器把信息给gpu将各层信息合并，显示到屏幕上；</p>
<h4 id="65-http-请求报文和响应报文的格式"><a href="#65-http-请求报文和响应报文的格式" class="headerlink" title="65.   http 请求报文和响应报文的格式"></a>65.   http 请求报文和响应报文的格式</h4><ul>
<li><p>向后端服务器发出一个web资源请求，称之为客户端向服务器端发出了一个http请求。</p>
<p>HTTP请求报文主要由请求行、请求头、请求正文3部分组成 。</p>
</li>
<li><p>响应就是后端服务器对该请求做了个处理，返回一些数据等等。</p>
<p>HTTP响应报文主要由响应行、响应头、响应正文3部分组成。</p>
</li>
</ul>
<h4 id="66-Token-cookie-session-区别"><a href="#66-Token-cookie-session-区别" class="headerlink" title="66.   Token cookie session 区别"></a>66.   Token cookie session 区别</h4><p> <strong>Session</strong>会话：客户端A访问服务器，服务器存储A的数据value，把key返回给客户端A，客户端A下次带着key（<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=session&spm=1001.2101.3001.7020">session</a> ID）来访问服务器，服务器就能给出客户端A的数据。 </p>
<p> <strong>Cookie</strong>：客户端A访问服务器，服务器返回cookie给客户端A，客户端A存储cookie，下次需要带着cookie访问服务器，服务器返回相应的数据。 </p>
<p> <strong>Token</strong>令牌：客户端A访问服务器，服务器给了客户端token，客户端A拿着token访问服务器，服务器验证token，返回数据。 </p>
<ul>
<li><code>cookie</code> 数据存放在浏览器上，session 数据存放在服务器上</li>
<li><code>cookie</code> 不是很安全，别人可以分析存放在本地的cookie 并进行 cookie 欺骗 考虑到安全应当使用 session</li>
<li><code>session</code> 会在一定时间内保存在服务器上。当访问增多，服务器性能会变差，这时应当使用cookie。</li>
<li>单个 <code>cookie</code> 保存的数据不能超过 <code>4K</code>，很多浏览器都限制一个站点最多保存 20 个 <code>cookie</code>。session是根据服务器大小来定。</li>
</ul>
<p>token：</p>
<p> token是服务器生成的一串字符串，作为客户端进行请求的一个令牌。 </p>
<p>token比较安全，cookie容易伪造，但是token不容易伪造，盗取。</p>
<h4 id="67-CORS跨域的原理"><a href="#67-CORS跨域的原理" class="headerlink" title="67.   CORS跨域的原理"></a>67.   CORS跨域的原理</h4><ul>
<li>当我们发起跨域请求时，如果是非简单请求，浏览器会帮我们自动触发预检请求，也就是 options请求，用于确认目标资源是否支持跨域。如果是简单请求，则不会触发预检，直接发出正常请求。</li>
<li>浏览器会根据服务端响应的 header 自动处理剩余的请求，如果响应支持跨域，则继续发出正常请求，如果不支持，则在控制台显示错误。</li>
</ul>
<h4 id="68-什么是MVVM"><a href="#68-什么是MVVM" class="headerlink" title="68.   什么是MVVM"></a>68.   什么是MVVM</h4><p>mvvm就是modle –view  –viewmodle。mvvm是一种设计思想 。</p>
<p>modle：模型层，用于处理逻辑和服务器的交互。</p>
<p>view：视图层，用于将数据渲染在页面上。UI视图。</p>
<p>view-modle：视图模型层，用来连接Model和View，是Model和View之间的通信桥梁。达到数据驱动视图的效果。</p>
<p> MVVM模式简化了界面与业务的依赖，解决了数据频繁更新。MVVM 在使用当中，利用双向绑定技术，使得 Model 变化时，ViewModel 会自动更新，而 ViewModel 变化时，View 也会自动变化。 </p>
<h4 id="69-说说你对版本管理的理解？常用的版本管理工具有哪些？"><a href="#69-说说你对版本管理的理解？常用的版本管理工具有哪些？" class="headerlink" title="69.   说说你对版本管理的理解？常用的版本管理工具有哪些？"></a>69.   说说你对版本管理的理解？常用的版本管理工具有哪些？</h4><p>简单来说： 你的修改只要提到到版本控制系统，基本都可以找回，版本控制系统就像一台时光机器，可以让你回到任何一个时间点 。</p>
<p>三个分类：</p>
<ul>
<li>本地版本控制系统</li>
<li>集中式版本控制系统    优点：适合多人团队协作开发，代码集中管理。  缺点：必须联网，无法单机工作。<ul>
<li>SVN</li>
<li>CVS</li>
</ul>
</li>
<li>分布式版本控制系统    优点：适合多人团队协作开发，代码集中管理。可离线工作。<ul>
<li>Git       一般公司都是使用git和gitlab自己搭建版本控制环境。比较安全。</li>
<li>HG</li>
</ul>
</li>
</ul>
<h4 id="70-说说你对Git的理解？"><a href="#70-说说你对Git的理解？" class="headerlink" title="70.   说说你对Git的理解？"></a>70.   说说你对Git的理解？</h4><p>git是目前世界上最先进的分布式版本控制系统，快速高效的处理小型到大型项目的事务。</p>
<p> 当我们通过<code>git init</code>创建或者<code>git clone</code>一个项目的时候，项目目录会隐藏一个<code>.git</code>子目录，其作用是用来跟踪管理版本库的 。</p>
<p>特性：易于学习，占用内存小，具有闪电般快速的性能。</p>
<p>使用<code>Git</code>和<code>Gitlab</code>搭建版本控制环境是现在互联网公司最流行的版本控制方式。</p>
<h4 id="71-说说Git常用的命令有哪些"><a href="#71-说说Git常用的命令有哪些" class="headerlink" title="71.   说说Git常用的命令有哪些"></a>71.   说说Git常用的命令有哪些</h4><ul>
<li>git add  .  ：提交暂存区</li>
<li>git status：  查看当前分支状态</li>
<li>git  commit -m  ‘’ ：提交本地库</li>
<li>git pull  更新或合并</li>
<li>git push -u origin master   提交到远程仓库</li>
</ul>
<h4 id="72-说说-git-发生冲突的场景？如何解决？"><a href="#72-说说-git-发生冲突的场景？如何解决？" class="headerlink" title="72.   说说 git 发生冲突的场景？如何解决？"></a>72.   说说 git 发生冲突的场景？如何解决？</h4><p>多个分支修改了同一个文件，比如在项目开发中，需要写组件了。要注册路由，然后你增加了几个路由。在你提交前，已经有人提交了并且已经修改了路由文件。这时你提交就会冲突。</p>
<p>首先将修改过的文件add 提到暂存区，commit 提交本地库，git pull 更新合并代码。然后根据提示手动去解决冲突。</p>
<h4 id="73-loader和plugin的区别"><a href="#73-loader和plugin的区别" class="headerlink" title="73.  loader和plugin的区别"></a>73.  loader和plugin的区别</h4><p>对于loader，它是一个转换器，将A文件进行编译形成B文件，这里操作的是文件，比如将A.scss转换为A.css，单纯的文件转换过程。<br>plugin是一个插件，在webpack中相当于一个扩展器。是对现有webpack功能的一个扩展。针对于loader结束后，在webpack打包过程中并不是直接进行操作的，而是遵循事件机制工作的。会监听webpack打包过程中的某些节点，执行广泛的任务。</p>

              
            </div>
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/" class="category-chain-item">面试题总结</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/72%E9%81%93%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/">#72道面试题总结</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>面试题总结</div>
      <div>http://example.com/2019/05/17/lin-first-blog/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>赵硕林</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2019年5月17日</div>
        </div>
      
      
      <div class="license-meta-item">
        <div>许可协议</div>
        <div>
          
            
            
              <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
              <span class="hint--top hint--rounded" aria-label="BY - 署名">
                <i class="iconfont icon-by"></i>
              </span>
              </a>
            
          
        </div>
      </div>
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2014/05/25/vue%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/" title="vue响应式原理">
                        <span class="hidden-mobile">vue响应式原理</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  






    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> <div>欧皇的博客 | 记录学习成长的过程</div> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>






  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.0/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script>
  (function() {
    var enableLang = CONFIG.code_language.enable && CONFIG.code_language.default;
    var enableCopy = CONFIG.copy_btn;
    if (!enableLang && !enableCopy) {
      return;
    }

    function getBgClass(ele) {
      return Fluid.utils.getBackgroundLightness(ele) >= 0 ? 'code-widget-light' : 'code-widget-dark';
    }

    var copyTmpl = '';
    copyTmpl += '<div class="code-widget">';
    copyTmpl += 'LANG';
    copyTmpl += '</div>';
    jQuery('.markdown-body pre').each(function() {
      var $pre = jQuery(this);
      if ($pre.find('code.mermaid').length > 0) {
        return;
      }
      if ($pre.find('span.line').length > 0) {
        return;
      }

      var lang = '';

      if (enableLang) {
        lang = CONFIG.code_language.default;
        if ($pre[0].children.length > 0 && $pre[0].children[0].classList.length >= 2 && $pre.children().hasClass('hljs')) {
          lang = $pre[0].children[0].classList[1];
        } else if ($pre[0].getAttribute('data-language')) {
          lang = $pre[0].getAttribute('data-language');
        } else if ($pre.parent().hasClass('sourceCode') && $pre[0].children.length > 0 && $pre[0].children[0].classList.length >= 2) {
          lang = $pre[0].children[0].classList[1];
          $pre.parent().addClass('code-wrapper');
        } else if ($pre.parent().hasClass('markdown-body') && $pre[0].classList.length === 0) {
          $pre.wrap('<div class="code-wrapper"></div>');
        }
        lang = lang.toUpperCase().replace('NONE', CONFIG.code_language.default);
      }
      $pre.append(copyTmpl.replace('LANG', lang).replace('code-widget">',
        getBgClass($pre[0]) + (enableCopy ? ' code-widget copy-btn" data-clipboard-snippet><i class="iconfont icon-copy"></i>' : ' code-widget">')));

      if (enableCopy) {
        Fluid.utils.createScript('https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js', function() {
          var clipboard = new window.ClipboardJS('.copy-btn', {
            target: function(trigger) {
              var nodes = trigger.parentNode.childNodes;
              for (var i = 0; i < nodes.length; i++) {
                if (nodes[i].tagName === 'CODE') {
                  return nodes[i];
                }
              }
            }
          });
          clipboard.on('success', function(e) {
            e.clearSelection();
            e.trigger.innerHTML = e.trigger.innerHTML.replace('icon-copy', 'icon-success');
            setTimeout(function() {
              e.trigger.innerHTML = e.trigger.innerHTML.replace('icon-success', 'icon-copy');
            }, 2000);
          });
        });
      }
    });
  })();
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
